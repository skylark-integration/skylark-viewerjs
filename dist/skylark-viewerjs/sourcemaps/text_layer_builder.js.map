{"version":3,"sources":["text_layer_builder.js"],"names":["define","PDFJS","viewerjs","uiutils","NonWhitespaceRegexp","TextLayerBuilder","options","this","textLayerDiv","renderingDone","divContentDone","pageIdx","pageIndex","pageNumber","matches","viewport","textDivs","findController","DefaultTextLayerFactory","prototype","_finishRendering","event","document","createEvent","initCustomEvent","dispatchEvent","renderLayer","textLayerFrag","createDocumentFragment","textDivsLength","length","ctx","createElement","getContext","lastFontSize","lastFontFamily","i","textDiv","undefined","dataset","isWhitespace","fontSize","style","fontFamily","font","width","measureText","textContent","transform","appendChild","canvasWidth","rotation","angle","CustomStyle","setProp","updateMatches","render","timeout","renderTimer","clearTimeout","self","setTimeout","appendText","geom","styles","fontName","push","str","test","tx","Util","Math","atan2","vertical","PI","left","top","fontHeight","sqrt","fontAscent","ascent","descent","sin","cos","pdfBug","height","scale","setTextContent","textItems","items","len","convertMatches","iIndex","bidiTexts","end","queryLen","state","query","ret","m","matchIdx","console","error","match","begin","divIdx","offset","renderMatches","prevEnd","isSelectedPage","selected","selectedMatchIdx","infinity","i0","i1","highlightAll","highlightSuffix","updateMatchPosition","appendTextToDiv","beginText","n0","n1","className","fromOffset","toOffset","div","content","substring","node","createTextNode","span","clearedUntilDivIdx","n","max","active","pageMatches","createTextLayerBuilder"],"mappings":"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","file":"../text_layer_builder.js","sourcesContent":["define([\n    \"skylark-pdfjs-display\",\n    \"./viewerjs\",\n    \"./ui_utils\"\n],function(PDFJS,viewerjs,uiutils) {\n  'use strict';\n\n  var MAX_TEXT_DIVS_TO_RENDER = 100000;\n\n  var NonWhitespaceRegexp = /\\S/;\n\n  function isAllWhitespace(str) {\n    return !NonWhitespaceRegexp.test(str);\n  }\n\n  /**\n   * @typedef {Object} TextLayerBuilderOptions\n   * @property {HTMLDivElement} textLayerDiv - The text layer container.\n   * @property {number} pageIndex - The page index.\n   * @property {PageViewport} viewport - The viewport of the text layer.\n   * @property {PDFFindController} findController\n   */\n\n  /**\n   * TextLayerBuilder provides text-selection functionality for the PDF.\n   * It does this by creating overlay divs over the PDF text. These divs\n   * contain text that matches the PDF text they are overlaying. This object\n   * also provides a way to highlight text that is being searched for.\n   * @class\n   */\n  function TextLayerBuilder(options) {\n    this.textLayerDiv = options.textLayerDiv;\n    this.renderingDone = false;\n    this.divContentDone = false;\n    this.pageIdx = options.pageIndex;\n    this.pageNumber = this.pageIdx + 1;\n    this.matches = [];\n    this.viewport = options.viewport;\n    this.textDivs = [];\n    this.findController = options.findController || null;\n  }\n\n  TextLayerBuilder.prototype = {\n    _finishRendering: function TextLayerBuilder_finishRendering() {\n      this.renderingDone = true;\n\n      var event = document.createEvent('CustomEvent');\n      event.initCustomEvent('textlayerrendered', true, true, {\n        pageNumber: this.pageNumber\n      });\n      this.textLayerDiv.dispatchEvent(event);\n    },\n\n    renderLayer: function TextLayerBuilder_renderLayer() {\n      var textLayerFrag = document.createDocumentFragment();\n      var textDivs = this.textDivs;\n      var textDivsLength = textDivs.length;\n      var canvas = document.createElement('canvas');\n      var ctx = canvas.getContext('2d');\n\n      // No point in rendering many divs as it would make the browser\n      // unusable even after the divs are rendered.\n      if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {\n        this._finishRendering();\n        return;\n      }\n\n      var lastFontSize;\n      var lastFontFamily;\n      for (var i = 0; i < textDivsLength; i++) {\n        var textDiv = textDivs[i];\n        if (textDiv.dataset.isWhitespace !== undefined) {\n          continue;\n        }\n\n        var fontSize = textDiv.style.fontSize;\n        var fontFamily = textDiv.style.fontFamily;\n\n        // Only build font string and set to context if different from last.\n        if (fontSize !== lastFontSize || fontFamily !== lastFontFamily) {\n          ctx.font = fontSize + ' ' + fontFamily;\n          lastFontSize = fontSize;\n          lastFontFamily = fontFamily;\n        }\n\n        var width = ctx.measureText(textDiv.textContent).width;\n        if (width > 0) {\n          textLayerFrag.appendChild(textDiv);\n          var transform;\n          if (textDiv.dataset.canvasWidth !== undefined) {\n            // Dataset values come of type string.\n            var textScale = textDiv.dataset.canvasWidth / width;\n            transform = 'scaleX(' + textScale + ')';\n          } else {\n            transform = '';\n          }\n          var rotation = textDiv.dataset.angle;\n          if (rotation) {\n            transform = 'rotate(' + rotation + 'deg) ' + transform;\n          }\n          if (transform) {\n            uiutils.CustomStyle.setProp('transform' , textDiv, transform);\n          }\n        }\n      }\n\n      this.textLayerDiv.appendChild(textLayerFrag);\n      this._finishRendering();\n      this.updateMatches();\n    },\n\n    /**\n     * Renders the text layer.\n     * @param {number} timeout (optional) if specified, the rendering waits\n     *   for specified amount of ms.\n     */\n    render: function TextLayerBuilder_render(timeout) {\n      if (!this.divContentDone || this.renderingDone) {\n        return;\n      }\n\n      if (this.renderTimer) {\n        clearTimeout(this.renderTimer);\n        this.renderTimer = null;\n      }\n\n      if (!timeout) { // Render right away\n        this.renderLayer();\n      } else { // Schedule\n        var self = this;\n        this.renderTimer = setTimeout(function() {\n          self.renderLayer();\n          self.renderTimer = null;\n        }, timeout);\n      }\n    },\n\n    appendText: function TextLayerBuilder_appendText(geom, styles) {\n      var style = styles[geom.fontName];\n      var textDiv = document.createElement('div');\n      this.textDivs.push(textDiv);\n      if (isAllWhitespace(geom.str)) {\n        textDiv.dataset.isWhitespace = true;\n        return;\n      }\n      var tx = PDFJS.Util.transform(this.viewport.transform, geom.transform);\n      var angle = Math.atan2(tx[1], tx[0]);\n      if (style.vertical) {\n        angle += Math.PI / 2;\n      }\n      var fontHeight = Math.sqrt((tx[2] * tx[2]) + (tx[3] * tx[3]));\n      var fontAscent = fontHeight;\n      if (style.ascent) {\n        fontAscent = style.ascent * fontAscent;\n      } else if (style.descent) {\n        fontAscent = (1 + style.descent) * fontAscent;\n      }\n\n      var left;\n      var top;\n      if (angle === 0) {\n        left = tx[4];\n        top = tx[5] - fontAscent;\n      } else {\n        left = tx[4] + (fontAscent * Math.sin(angle));\n        top = tx[5] - (fontAscent * Math.cos(angle));\n      }\n      textDiv.style.left = left + 'px';\n      textDiv.style.top = top + 'px';\n      textDiv.style.fontSize = fontHeight + 'px';\n      textDiv.style.fontFamily = style.fontFamily;\n\n      textDiv.textContent = geom.str;\n      // |fontName| is only used by the Font Inspector. This test will succeed\n      // when e.g. the Font Inspector is off but the Stepper is on, but it's\n      // not worth the effort to do a more accurate test.\n      if (PDFJS.pdfBug) {\n        textDiv.dataset.fontName = geom.fontName;\n      }\n      // Storing into dataset will convert number into string.\n      if (angle !== 0) {\n        textDiv.dataset.angle = angle * (180 / Math.PI);\n      }\n      // We don't bother scaling single-char text divs, because it has very\n      // little effect on text highlighting. This makes scrolling on docs with\n      // lots of such divs a lot faster.\n      if (textDiv.textContent.length > 1) {\n        if (style.vertical) {\n          textDiv.dataset.canvasWidth = geom.height * this.viewport.scale;\n        } else {\n          textDiv.dataset.canvasWidth = geom.width * this.viewport.scale;\n        }\n      }\n    },\n\n    setTextContent: function TextLayerBuilder_setTextContent(textContent) {\n      this.textContent = textContent;\n\n      var textItems = textContent.items;\n      for (var i = 0, len = textItems.length; i < len; i++) {\n        this.appendText(textItems[i], textContent.styles);\n      }\n      this.divContentDone = true;\n    },\n\n    convertMatches: function TextLayerBuilder_convertMatches(matches) {\n      var i = 0;\n      var iIndex = 0;\n      var bidiTexts = this.textContent.items;\n      var end = bidiTexts.length - 1;\n      var queryLen = (this.findController === null ?\n                      0 : this.findController.state.query.length);\n      var ret = [];\n\n      for (var m = 0, len = matches.length; m < len; m++) {\n        // Calculate the start position.\n        var matchIdx = matches[m];\n\n        // Loop over the divIdxs.\n        while (i !== end && matchIdx >= (iIndex + bidiTexts[i].str.length)) {\n          iIndex += bidiTexts[i].str.length;\n          i++;\n        }\n\n        if (i === bidiTexts.length) {\n          console.error('Could not find a matching mapping');\n        }\n\n        var match = {\n          begin: {\n            divIdx: i,\n            offset: matchIdx - iIndex\n          }\n        };\n\n        // Calculate the end position.\n        matchIdx += queryLen;\n\n        // Somewhat the same array as above, but use > instead of >= to get\n        // the end position right.\n        while (i !== end && matchIdx > (iIndex + bidiTexts[i].str.length)) {\n          iIndex += bidiTexts[i].str.length;\n          i++;\n        }\n\n        match.end = {\n          divIdx: i,\n          offset: matchIdx - iIndex\n        };\n        ret.push(match);\n      }\n\n      return ret;\n    },\n\n    renderMatches: function TextLayerBuilder_renderMatches(matches) {\n      // Early exit if there is nothing to render.\n      if (matches.length === 0) {\n        return;\n      }\n\n      var bidiTexts = this.textContent.items;\n      var textDivs = this.textDivs;\n      var prevEnd = null;\n      var pageIdx = this.pageIdx;\n      var isSelectedPage = (this.findController === null ?\n        false : (pageIdx === this.findController.selected.pageIdx));\n      var selectedMatchIdx = (this.findController === null ?\n                              -1 : this.findController.selected.matchIdx);\n      var highlightAll = (this.findController === null ?\n                          false : this.findController.state.highlightAll);\n      var infinity = {\n        divIdx: -1,\n        offset: undefined\n      };\n\n      function beginText(begin, className) {\n        var divIdx = begin.divIdx;\n        textDivs[divIdx].textContent = '';\n        appendTextToDiv(divIdx, 0, begin.offset, className);\n      }\n\n      function appendTextToDiv(divIdx, fromOffset, toOffset, className) {\n        var div = textDivs[divIdx];\n        var content = bidiTexts[divIdx].str.substring(fromOffset, toOffset);\n        var node = document.createTextNode(content);\n        if (className) {\n          var span = document.createElement('span');\n          span.className = className;\n          span.appendChild(node);\n          div.appendChild(span);\n          return;\n        }\n        div.appendChild(node);\n      }\n\n      var i0 = selectedMatchIdx, i1 = i0 + 1;\n      if (highlightAll) {\n        i0 = 0;\n        i1 = matches.length;\n      } else if (!isSelectedPage) {\n        // Not highlighting all and this isn't the selected page, so do nothing.\n        return;\n      }\n\n      for (var i = i0; i < i1; i++) {\n        var match = matches[i];\n        var begin = match.begin;\n        var end = match.end;\n        var isSelected = (isSelectedPage && i === selectedMatchIdx);\n        var highlightSuffix = (isSelected ? ' selected' : '');\n\n        if (this.findController) {\n          this.findController.updateMatchPosition(pageIdx, i, textDivs,\n                                                  begin.divIdx, end.divIdx);\n        }\n\n        // Match inside new div.\n        if (!prevEnd || begin.divIdx !== prevEnd.divIdx) {\n          // If there was a previous div, then add the text at the end.\n          if (prevEnd !== null) {\n            appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);\n          }\n          // Clear the divs and set the content until the starting point.\n          beginText(begin);\n        } else {\n          appendTextToDiv(prevEnd.divIdx, prevEnd.offset, begin.offset);\n        }\n\n        if (begin.divIdx === end.divIdx) {\n          appendTextToDiv(begin.divIdx, begin.offset, end.offset,\n                          'highlight' + highlightSuffix);\n        } else {\n          appendTextToDiv(begin.divIdx, begin.offset, infinity.offset,\n                          'highlight begin' + highlightSuffix);\n          for (var n0 = begin.divIdx + 1, n1 = end.divIdx; n0 < n1; n0++) {\n            textDivs[n0].className = 'highlight middle' + highlightSuffix;\n          }\n          beginText(end, 'highlight end' + highlightSuffix);\n        }\n        prevEnd = end;\n      }\n\n      if (prevEnd) {\n        appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);\n      }\n    },\n\n    updateMatches: function TextLayerBuilder_updateMatches() {\n      // Only show matches when all rendering is done.\n      if (!this.renderingDone) {\n        return;\n      }\n\n      // Clear all matches.\n      var matches = this.matches;\n      var textDivs = this.textDivs;\n      var bidiTexts = this.textContent.items;\n      var clearedUntilDivIdx = -1;\n\n      // Clear all current matches.\n      for (var i = 0, len = matches.length; i < len; i++) {\n        var match = matches[i];\n        var begin = Math.max(clearedUntilDivIdx, match.begin.divIdx);\n        for (var n = begin, end = match.end.divIdx; n <= end; n++) {\n          var div = textDivs[n];\n          div.textContent = bidiTexts[n].str;\n          div.className = '';\n        }\n        clearedUntilDivIdx = match.end.divIdx + 1;\n      }\n\n      if (this.findController === null || !this.findController.active) {\n        return;\n      }\n\n      // Convert the matches on the page controller into the match format\n      // used for the textLayer.\n      this.matches = this.convertMatches(this.findController === null ?\n        [] : (this.findController.pageMatches[this.pageIdx] || []));\n      this.renderMatches(this.matches);\n    }\n  };\n\n  /**\n   * @constructor\n   * @implements IPDFTextLayerFactory\n   */\n  function DefaultTextLayerFactory() {}\n  DefaultTextLayerFactory.prototype = {\n    /**\n     * @param {HTMLDivElement} textLayerDiv\n     * @param {number} pageIndex\n     * @param {PageViewport} viewport\n     * @returns {TextLayerBuilder}\n     */\n    createTextLayerBuilder: function (textLayerDiv, pageIndex, viewport) {\n      return new TextLayerBuilder({\n        textLayerDiv: textLayerDiv,\n        pageIndex: pageIndex,\n        viewport: viewport\n      });\n    }\n  };\n\n  TextLayerBuilder.DefaultTextLayerFactory = DefaultTextLayerFactory;\n\n  return viewerjs.TextLayerBuilder = TextLayerBuilder\n});"]}