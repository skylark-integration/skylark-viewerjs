/**
 * skylark-viewerjs - A version of viewerjs that ported to running on skylarkjs.
 * @author Hudaokeji Co.,Ltd
 * @version v0.9.0
 * @link www.skylarkjs.org
 * @license MIT
 */
(function(factory,globals) {
  var define = globals.define,
      require = globals.require,
      isAmd = (typeof define === 'function' && define.amd),
      isCmd = (!isAmd && typeof exports !== 'undefined');

  if (!isAmd && !define) {
    var map = {};
    function absolute(relative, base) {
        if (relative[0]!==".") {
          return relative;
        }
        var stack = base.split("/"),
            parts = relative.split("/");
        stack.pop(); 
        for (var i=0; i<parts.length; i++) {
            if (parts[i] == ".")
                continue;
            if (parts[i] == "..")
                stack.pop();
            else
                stack.push(parts[i]);
        }
        return stack.join("/");
    }
    define = globals.define = function(id, deps, factory) {
        if (typeof factory == 'function') {
            map[id] = {
                factory: factory,
                deps: deps.map(function(dep){
                  return absolute(dep,id);
                }),
                resolved: false,
                exports: null
            };
            require(id);
        } else {
            map[id] = {
                factory : null,
                resolved : true,
                exports : factory
            };
        }
    };
    require = globals.require = function(id) {
        if (!map.hasOwnProperty(id)) {
            throw new Error('Module ' + id + ' has not been defined');
        }
        var module = map[id];
        if (!module.resolved) {
            var args = [];

            module.deps.forEach(function(dep){
                args.push(require(dep));
            })

            module.exports = module.factory.apply(globals, args) || null;
            module.resolved = true;
        }
        return module.exports;
    };
  }
  
  if (!define) {
     throw new Error("The module utility (ex: requirejs or skylark-utils) is not loaded!");
  }

  factory(define,require);

  if (!isAmd) {
    var skylarkjs = require("skylark-langx-ns");

    if (isCmd) {
      module.exports = skylarkjs;
    } else {
      globals.skylarkjs  = skylarkjs;
    }
  }

})(function(define,require) {

define('skylark-langx-ns/_attach',[],function(){
    return  function attach(obj1,path,obj2) {
        if (typeof path == "string") {
            path = path.split(".");//[path]
        };
        var length = path.length,
            ns=obj1,
            i=0,
            name = path[i++];

        while (i < length) {
            ns = ns[name] = ns[name] || {};
            name = path[i++];
        }

        ns[name] = obj2 || {};
        return ns[name];
    }
});
define('skylark-langx-ns/ns',[
    "./_attach"
], function(_attach) {
    var skylark = {
    	attach : function(path,obj) {
    		return _attach(skylark,path,obj);
    	}
    };
    return skylark;
});

define('skylark-langx-ns/main',[
	"./ns"
],function(skylark){
	return skylark;
});
define('skylark-langx-ns', ['skylark-langx-ns/main'], function (main) { return main; });

define('skylark-viewerjs/viewerjs',[
	"skylark-langx-ns"
],function(skylark) {
	return skylark.attach("intg.viewerjs");
});
define('skylark-viewerjs/viewer',[
    "./viewerjs"
],function(viewerjs) {
    /*global document, window*/

    function Viewer(viewerPlugin, parameters) {
        "use strict";

        var self = this,
            kScrollbarPadding = 40,
            kMinScale = 0.25,
            kMaxScale = 4.0,
            kDefaultScaleDelta = 1.1,
            kDefaultScale = 'auto',
            presentationMode = false,
            isFullScreen = false,
            initialized = false,
            url,
            viewerElement = document.getElementById('viewer'),
            canvasContainer = document.getElementById('canvasContainer'),
            overlayNavigator = document.getElementById('overlayNavigator'),
            titlebar = document.getElementById('titlebar'),
            toolbar = document.getElementById('toolbarContainer'),
            pageSwitcher = document.getElementById('toolbarLeft'),
            zoomWidget = document.getElementById('toolbarMiddleContainer'),
            scaleSelector = document.getElementById('scaleSelect'),
            dialogOverlay = document.getElementById('dialogOverlay'),
            toolbarRight = document.getElementById('toolbarRight'),
            aboutDialog,
            pages = [],
            currentPage,
            scaleChangeTimer,
            touchTimer,
            toolbarTouchTimer,
            /**@const*/
            UI_FADE_DURATION = 5000;

        function isBlankedOut() {
            return (blanked.style.display === 'block');
        }

        function initializeAboutInformation() {
            var aboutDialogCentererTable, aboutDialogCentererCell, aboutButton, pluginName, pluginVersion, pluginURL,
                version;

            version = (String(typeof ViewerJS_version) !== "undefined" ? ViewerJS_version : "From Source");
            if (viewerPlugin) {
                pluginName = viewerPlugin.getPluginName();
                pluginVersion = viewerPlugin.getPluginVersion();
                pluginURL = viewerPlugin.getPluginURL();
            }

            // Create dialog
            aboutDialogCentererTable = document.createElement('div');
            aboutDialogCentererTable.id = "aboutDialogCentererTable";
            aboutDialogCentererCell = document.createElement('div');
            aboutDialogCentererCell.id = "aboutDialogCentererCell";
            aboutDialog = document.createElement('div');
            aboutDialog.id = "aboutDialog";
            aboutDialog.innerHTML =
                "<h1>ViewerJS</h1>" +
                "<p>Open Source document viewer for webpages, built with HTML and JavaScript.</p>" +
                "<p>Learn more and get your own copy on the <a href=\"http://viewerjs.org/\" target=\"_blank\">ViewerJS website</a>.</p>" +
                (viewerPlugin ? ("<p>Using the <a href = \""+ pluginURL + "\" target=\"_blank\">" + pluginName + "</a> " +
                                "(<span id = \"pluginVersion\">" + pluginVersion + "</span>) " +
                                "plugin to show you this document.</p>")
                             : "") +
                "<p>Version " + version + "</p>" +
                "<p>Supported by <a href=\"https://nlnet.nl\" target=\"_blank\"><br><img src=\"images\/nlnet.png\" width=\"160\" height=\"60\" alt=\"NLnet Foundation\"></a></p>" +
                "<p>Made by <a href=\"http://kogmbh.com\" target=\"_blank\"><br><img src=\"images\/kogmbh.png\" width=\"172\" height=\"40\" alt=\"KO GmbH\"></a></p>" +
                "<button id = \"aboutDialogCloseButton\" class = \"toolbarButton textButton\">Close</button>";
            dialogOverlay.appendChild(aboutDialogCentererTable);
            aboutDialogCentererTable.appendChild(aboutDialogCentererCell);
            aboutDialogCentererCell.appendChild(aboutDialog);

            // Create button to open dialog that says "ViewerJS"
            aboutButton = document.createElement('button');
            aboutButton.id = "about";
            aboutButton.className = "toolbarButton textButton about";
            aboutButton.title = "About";
            aboutButton.innerHTML = "ViewerJS"
            toolbarRight.appendChild(aboutButton);

            // Attach events to the above
            aboutButton.addEventListener('click', function () {
                    showAboutDialog();
            });
            document.getElementById('aboutDialogCloseButton').addEventListener('click', function () {
                    hideAboutDialog();
            });

        }

        function showAboutDialog() {
            dialogOverlay.style.display = "block";
        }

        function hideAboutDialog() {
            dialogOverlay.style.display = "none";
        }

        function selectScaleOption(value) {
            // Retrieve the options from the zoom level <select> element
            var options = scaleSelector.options,
                option,
                predefinedValueFound = false,
                i;

            for (i = 0; i < options.length; i += 1) {
                option = options[i];
                if (option.value !== value) {
                    option.selected = false;
                    continue;
                }
                option.selected = true;
                predefinedValueFound = true;
            }
            return predefinedValueFound;
        }

        function getPages() {
            return viewerPlugin.getPages();
        }

        function setScale(val, resetAutoSettings) {
            if (val === self.getZoomLevel()) {
                return;
            }

            self.setZoomLevel(val);

            var event = document.createEvent('UIEvents');
            event.initUIEvent('scalechange', false, false, window, 0);
            event.scale = val;
            event.resetAutoSettings = resetAutoSettings;
            window.dispatchEvent(event);
        }

        function onScroll() {
            var pageNumber;

            if (viewerPlugin.onScroll) {
                viewerPlugin.onScroll();
            }
            if (viewerPlugin.getPageInView) {
                pageNumber = viewerPlugin.getPageInView();
                if (pageNumber) {
                    currentPage = pageNumber;
                    document.getElementById('pageNumber').value = pageNumber;
                }
            }
        }

        function delayedRefresh(milliseconds) {
            window.clearTimeout(scaleChangeTimer);
            scaleChangeTimer = window.setTimeout(function () {
                onScroll();
            }, milliseconds);
        }

        function parseScale(value, resetAutoSettings) {
            var scale,
                maxWidth,
                maxHeight;

            if (value === 'custom') {
                scale = parseFloat(document.getElementById('customScaleOption').textContent) / 100;
            } else {
                scale = parseFloat(value);
            }

            if (scale) {
                setScale(scale, true);
                delayedRefresh(300);
                return;
            }

            maxWidth = canvasContainer.clientWidth - kScrollbarPadding;
            maxHeight = canvasContainer.clientHeight - kScrollbarPadding;

            switch (value) {
            case 'page-actual':
                setScale(1, resetAutoSettings);
                break;
            case 'page-width':
                viewerPlugin.fitToWidth(maxWidth);
                break;
            case 'page-height':
                viewerPlugin.fitToHeight(maxHeight);
                break;
            case 'page-fit':
                viewerPlugin.fitToPage(maxWidth, maxHeight);
                break;
            case 'auto':
                if (viewerPlugin.isSlideshow()) {
                    viewerPlugin.fitToPage(maxWidth + kScrollbarPadding, maxHeight + kScrollbarPadding);
                } else {
                    viewerPlugin.fitSmart(maxWidth);
                }
                break;
            }

            selectScaleOption(value);
            delayedRefresh(300);
        }

        function readZoomParameter(zoom) {
            var validZoomStrings = ["auto", "page-actual", "page-width"],
                number;

            if (validZoomStrings.indexOf(zoom) !== -1) {
                return zoom;
            }
            number = parseFloat(zoom);
            if (number && kMinScale <= number && number <= kMaxScale) {
                return zoom;
            }
            return kDefaultScale;
        }

        function readStartPageParameter(startPage) {
            var result = parseInt(startPage, 10);
            return isNaN(result) ? 1 : result;
        }

        this.initialize = function () {
            var initialScale,
                element;

            initialScale = readZoomParameter(parameters.zoom);

            url = parameters.documentUrl;
            document.title = parameters.title;
            var documentName = document.getElementById('documentName');
            documentName.innerHTML = "";
            documentName.appendChild(documentName.ownerDocument.createTextNode(parameters.title));

            viewerPlugin.onLoad = function () {
                document.getElementById('pluginVersion').innerHTML = viewerPlugin.getPluginVersion();

                if (viewerPlugin.isSlideshow()) {
                    // Slideshow pages should be centered
                    canvasContainer.classList.add("slideshow");
                    // Show page nav controls only for presentations
                    pageSwitcher.style.visibility = 'visible';
                } else {
                    // For text documents, show the zoom widget.
                    zoomWidget.style.visibility = 'visible';
                    // Only show the page switcher widget if the plugin supports page numbers
                    if (viewerPlugin.getPageInView) {
                        pageSwitcher.style.visibility = 'visible';
                    }
                }

                initialized = true;
                pages = getPages();
                document.getElementById('numPages').innerHTML = 'of ' + pages.length;


                // Set default scale
                parseScale(initialScale);


                self.showPage(readStartPageParameter(parameters.startpage));

                canvasContainer.onscroll = onScroll;
                delayedRefresh();
            };

            viewerPlugin.initialize(canvasContainer, url);
        };

        /**
         * Shows the 'n'th page. If n is larger than the page count,
         * shows the last page. If n is less than 1, shows the first page.
         * @return {undefined}
         */
        this.showPage = function (n) {
            if (n <= 0) {
                n = 1;
            } else if (n > pages.length) {
                n = pages.length;
            }

            viewerPlugin.showPage(n);

            currentPage = n;
            document.getElementById('pageNumber').value = currentPage;
        };

        /**
         * Shows the next page. If there is no subsequent page, does nothing.
         * @return {undefined}
         */
        this.showNextPage = function () {
            self.showPage(currentPage + 1);
        };

        /**
         * Shows the previous page. If there is no previous page, does nothing.
         * @return {undefined}
         */
        this.showPreviousPage = function () {
            self.showPage(currentPage - 1);
        };

        /**
         * Attempts to 'download' the file.
         * @return {undefined}
         */
        this.download = function () {
            var documentUrl = url.split('#')[0];
            documentUrl += '#viewer.action=download';
            window.open(documentUrl, '_parent');
        };

        /**
         * Toggles the fullscreen state of the viewer
         * @return {undefined}
         */
        this.toggleFullScreen = function () {
            var elem = viewerElement;
            if (!isFullScreen) {
                if (elem.requestFullscreen) {
                    elem.requestFullscreen();
                } else if (elem.mozRequestFullScreen) {
                    elem.mozRequestFullScreen();
                } else if (elem.webkitRequestFullscreen) {
                    elem.webkitRequestFullscreen();
                } else if (elem.webkitRequestFullScreen) {
                    elem.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT);
                } else if (elem.msRequestFullscreen) {
                    elem.msRequestFullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.cancelFullScreen) {
                    document.cancelFullScreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.webkitCancelFullScreen) {
                    document.webkitCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        };

        /**
         * Toggles the presentation mode of the viewer.
         * Presentation mode involves fullscreen + hidden UI controls
         */
        this.togglePresentationMode = function () {
            var overlayCloseButton = document.getElementById('overlayCloseButton');

            if (!presentationMode) {
                titlebar.style.display = toolbar.style.display = 'none';
                overlayCloseButton.style.display = 'block';
                canvasContainer.classList.add('presentationMode');
                canvasContainer.onmousedown = function (event) {
                    event.preventDefault();
                };
                canvasContainer.oncontextmenu = function (event) {
                    event.preventDefault();
                };
                canvasContainer.onmouseup = function (event) {
                    event.preventDefault();
                    if (event.which === 1) {
                        self.showNextPage();
                    } else {
                        self.showPreviousPage();
                    }
                };
                parseScale('page-fit');
            } else {
                if (isBlankedOut()) {
                    leaveBlankOut();
                }
                titlebar.style.display = toolbar.style.display = 'block';
                overlayCloseButton.style.display = 'none';
                canvasContainer.classList.remove('presentationMode');
                canvasContainer.onmouseup = function () {};
                canvasContainer.oncontextmenu = function () {};
                canvasContainer.onmousedown = function () {};
                parseScale('auto');
            }

            presentationMode = !presentationMode;
        };

        /**
         * Gets the zoom level of the document
         * @return {!number}
         */
        this.getZoomLevel = function () {
            return viewerPlugin.getZoomLevel();
        };

        /**
         * Set the zoom level of the document
         * @param {!number} value
         * @return {undefined}
         */
        this.setZoomLevel = function (value) {
            viewerPlugin.setZoomLevel(value);
        };

        /**
         * Zoom out by 10 %
         * @return {undefined}
         */
        this.zoomOut = function () {
            // 10 % decrement
            var newScale = (self.getZoomLevel() / kDefaultScaleDelta).toFixed(2);
            newScale = Math.max(kMinScale, newScale);
            parseScale(newScale, true);
        };

        /**
         * Zoom in by 10%
         * @return {undefined}
         */
        this.zoomIn = function () {
            // 10 % increment
            var newScale = (self.getZoomLevel() * kDefaultScaleDelta).toFixed(2);
            newScale = Math.min(kMaxScale, newScale);
            parseScale(newScale, true);
        };

        function cancelPresentationMode() {
            if (presentationMode && !isFullScreen) {
                self.togglePresentationMode();
            }
        }

        function handleFullScreenChange() {
            isFullScreen = !isFullScreen;
            cancelPresentationMode();
        }

        function showOverlayNavigator() {
            if (presentationMode || viewerPlugin.isSlideshow()) {
                overlayNavigator.className = 'viewer-touched';
                window.clearTimeout(touchTimer);
                touchTimer = window.setTimeout(function () {
                    overlayNavigator.className = '';
                }, UI_FADE_DURATION);
            }
        }

        /**
         * @param {!boolean} timed Fade after a while
         */
        function showToolbars() {
            titlebar.classList.add('viewer-touched');
            toolbar.classList.add('viewer-touched');
            window.clearTimeout(toolbarTouchTimer);
            toolbarTouchTimer = window.setTimeout(function () {
                hideToolbars();
            }, UI_FADE_DURATION);
        }

        function hideToolbars() {
            titlebar.classList.remove('viewer-touched');
            toolbar.classList.remove('viewer-touched');
        }

        function toggleToolbars() {
            if (titlebar.classList.contains('viewer-touched')) {
                hideToolbars();
            } else {
                showToolbars();
            }
        }

        function blankOut(value) {
            blanked.style.display = 'block';
            blanked.style.backgroundColor = value;
            hideToolbars();
        }

        function leaveBlankOut() {
            blanked.style.display = 'none';
            toggleToolbars();
        }

        function setButtonClickHandler(buttonId, handler) {
            var button = document.getElementById(buttonId);

            button.addEventListener('click', function () {
                handler();
                button.blur();
            });
        }

        function init() {

            initializeAboutInformation();

            if (viewerPlugin) {
                self.initialize();

                if (!(document.exitFullscreen || document.cancelFullScreen || document.mozCancelFullScreen || document.webkitExitFullscreen || document.webkitCancelFullScreen || document.msExitFullscreen)) {
                    document.getElementById('fullscreen').style.visibility = 'hidden';
                    document.getElementById('presentation').style.visibility = 'hidden';
                }

                setButtonClickHandler('overlayCloseButton', self.toggleFullScreen);
                setButtonClickHandler('fullscreen', self.toggleFullScreen);
                setButtonClickHandler('presentation', function () {
                    if (!isFullScreen) {
                        self.toggleFullScreen();
                    }
                    self.togglePresentationMode();
                });

                document.addEventListener('fullscreenchange', handleFullScreenChange);
                document.addEventListener('webkitfullscreenchange', handleFullScreenChange);
                document.addEventListener('mozfullscreenchange', handleFullScreenChange);
                document.addEventListener('MSFullscreenChange', handleFullScreenChange);

                setButtonClickHandler('download', self.download);

                setButtonClickHandler('zoomOut', self.zoomOut);
                setButtonClickHandler('zoomIn', self.zoomIn);

                setButtonClickHandler('previous', self.showPreviousPage);
                setButtonClickHandler('next', self.showNextPage);

                setButtonClickHandler('previousPage', self.showPreviousPage);
                setButtonClickHandler('nextPage', self.showNextPage);

                document.getElementById('pageNumber').addEventListener('change', function () {
                    self.showPage(this.value);
                });

                document.getElementById('scaleSelect').addEventListener('change', function () {
                    parseScale(this.value);
                });

                canvasContainer.addEventListener('click', showOverlayNavigator);
                overlayNavigator.addEventListener('click', showOverlayNavigator);
                canvasContainer.addEventListener('click', toggleToolbars);
                titlebar.addEventListener('click', showToolbars);
                toolbar.addEventListener('click', showToolbars);

                window.addEventListener('scalechange', function (evt) {
                    var customScaleOption = document.getElementById('customScaleOption'),
                        predefinedValueFound = selectScaleOption(String(evt.scale));

                    customScaleOption.selected = false;

                    if (!predefinedValueFound) {
                        customScaleOption.textContent = Math.round(evt.scale * 10000) / 100 + '%';
                        customScaleOption.selected = true;
                    }
                }, true);

                window.addEventListener('resize', function (evt) {
                    if (initialized &&
                              (document.getElementById('pageWidthOption').selected ||
                              document.getElementById('pageAutoOption').selected)) {
                        parseScale(document.getElementById('scaleSelect').value);
                    }
                    showOverlayNavigator();
                });

                window.addEventListener('keydown', function (evt) {
                    var key = evt.keyCode,
                        shiftKey = evt.shiftKey;

                    // blanked-out mode?
                    if (isBlankedOut()) {
                        switch (key) {
                        case 16: // Shift
                        case 17: // Ctrl
                        case 18: // Alt
                        case 91: // LeftMeta
                        case 93: // RightMeta
                        case 224: // MetaInMozilla
                        case 225: // AltGr
                            // ignore modifier keys alone
                            break;
                        default:
                            leaveBlankOut();
                            break;
                        }
                    } else {
                        switch (key) {
                        case 8: // backspace
                        case 33: // pageUp
                        case 37: // left arrow
                        case 38: // up arrow
                        case 80: // key 'p'
                            self.showPreviousPage();
                            break;
                        case 13: // enter
                        case 34: // pageDown
                        case 39: // right arrow
                        case 40: // down arrow
                        case 78: // key 'n'
                            self.showNextPage();
                            break;
                        case 32: // space
                            shiftKey ? self.showPreviousPage() : self.showNextPage();
                            break;
                        case 66:  // key 'b' blanks screen (to black) or returns to the document
                        case 190: // and so does the key '.' (dot)
                            if (presentationMode) {
                                blankOut('#000');
                            }
                            break;
                        case 87:  // key 'w' blanks page (to white) or returns to the document
                        case 188: // and so does the key ',' (comma)
                            if (presentationMode) {
                                blankOut('#FFF');
                            }
                            break;
                        case 36: // key 'Home' goes to first page
                            self.showPage(1);
                            break;
                        case 35: // key 'End' goes to last page
                            self.showPage(pages.length);
                            break;
                        }
                    }
                });
            }
        }

        init();
    }

    return viewerjs.Viewer = Viewer;
});
define('skylark-webodf/webodf',[],function() {
	var webodf_version = "0.5.9";
	function Runtime() {}
	Runtime.prototype.getVariable = function(g) {}
	;
	Runtime.prototype.toJson = function(g) {}
	;
	Runtime.prototype.fromJson = function(g) {}
	;
	Runtime.prototype.byteArrayFromString = function(g, k) {}
	;
	Runtime.prototype.byteArrayToString = function(g, k) {}
	;
	Runtime.prototype.read = function(g, k, d, b) {}
	;
	Runtime.prototype.readFile = function(g, k, d) {}
	;
	Runtime.prototype.readFileSync = function(g, k) {}
	;
	Runtime.prototype.loadXML = function(g, k) {}
	;
	Runtime.prototype.writeFile = function(g, k, d) {}
	;
	Runtime.prototype.deleteFile = function(g, k) {}
	;
	Runtime.prototype.log = function(g, k) {}
	;
	Runtime.prototype.setTimeout = function(g, k) {}
	;
	Runtime.prototype.clearTimeout = function(g) {}
	;
	Runtime.prototype.libraryPaths = function() {}
	;
	Runtime.prototype.currentDirectory = function() {}
	;
	Runtime.prototype.setCurrentDirectory = function(g) {}
	;
	Runtime.prototype.type = function() {}
	;
	Runtime.prototype.getDOMImplementation = function() {}
	;
	Runtime.prototype.parseXML = function(g) {}
	;
	Runtime.prototype.exit = function(g) {}
	;
	Runtime.prototype.getWindow = function() {}
	;
	Runtime.prototype.requestAnimationFrame = function(g) {}
	;
	Runtime.prototype.cancelAnimationFrame = function(g) {}
	;
	Runtime.prototype.assert = function(g, k) {}
	;
	var IS_COMPILED_CODE = !0;
	Runtime.byteArrayToString = function(g, k) {
	    function d(b) {
	        var d = "", r, q = b.length;
	        for (r = 0; r < q; r += 1)
	            d += String.fromCharCode(b[r] & 255);
	        return d
	    }
	    function b(b) {
	        var d = "", r, q = b.length, e = [], l, a, c, m;
	        for (r = 3 <= q && 239 === b[0] && 187 === b[1] && 191 === b[2] ? 3 : 0; r < q; r += 1)
	            l = b[r],
	            128 > l ? e.push(l) : (r += 1,
	            a = b[r],
	            194 <= l && 224 > l ? e.push((l & 31) << 6 | a & 63) : (r += 1,
	            c = b[r],
	            224 <= l && 240 > l ? e.push((l & 15) << 12 | (a & 63) << 6 | c & 63) : (r += 1,
	            m = b[r],
	            240 <= l && 245 > l && (l = (l & 7) << 18 | (a & 63) << 12 | (c & 63) << 6 | m & 63,
	            l -= 65536,
	            e.push((l >> 10) + 55296, (l & 1023) + 56320))))),
	            1E3 <= e.length && (d += String.fromCharCode.apply(null, e),
	            e.length = 0);
	        return d + String.fromCharCode.apply(null, e)
	    }
	    var f;
	    "utf8" === k ? f = b(g) : ("binary" !== k && this.log("Unsupported encoding: " + k),
	    f = d(g));
	    return f
	}
	;
	Runtime.getVariable = function(g) {
	    try {
	        return eval(g)
	    } catch (k) {}
	}
	;
	Runtime.toJson = function(g) {
	    return JSON.stringify(g)
	}
	;
	Runtime.fromJson = function(g) {
	    return JSON.parse(g)
	}
	;
	Runtime.getFunctionName = function(g) {
	    return void 0 === g.name ? (g = /function\s+(\w+)/.exec(g)) && g[1] : g.name
	}
	;
	Runtime.assert = function(g, k) {
	    if (!g)
	        throw this.log("alert", "ASSERTION FAILED:\n" + k),
	        Error(k);
	}
	;
	function BrowserRuntime() {
	    function g(b) {
	        var e = b.length, l, a, c = 0;
	        for (l = 0; l < e; l += 1)
	            a = b.charCodeAt(l),
	            c += 1 + (128 < a) + (2048 < a),
	            55040 < a && 57344 > a && (c += 1,
	            l += 1);
	        return c
	    }
	    function k(b, e, l) {
	        var a = b.length, c, m;
	        e = new Uint8Array(new ArrayBuffer(e));
	        l ? (e[0] = 239,
	        e[1] = 187,
	        e[2] = 191,
	        m = 3) : m = 0;
	        for (l = 0; l < a; l += 1)
	            c = b.charCodeAt(l),
	            128 > c ? (e[m] = c,
	            m += 1) : 2048 > c ? (e[m] = 192 | c >>> 6,
	            e[m + 1] = 128 | c & 63,
	            m += 2) : 55040 >= c || 57344 <= c ? (e[m] = 224 | c >>> 12 & 15,
	            e[m + 1] = 128 | c >>> 6 & 63,
	            e[m + 2] = 128 | c & 63,
	            m += 3) : (l += 1,
	            c = (c - 55296 << 10 | b.charCodeAt(l) - 56320) + 65536,
	            e[m] = 240 | c >>> 18 & 7,
	            e[m + 1] = 128 | c >>> 12 & 63,
	            e[m + 2] = 128 | c >>> 6 & 63,
	            e[m + 3] = 128 | c & 63,
	            m += 4);
	        return e
	    }
	    function d(b) {
	        var e = b.length, l = new Uint8Array(new ArrayBuffer(e)), a;
	        for (a = 0; a < e; a += 1)
	            l[a] = b.charCodeAt(a) & 255;
	        return l
	    }
	    function b(b, e) {
	        var l;
	        void 0 !== e ? l = b : e = b;
	        console.log(e);
	        r.enableAlerts && "alert" === l && alert(e)
	    }
	    function f(b, e, l) {
	        if (0 !== l.status || l.responseText)
	            if (200 === l.status || 0 === l.status) {
	                if (l.response && "string" !== typeof l.response)
	                    "binary" === e ? (l = l.response,
	                    l = new Uint8Array(l)) : l = String(l.response);
	                else if ("binary" === e)
	                    if (null !== l.responseBody && "undefined" !== String(typeof VBArray)) {
	                        l = (new VBArray(l.responseBody)).toArray();
	                        var a = l.length;
	                        e = new Uint8Array(new ArrayBuffer(a));
	                        for (b = 0; b < a; b += 1)
	                            e[b] = l[b];
	                        l = e
	                    } else {
	                        (b = l.getResponseHeader("Content-Length")) && (b = parseInt(b, 10));
	                        if (b && b !== l.responseText.length)
	                            a: {
	                                a = l.responseText;
	                                e = !1;
	                                var c = g(a);
	                                if ("number" === typeof b) {
	                                    if (b !== c && b !== c + 3) {
	                                        a = void 0;
	                                        break a
	                                    }
	                                    e = c + 3 === b;
	                                    c = b
	                                }
	                                a = k(a, c, e)
	                            }
	                        void 0 === a && (a = d(l.responseText));
	                        l = a
	                    }
	                else
	                    l = l.responseText;
	                l = {
	                    err: null,
	                    data: l
	                }
	            } else
	                l = {
	                    err: l.responseText || l.statusText,
	                    data: null
	                };
	        else
	            l = {
	                err: "File " + b + " is empty.",
	                data: null
	            };
	        return l
	    }
	    function n(b, e, l) {
	        var a = new XMLHttpRequest;
	        a.open("GET", b, l);
	        a.overrideMimeType && ("binary" !== e ? a.overrideMimeType("text/plain; charset=" + e) : a.overrideMimeType("text/plain; charset=x-user-defined"));
	        return a
	    }
	    function p(b, e, l) {
	        var a = n(b, e, !0);
	        a.onreadystatechange = function() {
	            var c;
	            4 === a.readyState && (c = f(b, e, a),
	            l(c.err, c.data))
	        }
	        ;
	        try {
	            a.send(null)
	        } catch (c) {
	            l(c.message, null)
	        }
	    }
	    var r = this;
	    this.byteArrayFromString = function(b, e) {
	        var l;
	        "utf8" === e ? l = k(b, g(b), !1) : ("binary" !== e && r.log("unknown encoding: " + e),
	        l = d(b));
	        return l
	    }
	    ;
	    this.byteArrayToString = Runtime.byteArrayToString;
	    this.getVariable = Runtime.getVariable;
	    this.fromJson = Runtime.fromJson;
	    this.toJson = Runtime.toJson;
	    this.readFile = p;
	    this.read = function(b, e, l, a) {
	        p(b, "binary", function(c, m) {
	            var h = null;
	            if (m) {
	                if ("string" === typeof m)
	                    throw "This should not happen.";
	                h = m.subarray(e, e + l)
	            }
	            a(c, h)
	        })
	    }
	    ;
	    this.readFileSync = function(b, e) {
	        var l = n(b, e, !1), a;
	        try {
	            l.send(null);
	            a = f(b, e, l);
	            if (a.err)
	                throw a.err;
	            if (null === a.data)
	                throw "No data read from " + b + ".";
	        } catch (c) {
	            throw c;
	        }
	        return a.data
	    }
	    ;
	    this.writeFile = function(b, e, l) {
	        var a = new XMLHttpRequest, c;
	        a.open("PUT", b, !0);
	        a.onreadystatechange = function() {
	            4 === a.readyState && (0 !== a.status || a.responseText ? 200 <= a.status && 300 > a.status || 0 === a.status ? l(null) : l("Status " + String(a.status) + ": " + a.responseText || a.statusText) : l("File " + b + " is empty."))
	        }
	        ;
	        c = e.buffer && !a.sendAsBinary ? e.buffer : r.byteArrayToString(e, "binary");
	        try {
	            a.sendAsBinary ? a.sendAsBinary(c) : a.send(c)
	        } catch (m) {
	            r.log("HUH? " + m + " " + e),
	            l(m.message)
	        }
	    }
	    ;
	    this.deleteFile = function(b, e) {
	        var l = new XMLHttpRequest;
	        l.open("DELETE", b, !0);
	        l.onreadystatechange = function() {
	            4 === l.readyState && (200 > l.status && 300 <= l.status ? e(l.responseText) : e(null))
	        }
	        ;
	        l.send(null)
	    }
	    ;
	    this.loadXML = function(b, e) {
	        var l = new XMLHttpRequest;
	        l.open("GET", b, !0);
	        l.overrideMimeType && l.overrideMimeType("text/xml");
	        l.onreadystatechange = function() {
	            4 === l.readyState && (0 !== l.status || l.responseText ? 200 === l.status || 0 === l.status ? e(null, l.responseXML) : e(l.responseText, null) : e("File " + b + " is empty.", null))
	        }
	        ;
	        try {
	            l.send(null)
	        } catch (a) {
	            e(a.message, null)
	        }
	    }
	    ;
	    this.log = b;
	    this.enableAlerts = !0;
	    this.assert = Runtime.assert;
	    this.setTimeout = function(b, e) {
	        return setTimeout(function() {
	            b()
	        }, e)
	    }
	    ;
	    this.clearTimeout = function(b) {
	        clearTimeout(b)
	    }
	    ;
	    this.libraryPaths = function() {
	        return ["lib"]
	    }
	    ;
	    this.setCurrentDirectory = function() {}
	    ;
	    this.currentDirectory = function() {
	        return ""
	    }
	    ;
	    this.type = function() {
	        return "BrowserRuntime"
	    }
	    ;
	    this.getDOMImplementation = function() {
	        return window.document.implementation
	    }
	    ;
	    this.parseXML = function(b) {
	        return (new DOMParser).parseFromString(b, "text/xml")
	    }
	    ;
	    this.exit = function(d) {
	        b("Calling exit with code " + String(d) + ", but exit() is not implemented.")
	    }
	    ;
	    this.getWindow = function() {
	        return window
	    }
	    ;
	    this.requestAnimationFrame = function(b) {
	        var e = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame
	          , l = 0;
	        if (e)
	            e.bind(window),
	            l = e(b);
	        else
	            return setTimeout(b, 15);
	        return l
	    }
	    ;
	    this.cancelAnimationFrame = function(b) {
	        var e = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame;
	        e ? (e.bind(window),
	        e(b)) : clearTimeout(b)
	    }
	}
	function NodeJSRuntime() {
	    function g(b) {
	        var e = b.length, l, a = new Uint8Array(new ArrayBuffer(e));
	        for (l = 0; l < e; l += 1)
	            a[l] = b[l];
	        return a
	    }
	    function k(d, e, l) {
	        function a(a, m) {
	            if (a)
	                return l(a, null);
	            if (!m)
	                return l("No data for " + d + ".", null);
	            if ("string" === typeof m)
	                return l(a, m);
	            l(a, g(m))
	        }
	        d = f.resolve(n, d);
	        "binary" !== e ? b.readFile(d, e, a) : b.readFile(d, null, a)
	    }
	    var d = this, b = require("fs"), f = require("path"), n = "", p, r;
	    this.byteArrayFromString = function(b, e) {
	        var l = new Buffer(b,e), a, c = l.length, m = new Uint8Array(new ArrayBuffer(c));
	        for (a = 0; a < c; a += 1)
	            m[a] = l[a];
	        return m
	    }
	    ;
	    this.byteArrayToString = Runtime.byteArrayToString;
	    this.getVariable = Runtime.getVariable;
	    this.fromJson = Runtime.fromJson;
	    this.toJson = Runtime.toJson;
	    this.readFile = k;
	    this.loadXML = function(b, e) {
	        k(b, "utf-8", function(l, a) {
	            if (l)
	                return e(l, null);
	            if (!a)
	                return e("No data for " + b + ".", null);
	            e(null, d.parseXML(a))
	        })
	    }
	    ;
	    this.writeFile = function(d, e, l) {
	        e = new Buffer(e);
	        d = f.resolve(n, d);
	        b.writeFile(d, e, "binary", function(a) {
	            l(a || null)
	        })
	    }
	    ;
	    this.deleteFile = function(d, e) {
	        d = f.resolve(n, d);
	        b.unlink(d, e)
	    }
	    ;
	    this.read = function(d, e, l, a) {
	        d = f.resolve(n, d);
	        b.open(d, "r+", 666, function(c, m) {
	            if (c)
	                a(c, null);
	            else {
	                var h = new Buffer(l);
	                b.read(m, h, 0, l, e, function(c) {
	                    b.close(m);
	                    a(c, g(h))
	                })
	            }
	        })
	    }
	    ;
	    this.readFileSync = function(d, e) {
	        var l;
	        l = b.readFileSync(d, "binary" === e ? null : e);
	        if (null === l)
	            throw "File " + d + " could not be read.";
	        "binary" === e && (l = g(l));
	        return l
	    }
	    ;
	    this.log = function(b, e) {
	        var l;
	        void 0 !== e ? l = b : e = b;
	        "alert" === l && process.stderr.write("\n!!!!! ALERT !!!!!\n");
	        process.stderr.write(e + "\n");
	        "alert" === l && process.stderr.write("!!!!! ALERT !!!!!\n")
	    }
	    ;
	    this.assert = Runtime.assert;
	    this.setTimeout = function(b, e) {
	        return setTimeout(function() {
	            b()
	        }, e)
	    }
	    ;
	    this.clearTimeout = function(b) {
	        clearTimeout(b)
	    }
	    ;
	    this.libraryPaths = function() {
	        return [__dirname]
	    }
	    ;
	    this.setCurrentDirectory = function(b) {
	        n = b
	    }
	    ;
	    this.currentDirectory = function() {
	        return n
	    }
	    ;
	    this.type = function() {
	        return "NodeJSRuntime"
	    }
	    ;
	    this.getDOMImplementation = function() {
	        return r
	    }
	    ;
	    this.parseXML = function(b) {
	        return p.parseFromString(b, "text/xml")
	    }
	    ;
	    this.exit = process.exit;
	    this.getWindow = function() {
	        return null
	    }
	    ;
	    this.requestAnimationFrame = function(b) {
	        return setTimeout(b, 15)
	    }
	    ;
	    this.cancelAnimationFrame = function(b) {
	        clearTimeout(b)
	    }
	    ;
	    p = new (require("xmldom").DOMParser);
	    r = d.parseXML("<a/>").implementation
	}
	function RhinoRuntime() {
	    var g = this, k = {}, d = k.javax.xml.parsers.DocumentBuilderFactory.newInstance(), b, f, n = "";
	    d.setValidating(!1);
	    d.setNamespaceAware(!0);
	    d.setExpandEntityReferences(!1);
	    d.setSchema(null);
	    f = k.org.xml.sax.EntityResolver({
	        resolveEntity: function(b, d) {
	            var f = new k.java.io.FileReader(d);
	            return new k.org.xml.sax.InputSource(f)
	        }
	    });
	    b = d.newDocumentBuilder();
	    b.setEntityResolver(f);
	    this.byteArrayFromString = function(b, d) {
	        var f, e = b.length, l = new Uint8Array(new ArrayBuffer(e));
	        for (f = 0; f < e; f += 1)
	            l[f] = b.charCodeAt(f) & 255;
	        return l
	    }
	    ;
	    this.byteArrayToString = Runtime.byteArrayToString;
	    this.getVariable = Runtime.getVariable;
	    this.fromJson = Runtime.fromJson;
	    this.toJson = Runtime.toJson;
	    this.loadXML = function(d, f) {
	        var n = new k.java.io.File(d)
	          , e = null;
	        try {
	            e = b.parse(n)
	        } catch (l) {
	            return print(l),
	            f(l, null)
	        }
	        f(null, e)
	    }
	    ;
	    this.readFile = function(b, d, f) {
	        n && (b = n + "/" + b);
	        var e = new k.java.io.File(b)
	          , l = "binary" === d ? "latin1" : d;
	        e.isFile() ? ((b = readFile(b, l)) && "binary" === d && (b = g.byteArrayFromString(b, "binary")),
	        f(null, b)) : f(b + " is not a file.", null)
	    }
	    ;
	    this.writeFile = function(b, d, f) {
	        n && (b = n + "/" + b);
	        b = new k.java.io.FileOutputStream(b);
	        var e, l = d.length;
	        for (e = 0; e < l; e += 1)
	            b.write(d[e]);
	        b.close();
	        f(null)
	    }
	    ;
	    this.deleteFile = function(b, d) {
	        n && (b = n + "/" + b);
	        var f = new k.java.io.File(b)
	          , e = b + Math.random()
	          , e = new k.java.io.File(e);
	        f.rename(e) ? (e.deleteOnExit(),
	        d(null)) : d("Could not delete " + b)
	    }
	    ;
	    this.read = function(b, d, f, e) {
	        n && (b = n + "/" + b);
	        var l;
	        l = b;
	        var a = "binary";
	        (new k.java.io.File(l)).isFile() ? ("binary" === a && (a = "latin1"),
	        l = readFile(l, a)) : l = null;
	        l ? e(null, this.byteArrayFromString(l.substring(d, d + f), "binary")) : e("Cannot read " + b, null)
	    }
	    ;
	    this.readFileSync = function(b, d) {
	        if (!d)
	            return "";
	        var f = readFile(b, d);
	        if (null === f)
	            throw "File could not be read.";
	        return f
	    }
	    ;
	    this.log = function(b, d) {
	        var f;
	        void 0 !== d ? f = b : d = b;
	        "alert" === f && print("\n!!!!! ALERT !!!!!");
	        print(d);
	        "alert" === f && print("!!!!! ALERT !!!!!")
	    }
	    ;
	    this.assert = Runtime.assert;
	    this.setTimeout = function(b) {
	        b();
	        return 0
	    }
	    ;
	    this.clearTimeout = function() {}
	    ;
	    this.libraryPaths = function() {
	        return ["lib"]
	    }
	    ;
	    this.setCurrentDirectory = function(b) {
	        n = b
	    }
	    ;
	    this.currentDirectory = function() {
	        return n
	    }
	    ;
	    this.type = function() {
	        return "RhinoRuntime"
	    }
	    ;
	    this.getDOMImplementation = function() {
	        return b.getDOMImplementation()
	    }
	    ;
	    this.parseXML = function(d) {
	        d = new k.java.io.StringReader(d);
	        d = new k.org.xml.sax.InputSource(d);
	        return b.parse(d)
	    }
	    ;
	    this.exit = quit;
	    this.getWindow = function() {
	        return null
	    }
	    ;
	    this.requestAnimationFrame = function(b) {
	        b();
	        return 0
	    }
	    ;
	    this.cancelAnimationFrame = function() {}
	}
	Runtime.create = function() {
	    return "undefined" !== String(typeof window) ? new BrowserRuntime : "undefined" !== String(typeof require) ? new NodeJSRuntime : new RhinoRuntime
	}
	;
	var runtime = Runtime.create()
	  , core = {}
	  , gui = {}
	  , xmldom = {}
	  , odf = {}
	  , ops = {}
	  , webodf = {};
	(function() {
	    webodf.Version = "undefined" !== String(typeof webodf_version) ? webodf_version : "From Source"
	}
	)();
	(function() {
	    function g(b, d, e) {
	        var l = b + "/manifest.json", a, c;
	        runtime.log("Loading manifest: " + l);
	        try {
	            a = runtime.readFileSync(l, "utf-8")
	        } catch (m) {
	            if (e)
	                runtime.log("No loadable manifest found.");
	            else
	                throw console.log(String(m)),
	                m;
	            return
	        }
	        e = JSON.parse(a);
	        for (c in e)
	            e.hasOwnProperty(c) && (d[c] = {
	                dir: b,
	                deps: e[c]
	            })
	    }
	    function k(b, d, e) {
	        function l(h) {
	            if (!m[h] && !e(h)) {
	                if (c[h])
	                    throw "Circular dependency detected for " + h + ".";
	                c[h] = !0;
	                if (!d[h])
	                    throw "Missing dependency information for class " + h + ".";
	                var b = d[h], f = b.deps, n, r = f.length;
	                for (n = 0; n < r; n += 1)
	                    l(f[n]);
	                c[h] = !1;
	                m[h] = !0;
	                a.push(b.dir + "/" + h.replace(".", "/") + ".js")
	            }
	        }
	        var a = []
	          , c = {}
	          , m = {};
	        b.forEach(l);
	        return a
	    }
	    function d(b, d) {
	        return d + ("\n//# sourceURL=" + b)
	    }
	    function b(b) {
	        var f, e;
	        for (f = 0; f < b.length; f += 1)
	            e = runtime.readFileSync(b[f], "utf-8"),
	            e = d(b[f], e),
	            eval(e)
	    }
	    function f(b) {
	        b = b.split(".");
	        var d, e = p, l = b.length;
	        for (d = 0; d < l; d += 1) {
	            if (!e.hasOwnProperty(b[d]))
	                return !1;
	            e = e[b[d]]
	        }
	        return !0
	    }
	    var n, p = {
	        core: core,
	        gui: gui,
	        xmldom: xmldom,
	        odf: odf,
	        ops: ops
	    };
	    runtime.loadClasses = function(d, p) {
	        if (IS_COMPILED_CODE || 0 === d.length)
	            return p && p();
	        var e;
	        if (!(e = n)) {
	            e = [];
	            var l = runtime.libraryPaths(), a;
	            runtime.currentDirectory() && -1 === l.indexOf(runtime.currentDirectory()) && g(runtime.currentDirectory(), e, !0);
	            for (a = 0; a < l.length; a += 1)
	                g(l[a], e)
	        }
	        n = e;
	        d = k(d, n, f);
	        if (0 === d.length)
	            return p && p();
	        if ("BrowserRuntime" === runtime.type() && p) {
	            e = d;
	            l = document.currentScript || document.documentElement.lastChild;
	            a = document.createDocumentFragment();
	            var c, m;
	            for (m = 0; m < e.length; m += 1)
	                c = document.createElement("script"),
	                c.type = "text/javascript",
	                c.charset = "utf-8",
	                c.async = !1,
	                c.setAttribute("src", e[m]),
	                a.appendChild(c);
	            p && (c.onload = p);
	            l.parentNode.insertBefore(a, l)
	        } else
	            b(d),
	            p && p()
	    }
	    ;
	    runtime.loadClass = function(b, d) {
	        runtime.loadClasses([b], d)
	    }
	}
	)();
	(function() {
	    var g = function(g) {
	        return g
	    };
	    runtime.getTranslator = function() {
	        return g
	    }
	    ;
	    runtime.setTranslator = function(k) {
	        g = k
	    }
	    ;
	    runtime.tr = function(k) {
	        var d = g(k);
	        return d && "string" === String(typeof d) ? d : k
	    }
	}
	)();
	(function(g) {
	    function k(d) {
	        if (d.length) {
	            var b = d[0];
	            runtime.readFile(b, "utf8", function(f, n) {
	                function g() {
	                    var b;
	                    (b = eval(k)) && runtime.exit(b)
	                }
	                var r = ""
	                  , r = b.lastIndexOf("/")
	                  , k = n
	                  , r = -1 !== r ? b.substring(0, r) : ".";
	                runtime.setCurrentDirectory(r);
	                f ? (runtime.log(f),
	                runtime.exit(1)) : null === k ? (runtime.log("No code found for " + b),
	                runtime.exit(1)) : g.apply(null, d)
	            })
	        }
	    }
	    g = g ? Array.prototype.slice.call(g) : [];
	    "NodeJSRuntime" === runtime.type() ? k(process.argv.slice(2)) : "RhinoRuntime" === runtime.type() ? k(g) : k(g.slice(1))
	}
	)("undefined" !== String(typeof arguments) && arguments);
	(function() {
	    core.Async = function() {
	        return {
	            forEach: function(g, k, d) {
	                function b(b) {
	                    p !== n && (b ? (p = n,
	                    d(b)) : (p += 1,
	                    p === n && d(null)))
	                }
	                var f, n = g.length, p = 0;
	                for (f = 0; f < n; f += 1)
	                    k(g[f], b)
	            },
	            destroyAll: function(g, k) {
	                function d(b, f) {
	                    if (f)
	                        k(f);
	                    else if (b < g.length)
	                        g[b](function(f) {
	                            d(b + 1, f)
	                        });
	                    else
	                        k()
	                }
	                d(0, void 0)
	            }
	        }
	    }()
	}
	)();
	function makeBase64() {
	    function g(a) {
	        var c, m = a.length, h = new Uint8Array(new ArrayBuffer(m));
	        for (c = 0; c < m; c += 1)
	            h[c] = a.charCodeAt(c) & 255;
	        return h
	    }
	    function k(a) {
	        var c, m = "", h, b = a.length - 2;
	        for (h = 0; h < b; h += 3)
	            c = a[h] << 16 | a[h + 1] << 8 | a[h + 2],
	            m += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[c >>> 18],
	            m += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[c >>> 12 & 63],
	            m += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[c >>> 6 & 63],
	            m += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[c & 63];
	        h === b + 1 ? (c = a[h] << 4,
	        m += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[c >>> 6],
	        m += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[c & 63],
	        m += "==") : h === b && (c = a[h] << 10 | a[h + 1] << 2,
	        m += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[c >>> 12],
	        m += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[c >>> 6 & 63],
	        m += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[c & 63],
	        m += "=");
	        return m
	    }
	    function d(a) {
	        a = a.replace(/[^A-Za-z0-9+\/]+/g, "");
	        var c = a.length, m = new Uint8Array(new ArrayBuffer(3 * c)), b = a.length % 4, d = 0, l, e;
	        for (l = 0; l < c; l += 4)
	            e = (h[a.charAt(l)] || 0) << 18 | (h[a.charAt(l + 1)] || 0) << 12 | (h[a.charAt(l + 2)] || 0) << 6 | (h[a.charAt(l + 3)] || 0),
	            m[d] = e >> 16,
	            m[d + 1] = e >> 8 & 255,
	            m[d + 2] = e & 255,
	            d += 3;
	        c = 3 * c - [0, 0, 2, 1][b];
	        return m.subarray(0, c)
	    }
	    function b(a) {
	        var c, m, h = a.length, b = 0, d = new Uint8Array(new ArrayBuffer(3 * h));
	        for (c = 0; c < h; c += 1)
	            m = a[c],
	            128 > m ? d[b++] = m : (2048 > m ? d[b++] = 192 | m >>> 6 : (d[b++] = 224 | m >>> 12 & 15,
	            d[b++] = 128 | m >>> 6 & 63),
	            d[b++] = 128 | m & 63);
	        return d.subarray(0, b)
	    }
	    function f(a) {
	        var c, m, h, b, d = a.length, l = new Uint8Array(new ArrayBuffer(d)), e = 0;
	        for (c = 0; c < d; c += 1)
	            m = a[c],
	            128 > m ? l[e++] = m : (c += 1,
	            h = a[c],
	            224 > m ? l[e++] = (m & 31) << 6 | h & 63 : (c += 1,
	            b = a[c],
	            l[e++] = (m & 15) << 12 | (h & 63) << 6 | b & 63));
	        return l.subarray(0, e)
	    }
	    function n(a) {
	        return k(g(a))
	    }
	    function p(a) {
	        return String.fromCharCode.apply(String, d(a))
	    }
	    function r(a) {
	        return f(g(a))
	    }
	    function q(a) {
	        a = f(a);
	        for (var c = "", m = 0; m < a.length; )
	            c += String.fromCharCode.apply(String, a.subarray(m, m + 45E3)),
	            m += 45E3;
	        return c
	    }
	    function e(a, c, m) {
	        var h, b, d, l = "";
	        for (d = c; d < m; d += 1)
	            c = a.charCodeAt(d) & 255,
	            128 > c ? l += String.fromCharCode(c) : (d += 1,
	            h = a.charCodeAt(d) & 255,
	            224 > c ? l += String.fromCharCode((c & 31) << 6 | h & 63) : (d += 1,
	            b = a.charCodeAt(d) & 255,
	            l += String.fromCharCode((c & 15) << 12 | (h & 63) << 6 | b & 63)));
	        return l
	    }
	    function l(a, c) {
	        function m() {
	            var d = b + 1E5;
	            d > a.length && (d = a.length);
	            h += e(a, b, d);
	            b = d;
	            d = b === a.length;
	            c(h, d) && !d && runtime.setTimeout(m, 0)
	        }
	        var h = ""
	          , b = 0;
	        1E5 > a.length ? c(e(a, 0, a.length), !0) : ("string" !== typeof a && (a = a.slice()),
	        m())
	    }
	    function a(a) {
	        return b(g(a))
	    }
	    function c(a) {
	        return String.fromCharCode.apply(String, b(a))
	    }
	    function m(a) {
	        return String.fromCharCode.apply(String, b(g(a)))
	    }
	    var h = function(a) {
	        var c = {}, m, h;
	        m = 0;
	        for (h = a.length; m < h; m += 1)
	            c[a.charAt(m)] = m;
	        return c
	    }("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), y, x, z = runtime.getWindow(), w, v;
	    z && z.btoa ? (w = z.btoa,
	    y = function(a) {
	        return w(m(a))
	    }
	    ) : (w = n,
	    y = function(c) {
	        return k(a(c))
	    }
	    );
	    z && z.atob ? (v = z.atob,
	    x = function(a) {
	        a = v(a);
	        return e(a, 0, a.length)
	    }
	    ) : (v = p,
	    x = function(a) {
	        return q(d(a))
	    }
	    );
	    core.Base64 = function() {
	        this.convertByteArrayToBase64 = this.convertUTF8ArrayToBase64 = k;
	        this.convertBase64ToByteArray = this.convertBase64ToUTF8Array = d;
	        this.convertUTF16ArrayToByteArray = this.convertUTF16ArrayToUTF8Array = b;
	        this.convertByteArrayToUTF16Array = this.convertUTF8ArrayToUTF16Array = f;
	        this.convertUTF8StringToBase64 = n;
	        this.convertBase64ToUTF8String = p;
	        this.convertUTF8StringToUTF16Array = r;
	        this.convertByteArrayToUTF16String = this.convertUTF8ArrayToUTF16String = q;
	        this.convertUTF8StringToUTF16String = l;
	        this.convertUTF16StringToByteArray = this.convertUTF16StringToUTF8Array = a;
	        this.convertUTF16ArrayToUTF8String = c;
	        this.convertUTF16StringToUTF8String = m;
	        this.convertUTF16StringToBase64 = y;
	        this.convertBase64ToUTF16String = x;
	        this.fromBase64 = p;
	        this.toBase64 = n;
	        this.atob = v;
	        this.btoa = w;
	        this.utob = m;
	        this.btou = l;
	        this.encode = y;
	        this.encodeURI = function(a) {
	            return y(a).replace(/[+\/]/g, function(a) {
	                return "+" === a ? "-" : "_"
	            }).replace(/\\=+$/, "")
	        }
	        ;
	        this.decode = function(a) {
	            return x(a.replace(/[\-_]/g, function(a) {
	                return "-" === a ? "+" : "/"
	            }))
	        }
	        ;
	        return this
	    }
	    ;
	    return core.Base64
	}
	core.Base64 = makeBase64();
	core.CSSUnits = function() {
	    var g = this
	      , k = {
	        "in": 1,
	        cm: 2.54,
	        mm: 25.4,
	        pt: 72,
	        pc: 12,
	        px: 96
	    };
	    this.convert = function(d, b, f) {
	        return d * k[f] / k[b]
	    }
	    ;
	    this.convertMeasure = function(d, b) {
	        var f, n;
	        d && b && (f = parseFloat(d),
	        n = d.replace(f.toString(), ""),
	        f = g.convert(f, n, b));
	        return f
	    }
	    ;
	    this.getUnits = function(d) {
	        return d.substr(d.length - 2, d.length)
	    }
	}
	;
	(function() {
	    function g() {
	        var b, f, n, g, r, k, e, l, a;
	        void 0 === d && (f = (b = runtime.getWindow()) && b.document,
	        k = f.documentElement,
	        e = f.body,
	        d = {
	            rangeBCRIgnoresElementBCR: !1,
	            unscaledRangeClientRects: !1,
	            elementBCRIgnoresBodyScroll: !1
	        },
	        f && (g = f.createElement("div"),
	        g.style.position = "absolute",
	        g.style.left = "-99999px",
	        g.style.transform = "scale(2)",
	        g.style["-webkit-transform"] = "scale(2)",
	        r = f.createElement("div"),
	        g.appendChild(r),
	        e.appendChild(g),
	        b = f.createRange(),
	        b.selectNode(r),
	        d.rangeBCRIgnoresElementBCR = 0 === b.getClientRects().length,
	        r.appendChild(f.createTextNode("Rect transform test")),
	        f = r.getBoundingClientRect(),
	        n = b.getBoundingClientRect(),
	        d.unscaledRangeClientRects = 2 < Math.abs(f.height - n.height),
	        g.style.transform = "",
	        g.style["-webkit-transform"] = "",
	        f = k.style.overflow,
	        n = e.style.overflow,
	        l = e.style.height,
	        a = e.scrollTop,
	        k.style.overflow = "visible",
	        e.style.overflow = "visible",
	        e.style.height = "200%",
	        e.scrollTop = e.scrollHeight,
	        d.elementBCRIgnoresBodyScroll = b.getBoundingClientRect().top !== r.getBoundingClientRect().top,
	        e.scrollTop = a,
	        e.style.height = l,
	        e.style.overflow = n,
	        k.style.overflow = f,
	        b.detach(),
	        e.removeChild(g),
	        b = Object.keys(d).map(function(a) {
	            return a + ":" + String(d[a])
	        }).join(", "),
	        runtime.log("Detected browser quirks - " + b)));
	        return d
	    }
	    function k(b, d, n) {
	        for (b = b ? b.firstElementChild : null; b; ) {
	            if (b.localName === n && b.namespaceURI === d)
	                return b;
	            b = b.nextElementSibling
	        }
	        return null
	    }
	    var d;
	    core.DomUtilsImpl = function() {
	        function b(a, c) {
	            for (var b = 0, d; a.parentNode !== c; )
	                runtime.assert(null !== a.parentNode, "parent is null"),
	                a = a.parentNode;
	            for (d = c.firstChild; d !== a; )
	                b += 1,
	                d = d.nextSibling;
	            return b
	        }
	        function d(a, c) {
	            return 0 >= a.compareBoundaryPoints(Range.START_TO_START, c) && 0 <= a.compareBoundaryPoints(Range.END_TO_END, c)
	        }
	        function n(a, c) {
	            return 0 >= a.compareBoundaryPoints(Range.END_TO_START, c) && 0 <= a.compareBoundaryPoints(Range.START_TO_END, c)
	        }
	        function p(a, c) {
	            var b = null;
	            a.nodeType === Node.TEXT_NODE && (0 === a.length ? (a.parentNode.removeChild(a),
	            c.nodeType === Node.TEXT_NODE && (b = c)) : (c.nodeType === Node.TEXT_NODE && (a.appendData(c.data),
	            c.parentNode.removeChild(c)),
	            b = a));
	            return b
	        }
	        function r(a) {
	            for (var c = a.parentNode; a.firstChild; )
	                c.insertBefore(a.firstChild, a);
	            c.removeChild(a);
	            return c
	        }
	        function q(a, c) {
	            var b = a.parentNode, d = a.firstChild, l = c(a), e;
	            if (l === NodeFilter.FILTER_SKIP)
	                return b;
	            for (; d; )
	                e = d.nextSibling,
	                q(d, c),
	                d = e;
	            b && l === NodeFilter.FILTER_REJECT && r(a);
	            return b
	        }
	        function e(a, c) {
	            return a === c || Boolean(a.compareDocumentPosition(c) & Node.DOCUMENT_POSITION_CONTAINED_BY)
	        }
	        function l(a, c) {
	            return g().unscaledRangeClientRects ? a : a / c
	        }
	        function a(c, h, b) {
	            Object.keys(h).forEach(function(d) {
	                var l = d.split(":")
	                  , e = l[1]
	                  , f = b(l[0])
	                  , l = h[d]
	                  , n = typeof l;
	                "object" === n ? Object.keys(l).length && (d = f ? c.getElementsByTagNameNS(f, e)[0] || c.ownerDocument.createElementNS(f, d) : c.getElementsByTagName(e)[0] || c.ownerDocument.createElement(d),
	                c.appendChild(d),
	                a(d, l, b)) : f && (runtime.assert("number" === n || "string" === n, "attempting to map unsupported type '" + n + "' (key: " + d + ")"),
	                c.setAttributeNS(f, d, String(l)))
	            })
	        }
	        var c = null;
	        this.splitBoundaries = function(a) {
	            var c, d = [], l, e, f;
	            if (a.startContainer.nodeType === Node.TEXT_NODE || a.endContainer.nodeType === Node.TEXT_NODE) {
	                l = a.endContainer;
	                e = a.endContainer.nodeType !== Node.TEXT_NODE ? a.endOffset === a.endContainer.childNodes.length : !1;
	                f = a.endOffset;
	                c = a.endContainer;
	                if (f < c.childNodes.length)
	                    for (c = c.childNodes.item(f),
	                    f = 0; c.firstChild; )
	                        c = c.firstChild;
	                else
	                    for (; c.lastChild; )
	                        c = c.lastChild,
	                        f = c.nodeType === Node.TEXT_NODE ? c.textContent.length : c.childNodes.length;
	                c === l && (l = null);
	                a.setEnd(c, f);
	                f = a.endContainer;
	                0 !== a.endOffset && f.nodeType === Node.TEXT_NODE && (c = f,
	                a.endOffset !== c.length && (d.push(c.splitText(a.endOffset)),
	                d.push(c)));
	                f = a.startContainer;
	                0 !== a.startOffset && f.nodeType === Node.TEXT_NODE && (c = f,
	                a.startOffset !== c.length && (f = c.splitText(a.startOffset),
	                d.push(c),
	                d.push(f),
	                a.setStart(f, 0)));
	                if (null !== l) {
	                    for (f = a.endContainer; f.parentNode && f.parentNode !== l; )
	                        f = f.parentNode;
	                    e = e ? l.childNodes.length : b(f, l);
	                    a.setEnd(l, e)
	                }
	            }
	            return d
	        }
	        ;
	        this.containsRange = d;
	        this.rangesIntersect = n;
	        this.rangeIntersection = function(a, c) {
	            var b;
	            n(a, c) && (b = a.cloneRange(),
	            -1 === a.compareBoundaryPoints(Range.START_TO_START, c) && b.setStart(c.startContainer, c.startOffset),
	            1 === a.compareBoundaryPoints(Range.END_TO_END, c) && b.setEnd(c.endContainer, c.endOffset));
	            return b
	        }
	        ;
	        this.getNodesInRange = function(a, c, b) {
	            var d = []
	              , l = a.commonAncestorContainer
	              , l = l.nodeType === Node.TEXT_NODE ? l.parentNode : l;
	            b = a.startContainer.ownerDocument.createTreeWalker(l, b, c, !1);
	            var e, f;
	            a.endContainer.childNodes[a.endOffset - 1] ? (e = a.endContainer.childNodes[a.endOffset - 1],
	            f = Node.DOCUMENT_POSITION_PRECEDING | Node.DOCUMENT_POSITION_CONTAINED_BY) : (e = a.endContainer,
	            f = Node.DOCUMENT_POSITION_PRECEDING);
	            if (a.startContainer.childNodes[a.startOffset])
	                a = a.startContainer.childNodes[a.startOffset],
	                b.currentNode = a;
	            else {
	                var n = a.startContainer;
	                a.startOffset === (n.nodeType === Node.TEXT_NODE ? n.length : n.childNodes.length) ? (a = a.startContainer,
	                b.currentNode = a,
	                b.lastChild(),
	                a = b.nextNode()) : (a = a.startContainer,
	                b.currentNode = a)
	            }
	            if (a) {
	                a = b.currentNode;
	                if (a !== l)
	                    for (a = a.parentNode; a && a !== l; )
	                        c(a) === NodeFilter.FILTER_REJECT && (b.currentNode = a),
	                        a = a.parentNode;
	                a = b.currentNode;
	                switch (c(a)) {
	                case NodeFilter.FILTER_REJECT:
	                    for (a = b.nextSibling(); !a && b.parentNode(); )
	                        a = b.nextSibling();
	                    break;
	                case NodeFilter.FILTER_SKIP:
	                    a = b.nextNode()
	                }
	                for (; a; ) {
	                    c = e.compareDocumentPosition(a);
	                    if (0 !== c && 0 === (c & f))
	                        break;
	                    d.push(a);
	                    a = b.nextNode()
	                }
	            }
	            return d
	        }
	        ;
	        this.normalizeTextNodes = function(a) {
	            a && a.nextSibling && (a = p(a, a.nextSibling));
	            a && a.previousSibling && p(a.previousSibling, a)
	        }
	        ;
	        this.rangeContainsNode = function(a, c) {
	            var b = c.ownerDocument.createRange(), l = c.ownerDocument.createRange(), e;
	            b.setStart(a.startContainer, a.startOffset);
	            b.setEnd(a.endContainer, a.endOffset);
	            l.selectNodeContents(c);
	            e = d(b, l);
	            b.detach();
	            l.detach();
	            return e
	        }
	        ;
	        this.mergeIntoParent = r;
	        this.removeUnwantedNodes = q;
	        this.removeAllChildNodes = function(a) {
	            for (; a.firstChild; )
	                a.removeChild(a.firstChild)
	        }
	        ;
	        this.getElementsByTagNameNS = function(a, c, b) {
	            var d = [];
	            a = a.getElementsByTagNameNS(c, b);
	            d.length = b = a.length;
	            for (c = 0; c < b; c += 1)
	                d[c] = a.item(c);
	            return d
	        }
	        ;
	        this.getElementsByTagName = function(a, c) {
	            var b = [], d, l, e;
	            d = a.getElementsByTagName(c);
	            b.length = e = d.length;
	            for (l = 0; l < e; l += 1)
	                b[l] = d.item(l);
	            return b
	        }
	        ;
	        this.containsNode = function(a, c) {
	            return a === c || a.contains(c)
	        }
	        ;
	        this.comparePoints = function(a, c, d, l) {
	            if (a === d)
	                return l - c;
	            var e = a.compareDocumentPosition(d);
	            2 === e ? e = -1 : 4 === e ? e = 1 : 10 === e ? (c = b(a, d),
	            e = c < l ? 1 : -1) : (l = b(d, a),
	            e = l < c ? -1 : 1);
	            return e
	        }
	        ;
	        this.adaptRangeDifferenceToZoomLevel = l;
	        this.translateRect = function(a, c, b) {
	            return {
	                top: l(a.top - c.top, b),
	                left: l(a.left - c.left, b),
	                bottom: l(a.bottom - c.top, b),
	                right: l(a.right - c.left, b),
	                width: l(a.width, b),
	                height: l(a.height, b)
	            }
	        }
	        ;
	        this.getBoundingClientRect = function(a) {
	            var b = a.ownerDocument
	              , d = g()
	              , l = b.body;
	            if ((!1 === d.unscaledRangeClientRects || d.rangeBCRIgnoresElementBCR) && a.nodeType === Node.ELEMENT_NODE)
	                return a = a.getBoundingClientRect(),
	                d.elementBCRIgnoresBodyScroll ? {
	                    left: a.left + l.scrollLeft,
	                    right: a.right + l.scrollLeft,
	                    top: a.top + l.scrollTop,
	                    bottom: a.bottom + l.scrollTop,
	                    width: a.width,
	                    height: a.height
	                } : a;
	            var e;
	            c ? e = c : c = e = b.createRange();
	            d = e;
	            d.selectNode(a);
	            return d.getBoundingClientRect()
	        }
	        ;
	        this.mapKeyValObjOntoNode = function(a, c, b) {
	            Object.keys(c).forEach(function(d) {
	                var l = d.split(":")
	                  , e = l[1]
	                  , l = b(l[0])
	                  , f = c[d];
	                l ? (e = a.getElementsByTagNameNS(l, e)[0],
	                e || (e = a.ownerDocument.createElementNS(l, d),
	                a.appendChild(e)),
	                e.textContent = f) : runtime.log("Key ignored: " + d)
	            })
	        }
	        ;
	        this.removeKeyElementsFromNode = function(a, c, b) {
	            c.forEach(function(c) {
	                var d = c.split(":")
	                  , h = d[1];
	                (d = b(d[0])) ? (h = a.getElementsByTagNameNS(d, h)[0]) ? h.parentNode.removeChild(h) : runtime.log("Element for " + c + " not found.") : runtime.log("Property Name ignored: " + c)
	            })
	        }
	        ;
	        this.getKeyValRepresentationOfNode = function(a, c) {
	            for (var b = {}, d = a.firstElementChild, l; d; ) {
	                if (l = c(d.namespaceURI))
	                    b[l + ":" + d.localName] = d.textContent;
	                d = d.nextElementSibling
	            }
	            return b
	        }
	        ;
	        this.mapObjOntoNode = a;
	        this.cloneEvent = function(a) {
	            var c = Object.create(null);
	            Object.keys(a.constructor.prototype).forEach(function(b) {
	                c[b] = a[b]
	            });
	            c.prototype = a.constructor.prototype;
	            return c
	        }
	        ;
	        this.getDirectChild = k;
	        (function(a) {
	            var c, b;
	            b = runtime.getWindow();
	            null !== b && (c = b.navigator.appVersion.toLowerCase(),
	            b = -1 === c.indexOf("chrome") && (-1 !== c.indexOf("applewebkit") || -1 !== c.indexOf("safari")),
	            c = -1 !== c.indexOf("msie") || -1 !== c.indexOf("trident"),
	            b || c) && (a.containsNode = e)
	        }
	        )(this)
	    }
	    ;
	    core.DomUtils = new core.DomUtilsImpl
	}
	)();
	core.Cursor = function(g, k) {
	    function d(a) {
	        a.parentNode && (r.push(a.previousSibling),
	        r.push(a.nextSibling),
	        a.parentNode.removeChild(a))
	    }
	    function b(a, c, b) {
	        if (c.nodeType === Node.TEXT_NODE) {
	            runtime.assert(Boolean(c), "putCursorIntoTextNode: invalid container");
	            var d = c.parentNode;
	            runtime.assert(Boolean(d), "putCursorIntoTextNode: container without parent");
	            runtime.assert(0 <= b && b <= c.length, "putCursorIntoTextNode: offset is out of bounds");
	            0 === b ? d.insertBefore(a, c) : (b !== c.length && c.splitText(b),
	            d.insertBefore(a, c.nextSibling))
	        } else
	            c.nodeType === Node.ELEMENT_NODE && c.insertBefore(a, c.childNodes.item(b));
	        r.push(a.previousSibling);
	        r.push(a.nextSibling)
	    }
	    var f = g.createElementNS("urn:webodf:names:cursor", "cursor"), n = g.createElementNS("urn:webodf:names:cursor", "anchor"), p, r = [], q = g.createRange(), e, l = core.DomUtils;
	    this.getNode = function() {
	        return f
	    }
	    ;
	    this.getAnchorNode = function() {
	        return n.parentNode ? n : f
	    }
	    ;
	    this.getSelectedRange = function() {
	        e ? (q.setStartBefore(f),
	        q.collapse(!0)) : (q.setStartAfter(p ? n : f),
	        q.setEndBefore(p ? f : n));
	        return q
	    }
	    ;
	    this.setSelectedRange = function(a, c) {
	        q && q !== a && q.detach();
	        q = a;
	        p = !1 !== c;
	        (e = a.collapsed) ? (d(n),
	        d(f),
	        b(f, a.startContainer, a.startOffset)) : (d(n),
	        d(f),
	        b(p ? f : n, a.endContainer, a.endOffset),
	        b(p ? n : f, a.startContainer, a.startOffset));
	        r.forEach(l.normalizeTextNodes);
	        r.length = 0
	    }
	    ;
	    this.hasForwardSelection = function() {
	        return p
	    }
	    ;
	    this.remove = function() {
	        d(f);
	        r.forEach(l.normalizeTextNodes);
	        r.length = 0
	    }
	    ;
	    f.setAttributeNS("urn:webodf:names:cursor", "memberId", k);
	    n.setAttributeNS("urn:webodf:names:cursor", "memberId", k)
	}
	;
	core.Destroyable = function() {}
	;
	core.Destroyable.prototype.destroy = function(g) {}
	;
	core.EventSource = function() {}
	;
	core.EventSource.prototype.subscribe = function(g, k) {}
	;
	core.EventSource.prototype.unsubscribe = function(g, k) {}
	;
	core.EventNotifier = function(g) {
	    function k(b) {
	        runtime.assert(!d.hasOwnProperty(b), 'Duplicated event ids: "' + b + '" registered more than once.');
	        d[b] = []
	    }
	    var d = {};
	    this.emit = function(b, f) {
	        var n, g;
	        runtime.assert(d.hasOwnProperty(b), 'unknown event fired "' + b + '"');
	        g = d[b];
	        for (n = 0; n < g.length; n += 1)
	            g[n](f)
	    }
	    ;
	    this.subscribe = function(b, f) {
	        runtime.assert(d.hasOwnProperty(b), 'tried to subscribe to unknown event "' + b + '"');
	        d[b].push(f)
	    }
	    ;
	    this.unsubscribe = function(b, f) {
	        var n;
	        runtime.assert(d.hasOwnProperty(b), 'tried to unsubscribe from unknown event "' + b + '"');
	        n = d[b].indexOf(f);
	        runtime.assert(-1 !== n, 'tried to unsubscribe unknown callback from event "' + b + '"');
	        -1 !== n && d[b].splice(n, 1)
	    }
	    ;
	    this.register = k;
	    g && g.forEach(k)
	}
	;
	core.ScheduledTask = function(g, k, d) {
	    function b() {
	        p && (d(n),
	        p = !1)
	    }
	    function f() {
	        b();
	        g.apply(void 0, r);
	        r = null
	    }
	    var n, p = !1, r = [], q = !1;
	    this.trigger = function() {
	        runtime.assert(!1 === q, "Can't trigger destroyed ScheduledTask instance");
	        r = Array.prototype.slice.call(arguments);
	        p || (p = !0,
	        n = k(f))
	    }
	    ;
	    this.triggerImmediate = function() {
	        runtime.assert(!1 === q, "Can't trigger destroyed ScheduledTask instance");
	        r = Array.prototype.slice.call(arguments);
	        f()
	    }
	    ;
	    this.processRequests = function() {
	        p && f()
	    }
	    ;
	    this.cancel = b;
	    this.restart = function() {
	        runtime.assert(!1 === q, "Can't trigger destroyed ScheduledTask instance");
	        b();
	        p = !0;
	        n = k(f)
	    }
	    ;
	    this.destroy = function(d) {
	        b();
	        q = !0;
	        d()
	    }
	}
	;
	(function() {
	    var g;
	    core.Task = {};
	    core.Task.SUPPRESS_MANUAL_PROCESSING = !1;
	    core.Task.processTasks = function() {
	        core.Task.SUPPRESS_MANUAL_PROCESSING || g.performRedraw()
	    }
	    ;
	    core.Task.createRedrawTask = function(k) {
	        return new core.ScheduledTask(k,g.requestRedrawTask,g.cancelRedrawTask)
	    }
	    ;
	    core.Task.createTimeoutTask = function(g, d) {
	        return new core.ScheduledTask(g,function(b) {
	            return runtime.setTimeout(b, d)
	        }
	        ,runtime.clearTimeout)
	    }
	    ;
	    g = new function() {
	        var g = {};
	        this.requestRedrawTask = function(d) {
	            var b = runtime.requestAnimationFrame(function() {
	                d();
	                delete g[b]
	            });
	            g[b] = d;
	            return b
	        }
	        ;
	        this.performRedraw = function() {
	            Object.keys(g).forEach(function(d) {
	                g[d]();
	                runtime.cancelAnimationFrame(parseInt(d, 10))
	            });
	            g = {}
	        }
	        ;
	        this.cancelRedrawTask = function(d) {
	            runtime.cancelAnimationFrame(d);
	            delete g[d]
	        }
	    }
	}
	)();
	core.EventSubscriptions = function() {
	    function g(b, f, n) {
	        b.subscribe(f, n);
	        d.push({
	            eventSource: b,
	            eventid: f,
	            callback: n
	        })
	    }
	    function k() {
	        var n = [];
	        d.forEach(function(b) {
	            b.eventSource.unsubscribe(b.eventid, b.callback)
	        });
	        d.length = 0;
	        Object.keys(f).forEach(function(b) {
	            f[b].forEach(function(b) {
	                n.push(b.task.destroy)
	            });
	            delete f[b]
	        });
	        core.Async.destroyAll(n, function() {});
	        b = new core.EventNotifier
	    }
	    var d = []
	      , b = new core.EventNotifier
	      , f = {}
	      , n = 0;
	    this.addSubscription = g;
	    this.addFrameSubscription = function(d, k, q) {
	        var e, l, a, c;
	        f.hasOwnProperty(k) || (f[k] = []);
	        a = f[k];
	        for (c = 0; c < a.length; c += 1)
	            if (a[c].eventSource === d) {
	                e = a[c];
	                break
	            }
	        e || (l = "s" + n,
	        n += 1,
	        b.register(l),
	        e = {
	            frameEventId: l,
	            eventSource: d,
	            task: core.Task.createRedrawTask(function() {
	                b.emit(l, void 0)
	            })
	        },
	        a.push(e),
	        g(d, k, e.task.trigger));
	        b.subscribe(e.frameEventId, q)
	    }
	    ;
	    this.unsubscribeAll = k;
	    this.destroy = function(b) {
	        k();
	        b()
	    }
	}
	;
	core.LazyProperty = function(g) {
	    var k, d = !1;
	    this.value = function() {
	        d || (k = g(),
	        d = !0);
	        return k
	    }
	    ;
	    this.reset = function() {
	        d = !1
	    }
	}
	;
	core.LoopWatchDog = function(g, k) {
	    var d = Date.now()
	      , b = 0;
	    this.check = function() {
	        var f;
	        if (g && (f = Date.now(),
	        f - d > g))
	            throw runtime.log("alert", "watchdog timeout"),
	            "timeout!";
	        if (0 < k && (b += 1,
	        b > k))
	            throw runtime.log("alert", "watchdog loop overflow"),
	            "loop overflow";
	    }
	}
	;
	core.NodeFilterChain = function(g) {
	    var k = NodeFilter.FILTER_REJECT
	      , d = NodeFilter.FILTER_ACCEPT;
	    this.acceptNode = function(b) {
	        var f;
	        for (f = 0; f < g.length; f += 1)
	            if (g[f].acceptNode(b) === k)
	                return k;
	        return d
	    }
	}
	;
	core.PositionIterator = function(g, k, d, b) {
	    function f() {
	        this.acceptNode = function(a) {
	            return !a || a.nodeType === m && 0 === a.length ? x : y
	        }
	    }
	    function n(a) {
	        this.acceptNode = function(c) {
	            return !c || c.nodeType === m && 0 === c.length ? x : a.acceptNode(c)
	        }
	    }
	    function p() {
	        var c = l.currentNode
	          , b = c.nodeType;
	        a = b === m ? c.length - 1 : b === h ? 1 : 0
	    }
	    function r() {
	        if (null === l.previousSibling()) {
	            if (!l.parentNode() || l.currentNode === g)
	                return l.firstChild(),
	                !1;
	            a = 0
	        } else
	            p();
	        return !0
	    }
	    function q() {
	        var b = l.currentNode, d;
	        d = c(b);
	        if (b !== g)
	            for (b = b.parentNode; b && b !== g; )
	                c(b) === x && (l.currentNode = b,
	                d = x),
	                b = b.parentNode;
	        d === x ? (a = l.currentNode.nodeType === m ? b.length : 1,
	        b = e.nextPosition()) : b = d === y ? !0 : e.nextPosition();
	        b && runtime.assert(c(l.currentNode) === y, "moveToAcceptedNode did not result in walker being on an accepted node");
	        return b
	    }
	    var e = this, l, a, c, m = Node.TEXT_NODE, h = Node.ELEMENT_NODE, y = NodeFilter.FILTER_ACCEPT, x = NodeFilter.FILTER_REJECT;
	    this.nextPosition = function() {
	        var c = l.currentNode
	          , b = c.nodeType;
	        if (c === g)
	            return !1;
	        if (0 === a && b === h)
	            null === l.firstChild() && (a = 1);
	        else if (b === m && a + 1 < c.length)
	            a += 1;
	        else if (null !== l.nextSibling())
	            a = 0;
	        else if (l.parentNode())
	            a = 1;
	        else
	            return !1;
	        return !0
	    }
	    ;
	    this.previousPosition = function() {
	        var c = !0
	          , b = l.currentNode;
	        0 === a ? c = r() : b.nodeType === m ? --a : null !== l.lastChild() ? p() : b === g ? c = !1 : a = 0;
	        return c
	    }
	    ;
	    this.previousNode = r;
	    this.container = function() {
	        var c = l.currentNode
	          , b = c.nodeType;
	        0 === a && b !== m && (c = c.parentNode);
	        return c
	    }
	    ;
	    this.rightNode = function() {
	        var b = l.currentNode
	          , d = b.nodeType;
	        if (d === m && a === b.length)
	            for (b = b.nextSibling; b && c(b) !== y; )
	                b = b.nextSibling;
	        else
	            d === h && 1 === a && (b = null);
	        return b
	    }
	    ;
	    this.leftNode = function() {
	        var b = l.currentNode;
	        if (0 === a)
	            for (b = b.previousSibling; b && c(b) !== y; )
	                b = b.previousSibling;
	        else if (b.nodeType === h)
	            for (b = b.lastChild; b && c(b) !== y; )
	                b = b.previousSibling;
	        return b
	    }
	    ;
	    this.getCurrentNode = function() {
	        return l.currentNode
	    }
	    ;
	    this.unfilteredDomOffset = function() {
	        if (l.currentNode.nodeType === m)
	            return a;
	        for (var c = 0, b = l.currentNode, b = 1 === a ? b.lastChild : b.previousSibling; b; )
	            c += 1,
	            b = b.previousSibling;
	        return c
	    }
	    ;
	    this.getPreviousSibling = function() {
	        var a = l.currentNode
	          , c = l.previousSibling();
	        l.currentNode = a;
	        return c
	    }
	    ;
	    this.getNextSibling = function() {
	        var a = l.currentNode
	          , c = l.nextSibling();
	        l.currentNode = a;
	        return c
	    }
	    ;
	    this.setPositionBeforeElement = function(c) {
	        runtime.assert(Boolean(c), "setPositionBeforeElement called without element");
	        l.currentNode = c;
	        a = 0;
	        return q()
	    }
	    ;
	    this.setUnfilteredPosition = function(c, b) {
	        runtime.assert(Boolean(c), "PositionIterator.setUnfilteredPosition called without container");
	        l.currentNode = c;
	        c.nodeType === m ? (a = b,
	        runtime.assert(b <= c.length, "Error in setPosition: " + b + " > " + c.length),
	        runtime.assert(0 <= b, "Error in setPosition: " + b + " < 0"),
	        b === c.length && (l.nextSibling() ? a = 0 : l.parentNode() ? a = 1 : runtime.assert(!1, "Error in setUnfilteredPosition: position not valid."))) : b < c.childNodes.length ? (l.currentNode = c.childNodes.item(b),
	        a = 0) : a = 1;
	        return q()
	    }
	    ;
	    this.moveToEnd = function() {
	        l.currentNode = g;
	        a = 1
	    }
	    ;
	    this.moveToEndOfNode = function(c) {
	        c.nodeType === m ? e.setUnfilteredPosition(c, c.length) : (l.currentNode = c,
	        a = 1)
	    }
	    ;
	    this.isBeforeNode = function() {
	        return 0 === a
	    }
	    ;
	    this.getNodeFilter = function() {
	        return c
	    }
	    ;
	    c = (d ? new n(d) : new f).acceptNode;
	    c.acceptNode = c;
	    k = k || NodeFilter.SHOW_ALL;
	    runtime.assert(g.nodeType !== Node.TEXT_NODE, "Internet Explorer doesn't allow tree walker roots to be text nodes");
	    l = g.ownerDocument.createTreeWalker(g, k, c, b);
	    a = 0;
	    null === l.firstChild() && (a = 1)
	}
	;
	core.PositionFilter = function() {}
	;
	core.PositionFilter.FilterResult = {
	    FILTER_ACCEPT: 1,
	    FILTER_REJECT: 2,
	    FILTER_SKIP: 3
	};
	core.PositionFilter.prototype.acceptPosition = function(g) {}
	;
	core.PositionFilterChain = function() {
	    var g = []
	      , k = core.PositionFilter.FilterResult.FILTER_ACCEPT
	      , d = core.PositionFilter.FilterResult.FILTER_REJECT;
	    this.acceptPosition = function(b) {
	        var f;
	        for (f = 0; f < g.length; f += 1)
	            if (g[f].acceptPosition(b) === d)
	                return d;
	        return k
	    }
	    ;
	    this.addFilter = function(b) {
	        g.push(b)
	    }
	}
	;
	core.StepDirection = {
	    PREVIOUS: 1,
	    NEXT: 2
	};
	core.StepIterator = function(g, k) {
	    function d() {
	        a = null;
	        m = c = void 0
	    }
	    function b() {
	        void 0 === m && (m = g.acceptPosition(k) === e);
	        return m
	    }
	    function f(a, c) {
	        d();
	        return k.setUnfilteredPosition(a, c)
	    }
	    function n() {
	        a || (a = k.container());
	        return a
	    }
	    function p() {
	        void 0 === c && (c = k.unfilteredDomOffset());
	        return c
	    }
	    function r() {
	        for (d(); k.nextPosition(); )
	            if (d(),
	            b())
	                return !0;
	        return !1
	    }
	    function q() {
	        for (d(); k.previousPosition(); )
	            if (d(),
	            b())
	                return !0;
	        return !1
	    }
	    var e = core.PositionFilter.FilterResult.FILTER_ACCEPT, l = core.StepDirection.NEXT, a, c, m;
	    this.isStep = b;
	    this.setPosition = f;
	    this.container = n;
	    this.offset = p;
	    this.nextStep = r;
	    this.previousStep = q;
	    this.advanceStep = function(a) {
	        return a === l ? r() : q()
	    }
	    ;
	    this.roundToClosestStep = function() {
	        var a, c, d = b();
	        d || (a = n(),
	        c = p(),
	        d = q(),
	        d || (f(a, c),
	        d = r()));
	        return d
	    }
	    ;
	    this.roundToPreviousStep = function() {
	        var a = b();
	        a || (a = q());
	        return a
	    }
	    ;
	    this.roundToNextStep = function() {
	        var a = b();
	        a || (a = r());
	        return a
	    }
	    ;
	    this.leftNode = function() {
	        return k.leftNode()
	    }
	    ;
	    this.snapshot = function() {
	        return new core.StepIterator.StepSnapshot(n(),p())
	    }
	    ;
	    this.restore = function(a) {
	        f(a.container, a.offset)
	    }
	}
	;
	core.StepIterator.StepSnapshot = function(g, k) {
	    this.container = g;
	    this.offset = k
	}
	;
	core.Utils = function() {
	    function g(k, d) {
	        if (d && Array.isArray(d)) {
	            k = k || [];
	            if (!Array.isArray(k))
	                throw "Destination is not an array.";
	            k = k.concat(d.map(function(b) {
	                return g(null, b)
	            }))
	        } else if (d && "object" === typeof d) {
	            k = k || {};
	            if ("object" !== typeof k)
	                throw "Destination is not an object.";
	            Object.keys(d).forEach(function(b) {
	                k[b] = g(k[b], d[b])
	            })
	        } else
	            k = d;
	        return k
	    }
	    this.hashString = function(g) {
	        var d = 0, b, f;
	        b = 0;
	        for (f = g.length; b < f; b += 1)
	            d = (d << 5) - d + g.charCodeAt(b),
	            d |= 0;
	        return d
	    }
	    ;
	    this.mergeObjects = function(k, d) {
	        Object.keys(d).forEach(function(b) {
	            k[b] = g(k[b], d[b])
	        });
	        return k
	    }
	}
	;
	core.Zip = function(g, k) {
	    function d(b, d) {
	        var a = r.file(b);
	        a ? d(null, a.asUint8Array()) : d(b + " not found.", null)
	    }
	    function b(b, l) {
	        d(b, function(a, c) {
	            if (a || null === c)
	                return l(a, null);
	            var b = runtime.byteArrayToString(c, "utf8");
	            l(null, b)
	        })
	    }
	    function f(b, d) {
	        try {
	            b(r.generate({
	                type: "uint8array",
	                compression: "STORE"
	            }))
	        } catch (a) {
	            d(a.message)
	        }
	    }
	    function n(b, d) {
	        f(function(a) {
	            runtime.writeFile(b, a, d)
	        }, d)
	    }
	    var p = this, r, q = new core.Base64;
	    this.load = d;
	    this.save = function(b, d, a, c) {
	        r.file(b, d, {
	            date: c,
	            compression: a ? "DEFLATE" : "STORE"
	        })
	    }
	    ;
	    this.remove = function(b) {
	        var d = null !== r.file(b);
	        r.remove(b);
	        return d
	    }
	    ;
	    this.write = function(b) {
	        n(g, b)
	    }
	    ;
	    this.writeAs = n;
	    this.createByteArray = f;
	    this.loadContentXmlAsFragments = function(d, l) {
	        b(d, function(a, c) {
	            if (a)
	                return l.rootElementReady(a);
	            l.rootElementReady(null, c, !0)
	        })
	    }
	    ;
	    this.loadAsString = b;
	    this.loadAsDOM = function(d, l) {
	        b(d, function(a, c) {
	            if (a || null === c)
	                l(a, null);
	            else {
	                var b = (new DOMParser).parseFromString(c, "text/xml");
	                l(null, b)
	            }
	        })
	    }
	    ;
	    this.loadAsDataURL = function(b, l, a) {
	        d(b, function(c, b) {
	            if (c || !b)
	                return a(c, null);
	            var d = 0, e;
	            l || (l = 80 === b[1] && 78 === b[2] && 71 === b[3] ? "image/png" : 255 === b[0] && 216 === b[1] && 255 === b[2] ? "image/jpeg" : 71 === b[0] && 73 === b[1] && 70 === b[2] ? "image/gif" : "");
	            for (e = "data:" + l + ";base64,"; d < b.length; )
	                e += q.convertUTF8ArrayToBase64(b.subarray(d, Math.min(d + 45E3, b.length))),
	                d += 45E3;
	            a(null, e)
	        })
	    }
	    ;
	    this.getEntries = function() {
	        return Object.keys(r.files).map(function(b) {
	            return {
	                filename: b,
	                date: r.files[b].date
	            }
	        })
	    }
	    ;
	    r = new externs.JSZip;
	    null !== k && runtime.readFile(g, "binary", function(b, d) {
	        "string" === typeof d && (b = "file was read as a string. Should be Uint8Array.");
	        if (b || !d || 0 === d.length)
	            k("File '" + g + "' cannot be read. Err: " + (b || "[none]"), p);
	        else
	            try {
	                r.load(d, {
	                    checkCRC32: !1
	                }),
	                k(null, p)
	            } catch (a) {
	                k(a.message, p)
	            }
	    })
	}
	;
	core.SimpleClientRect = null;
	gui.CommonConstraints = {
	    EDIT: {
	        ANNOTATIONS: {
	            ONLY_DELETE_OWN: "onlyDeleteOwn"
	        },
	        REVIEW_MODE: "reviewMode"
	    }
	};
	gui.SessionConstraints = function() {
	    function g(b) {
	        k.hasOwnProperty(b) || (k[b] = !1,
	        d.register(b))
	    }
	    var k = {}
	      , d = new core.EventNotifier;
	    this.registerConstraint = g;
	    this.subscribe = function(b, f) {
	        g(b);
	        d.subscribe(b, f)
	    }
	    ;
	    this.unsubscribe = function(b, f) {
	        d.unsubscribe(b, f)
	    }
	    ;
	    this.setState = function(b, f) {
	        runtime.assert(!0 === k.hasOwnProperty(b), "No such constraint");
	        k[b] !== f && (k[b] = f,
	        d.emit(b, f))
	    }
	    ;
	    this.getState = function(b) {
	        runtime.assert(!0 === k.hasOwnProperty(b), "No such constraint");
	        return k[b]
	    }
	}
	;
	gui.BlacklistNamespaceNodeFilter = function(g) {
	    var k = {}
	      , d = NodeFilter.FILTER_REJECT
	      , b = NodeFilter.FILTER_ACCEPT;
	    this.acceptNode = function(f) {
	        return !f || k.hasOwnProperty(f.namespaceURI) ? d : b
	    }
	    ;
	    (function() {
	        g.forEach(function(b) {
	            k[b] = !0
	        })
	    }
	    )()
	}
	;
	odf.Namespaces = {
	    namespaceMap: {
	        config: "urn:oasis:names:tc:opendocument:xmlns:config:1.0",
	        db: "urn:oasis:names:tc:opendocument:xmlns:database:1.0",
	        dc: "http://purl.org/dc/elements/1.1/",
	        dr3d: "urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0",
	        draw: "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0",
	        chart: "urn:oasis:names:tc:opendocument:xmlns:chart:1.0",
	        fo: "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0",
	        form: "urn:oasis:names:tc:opendocument:xmlns:form:1.0",
	        math: "http://www.w3.org/1998/Math/MathML",
	        meta: "urn:oasis:names:tc:opendocument:xmlns:meta:1.0",
	        number: "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0",
	        office: "urn:oasis:names:tc:opendocument:xmlns:office:1.0",
	        presentation: "urn:oasis:names:tc:opendocument:xmlns:presentation:1.0",
	        style: "urn:oasis:names:tc:opendocument:xmlns:style:1.0",
	        svg: "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0",
	        table: "urn:oasis:names:tc:opendocument:xmlns:table:1.0",
	        text: "urn:oasis:names:tc:opendocument:xmlns:text:1.0",
	        xforms: "http://www.w3.org/2002/xforms",
	        xlink: "http://www.w3.org/1999/xlink",
	        xml: "http://www.w3.org/XML/1998/namespace"
	    },
	    prefixMap: {},
	    configns: "urn:oasis:names:tc:opendocument:xmlns:config:1.0",
	    dbns: "urn:oasis:names:tc:opendocument:xmlns:database:1.0",
	    dcns: "http://purl.org/dc/elements/1.1/",
	    dr3dns: "urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0",
	    drawns: "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0",
	    chartns: "urn:oasis:names:tc:opendocument:xmlns:chart:1.0",
	    fons: "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0",
	    formns: "urn:oasis:names:tc:opendocument:xmlns:form:1.0",
	    mathns: "http://www.w3.org/1998/Math/MathML",
	    metans: "urn:oasis:names:tc:opendocument:xmlns:meta:1.0",
	    numberns: "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0",
	    officens: "urn:oasis:names:tc:opendocument:xmlns:office:1.0",
	    presentationns: "urn:oasis:names:tc:opendocument:xmlns:presentation:1.0",
	    stylens: "urn:oasis:names:tc:opendocument:xmlns:style:1.0",
	    svgns: "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0",
	    tablens: "urn:oasis:names:tc:opendocument:xmlns:table:1.0",
	    textns: "urn:oasis:names:tc:opendocument:xmlns:text:1.0",
	    xformsns: "http://www.w3.org/2002/xforms",
	    xlinkns: "http://www.w3.org/1999/xlink",
	    xmlns: "http://www.w3.org/XML/1998/namespace"
	};
	(function() {
	    var g = odf.Namespaces.namespaceMap, k = odf.Namespaces.prefixMap, d;
	    for (d in g)
	        g.hasOwnProperty(d) && (k[g[d]] = d)
	}
	)();
	odf.Namespaces.forEachPrefix = function(g) {
	    var k = odf.Namespaces.namespaceMap, d;
	    for (d in k)
	        k.hasOwnProperty(d) && g(d, k[d])
	}
	;
	odf.Namespaces.lookupNamespaceURI = function(g) {
	    var k = null;
	    odf.Namespaces.namespaceMap.hasOwnProperty(g) && (k = odf.Namespaces.namespaceMap[g]);
	    return k
	}
	;
	odf.Namespaces.lookupPrefix = function(g) {
	    var k = odf.Namespaces.prefixMap;
	    return k.hasOwnProperty(g) ? k[g] : null
	}
	;
	odf.Namespaces.lookupNamespaceURI.lookupNamespaceURI = odf.Namespaces.lookupNamespaceURI;
	(function() {
	    odf.OdfSchemaImpl = function() {
	        var g = [["config:config-item", "uncategorized"], ["form:item", "object"], ["form:option", "uncategorized"], ["math:math", "field"], ["meta:user-defined", "uncategorized"], ["number:currency-symbol", "uncategorized"], ["number:embedded-text", "uncategorized"], ["number:text", "uncategorized"], ["presentation:date-time-decl", "uncategorized"], ["presentation:footer-decl", "uncategorized"], ["presentation:header-decl", "uncategorized"], ["svg:desc", "text"], ["svg:title", "text"], ["table:desc", "uncategorized"], ["table:title", "uncategorized"], ["text:a", "text"], ["text:author-initials", "field"], ["text:author-name", "field"], ["text:bibliography-mark", "field"], ["text:bookmark-ref", "field"], ["text:chapter", "field"], ["text:character-count", "field"], ["text:conditional-text", "field"], ["text:creation-date", "field"], ["text:creation-time", "field"], ["text:creator", "field"], ["text:database-display", "field"], ["text:database-name", "field"], ["text:database-row-number", "field"], ["text:date", "field"], ["text:dde-connection", "field"], ["text:description", "field"], ["text:editing-cycles", "field"], ["text:editing-duration", "field"], ["text:execute-macro", "uncategorized"], ["text:expression", "uncategorized"], ["text:file-name", "field"], ["text:h", "text"], ["text:hidden-paragraph", "text"], ["text:hidden-text", "text"], ["text:image-count", "field"], ["text:index-entry-span", "uncategorized"], ["text:index-title-template", "uncategorized"], ["text:initial-creator", "field"], ["text:keywords", "field"], ["text:linenumbering-separator", "style"], ["text:measure", "uncategorized"], ["text:meta", "uncategorized"], ["text:meta-field", "uncategorized"], ["text:modification-date", "field"], ["text:modification-time", "field"], ["text:note-citation", "field"], ["text:note-continuation-notice-backward", "style"], ["text:note-continuation-notice-forward", "style"], ["text:note-ref", "field"], ["text:object-count", "field"], ["text:p", "text"], ["text:page-continuation", "uncategorized"], ["text:page-count", "field"], ["text:page-number", "field"], ["text:page-variable-get", "field"], ["text:page-variable-set", "field"], ["text:paragraph-count", "field"], ["text:placeholder", "field"], ["text:print-date", "field"], ["text:print-time", "field"], ["text:printed-by", "field"], ["text:reference-ref", "field"], ["text:ruby-base", "text"], ["text:ruby-text", "text"], ["text:script", "text"], ["text:sender-city", "field"], ["text:sender-company", "field"], ["text:sender-country", "field"], ["text:sender-email", "field"], ["text:sender-fax", "field"], ["text:sender-firstname", "field"], ["text:sender-initials", "field"], ["text:sender-lastname", "field"], ["text:sender-phone-private", "field"], ["text:sender-phone-work", "field"], ["text:sender-position", "field"], ["text:sender-postal-code", "field"], ["text:sender-state-or-province", "field"], ["text:sender-street", "field"], ["text:sender-title", "field"], ["text:sequence", "uncategorized"], ["text:sequence-ref", "uncategorized"], ["text:sheet-name", "uncategorized"], ["text:span", "text"], ["text:subject", "field"], ["text:table-count", "field"], ["text:table-formula", "deprecated"], ["text:template-name", "uncategorized"], ["text:text-input", "field"], ["text:time", "field"], ["text:title", "field"], ["text:user-defined", "field"], ["text:user-field-get", "field"], ["text:user-field-input", "field"], ["text:variable-get", "field"], ["text:variable-input", "field"], ["text:variable-set", "field"], ["text:word-count", "field"], ["xforms:model", "uncategorized"]]
	          , k = {};
	        this.isTextContainer = function(d, b) {
	            return "text" === k[d + ":" + b]
	        }
	        ;
	        this.isField = function(d, b) {
	            return "field" === k[d + ":" + b]
	        }
	        ;
	        this.getFields = function() {
	            return g.filter(function(d) {
	                return "field" === d[1]
	            }).map(function(d) {
	                return d[0]
	            })
	        }
	        ;
	        (function() {
	            g.forEach(function(d) {
	                var b = d[1]
	                  , f = d[0].split(":");
	                d = f[0];
	                var f = f[1]
	                  , n = odf.Namespaces.lookupNamespaceURI(d);
	                n ? k[n + ":" + f] = b : runtime.log("DEBUG: OdfSchema - unknown prefix '" + d + "'")
	            })
	        }
	        )()
	    }
	    ;
	    odf.OdfSchema = new odf.OdfSchemaImpl
	}
	)();
	odf.OdfUtilsImpl = function() {
	    function g(a) {
	        return "image" === (a && a.localName) && a.namespaceURI === R
	    }
	    function k(a) {
	        return null !== a && a.nodeType === Node.ELEMENT_NODE && "frame" === a.localName && a.namespaceURI === R && "as-char" === a.getAttributeNS(J, "anchor-type")
	    }
	    function d(a) {
	        var c;
	        (c = "annotation" === (a && a.localName) && a.namespaceURI === odf.Namespaces.officens) || (c = "div" === (a && a.localName) && "annotationWrapper" === a.className);
	        return c
	    }
	    function b(a) {
	        return "a" === (a && a.localName) && a.namespaceURI === J
	    }
	    function f(a) {
	        var c = a && a.localName;
	        return ("p" === c || "h" === c) && a.namespaceURI === J
	    }
	    function n(a, c) {
	        for (a && void 0 !== c && !f(a) && a.childNodes.item(c) && (a = a.childNodes.item(c)); a && !f(a); )
	            a = a.parentNode;
	        return a
	    }
	    function p(a, c) {
	        for (; a && a !== c; ) {
	            if (a.namespaceURI === odf.Namespaces.officens && "annotation" === a.localName)
	                return a;
	            a = a.parentNode
	        }
	        return null
	    }
	    function r(a) {
	        return /^[ \t\r\n]+$/.test(a)
	    }
	    function q(a) {
	        if (null === a || a.nodeType !== Node.ELEMENT_NODE)
	            return !1;
	        var c = a.localName;
	        return fa.isTextContainer(a.namespaceURI, c) || "span" === c && "webodf-annotationHighlight" === a.className
	    }
	    function e(a) {
	        return null === a || a.nodeType !== Node.ELEMENT_NODE ? !1 : fa.isField(a.namespaceURI, a.localName)
	    }
	    function l(a) {
	        var c = a && a.localName
	          , b = !1;
	        c && (a = a.namespaceURI,
	        a === J && (b = "s" === c || "tab" === c || "line-break" === c));
	        return b
	    }
	    function a(a) {
	        return l(a) || e(a) || k(a) || d(a)
	    }
	    function c(a) {
	        var c = a && a.localName
	          , b = !1;
	        c && (a = a.namespaceURI,
	        a === J && (b = "s" === c));
	        return b
	    }
	    function m(a) {
	        return -1 !== S.indexOf(a.namespaceURI)
	    }
	    function h(a) {
	        if (l(a) || e(a))
	            return !1;
	        if (q(a.parentNode) && a.nodeType === Node.TEXT_NODE)
	            return 0 === a.textContent.length;
	        for (a = a.firstChild; a; ) {
	            if (m(a) || !h(a))
	                return !1;
	            a = a.nextSibling
	        }
	        return !0
	    }
	    function y(a) {
	        for (; null !== a.firstChild && q(a); )
	            a = a.firstChild;
	        return a
	    }
	    function x(a) {
	        for (; null !== a.lastChild && q(a); )
	            a = a.lastChild;
	        return a
	    }
	    function z(a) {
	        for (; !f(a) && null === a.previousSibling; )
	            a = a.parentNode;
	        return f(a) ? null : x(a.previousSibling)
	    }
	    function w(a) {
	        for (; !f(a) && null === a.nextSibling; )
	            a = a.parentNode;
	        return f(a) ? null : y(a.nextSibling)
	    }
	    function v(b) {
	        for (var d = !1; b; )
	            if (b.nodeType === Node.TEXT_NODE)
	                if (0 === b.length)
	                    b = z(b);
	                else
	                    return !r(b.data.substr(b.length - 1, 1));
	            else
	                a(b) ? (d = !1 === c(b),
	                b = null) : b = z(b);
	        return d
	    }
	    function u(c) {
	        var b = !1, d;
	        for (c = c && y(c); c; ) {
	            d = c.nodeType === Node.TEXT_NODE ? c.length : 0;
	            if (0 < d && !r(c.data)) {
	                b = !0;
	                break
	            }
	            if (a(c)) {
	                b = !0;
	                break
	            }
	            c = w(c)
	        }
	        return b
	    }
	    function t(a, c) {
	        return r(a.data.substr(c)) ? !u(w(a)) : !1
	    }
	    function A(c, b) {
	        var d = c.data, m;
	        if (!r(d[b]) || a(c.parentNode))
	            return !1;
	        0 < b ? r(d[b - 1]) || (m = !0) : v(z(c)) && (m = !0);
	        return !0 === m ? t(c, b) ? !1 : !0 : !1
	    }
	    function I(a) {
	        return (a = /(-?[0-9]*[0-9][0-9]*(\.[0-9]*)?|0+\.[0-9]*[1-9][0-9]*|\.[0-9]*[1-9][0-9]*)((cm)|(mm)|(in)|(pt)|(pc)|(px)|(%))/.exec(a)) ? {
	            value: parseFloat(a[1]),
	            unit: a[3]
	        } : null
	    }
	    function K(a) {
	        return (a = I(a)) && (0 > a.value || "%" === a.unit) ? null : a
	    }
	    function L(a) {
	        return (a = I(a)) && "%" !== a.unit ? null : a
	    }
	    function E(a) {
	        switch (a.namespaceURI) {
	        case odf.Namespaces.drawns:
	        case odf.Namespaces.svgns:
	        case odf.Namespaces.dr3dns:
	            return !1;
	        case odf.Namespaces.textns:
	            switch (a.localName) {
	            case "note-body":
	            case "ruby-text":
	                return !1
	            }
	            break;
	        case odf.Namespaces.officens:
	            switch (a.localName) {
	            case "annotation":
	            case "binary-data":
	            case "event-listeners":
	                return !1
	            }
	            break;
	        default:
	            switch (a.localName) {
	            case "cursor":
	            case "editinfo":
	                return !1
	            }
	        }
	        return !0
	    }
	    function N(a) {
	        return Boolean(n(a) && (!r(a.textContent) || A(a, 0)))
	    }
	    function O(a, c) {
	        for (; 0 < c.length && !aa.rangeContainsNode(a, c[0]); )
	            c.shift();
	        for (; 0 < c.length && !aa.rangeContainsNode(a, c[c.length - 1]); )
	            c.pop()
	    }
	    function D(c, b, m) {
	        var h;
	        h = aa.getNodesInRange(c, function(c) {
	            var b = NodeFilter.FILTER_REJECT;
	            if (l(c.parentNode) || e(c.parentNode) || d(c))
	                b = NodeFilter.FILTER_REJECT;
	            else if (c.nodeType === Node.TEXT_NODE) {
	                if (m || N(c))
	                    b = NodeFilter.FILTER_ACCEPT
	            } else if (a(c))
	                b = NodeFilter.FILTER_ACCEPT;
	            else if (E(c) || q(c))
	                b = NodeFilter.FILTER_SKIP;
	            return b
	        }, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT);
	        b || O(c, h);
	        return h
	    }
	    function V(a, c, b) {
	        for (; a; ) {
	            if (b(a)) {
	                c[0] !== a && c.unshift(a);
	                break
	            }
	            if (d(a))
	                break;
	            a = a.parentNode
	        }
	    }
	    function W(a, c) {
	        var b = a;
	        if (c < b.childNodes.length - 1)
	            b = b.childNodes[c + 1];
	        else {
	            for (; !b.nextSibling; )
	                b = b.parentNode;
	            b = b.nextSibling
	        }
	        for (; b.firstChild; )
	            b = b.firstChild;
	        return b
	    }
	    var J = odf.Namespaces.textns
	      , R = odf.Namespaces.drawns
	      , P = odf.Namespaces.xlinkns
	      , aa = core.DomUtils
	      , S = [odf.Namespaces.dbns, odf.Namespaces.dcns, odf.Namespaces.dr3dns, odf.Namespaces.drawns, odf.Namespaces.chartns, odf.Namespaces.formns, odf.Namespaces.numberns, odf.Namespaces.officens, odf.Namespaces.presentationns, odf.Namespaces.stylens, odf.Namespaces.svgns, odf.Namespaces.tablens, odf.Namespaces.textns]
	      , fa = odf.OdfSchema;
	    this.isImage = g;
	    this.isCharacterFrame = k;
	    this.isInlineRoot = d;
	    this.isTextSpan = function(a) {
	        return "span" === (a && a.localName) && a.namespaceURI === J
	    }
	    ;
	    this.isHyperlink = b;
	    this.getHyperlinkTarget = function(a) {
	        return a.getAttributeNS(P, "href") || ""
	    }
	    ;
	    this.isParagraph = f;
	    this.getParagraphElement = n;
	    this.getParentAnnotation = p;
	    this.isWithinAnnotation = function(a, c) {
	        return Boolean(p(a, c))
	    }
	    ;
	    this.getAnnotationCreator = function(a) {
	        return a.getElementsByTagNameNS(odf.Namespaces.dcns, "creator")[0].textContent
	    }
	    ;
	    this.isListItem = function(a) {
	        return "list-item" === (a && a.localName) && a.namespaceURI === J
	    }
	    ;
	    this.isLineBreak = function(a) {
	        return "line-break" === (a && a.localName) && a.namespaceURI === J
	    }
	    ;
	    this.isODFWhitespace = r;
	    this.isGroupingElement = q;
	    this.isFieldElement = e;
	    this.isCharacterElement = l;
	    this.isAnchoredAsCharacterElement = a;
	    this.isSpaceElement = c;
	    this.isODFNode = m;
	    this.hasNoODFContent = h;
	    this.firstChild = y;
	    this.lastChild = x;
	    this.previousNode = z;
	    this.nextNode = w;
	    this.scanLeftForNonSpace = v;
	    this.lookLeftForCharacter = function(c) {
	        var b, d = b = 0;
	        c.nodeType === Node.TEXT_NODE && (d = c.length);
	        0 < d ? (b = c.data,
	        b = r(b.substr(d - 1, 1)) ? 1 === d ? v(z(c)) ? 2 : 0 : r(b.substr(d - 2, 1)) ? 0 : 2 : 1) : a(c) && (b = 1);
	        return b
	    }
	    ;
	    this.lookRightForCharacter = function(c) {
	        var b = !1
	          , d = 0;
	        c && c.nodeType === Node.TEXT_NODE && (d = c.length);
	        0 < d ? b = !r(c.data.substr(0, 1)) : a(c) && (b = !0);
	        return b
	    }
	    ;
	    this.scanLeftForAnyCharacter = function(c) {
	        var b = !1, d;
	        for (c = c && x(c); c; ) {
	            d = c.nodeType === Node.TEXT_NODE ? c.length : 0;
	            if (0 < d && !r(c.data)) {
	                b = !0;
	                break
	            }
	            if (a(c)) {
	                b = !0;
	                break
	            }
	            c = z(c)
	        }
	        return b
	    }
	    ;
	    this.scanRightForAnyCharacter = u;
	    this.isTrailingWhitespace = t;
	    this.isSignificantWhitespace = A;
	    this.isDowngradableSpaceElement = function(a) {
	        return c(a) ? v(z(a)) && u(w(a)) : !1
	    }
	    ;
	    this.parseLength = I;
	    this.parseNonNegativeLength = K;
	    this.parseFoFontSize = function(a) {
	        var c;
	        c = (c = I(a)) && (0 >= c.value || "%" === c.unit) ? null : c;
	        return c || L(a)
	    }
	    ;
	    this.parseFoLineHeight = function(a) {
	        return K(a) || L(a)
	    }
	    ;
	    this.isTextContentContainingNode = E;
	    this.getTextNodes = function(a, c) {
	        var b;
	        b = aa.getNodesInRange(a, function(a) {
	            var c = NodeFilter.FILTER_REJECT;
	            a.nodeType === Node.TEXT_NODE ? N(a) && (c = NodeFilter.FILTER_ACCEPT) : E(a) && (c = NodeFilter.FILTER_SKIP);
	            return c
	        }, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT);
	        c || O(a, b);
	        return b
	    }
	    ;
	    this.getTextElements = D;
	    this.getParagraphElements = function(a) {
	        var c;
	        c = aa.getNodesInRange(a, function(a) {
	            var c = NodeFilter.FILTER_REJECT;
	            if (f(a))
	                c = NodeFilter.FILTER_ACCEPT;
	            else if (E(a) || q(a))
	                c = NodeFilter.FILTER_SKIP;
	            return c
	        }, NodeFilter.SHOW_ELEMENT);
	        V(a.startContainer, c, f);
	        return c
	    }
	    ;
	    this.getImageElements = function(a) {
	        var c;
	        c = aa.getNodesInRange(a, function(a) {
	            var c = NodeFilter.FILTER_SKIP;
	            g(a) && (c = NodeFilter.FILTER_ACCEPT);
	            return c
	        }, NodeFilter.SHOW_ELEMENT);
	        V(a.startContainer, c, g);
	        return c
	    }
	    ;
	    this.getHyperlinkElements = function(a) {
	        var c = []
	          , d = a.cloneRange();
	        a.collapsed && a.endContainer.nodeType === Node.ELEMENT_NODE && (a = W(a.endContainer, a.endOffset),
	        a.nodeType === Node.TEXT_NODE && d.setEnd(a, 1));
	        D(d, !0, !1).forEach(function(a) {
	            for (a = a.parentNode; !f(a); ) {
	                if (b(a) && -1 === c.indexOf(a)) {
	                    c.push(a);
	                    break
	                }
	                a = a.parentNode
	            }
	        });
	        d.detach();
	        return c
	    }
	    ;
	    this.getNormalizedFontFamilyName = function(a) {
	        /^(["'])(?:.|[\n\r])*?\1$/.test(a) || (a = a.replace(/^[ \t\r\n\f]*((?:.|[\n\r])*?)[ \t\r\n\f]*$/, "$1"),
	        /[ \t\r\n\f]/.test(a) && (a = "'" + a.replace(/[ \t\r\n\f]+/g, " ") + "'"));
	        return a
	    }
	}
	;
	odf.OdfUtils = new odf.OdfUtilsImpl;
	gui.OdfTextBodyNodeFilter = function() {
	    var g = odf.OdfUtils
	      , k = Node.TEXT_NODE
	      , d = NodeFilter.FILTER_REJECT
	      , b = NodeFilter.FILTER_ACCEPT
	      , f = odf.Namespaces.textns;
	    this.acceptNode = function(n) {
	        if (n.nodeType === k) {
	            if (!g.isGroupingElement(n.parentNode))
	                return d
	        } else if (n.namespaceURI === f && "tracked-changes" === n.localName)
	            return d;
	        return b
	    }
	}
	;
	xmldom.LSSerializerFilter = function() {}
	;
	xmldom.LSSerializerFilter.prototype.acceptNode = function(g) {}
	;
	odf.OdfNodeFilter = function() {
	    this.acceptNode = function(g) {
	        return "http://www.w3.org/1999/xhtml" === g.namespaceURI ? NodeFilter.FILTER_SKIP : g.namespaceURI && g.namespaceURI.match(/^urn:webodf:/) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT
	    }
	}
	;
	xmldom.XPathIterator = function() {}
	;
	xmldom.XPathIterator.prototype.next = function() {}
	;
	xmldom.XPathIterator.prototype.reset = function() {}
	;
	function createXPathSingleton() {
	    function g(b, a, c) {
	        return -1 !== b && (b < a || -1 === a) && (b < c || -1 === c)
	    }
	    function k(b) {
	        for (var a = [], c = 0, d = b.length, h; c < d; ) {
	            var f = b
	              , n = d
	              , k = a
	              , r = ""
	              , p = []
	              , q = f.indexOf("[", c)
	              , t = f.indexOf("/", c)
	              , A = f.indexOf("=", c);
	            g(t, q, A) ? (r = f.substring(c, t),
	            c = t + 1) : g(q, t, A) ? (r = f.substring(c, q),
	            c = e(f, q, p)) : g(A, t, q) ? (r = f.substring(c, A),
	            c = A) : (r = f.substring(c, n),
	            c = n);
	            k.push({
	                location: r,
	                predicates: p
	            });
	            if (c < d && "=" === b[c]) {
	                h = b.substring(c + 1, d);
	                if (2 < h.length && ("'" === h[0] || '"' === h[0]))
	                    h = h.slice(1, h.length - 1);
	                else
	                    try {
	                        h = parseInt(h, 10)
	                    } catch (I) {}
	                c = d
	            }
	        }
	        return {
	            steps: a,
	            value: h
	        }
	    }
	    function d() {
	        var b = null
	          , a = !1;
	        this.setNode = function(a) {
	            b = a
	        }
	        ;
	        this.reset = function() {
	            a = !1
	        }
	        ;
	        this.next = function() {
	            var c = a ? null : b;
	            a = !0;
	            return c
	        }
	    }
	    function b(b, a, c) {
	        this.reset = function() {
	            b.reset()
	        }
	        ;
	        this.next = function() {
	            for (var d = b.next(); d; ) {
	                d.nodeType === Node.ELEMENT_NODE && (d = d.getAttributeNodeNS(a, c));
	                if (d)
	                    break;
	                d = b.next()
	            }
	            return d
	        }
	    }
	    function f(b, a) {
	        var c = b.next()
	          , d = null;
	        this.reset = function() {
	            b.reset();
	            c = b.next();
	            d = null
	        }
	        ;
	        this.next = function() {
	            for (; c; ) {
	                if (d)
	                    if (a && d.firstChild)
	                        d = d.firstChild;
	                    else {
	                        for (; !d.nextSibling && d !== c; )
	                            d = d.parentNode;
	                        d === c ? c = b.next() : d = d.nextSibling
	                    }
	                else {
	                    do
	                        (d = c.firstChild) || (c = b.next());
	                    while (c && !d)
	                }
	                if (d && d.nodeType === Node.ELEMENT_NODE)
	                    return d
	            }
	            return null
	        }
	    }
	    function n(b, a) {
	        this.reset = function() {
	            b.reset()
	        }
	        ;
	        this.next = function() {
	            for (var c = b.next(); c && !a(c); )
	                c = b.next();
	            return c
	        }
	    }
	    function p(b, a, c) {
	        a = a.split(":", 2);
	        var d = c(a[0])
	          , h = a[1];
	        return new n(b,function(a) {
	            return a.localName === h && a.namespaceURI === d
	        }
	        )
	    }
	    function r(b, a, c) {
	        var m = new d
	          , h = q(m, a, c)
	          , e = a.value;
	        return void 0 === e ? new n(b,function(a) {
	            m.setNode(a);
	            h.reset();
	            return null !== h.next()
	        }
	        ) : new n(b,function(a) {
	            m.setNode(a);
	            h.reset();
	            return (a = h.next()) ? a.nodeValue === e : !1
	        }
	        )
	    }
	    var q, e;
	    e = function(b, a, c) {
	        for (var d = a, h = b.length, e = 0; d < h; )
	            "]" === b[d] ? (--e,
	            0 >= e && c.push(k(b.substring(a, d)))) : "[" === b[d] && (0 >= e && (a = d + 1),
	            e += 1),
	            d += 1;
	        return d
	    }
	    ;
	    q = function(d, a, c) {
	        var m, h, e, n;
	        for (m = 0; m < a.steps.length; m += 1) {
	            e = a.steps[m];
	            h = e.location;
	            if ("" === h)
	                d = new f(d,!1);
	            else if ("@" === h[0]) {
	                h = h.substr(1).split(":", 2);
	                n = c(h[0]);
	                if (!n)
	                    throw "No namespace associated with the prefix " + h[0];
	                d = new b(d,n,h[1])
	            } else
	                "." !== h && (d = new f(d,!1),
	                -1 !== h.indexOf(":") && (d = p(d, h, c)));
	            for (h = 0; h < e.predicates.length; h += 1)
	                n = e.predicates[h],
	                d = r(d, n, c)
	        }
	        return d
	    }
	    ;
	    return {
	        getODFElementsWithXPath: function(b, a, c) {
	            var m = b.ownerDocument
	              , h = []
	              , e = null;
	            if (m && "function" === typeof m.evaluate)
	                for (c = m.evaluate(a, b, c, XPathResult.UNORDERED_NODE_ITERATOR_TYPE, null),
	                e = c.iterateNext(); null !== e; )
	                    e.nodeType === Node.ELEMENT_NODE && h.push(e),
	                    e = c.iterateNext();
	            else {
	                h = new d;
	                h.setNode(b);
	                b = k(a);
	                h = q(h, b, c);
	                b = [];
	                for (c = h.next(); c; )
	                    b.push(c),
	                    c = h.next();
	                h = b
	            }
	            return h
	        }
	    }
	}
	xmldom.XPath = createXPathSingleton();
	odf.StyleInfo = function() {
	    function g(a, c) {
	        var b, d, h, m, e, l = 0;
	        if (b = K[a.localName])
	            if (h = b[a.namespaceURI])
	                l = h.length;
	        for (b = 0; b < l; b += 1)
	            d = h[b],
	            m = d.ns,
	            e = d.localname,
	            (d = a.getAttributeNS(m, e)) && a.setAttributeNS(m, A[m] + e, c + d);
	        for (h = a.firstElementChild; h; )
	            g(h, c),
	            h = h.nextElementSibling
	    }
	    function k(a, c) {
	        var b, d, h, m, e, l = 0;
	        if (b = K[a.localName])
	            if (h = b[a.namespaceURI])
	                l = h.length;
	        for (b = 0; b < l; b += 1)
	            if (d = h[b],
	            m = d.ns,
	            e = d.localname,
	            d = a.getAttributeNS(m, e))
	                d = d.replace(c, ""),
	                a.setAttributeNS(m, A[m] + e, d);
	        for (h = a.firstElementChild; h; )
	            k(h, c),
	            h = h.nextElementSibling
	    }
	    function d(a, c) {
	        var b, d, h, m, e, l = 0;
	        if (b = K[a.localName])
	            if (h = b[a.namespaceURI])
	                l = h.length;
	        for (b = 0; b < l; b += 1)
	            if (m = h[b],
	            d = m.ns,
	            e = m.localname,
	            d = a.getAttributeNS(d, e))
	                c = c || {},
	                m = m.keyname,
	                c.hasOwnProperty(m) ? c[m][d] = 1 : (e = {},
	                e[d] = 1,
	                c[m] = e);
	        return c
	    }
	    function b(a, c) {
	        var h, m;
	        d(a, c);
	        for (h = a.firstChild; h; )
	            h.nodeType === Node.ELEMENT_NODE && (m = h,
	            b(m, c)),
	            h = h.nextSibling
	    }
	    function f(a, c, b) {
	        this.key = a;
	        this.name = c;
	        this.family = b;
	        this.requires = {}
	    }
	    function n(a, c, b) {
	        var d = a + '"' + c
	          , h = b[d];
	        h || (h = b[d] = new f(d,a,c));
	        return h
	    }
	    function p(a, c, b) {
	        var d, h, m, e, l, f = 0;
	        d = a.getAttributeNS(v, "name");
	        e = a.getAttributeNS(v, "family");
	        d && e && (c = n(d, e, b));
	        if (c) {
	            if (d = K[a.localName])
	                if (m = d[a.namespaceURI])
	                    f = m.length;
	            for (d = 0; d < f; d += 1)
	                if (e = m[d],
	                h = e.ns,
	                l = e.localname,
	                h = a.getAttributeNS(h, l))
	                    e = e.keyname,
	                    e = n(h, e, b),
	                    c.requires[e.key] = e
	        }
	        for (a = a.firstElementChild; a; )
	            p(a, c, b),
	            a = a.nextElementSibling;
	        return b
	    }
	    function r(a, c) {
	        var b = c[a.family];
	        b || (b = c[a.family] = {});
	        b[a.name] = 1;
	        Object.keys(a.requires).forEach(function(b) {
	            r(a.requires[b], c)
	        })
	    }
	    function q(a, c) {
	        var b = p(a, null, {});
	        Object.keys(b).forEach(function(a) {
	            a = b[a];
	            var d = c[a.family];
	            d && d.hasOwnProperty(a.name) && r(a, c)
	        })
	    }
	    function e(a, c) {
	        function b(c) {
	            (c = m.getAttributeNS(v, c)) && (a[c] = !0)
	        }
	        var d = ["font-name", "font-name-asian", "font-name-complex"], h, m;
	        for (h = c && c.firstElementChild; h; )
	            m = h,
	            d.forEach(b),
	            e(a, m),
	            h = h.nextElementSibling
	    }
	    function l(a, c) {
	        function b(a) {
	            var d = m.getAttributeNS(v, a);
	            d && c.hasOwnProperty(d) && m.setAttributeNS(v, "style:" + a, c[d])
	        }
	        var d = ["font-name", "font-name-asian", "font-name-complex"], h, m;
	        for (h = a && a.firstElementChild; h; )
	            m = h,
	            d.forEach(b),
	            l(m, c),
	            h = h.nextElementSibling
	    }
	    var a = odf.Namespaces.chartns, c = odf.Namespaces.dbns, m = odf.Namespaces.dr3dns, h = odf.Namespaces.drawns, y = odf.Namespaces.formns, x = odf.Namespaces.numberns, z = odf.Namespaces.officens, w = odf.Namespaces.presentationns, v = odf.Namespaces.stylens, u = odf.Namespaces.tablens, t = odf.Namespaces.textns, A = {
	        "urn:oasis:names:tc:opendocument:xmlns:chart:1.0": "chart:",
	        "urn:oasis:names:tc:opendocument:xmlns:database:1.0": "db:",
	        "urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0": "dr3d:",
	        "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0": "draw:",
	        "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0": "fo:",
	        "urn:oasis:names:tc:opendocument:xmlns:form:1.0": "form:",
	        "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0": "number:",
	        "urn:oasis:names:tc:opendocument:xmlns:office:1.0": "office:",
	        "urn:oasis:names:tc:opendocument:xmlns:presentation:1.0": "presentation:",
	        "urn:oasis:names:tc:opendocument:xmlns:style:1.0": "style:",
	        "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0": "svg:",
	        "urn:oasis:names:tc:opendocument:xmlns:table:1.0": "table:",
	        "urn:oasis:names:tc:opendocument:xmlns:text:1.0": "chart:",
	        "http://www.w3.org/XML/1998/namespace": "xml:"
	    }, I = {
	        text: [{
	            ens: v,
	            en: "tab-stop",
	            ans: v,
	            a: "leader-text-style"
	        }, {
	            ens: v,
	            en: "drop-cap",
	            ans: v,
	            a: "style-name"
	        }, {
	            ens: t,
	            en: "notes-configuration",
	            ans: t,
	            a: "citation-body-style-name"
	        }, {
	            ens: t,
	            en: "notes-configuration",
	            ans: t,
	            a: "citation-style-name"
	        }, {
	            ens: t,
	            en: "a",
	            ans: t,
	            a: "style-name"
	        }, {
	            ens: t,
	            en: "alphabetical-index",
	            ans: t,
	            a: "style-name"
	        }, {
	            ens: t,
	            en: "linenumbering-configuration",
	            ans: t,
	            a: "style-name"
	        }, {
	            ens: t,
	            en: "list-level-style-number",
	            ans: t,
	            a: "style-name"
	        }, {
	            ens: t,
	            en: "ruby-text",
	            ans: t,
	            a: "style-name"
	        }, {
	            ens: t,
	            en: "span",
	            ans: t,
	            a: "style-name"
	        }, {
	            ens: t,
	            en: "a",
	            ans: t,
	            a: "visited-style-name"
	        }, {
	            ens: v,
	            en: "text-properties",
	            ans: v,
	            a: "text-line-through-text-style"
	        }, {
	            ens: t,
	            en: "alphabetical-index-source",
	            ans: t,
	            a: "main-entry-style-name"
	        }, {
	            ens: t,
	            en: "index-entry-bibliography",
	            ans: t,
	            a: "style-name"
	        }, {
	            ens: t,
	            en: "index-entry-chapter",
	            ans: t,
	            a: "style-name"
	        }, {
	            ens: t,
	            en: "index-entry-link-end",
	            ans: t,
	            a: "style-name"
	        }, {
	            ens: t,
	            en: "index-entry-link-start",
	            ans: t,
	            a: "style-name"
	        }, {
	            ens: t,
	            en: "index-entry-page-number",
	            ans: t,
	            a: "style-name"
	        }, {
	            ens: t,
	            en: "index-entry-span",
	            ans: t,
	            a: "style-name"
	        }, {
	            ens: t,
	            en: "index-entry-tab-stop",
	            ans: t,
	            a: "style-name"
	        }, {
	            ens: t,
	            en: "index-entry-text",
	            ans: t,
	            a: "style-name"
	        }, {
	            ens: t,
	            en: "index-title-template",
	            ans: t,
	            a: "style-name"
	        }, {
	            ens: t,
	            en: "list-level-style-bullet",
	            ans: t,
	            a: "style-name"
	        }, {
	            ens: t,
	            en: "outline-level-style",
	            ans: t,
	            a: "style-name"
	        }],
	        paragraph: [{
	            ens: h,
	            en: "caption",
	            ans: h,
	            a: "text-style-name"
	        }, {
	            ens: h,
	            en: "circle",
	            ans: h,
	            a: "text-style-name"
	        }, {
	            ens: h,
	            en: "connector",
	            ans: h,
	            a: "text-style-name"
	        }, {
	            ens: h,
	            en: "control",
	            ans: h,
	            a: "text-style-name"
	        }, {
	            ens: h,
	            en: "custom-shape",
	            ans: h,
	            a: "text-style-name"
	        }, {
	            ens: h,
	            en: "ellipse",
	            ans: h,
	            a: "text-style-name"
	        }, {
	            ens: h,
	            en: "frame",
	            ans: h,
	            a: "text-style-name"
	        }, {
	            ens: h,
	            en: "line",
	            ans: h,
	            a: "text-style-name"
	        }, {
	            ens: h,
	            en: "measure",
	            ans: h,
	            a: "text-style-name"
	        }, {
	            ens: h,
	            en: "path",
	            ans: h,
	            a: "text-style-name"
	        }, {
	            ens: h,
	            en: "polygon",
	            ans: h,
	            a: "text-style-name"
	        }, {
	            ens: h,
	            en: "polyline",
	            ans: h,
	            a: "text-style-name"
	        }, {
	            ens: h,
	            en: "rect",
	            ans: h,
	            a: "text-style-name"
	        }, {
	            ens: h,
	            en: "regular-polygon",
	            ans: h,
	            a: "text-style-name"
	        }, {
	            ens: z,
	            en: "annotation",
	            ans: h,
	            a: "text-style-name"
	        }, {
	            ens: y,
	            en: "column",
	            ans: y,
	            a: "text-style-name"
	        }, {
	            ens: v,
	            en: "style",
	            ans: v,
	            a: "next-style-name"
	        }, {
	            ens: u,
	            en: "body",
	            ans: u,
	            a: "paragraph-style-name"
	        }, {
	            ens: u,
	            en: "even-columns",
	            ans: u,
	            a: "paragraph-style-name"
	        }, {
	            ens: u,
	            en: "even-rows",
	            ans: u,
	            a: "paragraph-style-name"
	        }, {
	            ens: u,
	            en: "first-column",
	            ans: u,
	            a: "paragraph-style-name"
	        }, {
	            ens: u,
	            en: "first-row",
	            ans: u,
	            a: "paragraph-style-name"
	        }, {
	            ens: u,
	            en: "last-column",
	            ans: u,
	            a: "paragraph-style-name"
	        }, {
	            ens: u,
	            en: "last-row",
	            ans: u,
	            a: "paragraph-style-name"
	        }, {
	            ens: u,
	            en: "odd-columns",
	            ans: u,
	            a: "paragraph-style-name"
	        }, {
	            ens: u,
	            en: "odd-rows",
	            ans: u,
	            a: "paragraph-style-name"
	        }, {
	            ens: t,
	            en: "notes-configuration",
	            ans: t,
	            a: "default-style-name"
	        }, {
	            ens: t,
	            en: "alphabetical-index-entry-template",
	            ans: t,
	            a: "style-name"
	        }, {
	            ens: t,
	            en: "bibliography-entry-template",
	            ans: t,
	            a: "style-name"
	        }, {
	            ens: t,
	            en: "h",
	            ans: t,
	            a: "style-name"
	        }, {
	            ens: t,
	            en: "illustration-index-entry-template",
	            ans: t,
	            a: "style-name"
	        }, {
	            ens: t,
	            en: "index-source-style",
	            ans: t,
	            a: "style-name"
	        }, {
	            ens: t,
	            en: "object-index-entry-template",
	            ans: t,
	            a: "style-name"
	        }, {
	            ens: t,
	            en: "p",
	            ans: t,
	            a: "style-name"
	        }, {
	            ens: t,
	            en: "table-index-entry-template",
	            ans: t,
	            a: "style-name"
	        }, {
	            ens: t,
	            en: "table-of-content-entry-template",
	            ans: t,
	            a: "style-name"
	        }, {
	            ens: t,
	            en: "table-index-entry-template",
	            ans: t,
	            a: "style-name"
	        }, {
	            ens: t,
	            en: "user-index-entry-template",
	            ans: t,
	            a: "style-name"
	        }, {
	            ens: v,
	            en: "page-layout-properties",
	            ans: v,
	            a: "register-truth-ref-style-name"
	        }],
	        chart: [{
	            ens: a,
	            en: "axis",
	            ans: a,
	            a: "style-name"
	        }, {
	            ens: a,
	            en: "chart",
	            ans: a,
	            a: "style-name"
	        }, {
	            ens: a,
	            en: "data-label",
	            ans: a,
	            a: "style-name"
	        }, {
	            ens: a,
	            en: "data-point",
	            ans: a,
	            a: "style-name"
	        }, {
	            ens: a,
	            en: "equation",
	            ans: a,
	            a: "style-name"
	        }, {
	            ens: a,
	            en: "error-indicator",
	            ans: a,
	            a: "style-name"
	        }, {
	            ens: a,
	            en: "floor",
	            ans: a,
	            a: "style-name"
	        }, {
	            ens: a,
	            en: "footer",
	            ans: a,
	            a: "style-name"
	        }, {
	            ens: a,
	            en: "grid",
	            ans: a,
	            a: "style-name"
	        }, {
	            ens: a,
	            en: "legend",
	            ans: a,
	            a: "style-name"
	        }, {
	            ens: a,
	            en: "mean-value",
	            ans: a,
	            a: "style-name"
	        }, {
	            ens: a,
	            en: "plot-area",
	            ans: a,
	            a: "style-name"
	        }, {
	            ens: a,
	            en: "regression-curve",
	            ans: a,
	            a: "style-name"
	        }, {
	            ens: a,
	            en: "series",
	            ans: a,
	            a: "style-name"
	        }, {
	            ens: a,
	            en: "stock-gain-marker",
	            ans: a,
	            a: "style-name"
	        }, {
	            ens: a,
	            en: "stock-loss-marker",
	            ans: a,
	            a: "style-name"
	        }, {
	            ens: a,
	            en: "stock-range-line",
	            ans: a,
	            a: "style-name"
	        }, {
	            ens: a,
	            en: "subtitle",
	            ans: a,
	            a: "style-name"
	        }, {
	            ens: a,
	            en: "title",
	            ans: a,
	            a: "style-name"
	        }, {
	            ens: a,
	            en: "wall",
	            ans: a,
	            a: "style-name"
	        }],
	        section: [{
	            ens: t,
	            en: "alphabetical-index",
	            ans: t,
	            a: "style-name"
	        }, {
	            ens: t,
	            en: "bibliography",
	            ans: t,
	            a: "style-name"
	        }, {
	            ens: t,
	            en: "illustration-index",
	            ans: t,
	            a: "style-name"
	        }, {
	            ens: t,
	            en: "index-title",
	            ans: t,
	            a: "style-name"
	        }, {
	            ens: t,
	            en: "object-index",
	            ans: t,
	            a: "style-name"
	        }, {
	            ens: t,
	            en: "section",
	            ans: t,
	            a: "style-name"
	        }, {
	            ens: t,
	            en: "table-of-content",
	            ans: t,
	            a: "style-name"
	        }, {
	            ens: t,
	            en: "table-index",
	            ans: t,
	            a: "style-name"
	        }, {
	            ens: t,
	            en: "user-index",
	            ans: t,
	            a: "style-name"
	        }],
	        ruby: [{
	            ens: t,
	            en: "ruby",
	            ans: t,
	            a: "style-name"
	        }],
	        table: [{
	            ens: c,
	            en: "query",
	            ans: c,
	            a: "style-name"
	        }, {
	            ens: c,
	            en: "table-representation",
	            ans: c,
	            a: "style-name"
	        }, {
	            ens: u,
	            en: "background",
	            ans: u,
	            a: "style-name"
	        }, {
	            ens: u,
	            en: "table",
	            ans: u,
	            a: "style-name"
	        }],
	        "table-column": [{
	            ens: c,
	            en: "column",
	            ans: c,
	            a: "style-name"
	        }, {
	            ens: u,
	            en: "table-column",
	            ans: u,
	            a: "style-name"
	        }],
	        "table-row": [{
	            ens: c,
	            en: "query",
	            ans: c,
	            a: "default-row-style-name"
	        }, {
	            ens: c,
	            en: "table-representation",
	            ans: c,
	            a: "default-row-style-name"
	        }, {
	            ens: u,
	            en: "table-row",
	            ans: u,
	            a: "style-name"
	        }],
	        "table-cell": [{
	            ens: c,
	            en: "column",
	            ans: c,
	            a: "default-cell-style-name"
	        }, {
	            ens: u,
	            en: "table-column",
	            ans: u,
	            a: "default-cell-style-name"
	        }, {
	            ens: u,
	            en: "table-row",
	            ans: u,
	            a: "default-cell-style-name"
	        }, {
	            ens: u,
	            en: "body",
	            ans: u,
	            a: "style-name"
	        }, {
	            ens: u,
	            en: "covered-table-cell",
	            ans: u,
	            a: "style-name"
	        }, {
	            ens: u,
	            en: "even-columns",
	            ans: u,
	            a: "style-name"
	        }, {
	            ens: u,
	            en: "covered-table-cell",
	            ans: u,
	            a: "style-name"
	        }, {
	            ens: u,
	            en: "even-columns",
	            ans: u,
	            a: "style-name"
	        }, {
	            ens: u,
	            en: "even-rows",
	            ans: u,
	            a: "style-name"
	        }, {
	            ens: u,
	            en: "first-column",
	            ans: u,
	            a: "style-name"
	        }, {
	            ens: u,
	            en: "first-row",
	            ans: u,
	            a: "style-name"
	        }, {
	            ens: u,
	            en: "last-column",
	            ans: u,
	            a: "style-name"
	        }, {
	            ens: u,
	            en: "last-row",
	            ans: u,
	            a: "style-name"
	        }, {
	            ens: u,
	            en: "odd-columns",
	            ans: u,
	            a: "style-name"
	        }, {
	            ens: u,
	            en: "odd-rows",
	            ans: u,
	            a: "style-name"
	        }, {
	            ens: u,
	            en: "table-cell",
	            ans: u,
	            a: "style-name"
	        }],
	        graphic: [{
	            ens: m,
	            en: "cube",
	            ans: h,
	            a: "style-name"
	        }, {
	            ens: m,
	            en: "extrude",
	            ans: h,
	            a: "style-name"
	        }, {
	            ens: m,
	            en: "rotate",
	            ans: h,
	            a: "style-name"
	        }, {
	            ens: m,
	            en: "scene",
	            ans: h,
	            a: "style-name"
	        }, {
	            ens: m,
	            en: "sphere",
	            ans: h,
	            a: "style-name"
	        }, {
	            ens: h,
	            en: "caption",
	            ans: h,
	            a: "style-name"
	        }, {
	            ens: h,
	            en: "circle",
	            ans: h,
	            a: "style-name"
	        }, {
	            ens: h,
	            en: "connector",
	            ans: h,
	            a: "style-name"
	        }, {
	            ens: h,
	            en: "control",
	            ans: h,
	            a: "style-name"
	        }, {
	            ens: h,
	            en: "custom-shape",
	            ans: h,
	            a: "style-name"
	        }, {
	            ens: h,
	            en: "ellipse",
	            ans: h,
	            a: "style-name"
	        }, {
	            ens: h,
	            en: "frame",
	            ans: h,
	            a: "style-name"
	        }, {
	            ens: h,
	            en: "g",
	            ans: h,
	            a: "style-name"
	        }, {
	            ens: h,
	            en: "line",
	            ans: h,
	            a: "style-name"
	        }, {
	            ens: h,
	            en: "measure",
	            ans: h,
	            a: "style-name"
	        }, {
	            ens: h,
	            en: "page-thumbnail",
	            ans: h,
	            a: "style-name"
	        }, {
	            ens: h,
	            en: "path",
	            ans: h,
	            a: "style-name"
	        }, {
	            ens: h,
	            en: "polygon",
	            ans: h,
	            a: "style-name"
	        }, {
	            ens: h,
	            en: "polyline",
	            ans: h,
	            a: "style-name"
	        }, {
	            ens: h,
	            en: "rect",
	            ans: h,
	            a: "style-name"
	        }, {
	            ens: h,
	            en: "regular-polygon",
	            ans: h,
	            a: "style-name"
	        }, {
	            ens: z,
	            en: "annotation",
	            ans: h,
	            a: "style-name"
	        }],
	        presentation: [{
	            ens: m,
	            en: "cube",
	            ans: w,
	            a: "style-name"
	        }, {
	            ens: m,
	            en: "extrude",
	            ans: w,
	            a: "style-name"
	        }, {
	            ens: m,
	            en: "rotate",
	            ans: w,
	            a: "style-name"
	        }, {
	            ens: m,
	            en: "scene",
	            ans: w,
	            a: "style-name"
	        }, {
	            ens: m,
	            en: "sphere",
	            ans: w,
	            a: "style-name"
	        }, {
	            ens: h,
	            en: "caption",
	            ans: w,
	            a: "style-name"
	        }, {
	            ens: h,
	            en: "circle",
	            ans: w,
	            a: "style-name"
	        }, {
	            ens: h,
	            en: "connector",
	            ans: w,
	            a: "style-name"
	        }, {
	            ens: h,
	            en: "control",
	            ans: w,
	            a: "style-name"
	        }, {
	            ens: h,
	            en: "custom-shape",
	            ans: w,
	            a: "style-name"
	        }, {
	            ens: h,
	            en: "ellipse",
	            ans: w,
	            a: "style-name"
	        }, {
	            ens: h,
	            en: "frame",
	            ans: w,
	            a: "style-name"
	        }, {
	            ens: h,
	            en: "g",
	            ans: w,
	            a: "style-name"
	        }, {
	            ens: h,
	            en: "line",
	            ans: w,
	            a: "style-name"
	        }, {
	            ens: h,
	            en: "measure",
	            ans: w,
	            a: "style-name"
	        }, {
	            ens: h,
	            en: "page-thumbnail",
	            ans: w,
	            a: "style-name"
	        }, {
	            ens: h,
	            en: "path",
	            ans: w,
	            a: "style-name"
	        }, {
	            ens: h,
	            en: "polygon",
	            ans: w,
	            a: "style-name"
	        }, {
	            ens: h,
	            en: "polyline",
	            ans: w,
	            a: "style-name"
	        }, {
	            ens: h,
	            en: "rect",
	            ans: w,
	            a: "style-name"
	        }, {
	            ens: h,
	            en: "regular-polygon",
	            ans: w,
	            a: "style-name"
	        }, {
	            ens: z,
	            en: "annotation",
	            ans: w,
	            a: "style-name"
	        }],
	        "drawing-page": [{
	            ens: h,
	            en: "page",
	            ans: h,
	            a: "style-name"
	        }, {
	            ens: w,
	            en: "notes",
	            ans: h,
	            a: "style-name"
	        }, {
	            ens: v,
	            en: "handout-master",
	            ans: h,
	            a: "style-name"
	        }, {
	            ens: v,
	            en: "master-page",
	            ans: h,
	            a: "style-name"
	        }],
	        "list-style": [{
	            ens: t,
	            en: "list",
	            ans: t,
	            a: "style-name"
	        }, {
	            ens: t,
	            en: "numbered-paragraph",
	            ans: t,
	            a: "style-name"
	        }, {
	            ens: t,
	            en: "list-item",
	            ans: t,
	            a: "style-override"
	        }, {
	            ens: v,
	            en: "style",
	            ans: v,
	            a: "list-style-name"
	        }],
	        data: [{
	            ens: v,
	            en: "style",
	            ans: v,
	            a: "data-style-name"
	        }, {
	            ens: v,
	            en: "style",
	            ans: v,
	            a: "percentage-data-style-name"
	        }, {
	            ens: w,
	            en: "date-time-decl",
	            ans: v,
	            a: "data-style-name"
	        }, {
	            ens: t,
	            en: "creation-date",
	            ans: v,
	            a: "data-style-name"
	        }, {
	            ens: t,
	            en: "creation-time",
	            ans: v,
	            a: "data-style-name"
	        }, {
	            ens: t,
	            en: "database-display",
	            ans: v,
	            a: "data-style-name"
	        }, {
	            ens: t,
	            en: "date",
	            ans: v,
	            a: "data-style-name"
	        }, {
	            ens: t,
	            en: "editing-duration",
	            ans: v,
	            a: "data-style-name"
	        }, {
	            ens: t,
	            en: "expression",
	            ans: v,
	            a: "data-style-name"
	        }, {
	            ens: t,
	            en: "meta-field",
	            ans: v,
	            a: "data-style-name"
	        }, {
	            ens: t,
	            en: "modification-date",
	            ans: v,
	            a: "data-style-name"
	        }, {
	            ens: t,
	            en: "modification-time",
	            ans: v,
	            a: "data-style-name"
	        }, {
	            ens: t,
	            en: "print-date",
	            ans: v,
	            a: "data-style-name"
	        }, {
	            ens: t,
	            en: "print-time",
	            ans: v,
	            a: "data-style-name"
	        }, {
	            ens: t,
	            en: "table-formula",
	            ans: v,
	            a: "data-style-name"
	        }, {
	            ens: t,
	            en: "time",
	            ans: v,
	            a: "data-style-name"
	        }, {
	            ens: t,
	            en: "user-defined",
	            ans: v,
	            a: "data-style-name"
	        }, {
	            ens: t,
	            en: "user-field-get",
	            ans: v,
	            a: "data-style-name"
	        }, {
	            ens: t,
	            en: "user-field-input",
	            ans: v,
	            a: "data-style-name"
	        }, {
	            ens: t,
	            en: "variable-get",
	            ans: v,
	            a: "data-style-name"
	        }, {
	            ens: t,
	            en: "variable-input",
	            ans: v,
	            a: "data-style-name"
	        }, {
	            ens: t,
	            en: "variable-set",
	            ans: v,
	            a: "data-style-name"
	        }],
	        "page-layout": [{
	            ens: w,
	            en: "notes",
	            ans: v,
	            a: "page-layout-name"
	        }, {
	            ens: v,
	            en: "handout-master",
	            ans: v,
	            a: "page-layout-name"
	        }, {
	            ens: v,
	            en: "master-page",
	            ans: v,
	            a: "page-layout-name"
	        }]
	    }, K, L = xmldom.XPath;
	    this.collectUsedFontFaces = e;
	    this.changeFontFaceNames = l;
	    this.UsedStyleList = function(a, c) {
	        var d = {};
	        this.uses = function(a) {
	            var c = a.localName
	              , b = a.getAttributeNS(h, "name") || a.getAttributeNS(v, "name");
	            a = "style" === c ? a.getAttributeNS(v, "family") : a.namespaceURI === x ? "data" : c;
	            return (a = d[a]) ? 0 < a[b] : !1
	        }
	        ;
	        b(a, d);
	        c && q(c, d)
	    }
	    ;
	    this.getStyleName = function(a, c) {
	        var b, d, h = K[c.localName];
	        if (h && (h = h[c.namespaceURI]))
	            for (d = 0; d < h.length; d += 1)
	                if (h[d].keyname === a && (h = h[d],
	                c.hasAttributeNS(h.ns, h.localname))) {
	                    b = c.getAttributeNS(h.ns, h.localname);
	                    break
	                }
	        return b
	    }
	    ;
	    this.hasDerivedStyles = function(a, c, b) {
	        var d = b.getAttributeNS(v, "name");
	        b = b.getAttributeNS(v, "family");
	        return L.getODFElementsWithXPath(a, '//style:*[@style:parent-style-name="' + d + '"][@style:family="' + b + '"]', c).length ? !0 : !1
	    }
	    ;
	    this.prefixStyleNames = function(a, c, b) {
	        var d;
	        if (a) {
	            for (d = a.firstChild; d; ) {
	                if (d.nodeType === Node.ELEMENT_NODE) {
	                    var m = d
	                      , e = c
	                      , l = m.getAttributeNS(h, "name")
	                      , f = void 0;
	                    l ? f = h : (l = m.getAttributeNS(v, "name")) && (f = v);
	                    f && m.setAttributeNS(f, A[f] + "name", e + l)
	                }
	                d = d.nextSibling
	            }
	            g(a, c);
	            b && g(b, c)
	        }
	    }
	    ;
	    this.removePrefixFromStyleNames = function(a, c, b) {
	        var d = new RegExp("^" + c);
	        if (a) {
	            for (c = a.firstChild; c; ) {
	                if (c.nodeType === Node.ELEMENT_NODE) {
	                    var m = c
	                      , e = d
	                      , l = m.getAttributeNS(h, "name")
	                      , f = void 0;
	                    l ? f = h : (l = m.getAttributeNS(v, "name")) && (f = v);
	                    f && (l = l.replace(e, ""),
	                    m.setAttributeNS(f, A[f] + "name", l))
	                }
	                c = c.nextSibling
	            }
	            k(a, d);
	            b && k(b, d)
	        }
	    }
	    ;
	    this.determineStylesForNode = d;
	    K = function() {
	        var a, c, b, d, h, m = {}, e, l, f, n;
	        for (b in I)
	            if (I.hasOwnProperty(b))
	                for (d = I[b],
	                c = d.length,
	                a = 0; a < c; a += 1)
	                    h = d[a],
	                    f = h.en,
	                    n = h.ens,
	                    m.hasOwnProperty(f) ? e = m[f] : m[f] = e = {},
	                    e.hasOwnProperty(n) ? l = e[n] : e[n] = l = [],
	                    l.push({
	                        ns: h.ans,
	                        localname: h.a,
	                        keyname: b
	                    });
	        return m
	    }()
	}
	;
	"function" !== typeof Object.create && (Object.create = function(g) {
	    var k = function() {};
	    k.prototype = g;
	    return new k
	}
	);
	xmldom.LSSerializer = function() {
	    function g(b) {
	        var d = b || {}
	          , g = function(b) {
	            var a = {}, c;
	            for (c in b)
	                b.hasOwnProperty(c) && (a[b[c]] = c);
	            return a
	        }(b)
	          , k = [d]
	          , q = [g]
	          , e = 0;
	        this.push = function() {
	            e += 1;
	            d = k[e] = Object.create(d);
	            g = q[e] = Object.create(g)
	        }
	        ;
	        this.pop = function() {
	            k.pop();
	            q.pop();
	            --e;
	            d = k[e];
	            g = q[e]
	        }
	        ;
	        this.getLocalNamespaceDefinitions = function() {
	            return g
	        }
	        ;
	        this.getQName = function(b) {
	            var a = b.namespaceURI, c = 0, m;
	            if (!a)
	                return b.localName;
	            if (m = g[a])
	                return m + ":" + b.localName;
	            do {
	                m || !b.prefix ? (m = "ns" + c,
	                c += 1) : m = b.prefix;
	                if (d[m] === a)
	                    break;
	                if (!d[m]) {
	                    d[m] = a;
	                    g[a] = m;
	                    break
	                }
	                m = null
	            } while (null === m);
	            return m + ":" + b.localName
	        }
	    }
	    function k(b) {
	        return b.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/'/g, "&apos;").replace(/"/g, "&quot;")
	    }
	    function d(f, n) {
	        var g = "", r = b.filter ? b.filter.acceptNode(n) : NodeFilter.FILTER_ACCEPT, q;
	        if (r === NodeFilter.FILTER_ACCEPT && n.nodeType === Node.ELEMENT_NODE) {
	            f.push();
	            q = f.getQName(n);
	            var e, l = n.attributes, a, c, m, h = "", y;
	            e = "<" + q;
	            a = l.length;
	            for (c = 0; c < a; c += 1)
	                m = l.item(c),
	                "http://www.w3.org/2000/xmlns/" !== m.namespaceURI && (y = b.filter ? b.filter.acceptNode(m) : NodeFilter.FILTER_ACCEPT,
	                y === NodeFilter.FILTER_ACCEPT && (y = f.getQName(m),
	                m = "string" === typeof m.value ? k(m.value) : m.value,
	                h += " " + (y + '="' + m + '"')));
	            a = f.getLocalNamespaceDefinitions();
	            for (c in a)
	                a.hasOwnProperty(c) && ((l = a[c]) ? "xmlns" !== l && (e += " xmlns:" + a[c] + '="' + c + '"') : e += ' xmlns="' + c + '"');
	            g += e + (h + ">")
	        }
	        if (r === NodeFilter.FILTER_ACCEPT || r === NodeFilter.FILTER_SKIP) {
	            for (r = n.firstChild; r; )
	                g += d(f, r),
	                r = r.nextSibling;
	            n.nodeValue && (g += k(n.nodeValue))
	        }
	        q && (g += "</" + q + ">",
	        f.pop());
	        return g
	    }
	    var b = this;
	    this.filter = null;
	    this.writeToString = function(b, n) {
	        if (!b)
	            return "";
	        var k = new g(n);
	        return d(k, b)
	    }
	}
	;
	(function() {
	    function g(b) {
	        var a, c = r.length;
	        for (a = 0; a < c; a += 1)
	            if ("urn:oasis:names:tc:opendocument:xmlns:office:1.0" === b.namespaceURI && b.localName === r[a])
	                return a;
	        return -1
	    }
	    function k(b, a) {
	        var c = new f.UsedStyleList(b,a)
	          , d = new odf.OdfNodeFilter;
	        this.acceptNode = function(b) {
	            var e = d.acceptNode(b);
	            e === NodeFilter.FILTER_ACCEPT && b.parentNode === a && b.nodeType === Node.ELEMENT_NODE && (e = c.uses(b) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT);
	            return e
	        }
	    }
	    function d(b, a) {
	        var c = new k(b,a);
	        this.acceptNode = function(a) {
	            var b = c.acceptNode(a);
	            b !== NodeFilter.FILTER_ACCEPT || !a.parentNode || a.parentNode.namespaceURI !== odf.Namespaces.textns || "s" !== a.parentNode.localName && "tab" !== a.parentNode.localName || (b = NodeFilter.FILTER_REJECT);
	            return b
	        }
	    }
	    function b(b, a) {
	        if (a) {
	            var c = g(a), d, h = b.firstChild;
	            if (-1 !== c) {
	                for (; h; ) {
	                    d = g(h);
	                    if (-1 !== d && d > c)
	                        break;
	                    h = h.nextSibling
	                }
	                b.insertBefore(a, h)
	            }
	        }
	    }
	    var f = new odf.StyleInfo
	      , n = core.DomUtils
	      , p = odf.Namespaces.stylens
	      , r = "meta settings scripts font-face-decls styles automatic-styles master-styles body".split(" ")
	      , q = Date.now() + "_webodf_"
	      , e = new core.Base64;
	    odf.ODFElement = function() {}
	    ;
	    odf.ODFDocumentElement = function() {}
	    ;
	    odf.ODFDocumentElement.prototype = new odf.ODFElement;
	    odf.ODFDocumentElement.prototype.constructor = odf.ODFDocumentElement;
	    odf.ODFDocumentElement.prototype.fontFaceDecls = null;
	    odf.ODFDocumentElement.prototype.manifest = null;
	    odf.ODFDocumentElement.prototype.settings = null;
	    odf.ODFDocumentElement.namespaceURI = "urn:oasis:names:tc:opendocument:xmlns:office:1.0";
	    odf.ODFDocumentElement.localName = "document";
	    odf.AnnotationElement = function() {}
	    ;
	    odf.OdfPart = function(b, a, c, d) {
	        var h = this;
	        this.size = 0;
	        this.type = null;
	        this.name = b;
	        this.container = c;
	        this.url = null;
	        this.mimetype = a;
	        this.onstatereadychange = this.document = null;
	        this.EMPTY = 0;
	        this.LOADING = 1;
	        this.DONE = 2;
	        this.state = this.EMPTY;
	        this.data = "";
	        this.load = function() {
	            null !== d && (this.mimetype = a,
	            d.loadAsDataURL(b, a, function(a, c) {
	                a && runtime.log(a);
	                h.url = c;
	                if (h.onchange)
	                    h.onchange(h);
	                if (h.onstatereadychange)
	                    h.onstatereadychange(h)
	            }))
	        }
	    }
	    ;
	    odf.OdfPart.prototype.load = function() {}
	    ;
	    odf.OdfPart.prototype.getUrl = function() {
	        return this.data ? "data:;base64," + e.toBase64(this.data) : null
	    }
	    ;
	    odf.OdfContainer = function a(c, m) {
	        function h(a) {
	            for (var c = a.firstChild, b; c; )
	                b = c.nextSibling,
	                c.nodeType === Node.ELEMENT_NODE ? h(c) : c.nodeType === Node.PROCESSING_INSTRUCTION_NODE && a.removeChild(c),
	                c = b
	        }
	        function g(a) {
	            var c = {}, b, d, h = a.ownerDocument.createNodeIterator(a, NodeFilter.SHOW_ELEMENT, null, !1);
	            for (a = h.nextNode(); a; )
	                "urn:oasis:names:tc:opendocument:xmlns:office:1.0" === a.namespaceURI && ("annotation" === a.localName ? (b = a.getAttributeNS("urn:oasis:names:tc:opendocument:xmlns:office:1.0", "name")) && (c.hasOwnProperty(b) ? runtime.log("Warning: annotation name used more than once with <office:annotation/>: '" + b + "'") : c[b] = a) : "annotation-end" === a.localName && ((b = a.getAttributeNS("urn:oasis:names:tc:opendocument:xmlns:office:1.0", "name")) ? c.hasOwnProperty(b) ? (d = c[b],
	                d.annotationEndElement ? runtime.log("Warning: annotation name used more than once with <office:annotation-end/>: '" + b + "'") : d.annotationEndElement = a) : runtime.log("Warning: annotation end without an annotation start, name: '" + b + "'") : runtime.log("Warning: annotation end without a name found"))),
	                a = h.nextNode()
	        }
	        function r(a, c) {
	            for (var b = a && a.firstChild; b; )
	                b.nodeType === Node.ELEMENT_NODE && b.setAttributeNS("urn:webodf:names:scope", "scope", c),
	                b = b.nextSibling
	        }
	        function z(a, c) {
	            for (var b = B.rootElement.meta, b = b && b.firstChild; b && (b.namespaceURI !== a || b.localName !== c); )
	                b = b.nextSibling;
	            for (b = b && b.firstChild; b && b.nodeType !== Node.TEXT_NODE; )
	                b = b.nextSibling;
	            return b ? b.data : null
	        }
	        function w(a) {
	            var c = {}, b;
	            for (a = a.firstChild; a; )
	                a.nodeType === Node.ELEMENT_NODE && a.namespaceURI === p && "font-face" === a.localName && (b = a.getAttributeNS(p, "name"),
	                c[b] = a),
	                a = a.nextSibling;
	            return c
	        }
	        function v(a, c) {
	            var b = null, d, h, e;
	            if (a)
	                for (b = a.cloneNode(!0),
	                d = b.firstElementChild; d; )
	                    h = d.nextElementSibling,
	                    (e = d.getAttributeNS("urn:webodf:names:scope", "scope")) && e !== c && b.removeChild(d),
	                    d = h;
	            return b
	        }
	        function u(a, c) {
	            var b, d, h, e = null, m = {};
	            if (a)
	                for (c.forEach(function(a) {
	                    f.collectUsedFontFaces(m, a)
	                }),
	                e = a.cloneNode(!0),
	                b = e.firstElementChild; b; )
	                    d = b.nextElementSibling,
	                    h = b.getAttributeNS(p, "name"),
	                    m[h] || e.removeChild(b),
	                    b = d;
	            return e
	        }
	        function t(a) {
	            var c = B.rootElement.ownerDocument, b;
	            if (a) {
	                h(a.documentElement);
	                try {
	                    b = c.importNode(a.documentElement, !0)
	                } catch (d) {}
	            }
	            return b
	        }
	        function A(a) {
	            B.state = a;
	            if (B.onchange)
	                B.onchange(B);
	            if (B.onstatereadychange)
	                B.onstatereadychange(B)
	        }
	        function I(a) {
	            Q = null;
	            B.rootElement = a;
	            a.fontFaceDecls = n.getDirectChild(a, "urn:oasis:names:tc:opendocument:xmlns:office:1.0", "font-face-decls");
	            a.styles = n.getDirectChild(a, "urn:oasis:names:tc:opendocument:xmlns:office:1.0", "styles");
	            a.automaticStyles = n.getDirectChild(a, "urn:oasis:names:tc:opendocument:xmlns:office:1.0", "automatic-styles");
	            a.masterStyles = n.getDirectChild(a, "urn:oasis:names:tc:opendocument:xmlns:office:1.0", "master-styles");
	            a.body = n.getDirectChild(a, "urn:oasis:names:tc:opendocument:xmlns:office:1.0", "body");
	            a.meta = n.getDirectChild(a, "urn:oasis:names:tc:opendocument:xmlns:office:1.0", "meta");
	            a.settings = n.getDirectChild(a, "urn:oasis:names:tc:opendocument:xmlns:office:1.0", "settings");
	            a.scripts = n.getDirectChild(a, "urn:oasis:names:tc:opendocument:xmlns:office:1.0", "scripts");
	            g(a)
	        }
	        function K(c) {
	            var d = t(c), h = B.rootElement, e;
	            d && "document-styles" === d.localName && "urn:oasis:names:tc:opendocument:xmlns:office:1.0" === d.namespaceURI ? (h.fontFaceDecls = n.getDirectChild(d, "urn:oasis:names:tc:opendocument:xmlns:office:1.0", "font-face-decls"),
	            b(h, h.fontFaceDecls),
	            e = n.getDirectChild(d, "urn:oasis:names:tc:opendocument:xmlns:office:1.0", "styles"),
	            h.styles = e || c.createElementNS("urn:oasis:names:tc:opendocument:xmlns:office:1.0", "styles"),
	            b(h, h.styles),
	            e = n.getDirectChild(d, "urn:oasis:names:tc:opendocument:xmlns:office:1.0", "automatic-styles"),
	            h.automaticStyles = e || c.createElementNS("urn:oasis:names:tc:opendocument:xmlns:office:1.0", "automatic-styles"),
	            r(h.automaticStyles, "document-styles"),
	            b(h, h.automaticStyles),
	            d = n.getDirectChild(d, "urn:oasis:names:tc:opendocument:xmlns:office:1.0", "master-styles"),
	            h.masterStyles = d || c.createElementNS("urn:oasis:names:tc:opendocument:xmlns:office:1.0", "master-styles"),
	            b(h, h.masterStyles),
	            f.prefixStyleNames(h.automaticStyles, q, h.masterStyles)) : A(a.INVALID)
	        }
	        function L(c) {
	            c = t(c);
	            var d, h, e, m;
	            if (c && "document-content" === c.localName && "urn:oasis:names:tc:opendocument:xmlns:office:1.0" === c.namespaceURI) {
	                d = B.rootElement;
	                e = n.getDirectChild(c, "urn:oasis:names:tc:opendocument:xmlns:office:1.0", "font-face-decls");
	                if (d.fontFaceDecls && e) {
	                    m = d.fontFaceDecls;
	                    var g, k, O, q, D = {};
	                    h = w(m);
	                    q = w(e);
	                    for (e = e.firstElementChild; e; ) {
	                        g = e.nextElementSibling;
	                        if (e.namespaceURI === p && "font-face" === e.localName)
	                            if (k = e.getAttributeNS(p, "name"),
	                            h.hasOwnProperty(k)) {
	                                if (!e.isEqualNode(h[k])) {
	                                    O = k;
	                                    for (var y = h, E = q, u = 0, W = void 0, W = O = O.replace(/\d+$/, ""); y.hasOwnProperty(W) || E.hasOwnProperty(W); )
	                                        u += 1,
	                                        W = O + u;
	                                    O = W;
	                                    e.setAttributeNS(p, "style:name", O);
	                                    m.appendChild(e);
	                                    h[O] = e;
	                                    delete q[k];
	                                    D[k] = O
	                                }
	                            } else
	                                m.appendChild(e),
	                                h[k] = e,
	                                delete q[k];
	                        e = g
	                    }
	                    m = D
	                } else
	                    e && (d.fontFaceDecls = e,
	                    b(d, e));
	                h = n.getDirectChild(c, "urn:oasis:names:tc:opendocument:xmlns:office:1.0", "automatic-styles");
	                r(h, "document-content");
	                m && f.changeFontFaceNames(h, m);
	                if (d.automaticStyles && h)
	                    for (m = h.firstChild; m; )
	                        d.automaticStyles.appendChild(m),
	                        m = h.firstChild;
	                else
	                    h && (d.automaticStyles = h,
	                    b(d, h));
	                c = n.getDirectChild(c, "urn:oasis:names:tc:opendocument:xmlns:office:1.0", "body");
	                if (null === c)
	                    throw "<office:body/> tag is mising.";
	                d.body = c;
	                b(d, d.body)
	            } else
	                A(a.INVALID)
	        }
	        function E(a) {
	            a = t(a);
	            var c;
	            a && "document-meta" === a.localName && "urn:oasis:names:tc:opendocument:xmlns:office:1.0" === a.namespaceURI && (c = B.rootElement,
	            c.meta = n.getDirectChild(a, "urn:oasis:names:tc:opendocument:xmlns:office:1.0", "meta"),
	            b(c, c.meta))
	        }
	        function N(a) {
	            a = t(a);
	            var c;
	            a && "document-settings" === a.localName && "urn:oasis:names:tc:opendocument:xmlns:office:1.0" === a.namespaceURI && (c = B.rootElement,
	            c.settings = n.getDirectChild(a, "urn:oasis:names:tc:opendocument:xmlns:office:1.0", "settings"),
	            b(c, c.settings))
	        }
	        function O(a) {
	            a = t(a);
	            var c;
	            if (a && "manifest" === a.localName && "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" === a.namespaceURI)
	                for (c = B.rootElement,
	                c.manifest = a,
	                a = c.manifest.firstElementChild; a; )
	                    "file-entry" === a.localName && "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" === a.namespaceURI && (M[a.getAttributeNS("urn:oasis:names:tc:opendocument:xmlns:manifest:1.0", "full-path")] = a.getAttributeNS("urn:oasis:names:tc:opendocument:xmlns:manifest:1.0", "media-type")),
	                    a = a.nextElementSibling
	        }
	        function D(a, c, b) {
	            a = n.getElementsByTagName(a, c);
	            var d;
	            for (d = 0; d < a.length; d += 1)
	                c = a[d],
	                b.hasOwnProperty(c.namespaceURI) || c.parentNode.removeChild(c)
	        }
	        function V(a) {
	            D(a, "script", {
	                "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0": !0,
	                "urn:oasis:names:tc:opendocument:xmlns:office:1.0": !0,
	                "urn:oasis:names:tc:opendocument:xmlns:table:1.0": !0,
	                "urn:oasis:names:tc:opendocument:xmlns:text:1.0": !0,
	                "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0": !0
	            });
	            D(a, "style", {
	                "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0": !0,
	                "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0": !0,
	                "urn:oasis:names:tc:opendocument:xmlns:style:1.0": !0
	            })
	        }
	        function W(a) {
	            var c = a.firstElementChild, b = [], d, h, e, m = a.attributes, f = m.length;
	            for (d = 0; d < f; d += 1)
	                e = m.item(d),
	                h = e.localName.substr(0, 2).toLowerCase(),
	                null === e.namespaceURI && "on" === h && b.push(e);
	            f = b.length;
	            for (d = 0; d < f; d += 1)
	                a.removeAttributeNode(b[d]);
	            for (; c; )
	                W(c),
	                c = c.nextElementSibling
	        }
	        function J(c) {
	            var b = c.shift();
	            b ? Y.loadAsDOM(b.path, function(d, h) {
	                h && (V(h),
	                W(h.documentElement));
	                b.handler(h);
	                B.state === a.INVALID ? d ? runtime.log("ERROR: Unable to load " + b.path + " - " + d) : runtime.log("ERROR: Unable to load " + b.path) : (d && runtime.log("DEBUG: Unable to load " + b.path + " - " + d),
	                J(c))
	            }) : (g(B.rootElement),
	            A(a.DONE))
	        }
	        function R(a) {
	            var c = "";
	            odf.Namespaces.forEachPrefix(function(a, b) {
	                c += " xmlns:" + a + '="' + b + '"'
	            });
	            return '<?xml version="1.0" encoding="UTF-8"?><office:' + a + " " + c + ' office:version="1.2">'
	        }
	        function P() {
	            var a = new xmldom.LSSerializer
	              , c = R("document-meta");
	            a.filter = new odf.OdfNodeFilter;
	            c += a.writeToString(B.rootElement.meta, odf.Namespaces.namespaceMap);
	            return c + "</office:document-meta>"
	        }
	        function aa(a, c) {
	            var b = document.createElementNS("urn:oasis:names:tc:opendocument:xmlns:manifest:1.0", "manifest:file-entry");
	            b.setAttributeNS("urn:oasis:names:tc:opendocument:xmlns:manifest:1.0", "manifest:full-path", a);
	            b.setAttributeNS("urn:oasis:names:tc:opendocument:xmlns:manifest:1.0", "manifest:media-type", c);
	            return b
	        }
	        function S() {
	            var a = runtime.parseXML('<manifest:manifest xmlns:manifest="urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" manifest:version="1.2"></manifest:manifest>'), c = a.documentElement, b = new xmldom.LSSerializer, d;
	            for (d in M)
	                M.hasOwnProperty(d) && c.appendChild(aa(d, M[d]));
	            b.filter = new odf.OdfNodeFilter;
	            return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n' + b.writeToString(a, odf.Namespaces.namespaceMap)
	        }
	        function fa() {
	            var a, c, b, d = odf.Namespaces.namespaceMap, h = new xmldom.LSSerializer, e = R("document-styles");
	            c = v(B.rootElement.automaticStyles, "document-styles");
	            b = B.rootElement.masterStyles.cloneNode(!0);
	            a = u(B.rootElement.fontFaceDecls, [b, B.rootElement.styles, c]);
	            f.removePrefixFromStyleNames(c, q, b);
	            h.filter = new k(b,c);
	            e += h.writeToString(a, d);
	            e += h.writeToString(B.rootElement.styles, d);
	            e += h.writeToString(c, d);
	            e += h.writeToString(b, d);
	            return e + "</office:document-styles>"
	        }
	        function ha() {
	            var a, c, b = odf.Namespaces.namespaceMap, h = new xmldom.LSSerializer, e = R("document-content");
	            c = v(B.rootElement.automaticStyles, "document-content");
	            a = u(B.rootElement.fontFaceDecls, [c]);
	            h.filter = new d(B.rootElement.body,c);
	            e += h.writeToString(a, b);
	            e += h.writeToString(c, b);
	            e += h.writeToString(B.rootElement.body, b);
	            return e + "</office:document-content>"
	        }
	        function C(c, b) {
	            runtime.loadXML(c, function(c, d) {
	                if (c)
	                    b(c);
	                else if (d) {
	                    V(d);
	                    W(d.documentElement);
	                    var h = t(d);
	                    h && "document" === h.localName && "urn:oasis:names:tc:opendocument:xmlns:office:1.0" === h.namespaceURI ? (I(h),
	                    A(a.DONE)) : A(a.INVALID)
	                } else
	                    b("No DOM was loaded.")
	            })
	        }
	        function Z(a, c) {
	            var d;
	            d = B.rootElement;
	            var h = d.meta;
	            h || (d.meta = h = document.createElementNS("urn:oasis:names:tc:opendocument:xmlns:office:1.0", "meta"),
	            b(d, h));
	            d = h;
	            a && n.mapKeyValObjOntoNode(d, a, odf.Namespaces.lookupNamespaceURI);
	            c && n.removeKeyElementsFromNode(d, c, odf.Namespaces.lookupNamespaceURI)
	        }
	        function ba(c, b) {
	            function d(a, c) {
	                var b;
	                c || (c = a);
	                b = document.createElementNS("urn:oasis:names:tc:opendocument:xmlns:office:1.0", c);
	                f[a] = b;
	                f.appendChild(b)
	            }
	            var h = new core.Zip("",null)
	              , e = "application/vnd.oasis.opendocument." + c + (!0 === b ? "-template" : "")
	              , m = runtime.byteArrayFromString(e, "utf8")
	              , f = B.rootElement
	              , g = document.createElementNS("urn:oasis:names:tc:opendocument:xmlns:office:1.0", c);
	            h.save("mimetype", m, !1, new Date);
	            d("meta");
	            d("settings");
	            d("scripts");
	            d("fontFaceDecls", "font-face-decls");
	            d("styles");
	            d("automaticStyles", "automatic-styles");
	            d("masterStyles", "master-styles");
	            d("body");
	            f.body.appendChild(g);
	            M["/"] = e;
	            M["settings.xml"] = "text/xml";
	            M["meta.xml"] = "text/xml";
	            M["styles.xml"] = "text/xml";
	            M["content.xml"] = "text/xml";
	            A(a.DONE);
	            return h
	        }
	        function U() {
	            var a, c = new Date, b = "";
	            B.rootElement.settings && B.rootElement.settings.firstElementChild && (a = new xmldom.LSSerializer,
	            b = R("document-settings"),
	            a.filter = new odf.OdfNodeFilter,
	            b += a.writeToString(B.rootElement.settings, odf.Namespaces.namespaceMap),
	            b += "</office:document-settings>");
	            (a = b) ? (a = runtime.byteArrayFromString(a, "utf8"),
	            Y.save("settings.xml", a, !0, c)) : Y.remove("settings.xml");
	            b = runtime.getWindow();
	            a = "WebODF/" + webodf.Version;
	            b && (a = a + " " + b.navigator.userAgent);
	            Z({
	                "meta:generator": a
	            }, null);
	            a = runtime.byteArrayFromString(P(), "utf8");
	            Y.save("meta.xml", a, !0, c);
	            a = runtime.byteArrayFromString(fa(), "utf8");
	            Y.save("styles.xml", a, !0, c);
	            a = runtime.byteArrayFromString(ha(), "utf8");
	            Y.save("content.xml", a, !0, c);
	            a = runtime.byteArrayFromString(S(), "utf8");
	            Y.save("META-INF/manifest.xml", a, !0, c)
	        }
	        function ga(a, c) {
	            U();
	            Y.writeAs(a, function(a) {
	                c(a)
	            })
	        }
	        var B = this, Y, M = {}, Q, F = "";
	        this.onstatereadychange = m;
	        this.state = this.onchange = null;
	        this.getMetadata = z;
	        this.setRootElement = I;
	        this.getContentElement = function() {
	            var a;
	            Q || (a = B.rootElement.body,
	            Q = n.getDirectChild(a, "urn:oasis:names:tc:opendocument:xmlns:office:1.0", "text") || n.getDirectChild(a, "urn:oasis:names:tc:opendocument:xmlns:office:1.0", "presentation") || n.getDirectChild(a, "urn:oasis:names:tc:opendocument:xmlns:office:1.0", "spreadsheet"));
	            if (!Q)
	                throw "Could not find content element in <office:body/>.";
	            return Q
	        }
	        ;
	        this.getDocumentType = function() {
	            var a = B.getContentElement();
	            return a && a.localName
	        }
	        ;
	        this.isTemplate = function() {
	            return "-template" === M["/"].substr(-9)
	        }
	        ;
	        this.setIsTemplate = function(a) {
	            var c = M["/"]
	              , b = "-template" === c.substr(-9);
	            a !== b && (c = a ? c + "-template" : c.substr(0, c.length - 9),
	            M["/"] = c,
	            a = runtime.byteArrayFromString(c, "utf8"),
	            Y.save("mimetype", a, !1, new Date))
	        }
	        ;
	        this.getPart = function(a) {
	            return new odf.OdfPart(a,M[a],B,Y)
	        }
	        ;
	        this.getPartData = function(a, c) {
	            Y.load(a, c)
	        }
	        ;
	        this.setMetadata = Z;
	        this.incrementEditingCycles = function() {
	            var a = z(odf.Namespaces.metans, "editing-cycles")
	              , a = a ? parseInt(a, 10) : 0;
	            isNaN(a) && (a = 0);
	            Z({
	                "meta:editing-cycles": a + 1
	            }, null);
	            return a + 1
	        }
	        ;
	        this.createByteArray = function(a, c) {
	            U();
	            Y.createByteArray(a, c)
	        }
	        ;
	        this.saveAs = ga;
	        this.save = function(a) {
	            ga(F, a)
	        }
	        ;
	        this.getUrl = function() {
	            return F
	        }
	        ;
	        this.setBlob = function(a, c, b) {
	            b = e.convertBase64ToByteArray(b);
	            Y.save(a, b, !1, new Date);
	            M.hasOwnProperty(a) && runtime.log(a + " has been overwritten.");
	            M[a] = c
	        }
	        ;
	        this.removeBlob = function(a) {
	            var c = Y.remove(a);
	            runtime.assert(c, "file is not found: " + a);
	            delete M[a]
	        }
	        ;
	        this.state = a.LOADING;
	        this.rootElement = function(a) {
	            var c = document.createElementNS(a.namespaceURI, a.localName), b;
	            a = new a.Type;
	            for (b in a)
	                a.hasOwnProperty(b) && (c[b] = a[b]);
	            return c
	        }({
	            Type: odf.ODFDocumentElement,
	            namespaceURI: odf.ODFDocumentElement.namespaceURI,
	            localName: odf.ODFDocumentElement.localName
	        });
	        c === odf.OdfContainer.DocumentType.TEXT ? Y = ba("text") : c === odf.OdfContainer.DocumentType.TEXT_TEMPLATE ? Y = ba("text", !0) : c === odf.OdfContainer.DocumentType.PRESENTATION ? Y = ba("presentation") : c === odf.OdfContainer.DocumentType.PRESENTATION_TEMPLATE ? Y = ba("presentation", !0) : c === odf.OdfContainer.DocumentType.SPREADSHEET ? Y = ba("spreadsheet") : c === odf.OdfContainer.DocumentType.SPREADSHEET_TEMPLATE ? Y = ba("spreadsheet", !0) : (F = c,
	        Y = new core.Zip(F,function(c, b) {
	            Y = b;
	            c ? C(F, function(b) {
	                c && (Y.error = c + "\n" + b,
	                A(a.INVALID))
	            }) : J([{
	                path: "styles.xml",
	                handler: K
	            }, {
	                path: "content.xml",
	                handler: L
	            }, {
	                path: "meta.xml",
	                handler: E
	            }, {
	                path: "settings.xml",
	                handler: N
	            }, {
	                path: "META-INF/manifest.xml",
	                handler: O
	            }])
	        }
	        ))
	    }
	    ;
	    odf.OdfContainer.EMPTY = 0;
	    odf.OdfContainer.LOADING = 1;
	    odf.OdfContainer.DONE = 2;
	    odf.OdfContainer.INVALID = 3;
	    odf.OdfContainer.SAVING = 4;
	    odf.OdfContainer.MODIFIED = 5;
	    odf.OdfContainer.getContainer = function(a) {
	        return new odf.OdfContainer(a,null)
	    }
	}
	)();
	odf.OdfContainer.DocumentType = {
	    TEXT: 1,
	    TEXT_TEMPLATE: 2,
	    PRESENTATION: 3,
	    PRESENTATION_TEMPLATE: 4,
	    SPREADSHEET: 5,
	    SPREADSHEET_TEMPLATE: 6
	};
	gui.AnnotatableCanvas = function() {}
	;
	gui.AnnotatableCanvas.prototype.refreshSize = function() {}
	;
	gui.AnnotatableCanvas.prototype.getZoomLevel = function() {}
	;
	gui.AnnotatableCanvas.prototype.getSizer = function() {}
	;
	gui.AnnotationViewManager = function(g, k, d, b) {
	    function f(c) {
	        var b = c.annotationEndElement
	          , d = l.createRange()
	          , e = c.getAttributeNS(odf.Namespaces.officens, "name");
	        b && (d.setStart(c, c.childNodes.length),
	        d.setEnd(b, 0),
	        c = a.getTextNodes(d, !1),
	        c.forEach(function(a) {
	            var c;
	            a: {
	                for (c = a.parentNode; c.namespaceURI !== odf.Namespaces.officens || "body" !== c.localName; ) {
	                    if ("http://www.w3.org/1999/xhtml" === c.namespaceURI && "webodf-annotationHighlight" === c.className && c.getAttribute("annotation") === e) {
	                        c = !0;
	                        break a
	                    }
	                    c = c.parentNode
	                }
	                c = !1
	            }
	            c || (c = l.createElement("span"),
	            c.className = "webodf-annotationHighlight",
	            c.setAttribute("annotation", e),
	            a.parentNode.replaceChild(c, a),
	            c.appendChild(a))
	        }));
	        d.detach()
	    }
	    function n(a) {
	        var b = g.getSizer();
	        a ? (d.style.display = "inline-block",
	        b.style.paddingRight = c.getComputedStyle(d).width) : (d.style.display = "none",
	        b.style.paddingRight = 0);
	        g.refreshSize()
	    }
	    function p() {
	        e.sort(function(a, c) {
	            return 0 !== (a.compareDocumentPosition(c) & Node.DOCUMENT_POSITION_FOLLOWING) ? -1 : 1
	        })
	    }
	    function r() {
	        var a;
	        for (a = 0; a < e.length; a += 1) {
	            var c = e[a]
	              , b = c.parentNode
	              , f = b.nextElementSibling
	              , l = f.nextElementSibling
	              , n = b.parentNode
	              , k = 0
	              , k = e[e.indexOf(c) - 1]
	              , r = void 0
	              , c = g.getZoomLevel();
	            b.style.left = (d.getBoundingClientRect().left - n.getBoundingClientRect().left) / c + "px";
	            b.style.width = d.getBoundingClientRect().width / c + "px";
	            f.style.width = parseFloat(b.style.left) - 30 + "px";
	            k ? (r = k.parentNode.getBoundingClientRect(),
	            20 >= (n.getBoundingClientRect().top - r.bottom) / c ? b.style.top = Math.abs(n.getBoundingClientRect().top - r.bottom) / c + 20 + "px" : b.style.top = "0px") : b.style.top = "0px";
	            l.style.left = f.getBoundingClientRect().width / c + "px";
	            var f = l.style
	              , n = l.getBoundingClientRect().left / c
	              , k = l.getBoundingClientRect().top / c
	              , r = b.getBoundingClientRect().left / c
	              , p = b.getBoundingClientRect().top / c
	              , q = 0
	              , I = 0
	              , q = r - n
	              , q = q * q
	              , I = p - k
	              , I = I * I
	              , n = Math.sqrt(q + I);
	            f.width = n + "px";
	            k = Math.asin((b.getBoundingClientRect().top - l.getBoundingClientRect().top) / (c * parseFloat(l.style.width)));
	            l.style.transform = "rotate(" + k + "rad)";
	            l.style.MozTransform = "rotate(" + k + "rad)";
	            l.style.WebkitTransform = "rotate(" + k + "rad)";
	            l.style.msTransform = "rotate(" + k + "rad)"
	        }
	    }
	    function q(a) {
	        var c = e.indexOf(a)
	          , b = a.parentNode.parentNode;
	        "div" === b.localName && (b.parentNode.insertBefore(a, b),
	        b.parentNode.removeChild(b));
	        a = a.getAttributeNS(odf.Namespaces.officens, "name");
	        a = l.querySelectorAll('span.webodf-annotationHighlight[annotation="' + a + '"]');
	        for (var d, b = 0; b < a.length; b += 1) {
	            for (d = a.item(b); d.firstChild; )
	                d.parentNode.insertBefore(d.firstChild, d);
	            d.parentNode.removeChild(d)
	        }
	        -1 !== c && e.splice(c, 1);
	        0 === e.length && n(!1)
	    }
	    var e = []
	      , l = k.ownerDocument
	      , a = odf.OdfUtils
	      , c = runtime.getWindow();
	    runtime.assert(Boolean(c), "Expected to be run in an environment which has a global window, like a browser.");
	    this.rerenderAnnotations = r;
	    this.rehighlightAnnotations = function() {
	        e.forEach(function(a) {
	            f(a)
	        })
	    }
	    ;
	    this.getMinimumHeightForAnnotationPane = function() {
	        return "none" !== d.style.display && 0 < e.length ? (e[e.length - 1].parentNode.getBoundingClientRect().bottom - d.getBoundingClientRect().top) / g.getZoomLevel() + "px" : null
	    }
	    ;
	    this.addAnnotations = function(c) {
	        0 !== c.length && (n(!0),
	        c.forEach(function(c) {
	            e.push(c);
	            var d = l.createElement("div"), m = l.createElement("div"), n = l.createElement("div"), g = l.createElement("div"), k;
	            d.className = "annotationWrapper";
	            d.setAttribute("creator", a.getAnnotationCreator(c));
	            c.parentNode.insertBefore(d, c);
	            m.className = "annotationNote";
	            m.appendChild(c);
	            b && (k = l.createElement("div"),
	            k.className = "annotationRemoveButton",
	            m.appendChild(k));
	            n.className = "annotationConnector horizontal";
	            g.className = "annotationConnector angular";
	            d.appendChild(m);
	            d.appendChild(n);
	            d.appendChild(g);
	            c.annotationEndElement && f(c)
	        }),
	        p(),
	        r())
	    }
	    ;
	    this.forgetAnnotation = q;
	    this.forgetAnnotations = function() {
	        for (; e.length; )
	            q(e[0])
	    }
	}
	;
	gui.Viewport = function() {}
	;
	gui.Viewport.prototype.scrollIntoView = function(g, k) {}
	;
	gui.SingleScrollViewport = function(g) {
	    this.scrollIntoView = function(k, d) {
	        var b, f, n, p;
	        p = g.offsetHeight - g.clientHeight;
	        n = g.offsetWidth - g.clientWidth;
	        var r = g.getBoundingClientRect();
	        if (k && r) {
	            b = r.left + 5;
	            f = r.top + 5;
	            n = r.right - (n + 5);
	            p = r.bottom - (p + 5);
	            if (d || k.top < f)
	                g.scrollTop -= f - k.top;
	            else if (k.top > p || k.bottom > p)
	                g.scrollTop = k.bottom - k.top <= p - f ? g.scrollTop + (k.bottom - p) : g.scrollTop + (k.top - f);
	            k.left < b ? g.scrollLeft -= b - k.left : k.right > n && (g.scrollLeft = k.right - k.left <= n - b ? g.scrollLeft + (k.right - n) : g.scrollLeft - (b - k.left))
	        }
	    }
	}
	;
	(function() {
	    function g(d, n, k, r, q) {
	        var e, l = 0, a;
	        for (a in d)
	            if (d.hasOwnProperty(a)) {
	                if (l === k) {
	                    e = a;
	                    break
	                }
	                l += 1
	            }
	        e ? n.getPartData(d[e].href, function(a, m) {
	            if (a)
	                runtime.log(a);
	            else if (m) {
	                var h = "@font-face { font-family: " + (d[e].family || e) + "; src: url(data:application/x-font-ttf;charset=binary;base64," + b.convertUTF8ArrayToBase64(m) + ') format("truetype"); }';
	                try {
	                    r.insertRule(h, r.cssRules.length)
	                } catch (l) {
	                    runtime.log("Problem inserting rule in CSS: " + runtime.toJson(l) + "\nRule: " + h)
	                }
	            } else
	                runtime.log("missing font data for " + d[e].href);
	            g(d, n, k + 1, r, q)
	        }) : q && q()
	    }
	    var k = xmldom.XPath
	      , d = odf.OdfUtils
	      , b = new core.Base64;
	    odf.FontLoader = function() {
	        this.loadFonts = function(b, n) {
	            for (var p = b.rootElement.fontFaceDecls; n.cssRules.length; )
	                n.deleteRule(n.cssRules.length - 1);
	            if (p) {
	                var r = {}, q, e, l, a;
	                if (p)
	                    for (p = k.getODFElementsWithXPath(p, "style:font-face[svg:font-face-src]", odf.Namespaces.lookupNamespaceURI),
	                    q = 0; q < p.length; q += 1)
	                        e = p[q],
	                        l = e.getAttributeNS(odf.Namespaces.stylens, "name"),
	                        a = d.getNormalizedFontFamilyName(e.getAttributeNS(odf.Namespaces.svgns, "font-family")),
	                        e = k.getODFElementsWithXPath(e, "svg:font-face-src/svg:font-face-uri", odf.Namespaces.lookupNamespaceURI),
	                        0 < e.length && (e = e[0].getAttributeNS(odf.Namespaces.xlinkns, "href"),
	                        r[l] = {
	                            href: e,
	                            family: a
	                        });
	                g(r, b, 0, n)
	            }
	        }
	    }
	}
	)();
	odf.Formatting = function() {
	    function g(a) {
	        return (a = A[a]) ? u.mergeObjects({}, a) : {}
	    }
	    function k() {
	        for (var c = a.rootElement.fontFaceDecls, b = {}, d, e, c = c && c.firstElementChild; c; ) {
	            if (d = c.getAttributeNS(h, "name"))
	                if ((e = c.getAttributeNS(m, "font-family")) || 0 < c.getElementsByTagNameNS(m, "font-face-uri").length)
	                    b[d] = e;
	            c = c.nextElementSibling
	        }
	        return b
	    }
	    function d(c) {
	        for (var b = a.rootElement.styles.firstElementChild; b; ) {
	            if (b.namespaceURI === h && "default-style" === b.localName && b.getAttributeNS(h, "family") === c)
	                return b;
	            b = b.nextElementSibling
	        }
	        return null
	    }
	    function b(c, b, d) {
	        var e, m, l;
	        d = d || [a.rootElement.automaticStyles, a.rootElement.styles];
	        for (l = 0; l < d.length; l += 1)
	            for (e = d[l],
	            e = e.firstElementChild; e; ) {
	                m = e.getAttributeNS(h, "name");
	                if (e.namespaceURI === h && "style" === e.localName && e.getAttributeNS(h, "family") === b && m === c || "list-style" === b && e.namespaceURI === y && "list-style" === e.localName && m === c || "data" === b && e.namespaceURI === x && m === c)
	                    return e;
	                e = e.nextElementSibling
	            }
	        return null
	    }
	    function f(a) {
	        for (var c, b, d, e, m = {}, l = a.firstElementChild; l; ) {
	            if (l.namespaceURI === h)
	                for (d = m[l.nodeName] = {},
	                b = l.attributes,
	                c = 0; c < b.length; c += 1)
	                    e = b.item(c),
	                    d[e.name] = e.value;
	            l = l.nextElementSibling
	        }
	        b = a.attributes;
	        for (c = 0; c < b.length; c += 1)
	            e = b.item(c),
	            m[e.name] = e.value;
	        return m
	    }
	    function n(c, e) {
	        for (var m = a.rootElement.styles, l, n = {}, k = c.getAttributeNS(h, "family"), r = c; r; )
	            l = f(r),
	            n = u.mergeObjects(l, n),
	            r = (l = r.getAttributeNS(h, "parent-style-name")) ? b(l, k, [m]) : null;
	        if (r = d(k))
	            l = f(r),
	            n = u.mergeObjects(l, n);
	        !1 !== e && (l = g(k),
	        n = u.mergeObjects(l, n));
	        return n
	    }
	    function p(b, d) {
	        function h(a) {
	            Object.keys(a).forEach(function(c) {
	                Object.keys(a[c]).forEach(function(a) {
	                    f += "|" + c + ":" + a + "|"
	                })
	            })
	        }
	        for (var e = b.nodeType === Node.TEXT_NODE ? b.parentNode : b, m, l = [], f = "", n = !1; e && !w.isInlineRoot(e) && e.parentNode !== a.rootElement; )
	            !n && w.isGroupingElement(e) && (n = !0),
	            (m = c.determineStylesForNode(e)) && l.push(m),
	            e = e.parentNode;
	        n && (l.forEach(h),
	        d && (d[f] = l));
	        return n ? l : void 0
	    }
	    function r(c) {
	        var d = {
	            orderedStyles: [],
	            styleProperties: {}
	        };
	        c.forEach(function(c) {
	            Object.keys(c).forEach(function(e) {
	                var m = Object.keys(c[e])[0], l = {
	                    name: m,
	                    family: e,
	                    displayName: void 0,
	                    isCommonStyle: !1
	                }, f;
	                (f = b(m, e)) ? (e = n(f),
	                d.styleProperties = u.mergeObjects(e, d.styleProperties),
	                l.displayName = f.getAttributeNS(h, "display-name") || void 0,
	                l.isCommonStyle = f.parentNode === a.rootElement.styles) : runtime.log("No style element found for '" + m + "' of family '" + e + "'");
	                d.orderedStyles.push(l)
	            })
	        });
	        return d
	    }
	    function q(a, c) {
	        var b = {}
	          , d = [];
	        c || (c = {});
	        a.forEach(function(a) {
	            p(a, b)
	        });
	        Object.keys(b).forEach(function(a) {
	            c[a] || (c[a] = r(b[a]));
	            d.push(c[a])
	        });
	        return d
	    }
	    function e(c) {
	        for (var b = a.rootElement.masterStyles.firstElementChild; b && (b.namespaceURI !== h || "master-page" !== b.localName || b.getAttributeNS(h, "name") !== c); )
	            b = b.nextElementSibling;
	        return b
	    }
	    function l(a, c) {
	        var b;
	        a && (b = t.convertMeasure(a, "px"));
	        void 0 === b && c && (b = t.convertMeasure(c, "px"));
	        return b
	    }
	    var a, c = new odf.StyleInfo, m = odf.Namespaces.svgns, h = odf.Namespaces.stylens, y = odf.Namespaces.textns, x = odf.Namespaces.numberns, z = odf.Namespaces.fons, w = odf.OdfUtils, v = core.DomUtils, u = new core.Utils, t = new core.CSSUnits, A = {
	        paragraph: {
	            "style:paragraph-properties": {
	                "fo:text-align": "left"
	            }
	        }
	    };
	    this.getSystemDefaultStyleAttributes = g;
	    this.setOdfContainer = function(c) {
	        a = c
	    }
	    ;
	    this.getFontMap = k;
	    this.getAvailableParagraphStyles = function() {
	        for (var c = a.rootElement.styles, b, d, e = [], c = c && c.firstElementChild; c; )
	            "style" === c.localName && c.namespaceURI === h && (b = c.getAttributeNS(h, "family"),
	            "paragraph" === b && (b = c.getAttributeNS(h, "name"),
	            d = c.getAttributeNS(h, "display-name") || b,
	            b && d && e.push({
	                name: b,
	                displayName: d
	            }))),
	            c = c.nextElementSibling;
	        return e
	    }
	    ;
	    this.isStyleUsed = function(b) {
	        var d, e = a.rootElement;
	        d = c.hasDerivedStyles(e, odf.Namespaces.lookupNamespaceURI, b);
	        b = (new c.UsedStyleList(e.styles)).uses(b) || (new c.UsedStyleList(e.automaticStyles)).uses(b) || (new c.UsedStyleList(e.body)).uses(b);
	        return d || b
	    }
	    ;
	    this.getDefaultStyleElement = d;
	    this.getStyleElement = b;
	    this.getStyleAttributes = f;
	    this.getInheritedStyleAttributes = n;
	    this.getFirstCommonParentStyleNameOrSelf = function(c) {
	        var d = a.rootElement.styles, e;
	        if (e = b(c, "paragraph", [a.rootElement.automaticStyles]))
	            if (c = e.getAttributeNS(h, "parent-style-name"),
	            !c)
	                return null;
	        return (e = b(c, "paragraph", [d])) ? c : null
	    }
	    ;
	    this.hasParagraphStyle = function(a) {
	        return Boolean(b(a, "paragraph"))
	    }
	    ;
	    this.getAppliedStyles = q;
	    this.getAppliedStylesForElement = function(a, c) {
	        return q([a], c)[0]
	    }
	    ;
	    this.updateStyle = function(c, b) {
	        var d, e;
	        v.mapObjOntoNode(c, b, odf.Namespaces.lookupNamespaceURI);
	        (d = (d = b["style:text-properties"]) && d["style:font-name"]) && !k().hasOwnProperty(d) && (e = c.ownerDocument.createElementNS(h, "style:font-face"),
	        e.setAttributeNS(h, "style:name", d),
	        e.setAttributeNS(m, "svg:font-family", d),
	        a.rootElement.fontFaceDecls.appendChild(e))
	    }
	    ;
	    this.createDerivedStyleObject = function(c, d, e) {
	        var h = b(c, d);
	        runtime.assert(Boolean(h), "No style element found for '" + c + "' of family '" + d + "'");
	        c = h.parentNode === a.rootElement.styles ? {
	            "style:parent-style-name": c
	        } : f(h);
	        c["style:family"] = d;
	        u.mergeObjects(c, e);
	        return c
	    }
	    ;
	    this.getDefaultTabStopDistance = function() {
	        for (var a = d("paragraph"), a = a && a.firstElementChild, c; a; )
	            a.namespaceURI === h && "paragraph-properties" === a.localName && (c = a.getAttributeNS(h, "tab-stop-distance")),
	            a = a.nextElementSibling;
	        c || (c = "1.25cm");
	        return w.parseNonNegativeLength(c)
	    }
	    ;
	    this.getMasterPageElement = e;
	    this.getContentSize = function(c, d) {
	        var m, f, n, g, k, r, p, q, y, u;
	        a: {
	            f = b(c, d);
	            runtime.assert("paragraph" === d || "table" === d, "styleFamily must be either paragraph or table");
	            if (f) {
	                if (f = f.getAttributeNS(h, "master-page-name"))
	                    (m = e(f)) || runtime.log("WARN: No master page definition found for " + f);
	                m || (m = e("Standard"));
	                m || (m = a.rootElement.masterStyles.getElementsByTagNameNS(h, "master-page")[0]) || runtime.log("WARN: Document has no master pages defined");
	                if (m)
	                    for (f = m.getAttributeNS(h, "page-layout-name"),
	                    n = a.rootElement.automaticStyles.getElementsByTagNameNS(h, "page-layout"),
	                    g = 0; g < n.length; g += 1)
	                        if (m = n.item(g),
	                        m.getAttributeNS(h, "name") === f)
	                            break a
	            }
	            m = null
	        }
	        m || (m = v.getDirectChild(a.rootElement.styles, h, "default-page-layout"));
	        (m = v.getDirectChild(m, h, "page-layout-properties")) ? ("landscape" === m.getAttributeNS(h, "print-orientation") ? (f = "29.7cm",
	        n = "21.001cm") : (f = "21.001cm",
	        n = "29.7cm"),
	        f = l(m.getAttributeNS(z, "page-width"), f),
	        n = l(m.getAttributeNS(z, "page-height"), n),
	        g = l(m.getAttributeNS(z, "margin")),
	        void 0 === g ? (g = l(m.getAttributeNS(z, "margin-left"), "2cm"),
	        k = l(m.getAttributeNS(z, "margin-right"), "2cm"),
	        r = l(m.getAttributeNS(z, "margin-top"), "2cm"),
	        p = l(m.getAttributeNS(z, "margin-bottom"), "2cm")) : g = k = r = p = g,
	        q = l(m.getAttributeNS(z, "padding")),
	        void 0 === q ? (q = l(m.getAttributeNS(z, "padding-left"), "0cm"),
	        y = l(m.getAttributeNS(z, "padding-right"), "0cm"),
	        u = l(m.getAttributeNS(z, "padding-top"), "0cm"),
	        m = l(m.getAttributeNS(z, "padding-bottom"), "0cm")) : q = y = u = m = q) : (f = l("21.001cm"),
	        n = l("29.7cm"),
	        g = k = r = p = g = l("2cm"),
	        q = y = u = m = q = l("0cm"));
	        return {
	            width: f - g - k - q - y,
	            height: n - r - p - u - m
	        }
	    }
	}
	;
	(function() {
	    var g = odf.Namespaces.stylens
	      , k = odf.Namespaces.textns
	      , d = {
	        graphic: "draw",
	        "drawing-page": "draw",
	        paragraph: "text",
	        presentation: "presentation",
	        ruby: "text",
	        section: "text",
	        table: "table",
	        "table-cell": "table",
	        "table-column": "table",
	        "table-row": "table",
	        text: "text",
	        list: "text",
	        page: "office"
	    };
	    odf.StyleTreeNode = function(b) {
	        this.derivedStyles = {};
	        this.element = b
	    }
	    ;
	    odf.StyleTree = function(b, f) {
	        function n(b) {
	            var a, c, d, e = {};
	            if (!b)
	                return e;
	            for (b = b.firstElementChild; b; ) {
	                if (c = b.namespaceURI !== g || "style" !== b.localName && "default-style" !== b.localName ? b.namespaceURI === k && "list-style" === b.localName ? "list" : b.namespaceURI !== g || "page-layout" !== b.localName && "default-page-layout" !== b.localName ? void 0 : "page" : b.getAttributeNS(g, "family"))
	                    (a = b.getAttributeNS(g, "name")) || (a = ""),
	                    e.hasOwnProperty(c) ? d = e[c] : e[c] = d = {},
	                    d[a] = b;
	                b = b.nextElementSibling
	            }
	            return e
	        }
	        function p(b, a) {
	            if (b.hasOwnProperty(a))
	                return b[a];
	            var c = null, d = Object.keys(b), e;
	            for (e = 0; e < d.length && !(c = p(b[d[e]].derivedStyles, a)); e += 1)
	                ;
	            return c
	        }
	        function r(b, a, c) {
	            var d, e, f;
	            if (!a.hasOwnProperty(b))
	                return null;
	            d = new odf.StyleTreeNode(a[b]);
	            e = d.element.getAttributeNS(g, "parent-style-name");
	            f = null;
	            e && (f = p(c, e) || r(e, a, c));
	            f ? f.derivedStyles[b] = d : c[b] = d;
	            delete a[b];
	            return d
	        }
	        function q(b, a) {
	            b && Object.keys(b).forEach(function(c) {
	                r(c, b, a)
	            })
	        }
	        var e = {};
	        this.getStyleTree = function() {
	            return e
	        }
	        ;
	        (function() {
	            var l, a, c;
	            a = n(b);
	            c = n(f);
	            Object.keys(d).forEach(function(b) {
	                l = e[b] = {};
	                q(a[b], l);
	                q(c[b], l)
	            })
	        }
	        )()
	    }
	}
	)();
	(function() {
	    function g(b, d) {
	        try {
	            b.insertRule(d, b.cssRules.length)
	        } catch (f) {
	            runtime.log("cannot load rule: " + d + " - " + f)
	        }
	    }
	    function k(b, d) {
	        this.listCounterCount = 0;
	        this.contentRules = b;
	        this.counterIdStack = [];
	        this.continuedCounterIdStack = d
	    }
	    function d(b) {
	        function d(c, h, f, l) {
	            var k = h.namespaceURI === n && "list" === h.localName
	              , r = h.namespaceURI === n && "list-item" === h.localName;
	            if (k || r) {
	                if (k) {
	                    var k = f += 1, p, u, t;
	                    l.listCounterCount += 1;
	                    r = c + "-level" + k + "-" + l.listCounterCount;
	                    h.setAttributeNS("urn:webodf:names:helper", "counter-id", r);
	                    p = l.continuedCounterIdStack.shift();
	                    p || (p = r,
	                    a += r + " 1 ",
	                    u = 'text|list[webodfhelper|counter-id="' + r + '"] > text|list-item:first-child > :not(text|list):first-child:before',
	                    u += "{",
	                    u += "counter-increment: " + p + " 0;",
	                    u += "}",
	                    g(b, u));
	                    for (; l.counterIdStack.length >= k; )
	                        l.counterIdStack.pop();
	                    l.counterIdStack.push(p);
	                    t = l.contentRules[k.toString()] || "";
	                    for (u = 1; u <= k; u += 1)
	                        t = t.replace(u + "webodf-listLevel", l.counterIdStack[u - 1]);
	                    u = 'text|list[webodfhelper|counter-id="' + r + '"] > text|list-item > :not(text|list):first-child:before';
	                    u += "{";
	                    u += t;
	                    u += "counter-increment: " + p + ";";
	                    u += "}";
	                    g(b, u)
	                }
	                for (h = h.firstElementChild; h; )
	                    d(c, h, f, l),
	                    h = h.nextElementSibling
	            } else
	                l.continuedCounterIdStack = []
	        }
	        var f = 0
	          , a = ""
	          , c = {};
	        this.createCounterRules = function(a, b, n) {
	            var g = b.getAttributeNS(p, "id")
	              , r = [];
	            n && (n = n.getAttributeNS("urn:webodf:names:helper", "counter-id"),
	            r = c[n].slice(0));
	            a = new k(a,r);
	            g ? g = "Y" + g : (f += 1,
	            g = "X" + f);
	            d(g, b, 0, a);
	            c[g + "-level1-1"] = a.counterIdStack
	        }
	        ;
	        this.initialiseCreatedCounters = function() {
	            var c;
	            c = "office|document{" + ("counter-reset: " + a + ";");
	            c += "}";
	            g(b, c)
	        }
	    }
	    var b = odf.Namespaces.fons
	      , f = odf.Namespaces.stylens
	      , n = odf.Namespaces.textns
	      , p = odf.Namespaces.xmlns
	      , r = {
	        1: "decimal",
	        a: "lower-latin",
	        A: "upper-latin",
	        i: "lower-roman",
	        I: "upper-roman"
	    };
	    odf.ListStyleToCss = function() {
	        function k(a) {
	            var b = m.parseLength(a);
	            return b ? c.convert(b.value, b.unit, "px") : (runtime.log("Could not parse value '" + a + "'."),
	            0)
	        }
	        function e(a) {
	            return a.replace(/\\/g, "\\\\").replace(/"/g, '\\"')
	        }
	        function l(a, c) {
	            var b;
	            a && (b = a.getAttributeNS(n, "style-name"));
	            return b === c
	        }
	        function a(a, c, b) {
	            c = c.getElementsByTagNameNS(n, "list");
	            a = new d(a);
	            var m, g, k, q, t, A, I = {}, K;
	            for (K = 0; K < c.length; K += 1)
	                if (m = c.item(K),
	                A = m.getAttributeNS(n, "style-name")) {
	                    k = m.getAttributeNS(n, "continue-numbering");
	                    q = m.getAttributeNS(n, "continue-list");
	                    (t = m.getAttributeNS(p, "id")) && (I[t] = m);
	                    t = b[A].element.firstElementChild;
	                    for (var L = void 0, E = {}; t; ) {
	                        var L = (L = t.getAttributeNS(n, "level")) && parseInt(L, 10)
	                          , N = t
	                          , O = ""
	                          , D = void 0
	                          , V = void 0
	                          , W = D = void 0;
	                        if ("list-level-style-number" === N.localName) {
	                            var J = N
	                              , O = J.getAttributeNS(f, "num-format")
	                              , D = J.getAttributeNS(f, "num-suffix") || ""
	                              , V = J.getAttributeNS(f, "num-prefix") || ""
	                              , R = ""
	                              , P = J.getAttributeNS(n, "level")
	                              , J = J.getAttributeNS(n, "display-levels");
	                            V && (R += '"' + e(V) + '"\n');
	                            if (r.hasOwnProperty(O))
	                                for (P = P ? parseInt(P, 10) : 1,
	                                J = J ? parseInt(J, 10) : 1; 0 < J; )
	                                    R += " counter(" + (P - J + 1) + "webodf-listLevel," + r[O] + ")",
	                                    1 < J && (R += '"."'),
	                                    --J;
	                            else
	                                R = O ? R + (' "' + O + '"') : R + ' ""';
	                            O = "content:" + R + ' "' + e(D) + '"'
	                        } else
	                            "list-level-style-image" === N.localName ? O = "content: none" : "list-level-style-bullet" === N.localName && (O = N.getAttributeNS(n, "bullet-char"),
	                            O = 'content: "' + e(O) + '"');
	                        if (D = N.getElementsByTagNameNS(f, "list-level-properties")[0])
	                            V = D.getAttributeNS(n, "list-level-position-and-space-mode"),
	                            "label-alignment" === V && ((D = D.getElementsByTagNameNS(f, "list-level-label-alignment")[0]) && (W = D.getAttributeNS(n, "label-followed-by")),
	                            "space" === W && (O += ' "\\a0"'));
	                        E[L] = "\n" + O + ";\n";
	                        t = t.nextElementSibling
	                    }
	                    t = E;
	                    k && !q && l(g, A) ? a.createCounterRules(t, m, g) : q && l(I[q], A) ? a.createCounterRules(t, m, I[q]) : a.createCounterRules(t, m);
	                    g = m
	                }
	            a.initialiseCreatedCounters()
	        }
	        var c = new core.CSSUnits
	          , m = odf.OdfUtils;
	        this.applyListStyles = function(c, d, e) {
	            var m, l;
	            (m = d.list) && Object.keys(m).forEach(function(a) {
	                l = m[a];
	                for (var d = l.element.firstElementChild; d; ) {
	                    if (d.namespaceURI === n) {
	                        for (var e = c, r = d, p = 'text|list[text|style-name="' + a + '"]', y = r.getAttributeNS(n, "level"), x = void 0, E = void 0, N = E = void 0, O = void 0, D = void 0, V = x = void 0, W = void 0, J = void 0, R = void 0, O = void 0, N = (E = r.getElementsByTagNameNS(f, "list-level-properties")[0]) && E.getAttributeNS(n, "list-level-position-and-space-mode"), O = E && E.getElementsByTagNameNS(f, "list-level-label-alignment")[0], x = y = y && parseInt(y, 10); 1 < x; )
	                            p += " > text|list-item > text|list",
	                            --x;
	                        x = E && E.getAttributeNS(b, "text-align") || "left";
	                        switch (x) {
	                        case "end":
	                            x = "right";
	                            break;
	                        case "start":
	                            x = "left"
	                        }
	                        "label-alignment" === N ? (D = O && O.getAttributeNS(b, "margin-left") || "0px",
	                        J = O && O.getAttributeNS(b, "text-indent") || "0px",
	                        R = O && O.getAttributeNS(n, "label-followed-by"),
	                        O = k(D)) : (D = E && E.getAttributeNS(n, "space-before") || "0px",
	                        V = E && E.getAttributeNS(n, "min-label-width") || "0px",
	                        W = E && E.getAttributeNS(n, "min-label-distance") || "0px",
	                        O = k(D) + k(V));
	                        E = p + " > text|list-item";
	                        E += "{";
	                        E += "margin-left: " + O + "px;";
	                        E += "}";
	                        g(e, E);
	                        E = p + " > text|list-item > text|list";
	                        E += "{";
	                        E += "margin-left: " + -O + "px;";
	                        E += "}";
	                        g(e, E);
	                        E = p + " > text|list-item > :not(text|list):first-child:before";
	                        E += "{";
	                        E += "text-align: " + x + ";";
	                        E += "display: inline-block;";
	                        "label-alignment" === N ? (E += "margin-left: " + J + ";",
	                        "listtab" === R && (E += "padding-right: 0.2cm;")) : (E += "min-width: " + V + ";",
	                        E += "margin-left: " + (0 === parseFloat(V) ? "" : "-") + V + ";",
	                        E += "padding-right: " + W + ";");
	                        E += "}";
	                        g(e, E)
	                    }
	                    d = d.nextElementSibling
	                }
	            });
	            a(c, e, m)
	        }
	    }
	}
	)();
	odf.LazyStyleProperties = function(g, k) {
	    var d = {};
	    this.value = function(b) {
	        var f;
	        d.hasOwnProperty(b) ? f = d[b] : (f = k[b](),
	        void 0 === f && g && (f = g.value(b)),
	        d[b] = f);
	        return f
	    }
	    ;
	    this.reset = function(b) {
	        g = b;
	        d = {}
	    }
	}
	;
	odf.StyleParseUtils = function() {
	    function g(d) {
	        var b, f;
	        d = (d = /(-?[0-9]*[0-9][0-9]*(\.[0-9]*)?|0+\.[0-9]*[1-9][0-9]*|\.[0-9]*[1-9][0-9]*)((cm)|(mm)|(in)|(pt)|(pc)|(px))/.exec(d)) ? {
	            value: parseFloat(d[1]),
	            unit: d[3]
	        } : null;
	        f = d && d.unit;
	        "px" === f ? b = d.value : "cm" === f ? b = d.value / 2.54 * 96 : "mm" === f ? b = d.value / 25.4 * 96 : "in" === f ? b = 96 * d.value : "pt" === f ? b = d.value / .75 : "pc" === f && (b = 16 * d.value);
	        return b
	    }
	    var k = odf.Namespaces.stylens;
	    this.parseLength = g;
	    this.parsePositiveLengthOrPercent = function(d, b, f) {
	        var n;
	        d && (n = parseFloat(d.substr(0, d.indexOf("%"))),
	        isNaN(n) && (n = void 0));
	        var k;
	        void 0 !== n ? (f && (k = f.value(b)),
	        n = void 0 === k ? void 0 : k / 100 * n) : n = g(d);
	        return n
	    }
	    ;
	    this.getPropertiesElement = function(d, b, f) {
	        for (b = f ? f.nextElementSibling : b.firstElementChild; null !== b && (b.localName !== d || b.namespaceURI !== k); )
	            b = b.nextElementSibling;
	        return b
	    }
	    ;
	    this.parseAttributeList = function(d) {
	        d && (d = d.replace(/^\s*(.*?)\s*$/g, "$1"));
	        return d && 0 < d.length ? d.split(/\s+/) : []
	    }
	}
	;
	odf.Style2CSS = function() {
	    function g(a, c, b) {
	        var d = [];
	        b = b.derivedStyles;
	        var e;
	        var h = z[a], m;
	        void 0 === h ? c = null : (m = c ? "[" + h + '|style-name="' + c + '"]' : "",
	        "presentation" === h && (h = "draw",
	        m = c ? '[presentation|style-name="' + c + '"]' : ""),
	        c = h + "|" + w[a].join(m + "," + h + "|") + m);
	        null !== c && d.push(c);
	        for (e in b)
	            b.hasOwnProperty(e) && (c = g(a, e, b[e]),
	            d = d.concat(c));
	        return d
	    }
	    function k(a) {
	        var c = ""
	          , b = ""
	          , c = null;
	        if ("default-style" === a.localName)
	            return null;
	        c = a.getAttributeNS(l, "parent-style-name");
	        b = a.getAttributeNS(l, "family");
	        return c = S.getODFElementsWithXPath(P, c ? "//style:*[@style:name='" + c + "'][@style:family='" + b + "']" : "//style:default-style[@style:family='" + b + "']", odf.Namespaces.lookupNamespaceURI)[0]
	    }
	    function d(a, c) {
	        var b = "", d, e, h;
	        for (d = 0; d < c.length; d += 1)
	            if (e = c[d],
	            h = a.getAttributeNS(e[0], e[1])) {
	                h = h.trim();
	                if (D.hasOwnProperty(e[1])) {
	                    var m = h
	                      , f = m.indexOf(" ")
	                      , n = void 0;
	                    h = void 0;
	                    -1 !== f ? (n = m.substring(0, f),
	                    h = m.substring(f)) : (n = m,
	                    h = "");
	                    (n = J.parseLength(n)) && "pt" === n.unit && .75 > n.value && (m = "0.75pt" + h);
	                    h = m
	                } else if (V.hasOwnProperty(e[1])) {
	                    var m = a
	                      , f = e[0]
	                      , n = e[1]
	                      , g = J.parseLength(h)
	                      , r = void 0
	                      , p = void 0
	                      , q = void 0
	                      , O = void 0
	                      , q = void 0;
	                    if (g && "%" === g.unit) {
	                        r = g.value / 100;
	                        p = k(m.parentNode);
	                        for (O = "0"; p; ) {
	                            if (q = y.getDirectChild(p, l, "paragraph-properties"))
	                                if (q = J.parseLength(q.getAttributeNS(f, n))) {
	                                    if ("%" !== q.unit) {
	                                        O = q.value * r + q.unit;
	                                        break
	                                    }
	                                    r *= q.value / 100
	                                }
	                            p = k(p)
	                        }
	                        h = O
	                    }
	                }
	                e[2] && (b += e[2] + ":" + h + ";")
	            }
	        return b
	    }
	    function b(a, c, b, d) {
	        return c + c + b + b + d + d
	    }
	    function f(a, c) {
	        var b = [a]
	          , d = c.derivedStyles;
	        Object.keys(d).forEach(function(a) {
	            a = f(a, d[a]);
	            b = b.concat(a)
	        });
	        return b
	    }
	    function n(a, c, b, d) {
	        function e(c, b) {
	            var d = [], h;
	            c.forEach(function(a) {
	                m.forEach(function(c) {
	                    d.push('draw|page[webodfhelper|page-style-name="' + c + '"] draw|frame[presentation|class="' + a + '"]')
	                })
	            });
	            0 < d.length && (h = d.join(",") + "{visibility:" + b + ";}",
	            a.insertRule(h, a.cssRules.length))
	        }
	        var m = f(c, d)
	          , l = []
	          , n = [];
	        ["page-number", "date-time", "header", "footer"].forEach(function(a) {
	            var c;
	            c = b.getAttributeNS(h, "display-" + a);
	            "true" === c ? l.push(a) : "false" === c && n.push(a)
	        });
	        e(l, "visible");
	        e(n, "hidden")
	    }
	    function p(a, f, D, V) {
	        var z, w;
	        if ("page" === f) {
	            var B = V.element, P = "", M, Q;
	            Q = M = "";
	            D = y.getDirectChild(B, l, "page-layout-properties");
	            var F;
	            if (D)
	                if (F = B.getAttributeNS(l, "name"),
	                P += d(D, N),
	                (M = y.getDirectChild(D, l, "background-image")) && (Q = M.getAttributeNS(m, "href")) && (P = P + ("background-image: url('odfkit:" + Q + "');") + d(M, u)),
	                "presentation" === R)
	                    for (B = (B = y.getDirectChild(B.parentNode.parentNode, e, "master-styles")) && B.firstElementChild; B; )
	                        B.namespaceURI === l && "master-page" === B.localName && B.getAttributeNS(l, "page-layout-name") === F && (Q = B.getAttributeNS(l, "name"),
	                        M = 'draw|page[draw|master-page-name="' + Q + '"] {' + P + "}",
	                        Q = 'office|body, draw|page[draw|master-page-name="' + Q + '"] {' + d(D, O) + " }",
	                        a.insertRule(M, a.cssRules.length),
	                        a.insertRule(Q, a.cssRules.length)),
	                        B = B.nextElementSibling;
	                else
	                    "text" === R && (M = "office|text {" + P + "}",
	                    Q = "office|body {width: " + D.getAttributeNS(q, "page-width") + ";}",
	                    a.insertRule(M, a.cssRules.length),
	                    a.insertRule(Q, a.cssRules.length))
	        } else {
	            P = g(f, D, V).join(",");
	            F = "";
	            if (B = y.getDirectChild(V.element, l, "text-properties")) {
	                var S = B
	                  , ca = w = "";
	                M = "";
	                Q = 1;
	                B = "" + d(S, v);
	                z = S.getAttributeNS(l, "text-underline-style");
	                "solid" === z && (w += " underline");
	                z = S.getAttributeNS(l, "text-line-through-style");
	                "solid" === z && (w += " line-through");
	                w.length && (B = B + ("text-decoration:" + w + ";\n") + ("text-decoration-line:" + w + ";\n"),
	                B += "-moz-text-decoration-line:" + w + ";\n");
	                z = S.getAttributeNS(l, "text-line-through-type");
	                switch (z) {
	                case "double":
	                    ca += " double";
	                    break;
	                case "single":
	                    ca += " single"
	                }
	                ca && (B += "text-decoration-style:" + ca + ";\n",
	                B += "-moz-text-decoration-style:" + ca + ";\n");
	                if (w = S.getAttributeNS(l, "font-name") || S.getAttributeNS(q, "font-family"))
	                    z = W[w],
	                    B += "font-family: " + (z || w) + ";";
	                if (z = S.getAttributeNS(l, "text-position"))
	                    w = x.parseAttributeList(z),
	                    z = w[0],
	                    w = w[1],
	                    B += "vertical-align: " + z + "\n; ",
	                    w && (Q = parseFloat(w) / 100);
	                if (S.hasAttributeNS(q, "font-size") || 1 !== Q) {
	                    for (S = S.parentNode; S; ) {
	                        if (z = (z = y.getDirectChild(S, l, "text-properties")) ? J.parseFoFontSize(z.getAttributeNS(q, "font-size")) : null) {
	                            if ("%" !== z.unit) {
	                                M = "font-size: " + z.value * Q + z.unit + ";";
	                                break
	                            }
	                            Q *= z.value / 100
	                        }
	                        S = k(S)
	                    }
	                    M || (M = "font-size: " + parseFloat(aa) * Q + fa.getUnits(aa) + ";")
	                }
	                B += M;
	                F += B
	            }
	            if (B = y.getDirectChild(V.element, l, "paragraph-properties"))
	                M = B,
	                B = "" + d(M, t),
	                (Q = y.getDirectChild(M, l, "background-image")) && (S = Q.getAttributeNS(m, "href")) && (B = B + ("background-image: url('odfkit:" + S + "');") + d(Q, u)),
	                (M = M.getAttributeNS(q, "line-height")) && "normal" !== M && (M = J.parseFoLineHeight(M),
	                B = "%" !== M.unit ? B + ("line-height: " + M.value + M.unit + ";") : B + ("line-height: " + M.value / 100 + ";")),
	                F += B;
	            if (B = y.getDirectChild(V.element, l, "graphic-properties"))
	                S = B,
	                B = "" + d(S, A),
	                M = S.getAttributeNS(r, "opacity"),
	                Q = S.getAttributeNS(r, "fill"),
	                S = S.getAttributeNS(r, "fill-color"),
	                "solid" === Q || "hatch" === Q ? S && "none" !== S ? (M = isNaN(parseFloat(M)) ? 1 : parseFloat(M) / 100,
	                Q = S.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, b),
	                (S = (Q = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(Q)) ? {
	                    r: parseInt(Q[1], 16),
	                    g: parseInt(Q[2], 16),
	                    b: parseInt(Q[3], 16)
	                } : null) && (B += "background-color: rgba(" + S.r + "," + S.g + "," + S.b + "," + M + ");")) : B += "background: none;" : "none" === Q && (B += "background: none;"),
	                F += B;
	            if (B = y.getDirectChild(V.element, l, "drawing-page-properties"))
	                M = B,
	                Q = "" + d(M, A),
	                "true" === M.getAttributeNS(h, "background-visible") && (Q += "background: none;"),
	                F += Q,
	                n(a, D, B, V);
	            if (B = y.getDirectChild(V.element, l, "table-cell-properties"))
	                D = F,
	                F = "" + d(B, I),
	                F = D + F;
	            if (B = y.getDirectChild(V.element, l, "table-row-properties"))
	                D = F,
	                F = "" + d(B, L),
	                F = D + F;
	            if (B = y.getDirectChild(V.element, l, "table-column-properties"))
	                D = F,
	                F = "" + d(B, K),
	                F = D + F;
	            if (B = y.getDirectChild(V.element, l, "table-properties"))
	                D = F,
	                F = "" + d(B, E),
	                B = B.getAttributeNS(c, "border-model"),
	                "collapsing" === B ? F += "border-collapse:collapse;" : "separating" === B && (F += "border-collapse:separate;"),
	                F = D + F;
	            0 !== F.length && a.insertRule(P + "{" + F + "}", a.cssRules.length)
	        }
	        for (var X in V.derivedStyles)
	            V.derivedStyles.hasOwnProperty(X) && p(a, f, X, V.derivedStyles[X])
	    }
	    var r = odf.Namespaces.drawns, q = odf.Namespaces.fons, e = odf.Namespaces.officens, l = odf.Namespaces.stylens, a = odf.Namespaces.svgns, c = odf.Namespaces.tablens, m = odf.Namespaces.xlinkns, h = odf.Namespaces.presentationns, y = core.DomUtils, x = new odf.StyleParseUtils, z = {
	        graphic: "draw",
	        "drawing-page": "draw",
	        paragraph: "text",
	        presentation: "presentation",
	        ruby: "text",
	        section: "text",
	        table: "table",
	        "table-cell": "table",
	        "table-column": "table",
	        "table-row": "table",
	        text: "text",
	        list: "text",
	        page: "office"
	    }, w = {
	        graphic: "circle connected control custom-shape ellipse frame g line measure page page-thumbnail path polygon polyline rect regular-polygon".split(" "),
	        paragraph: "alphabetical-index-entry-template h illustration-index-entry-template index-source-style object-index-entry-template p table-index-entry-template table-of-content-entry-template user-index-entry-template".split(" "),
	        presentation: "caption circle connector control custom-shape ellipse frame g line measure page-thumbnail path polygon polyline rect regular-polygon".split(" "),
	        "drawing-page": "caption circle connector control page custom-shape ellipse frame g line measure page-thumbnail path polygon polyline rect regular-polygon".split(" "),
	        ruby: ["ruby", "ruby-text"],
	        section: "alphabetical-index bibliography illustration-index index-title object-index section table-of-content table-index user-index".split(" "),
	        table: ["background", "table"],
	        "table-cell": "body covered-table-cell even-columns even-rows first-column first-row last-column last-row odd-columns odd-rows table-cell".split(" "),
	        "table-column": ["table-column"],
	        "table-row": ["table-row"],
	        text: "a index-entry-chapter index-entry-link-end index-entry-link-start index-entry-page-number index-entry-span index-entry-tab-stop index-entry-text index-title-template linenumbering-configuration list-level-style-number list-level-style-bullet outline-level-style span".split(" "),
	        list: ["list-item"]
	    }, v = [[q, "color", "color"], [q, "background-color", "background-color"], [q, "font-weight", "font-weight"], [q, "font-style", "font-style"]], u = [[l, "repeat", "background-repeat"]], t = [[q, "background-color", "background-color"], [q, "text-align", "text-align"], [q, "text-indent", "text-indent"], [q, "padding", "padding"], [q, "padding-left", "padding-left"], [q, "padding-right", "padding-right"], [q, "padding-top", "padding-top"], [q, "padding-bottom", "padding-bottom"], [q, "border-left", "border-left"], [q, "border-right", "border-right"], [q, "border-top", "border-top"], [q, "border-bottom", "border-bottom"], [q, "margin", "margin"], [q, "margin-left", "margin-left"], [q, "margin-right", "margin-right"], [q, "margin-top", "margin-top"], [q, "margin-bottom", "margin-bottom"], [q, "border", "border"]], A = [[q, "background-color", "background-color"], [q, "min-height", "min-height"], [r, "stroke", "border"], [a, "stroke-color", "border-color"], [a, "stroke-width", "border-width"], [q, "border", "border"], [q, "border-left", "border-left"], [q, "border-right", "border-right"], [q, "border-top", "border-top"], [q, "border-bottom", "border-bottom"]], I = [[q, "background-color", "background-color"], [q, "border-left", "border-left"], [q, "border-right", "border-right"], [q, "border-top", "border-top"], [q, "border-bottom", "border-bottom"], [q, "border", "border"]], K = [[l, "column-width", "width"]], L = [[l, "row-height", "height"], [q, "keep-together", null]], E = [[l, "width", "width"], [q, "margin-left", "margin-left"], [q, "margin-right", "margin-right"], [q, "margin-top", "margin-top"], [q, "margin-bottom", "margin-bottom"]], N = [[q, "background-color", "background-color"], [q, "padding", "padding"], [q, "padding-left", "padding-left"], [q, "padding-right", "padding-right"], [q, "padding-top", "padding-top"], [q, "padding-bottom", "padding-bottom"], [q, "border", "border"], [q, "border-left", "border-left"], [q, "border-right", "border-right"], [q, "border-top", "border-top"], [q, "border-bottom", "border-bottom"], [q, "margin", "margin"], [q, "margin-left", "margin-left"], [q, "margin-right", "margin-right"], [q, "margin-top", "margin-top"], [q, "margin-bottom", "margin-bottom"]], O = [[q, "page-width", "width"], [q, "page-height", "height"]], D = {
	        border: !0,
	        "border-left": !0,
	        "border-right": !0,
	        "border-top": !0,
	        "border-bottom": !0,
	        "stroke-width": !0
	    }, V = {
	        margin: !0,
	        "margin-left": !0,
	        "margin-right": !0,
	        "margin-top": !0,
	        "margin-bottom": !0
	    }, W = {}, J = odf.OdfUtils, R, P, aa, S = xmldom.XPath, fa = new core.CSSUnits;
	    this.style2css = function(a, c, b, d, e) {
	        function h(a, c) {
	            m = "@namespace " + a + " url(" + c + ");";
	            try {
	                b.insertRule(m, b.cssRules.length)
	            } catch (d) {}
	        }
	        var m, f, l;
	        for (P = c; b.cssRules.length; )
	            b.deleteRule(b.cssRules.length - 1);
	        odf.Namespaces.forEachPrefix(h);
	        h("webodfhelper", "urn:webodf:names:helper");
	        W = d;
	        R = a;
	        aa = runtime.getWindow().getComputedStyle(document.body, null).getPropertyValue("font-size") || "12pt";
	        for (l in z)
	            if (z.hasOwnProperty(l))
	                for (f in a = e[l],
	                a)
	                    a.hasOwnProperty(f) && p(b, l, f, a[f])
	    }
	}
	;
	(function() {
	    function g(k, d) {
	        var b = this;
	        this.getDistance = function(d) {
	            var n = b.x - d.x;
	            d = b.y - d.y;
	            return Math.sqrt(n * n + d * d)
	        }
	        ;
	        this.getCenter = function(d) {
	            return new g((b.x + d.x) / 2,(b.y + d.y) / 2)
	        }
	        ;
	        b.x = k;
	        b.y = d
	    }
	    gui.ZoomHelper = function() {
	        function k(a, b, d, e) {
	            a = e ? "translate3d(" + a + "px, " + b + "px, 0) scale3d(" + d + ", " + d + ", 1)" : "translate(" + a + "px, " + b + "px) scale(" + d + ")";
	            c.style.WebkitTransform = a;
	            c.style.MozTransform = a;
	            c.style.msTransform = a;
	            c.style.OTransform = a;
	            c.style.transform = a
	        }
	        function d(a) {
	            a ? k(-m.x, -m.y, x, !0) : (k(0, 0, x, !0),
	            k(0, 0, x, !1))
	        }
	        function b(a) {
	            if (w && I) {
	                var c = w.style.overflow
	                  , b = w.classList.contains("webodf-customScrollbars");
	                a && b || !a && !b || (a ? (w.classList.add("webodf-customScrollbars"),
	                w.style.overflow = "hidden",
	                runtime.requestAnimationFrame(function() {
	                    w.style.overflow = c
	                })) : w.classList.remove("webodf-customScrollbars"))
	            }
	        }
	        function f() {
	            k(-m.x, -m.y, x, !0);
	            w.scrollLeft = 0;
	            w.scrollTop = 0;
	            K = v.style.overflow;
	            v.style.overflow = "visible";
	            b(!1)
	        }
	        function n() {
	            k(0, 0, x, !0);
	            w.scrollLeft = m.x;
	            w.scrollTop = m.y;
	            v.style.overflow = K || "";
	            b(!0)
	        }
	        function p(a) {
	            return new g(a.pageX - c.offsetLeft,a.pageY - c.offsetTop)
	        }
	        function r(a) {
	            if (h) {
	                m.x -= a.x - h.x;
	                m.y -= a.y - h.y;
	                var b = m;
	                m = new g(Math.min(Math.max(b.x, c.offsetLeft), (c.offsetLeft + c.offsetWidth) * x - w.clientWidth),Math.min(Math.max(b.y, c.offsetTop), (c.offsetTop + c.offsetHeight) * x - w.clientHeight))
	            }
	            h = a
	        }
	        function q(a) {
	            var c = a.touches.length
	              , b = 0 < c ? p(a.touches[0]) : null;
	            a = 1 < c ? p(a.touches[1]) : null;
	            b && a ? (y = b.getDistance(a),
	            z = x,
	            h = b.getCenter(a),
	            f(),
	            A = t.PINCH) : b && (h = b,
	            A = t.SCROLL)
	        }
	        function e(a) {
	            var b = a.touches.length
	              , e = 0 < b ? p(a.touches[0]) : null
	              , b = 1 < b ? p(a.touches[1]) : null;
	            if (e && b)
	                if (a.preventDefault(),
	                A === t.SCROLL)
	                    A = t.PINCH,
	                    f(),
	                    y = e.getDistance(b);
	                else {
	                    a = e.getCenter(b);
	                    e = e.getDistance(b) / y;
	                    r(a);
	                    var b = x
	                      , h = Math.min(4, c.offsetParent.clientWidth / c.offsetWidth);
	                    x = z * e;
	                    x = Math.min(Math.max(x, h), 4);
	                    e = x / b;
	                    m.x += (e - 1) * (a.x + m.x);
	                    m.y += (e - 1) * (a.y + m.y);
	                    d(!0)
	                }
	            else
	                e && (A === t.PINCH ? (A = t.SCROLL,
	                n()) : r(e))
	        }
	        function l() {
	            A === t.PINCH && (u.emit(gui.ZoomHelper.signalZoomChanged, x),
	            n(),
	            d(!1));
	            A = t.NONE
	        }
	        function a() {
	            w && (w.removeEventListener("touchstart", q, !1),
	            w.removeEventListener("touchmove", e, !1),
	            w.removeEventListener("touchend", l, !1))
	        }
	        var c, m, h, y, x, z, w, v, u = new core.EventNotifier([gui.ZoomHelper.signalZoomChanged]), t = {
	            NONE: 0,
	            SCROLL: 1,
	            PINCH: 2
	        }, A = t.NONE, I = runtime.getWindow().hasOwnProperty("ontouchstart"), K = "";
	        this.subscribe = function(a, c) {
	            u.subscribe(a, c)
	        }
	        ;
	        this.unsubscribe = function(a, c) {
	            u.unsubscribe(a, c)
	        }
	        ;
	        this.getZoomLevel = function() {
	            return x
	        }
	        ;
	        this.setZoomLevel = function(a) {
	            c && (x = a,
	            d(!1),
	            u.emit(gui.ZoomHelper.signalZoomChanged, x))
	        }
	        ;
	        this.destroy = function(c) {
	            a();
	            b(!1);
	            c()
	        }
	        ;
	        this.setZoomableElement = function(h) {
	            a();
	            c = h;
	            w = c.offsetParent;
	            v = c.parentNode;
	            d(!1);
	            w && (w.addEventListener("touchstart", q, !1),
	            w.addEventListener("touchmove", e, !1),
	            w.addEventListener("touchend", l, !1));
	            b(!0)
	        }
	        ;
	        z = x = 1;
	        m = new g(0,0)
	    }
	    ;
	    gui.ZoomHelper.signalZoomChanged = "zoomChanged"
	}
	)();
	ops.Canvas = function() {}
	;
	ops.Canvas.prototype.getZoomLevel = function() {}
	;
	ops.Canvas.prototype.getElement = function() {}
	;
	ops.Canvas.prototype.getSizer = function() {}
	;
	ops.Canvas.prototype.getZoomHelper = function() {}
	;
	(function() {
	    function g() {
	        function a(d) {
	            b = !0;
	            runtime.setTimeout(function() {
	                try {
	                    d()
	                } catch (e) {
	                    runtime.log(String(e) + "\n" + e.stack)
	                }
	                b = !1;
	                0 < c.length && a(c.pop())
	            }, 10)
	        }
	        var c = []
	          , b = !1;
	        this.clearQueue = function() {
	            c.length = 0
	        }
	        ;
	        this.addToQueue = function(d) {
	            if (0 === c.length && !b)
	                return a(d);
	            c.push(d)
	        }
	    }
	    function k(a) {
	        function c() {
	            for (; 0 < b.cssRules.length; )
	                b.deleteRule(0);
	            b.insertRule("#shadowContent draw|page {display:none;}", 0);
	            b.insertRule("office|presentation draw|page {display:none;}", 1);
	            b.insertRule("#shadowContent draw|page:nth-of-type(" + d + ") {display:block;}", 2);
	            b.insertRule("office|presentation draw|page:nth-of-type(" + d + ") {display:block;}", 3)
	        }
	        var b = a.sheet
	          , d = 1;
	        this.showFirstPage = function() {
	            d = 1;
	            c()
	        }
	        ;
	        this.showNextPage = function() {
	            d += 1;
	            c()
	        }
	        ;
	        this.showPreviousPage = function() {
	            1 < d && (--d,
	            c())
	        }
	        ;
	        this.showPage = function(a) {
	            0 < a && (d = a,
	            c())
	        }
	        ;
	        this.css = a;
	        this.destroy = function(c) {
	            a.parentNode.removeChild(a);
	            c()
	        }
	    }
	    function d(a) {
	        a = a.sheet;
	        for (var c = a.cssRules; c.length; )
	            a.deleteRule(c.length - 1)
	    }
	    function b(a, c, b) {
	        var d = new odf.Style2CSS
	          , e = new odf.ListStyleToCss;
	        b = b.sheet;
	        var h = (new odf.StyleTree(a.rootElement.styles,a.rootElement.automaticStyles)).getStyleTree();
	        d.style2css(a.getDocumentType(), a.rootElement, b, c.getFontMap(), h);
	        e.applyListStyles(b, h, a.rootElement.body)
	    }
	    function f(a, c) {
	        (new odf.FontLoader).loadFonts(a, c.sheet)
	    }
	    function n(a, c, b) {
	        var d = null;
	        a = a.rootElement.body.getElementsByTagNameNS(L, b + "-decl");
	        b = c.getAttributeNS(L, "use-" + b + "-name");
	        var e;
	        if (b && 0 < a.length)
	            for (c = 0; c < a.length; c += 1)
	                if (e = a[c],
	                e.getAttributeNS(L, "name") === b) {
	                    d = e.textContent;
	                    break
	                }
	        return d
	    }
	    function p(a, c, b, d) {
	        var e = a.ownerDocument;
	        c = N.getElementsByTagNameNS(a, c, b);
	        for (a = 0; a < c.length; a += 1)
	            N.removeAllChildNodes(c[a]),
	            d && (b = c[a],
	            b.appendChild(e.createTextNode(d)))
	    }
	    function r(a, c, b) {
	        c.setAttributeNS("urn:webodf:names:helper", "styleid", a);
	        var d, e = c.getAttributeNS(I, "anchor-type"), h = c.getAttributeNS(t, "x"), m = c.getAttributeNS(t, "y"), f = c.getAttributeNS(t, "width"), l = c.getAttributeNS(t, "height"), n = c.getAttributeNS(w, "min-height"), g = c.getAttributeNS(w, "min-width");
	        if ("as-char" === e)
	            d = "display: inline-block;";
	        else if (e || h || m)
	            d = "position: absolute;";
	        else if (f || l || n || g)
	            d = "display: block;";
	        h && (d += "left: " + h + ";");
	        m && (d += "top: " + m + ";");
	        f && (d += "width: " + f + ";");
	        l && (d += "height: " + l + ";");
	        n && (d += "min-height: " + n + ";");
	        g && (d += "min-width: " + g + ";");
	        d && (d = "draw|" + c.localName + '[webodfhelper|styleid="' + a + '"] {' + d + "}",
	        b.insertRule(d, b.cssRules.length))
	    }
	    function q(a) {
	        for (a = a.firstChild; a; ) {
	            if (a.namespaceURI === v && "binary-data" === a.localName)
	                return "data:image/png;base64," + a.textContent.replace(/[\r\n\s]/g, "");
	            a = a.nextSibling
	        }
	        return ""
	    }
	    function e(a, c, b, d) {
	        function e(c) {
	            c && (c = 'draw|image[webodfhelper|styleid="' + a + '"] {' + ("background-image: url(" + c + ");") + "}",
	            d.insertRule(c, d.cssRules.length))
	        }
	        function h(a) {
	            e(a.url)
	        }
	        b.setAttributeNS("urn:webodf:names:helper", "styleid", a);
	        var m = b.getAttributeNS(K, "href"), f;
	        if (m)
	            try {
	                f = c.getPart(m),
	                f.onchange = h,
	                f.load()
	            } catch (l) {
	                runtime.log("slight problem: " + String(l))
	            }
	        else
	            m = q(b),
	            e(m)
	    }
	    function l(a) {
	        var c = a.ownerDocument;
	        N.getElementsByTagNameNS(a, I, "line-break").forEach(function(a) {
	            a.hasChildNodes() || a.appendChild(c.createElement("br"))
	        })
	    }
	    function a(a) {
	        var c = a.ownerDocument;
	        N.getElementsByTagNameNS(a, I, "s").forEach(function(a) {
	            var b, d;
	            N.removeAllChildNodes(a);
	            a.appendChild(c.createTextNode(" "));
	            d = parseInt(a.getAttributeNS(I, "c"), 10);
	            if (1 < d)
	                for (a.removeAttributeNS(I, "c"),
	                b = 1; b < d; b += 1)
	                    a.parentNode.insertBefore(a.cloneNode(!0), a)
	        })
	    }
	    function c(a) {
	        N.getElementsByTagNameNS(a, I, "tab").forEach(function(a) {
	            a.textContent = "\t"
	        })
	    }
	    function m(a, c) {
	        function b(a, d) {
	            var m = f.documentElement.namespaceURI;
	            "video/" === d.substr(0, 6) ? (e = f.createElementNS(m, "video"),
	            e.setAttribute("controls", "controls"),
	            h = f.createElementNS(m, "source"),
	            a && h.setAttribute("src", a),
	            h.setAttribute("type", d),
	            e.appendChild(h),
	            c.parentNode.appendChild(e)) : c.innerHtml = "Unrecognised Plugin"
	        }
	        function d(a) {
	            b(a.url, a.mimetype)
	        }
	        var e, h, m, f = c.ownerDocument, l;
	        if (m = c.getAttributeNS(K, "href"))
	            try {
	                l = a.getPart(m),
	                l.onchange = d,
	                l.load()
	            } catch (n) {
	                runtime.log("slight problem: " + String(n))
	            }
	        else
	            runtime.log("using MP4 data fallback"),
	            m = q(c),
	            b(m, "video/mp4")
	    }
	    function h(a) {
	        var c = a.getElementsByTagName("head")[0], b, d;
	        b = a.styleSheets.length;
	        for (d = c.firstElementChild; d && ("style" !== d.localName || !d.hasAttribute("webodfcss")); )
	            d = d.nextElementSibling;
	        if (d)
	            return b = parseInt(d.getAttribute("webodfcss"), 10),
	            d.setAttribute("webodfcss", b + 1),
	            d;
	        "string" === String(typeof webodf_css) ? b = webodf_css : (d = "webodf.css",
	        runtime.currentDirectory && (d = runtime.currentDirectory(),
	        0 < d.length && "/" !== d.substr(-1) && (d += "/"),
	        d += "../webodf.css"),
	        b = runtime.readFileSync(d, "utf-8"));
	        d = a.createElementNS(c.namespaceURI, "style");
	        d.setAttribute("media", "screen, print, handheld, projection");
	        d.setAttribute("type", "text/css");
	        d.setAttribute("webodfcss", "1");
	        d.appendChild(a.createTextNode(b));
	        c.appendChild(d);
	        return d
	    }
	    function y(a) {
	        var c = parseInt(a.getAttribute("webodfcss"), 10);
	        1 === c ? a.parentNode.removeChild(a) : a.setAttribute("count", c - 1)
	    }
	    function x(a) {
	        var c = a.getElementsByTagName("head")[0]
	          , b = a.createElementNS(c.namespaceURI, "style")
	          , d = "";
	        b.setAttribute("type", "text/css");
	        b.setAttribute("media", "screen, print, handheld, projection");
	        odf.Namespaces.forEachPrefix(function(a, c) {
	            d += "@namespace " + a + " url(" + c + ");\n"
	        });
	        d += "@namespace webodfhelper url(urn:webodf:names:helper);\n";
	        b.appendChild(a.createTextNode(d));
	        c.appendChild(b);
	        return b
	    }
	    var z = odf.Namespaces.drawns
	      , w = odf.Namespaces.fons
	      , v = odf.Namespaces.officens
	      , u = odf.Namespaces.stylens
	      , t = odf.Namespaces.svgns
	      , A = odf.Namespaces.tablens
	      , I = odf.Namespaces.textns
	      , K = odf.Namespaces.xlinkns
	      , L = odf.Namespaces.presentationns
	      , E = xmldom.XPath
	      , N = core.DomUtils;
	    odf.OdfCanvas = function(q, D) {
	        function t(a, c, b) {
	            function d(a, c, b, h) {
	                na.addToQueue(function() {
	                    e(a, c, b, h)
	                })
	            }
	            var h, m;
	            h = c.getElementsByTagNameNS(z, "image");
	            for (c = 0; c < h.length; c += 1)
	                m = h.item(c),
	                d("image" + String(c), a, m, b)
	        }
	        function W(a, c) {
	            function b(a, c) {
	                na.addToQueue(function() {
	                    m(a, c)
	                })
	            }
	            var d, e, h;
	            e = c.getElementsByTagNameNS(z, "plugin");
	            for (d = 0; d < e.length; d += 1)
	                h = e.item(d),
	                b(a, h)
	        }
	        function w() {
	            var a;
	            a = U.firstChild;
	            var c = ea.getZoomLevel();
	            a && (U.style.WebkitTransformOrigin = "0% 0%",
	            U.style.MozTransformOrigin = "0% 0%",
	            U.style.msTransformOrigin = "0% 0%",
	            U.style.OTransformOrigin = "0% 0%",
	            U.style.transformOrigin = "0% 0%",
	            M && ((a = M.getMinimumHeightForAnnotationPane()) ? U.style.minHeight = a : U.style.removeProperty("min-height")),
	            q.style.width = Math.round(c * U.offsetWidth) + "px",
	            q.style.height = Math.round(c * U.offsetHeight) + "px",
	            q.style.display = "inline-block")
	        }
	        function K(b, d) {
	            var e = ca.sheet;
	            N.removeAllChildNodes(q);
	            U = ha.createElementNS(q.namespaceURI, "div");
	            U.style.display = "inline-block";
	            U.style.background = "white";
	            U.style.setProperty("float", "left", "important");
	            U.appendChild(d);
	            q.appendChild(U);
	            ga = ha.createElementNS(q.namespaceURI, "div");
	            ga.id = "annotationsPane";
	            X = ha.createElementNS(q.namespaceURI, "div");
	            X.id = "shadowContent";
	            X.style.position = "absolute";
	            X.style.top = 0;
	            X.style.left = 0;
	            b.getContentElement().appendChild(X);
	            var h = d.body, m, f = [], g;
	            for (m = h.firstElementChild; m && m !== h; )
	                if (m.namespaceURI === z && (f[f.length] = m),
	                m.firstElementChild)
	                    m = m.firstElementChild;
	                else {
	                    for (; m && m !== h && !m.nextElementSibling; )
	                        m = m.parentNode;
	                    m && m.nextElementSibling && (m = m.nextElementSibling)
	                }
	            for (g = 0; g < f.length; g += 1)
	                m = f[g],
	                r("frame" + String(g), m, e);
	            f = E.getODFElementsWithXPath(h, ".//*[*[@text:anchor-type='paragraph']]", odf.Namespaces.lookupNamespaceURI);
	            for (m = 0; m < f.length; m += 1)
	                h = f[m],
	                h.setAttributeNS && h.setAttributeNS("urn:webodf:names:helper", "containsparagraphanchor", !0);
	            h = Z;
	            m = X;
	            var k, D, y, x, w = 0, J;
	            g = b.rootElement.ownerDocument;
	            if ((f = d.body.firstElementChild) && f.namespaceURI === v && ("presentation" === f.localName || "drawing" === f.localName))
	                for (f = f.firstElementChild; f; ) {
	                    if (k = (k = f.getAttributeNS(z, "master-page-name")) ? h.getMasterPageElement(k) : null) {
	                        D = f.getAttributeNS("urn:webodf:names:helper", "styleid");
	                        y = g.createElementNS(z, "draw:page");
	                        J = k.firstElementChild;
	                        for (w = 0; J; )
	                            "true" !== J.getAttributeNS(L, "placeholder") && (x = J.cloneNode(!0),
	                            y.appendChild(x)),
	                            J = J.nextElementSibling,
	                            w += 1;
	                        J = x = w = void 0;
	                        for (var B = N.getElementsByTagNameNS(y, z, "frame"), w = 0; w < B.length; w += 1)
	                            x = B[w],
	                            (J = x.getAttributeNS(L, "class")) && !/^(date-time|footer|header|page-number)$/.test(J) && x.parentNode.removeChild(x);
	                        x = N.getElementsByTagNameNS(y, z, "*");
	                        for (w = 0; w < x.length; w += 1)
	                            r(D + "_" + w, x[w], e);
	                        m.appendChild(y);
	                        w = String(m.getElementsByTagNameNS(z, "page").length);
	                        p(y, I, "page-number", w);
	                        p(y, L, "header", n(b, f, "header"));
	                        p(y, L, "footer", n(b, f, "footer"));
	                        r(D, y, e);
	                        y.setAttributeNS("urn:webodf:names:helper", "page-style-name", f.getAttributeNS(z, "style-name"));
	                        y.setAttributeNS(z, "draw:master-page-name", k.getAttributeNS(u, "name"))
	                    }
	                    f = f.nextElementSibling
	                }
	            h = q.namespaceURI;
	            f = N.getElementsByTagNameNS(d.body, A, "table-cell");
	            for (m = 0; m < f.length; m += 1)
	                g = f[m],
	                g.hasAttributeNS(A, "number-columns-spanned") && g.setAttributeNS(h, "colspan", g.getAttributeNS(A, "number-columns-spanned")),
	                g.hasAttributeNS(A, "number-rows-spanned") && g.setAttributeNS(h, "rowspan", g.getAttributeNS(A, "number-rows-spanned"));
	            l(d.body);
	            a(d.body);
	            c(d.body);
	            t(b, d.body, e);
	            W(b, d.body);
	            U.insertBefore(X, U.firstChild);
	            ea.setZoomableElement(U)
	        }
	        function P(a) {
	            B ? (ga.parentNode || U.appendChild(ga),
	            M && M.forgetAnnotations(),
	            M = new gui.AnnotationViewManager(fa,a.body,ga,Y),
	            a = N.getElementsByTagNameNS(a.body, v, "annotation"),
	            M.addAnnotations(a),
	            w()) : ga.parentNode && (U.removeChild(ga),
	            M.forgetAnnotations(),
	            w())
	        }
	        function aa(a) {
	            function c() {
	                d(F);
	                d(ja);
	                d(ca);
	                N.removeAllChildNodes(q);
	                q.style.display = "inline-block";
	                var e = C.rootElement;
	                q.ownerDocument.importNode(e, !0);
	                Z.setOdfContainer(C);
	                f(C, F);
	                b(C, Z, ja);
	                K(C, e);
	                P(e);
	                a || na.addToQueue(function() {
	                    var a = [C];
	                    if (da.hasOwnProperty("statereadychange")) {
	                        var c = da.statereadychange, b;
	                        for (b = 0; b < c.length; b += 1)
	                            c[b].apply(null, a)
	                    }
	                })
	            }
	            C.state === odf.OdfContainer.DONE ? c() : (runtime.log("WARNING: refreshOdf called but ODF was not DONE."),
	            qa = runtime.setTimeout(function T() {
	                C.state === odf.OdfContainer.DONE ? c() : (runtime.log("will be back later..."),
	                qa = runtime.setTimeout(T, 500))
	            }, 100))
	        }
	        function S(a) {
	            na.clearQueue();
	            N.removeAllChildNodes(q);
	            q.appendChild(q.ownerDocument.createTextNode(runtime.tr("Loading") + a + "..."));
	            q.removeAttribute("style");
	            C = new odf.OdfContainer(a,function(a) {
	                C = a;
	                aa(!1)
	            }
	            )
	        }
	        runtime.assert(null !== q && void 0 !== q, "odf.OdfCanvas constructor needs DOM element");
	        runtime.assert(null !== q.ownerDocument && void 0 !== q.ownerDocument, "odf.OdfCanvas constructor needs DOM");
	        var fa = this, ha = q.ownerDocument, C, Z = new odf.Formatting, ba, U = null, ga = null, B = !1, Y = !1, M = null, Q, F, ja, ca, X, da = {}, qa, la, ia = !1, ma = !1, na = new g, ea = new gui.ZoomHelper, ka = D || new gui.SingleScrollViewport(q.parentNode);
	        this.refreshCSS = function() {
	            ia = !0;
	            la.trigger()
	        }
	        ;
	        this.refreshSize = function() {
	            la.trigger()
	        }
	        ;
	        this.odfContainer = function() {
	            return C
	        }
	        ;
	        this.setOdfContainer = function(a, c) {
	            C = a;
	            aa(!0 === c)
	        }
	        ;
	        this.load = this.load = S;
	        this.save = function(a) {
	            C.save(a)
	        }
	        ;
	        this.addListener = function(a, c) {
	            switch (a) {
	            case "click":
	                var b = a;
	                q.addEventListener ? q.addEventListener(b, c, !1) : q.attachEvent ? q.attachEvent("on" + b, c) : q["on" + b] = c;
	                break;
	            default:
	                b = da.hasOwnProperty(a) ? da[a] : da[a] = [],
	                c && -1 === b.indexOf(c) && b.push(c)
	            }
	        }
	        ;
	        this.getFormatting = function() {
	            return Z
	        }
	        ;
	        this.getAnnotationViewManager = function() {
	            return M
	        }
	        ;
	        this.refreshAnnotations = function() {
	            P(C.rootElement)
	        }
	        ;
	        this.rerenderAnnotations = function() {
	            M && (ma = !0,
	            la.trigger())
	        }
	        ;
	        this.getSizer = function() {
	            return U
	        }
	        ;
	        this.enableAnnotations = function(a, c) {
	            a !== B && (B = a,
	            Y = c,
	            C && P(C.rootElement))
	        }
	        ;
	        this.addAnnotation = function(a) {
	            M && (M.addAnnotations([a]),
	            w())
	        }
	        ;
	        this.forgetAnnotation = function(a) {
	            M && (M.forgetAnnotation(a),
	            w())
	        }
	        ;
	        this.getZoomHelper = function() {
	            return ea
	        }
	        ;
	        this.setZoomLevel = function(a) {
	            ea.setZoomLevel(a)
	        }
	        ;
	        this.getZoomLevel = function() {
	            return ea.getZoomLevel()
	        }
	        ;
	        this.fitToContainingElement = function(a, c) {
	            var b = ea.getZoomLevel()
	              , d = q.offsetHeight / b
	              , b = a / (q.offsetWidth / b);
	            c / d < b && (b = c / d);
	            ea.setZoomLevel(b)
	        }
	        ;
	        this.fitToWidth = function(a) {
	            var c = q.offsetWidth / ea.getZoomLevel();
	            ea.setZoomLevel(a / c)
	        }
	        ;
	        this.fitSmart = function(a, c) {
	            var b, d;
	            d = ea.getZoomLevel();
	            b = q.offsetWidth / d;
	            d = q.offsetHeight / d;
	            b = a / b;
	            void 0 !== c && c / d < b && (b = c / d);
	            ea.setZoomLevel(Math.min(1, b))
	        }
	        ;
	        this.fitToHeight = function(a) {
	            var c = q.offsetHeight / ea.getZoomLevel();
	            ea.setZoomLevel(a / c)
	        }
	        ;
	        this.showFirstPage = function() {
	            ba.showFirstPage()
	        }
	        ;
	        this.showNextPage = function() {
	            ba.showNextPage()
	        }
	        ;
	        this.showPreviousPage = function() {
	            ba.showPreviousPage()
	        }
	        ;
	        this.showPage = function(a) {
	            ba.showPage(a);
	            w()
	        }
	        ;
	        this.getElement = function() {
	            return q
	        }
	        ;
	        this.getViewport = function() {
	            return ka
	        }
	        ;
	        this.addCssForFrameWithImage = function(a) {
	            var c = a.getAttributeNS(z, "name")
	              , b = a.firstElementChild;
	            r(c, a, ca.sheet);
	            b && e(c + "img", C, b, ca.sheet)
	        }
	        ;
	        this.destroy = function(a) {
	            var c = ha.getElementsByTagName("head")[0]
	              , b = [ba.destroy, la.destroy];
	            runtime.clearTimeout(qa);
	            ga && ga.parentNode && ga.parentNode.removeChild(ga);
	            ea.destroy(function() {
	                U && (q.removeChild(U),
	                U = null)
	            });
	            y(Q);
	            c.removeChild(F);
	            c.removeChild(ja);
	            c.removeChild(ca);
	            core.Async.destroyAll(b, a)
	        }
	        ;
	        Q = h(ha);
	        ba = new k(x(ha));
	        F = x(ha);
	        ja = x(ha);
	        ca = x(ha);
	        la = core.Task.createRedrawTask(function() {
	            ia && (b(C, Z, ja),
	            ia = !1);
	            ma && (M && M.rerenderAnnotations(),
	            ma = !1);
	            w()
	        });
	        ea.subscribe(gui.ZoomHelper.signalZoomChanged, w)
	    }
	}
	)();
	odf.StepUtils = function() {
	    this.getContentBounds = function(g) {
	        var k = g.container(), d, b;
	        runtime.assert(g.isStep(), "Step iterator must be on a step");
	        k.nodeType === Node.TEXT_NODE && 0 < g.offset() ? d = g.offset() : (k = g.leftNode()) && k.nodeType === Node.TEXT_NODE && (d = k.length);
	        k && (k.nodeType === Node.TEXT_NODE ? (runtime.assert(0 < d, "Empty text node found"),
	        b = {
	            container: k,
	            startOffset: d - 1,
	            endOffset: d
	        }) : b = {
	            container: k,
	            startOffset: 0,
	            endOffset: k.childNodes.length
	        });
	        return b
	    }
	}
	;
	ops.MemberProperties = function() {}
	;
	ops.Member = function(g, k) {
	    var d = new ops.MemberProperties;
	    this.getMemberId = function() {
	        return g
	    }
	    ;
	    this.getProperties = function() {
	        return d
	    }
	    ;
	    this.setProperties = function(b) {
	        Object.keys(b).forEach(function(f) {
	            d[f] = b[f]
	        })
	    }
	    ;
	    this.removeProperties = function(b) {
	        Object.keys(b).forEach(function(b) {
	            "fullName" !== b && "color" !== b && "imageUrl" !== b && d.hasOwnProperty(b) && delete d[b]
	        })
	    }
	    ;
	    runtime.assert(Boolean(g), "No memberId was supplied!");
	    k.fullName || (k.fullName = runtime.tr("Unknown Author"));
	    k.color || (k.color = "black");
	    k.imageUrl || (k.imageUrl = "avatar-joe.png");
	    d = k
	}
	;
	ops.Document = function() {}
	;
	ops.Document.prototype.getMemberIds = function() {}
	;
	ops.Document.prototype.removeCursor = function(g) {}
	;
	ops.Document.prototype.getDocumentElement = function() {}
	;
	ops.Document.prototype.getRootNode = function() {}
	;
	ops.Document.prototype.getDOMDocument = function() {}
	;
	ops.Document.prototype.cloneDocumentElement = function() {}
	;
	ops.Document.prototype.setDocumentElement = function(g) {}
	;
	ops.Document.prototype.subscribe = function(g, k) {}
	;
	ops.Document.prototype.unsubscribe = function(g, k) {}
	;
	ops.Document.prototype.getCanvas = function() {}
	;
	ops.Document.prototype.createRootFilter = function(g) {}
	;
	ops.Document.prototype.createPositionIterator = function(g) {}
	;
	ops.Document.prototype.hasCursor = function(g) {}
	;
	ops.Document.signalCursorAdded = "cursor/added";
	ops.Document.signalCursorRemoved = "cursor/removed";
	ops.Document.signalCursorMoved = "cursor/moved";
	ops.Document.signalMemberAdded = "member/added";
	ops.Document.signalMemberUpdated = "member/updated";
	ops.Document.signalMemberRemoved = "member/removed";
	ops.OdtCursor = function(g, k) {
	    var d = this, b = {}, f, n, p = new core.EventNotifier([ops.OdtCursor.signalCursorUpdated]);
	    this.removeFromDocument = function() {
	        n.remove()
	    }
	    ;
	    this.subscribe = function(b, d) {
	        p.subscribe(b, d)
	    }
	    ;
	    this.unsubscribe = function(b, d) {
	        p.unsubscribe(b, d)
	    }
	    ;
	    this.getMemberId = function() {
	        return g
	    }
	    ;
	    this.getNode = function() {
	        return n.getNode()
	    }
	    ;
	    this.getAnchorNode = function() {
	        return n.getAnchorNode()
	    }
	    ;
	    this.getSelectedRange = function() {
	        return n.getSelectedRange()
	    }
	    ;
	    this.setSelectedRange = function(b, f) {
	        n.setSelectedRange(b, f);
	        p.emit(ops.OdtCursor.signalCursorUpdated, d)
	    }
	    ;
	    this.hasForwardSelection = function() {
	        return n.hasForwardSelection()
	    }
	    ;
	    this.getDocument = function() {
	        return k
	    }
	    ;
	    this.getSelectionType = function() {
	        return f
	    }
	    ;
	    this.setSelectionType = function(d) {
	        b.hasOwnProperty(d) ? f = d : runtime.log("Invalid selection type: " + d)
	    }
	    ;
	    this.resetSelectionType = function() {
	        d.setSelectionType(ops.OdtCursor.RangeSelection)
	    }
	    ;
	    n = new core.Cursor(k.getDOMDocument(),g);
	    b[ops.OdtCursor.RangeSelection] = !0;
	    b[ops.OdtCursor.RegionSelection] = !0;
	    d.resetSelectionType()
	}
	;
	ops.OdtCursor.RangeSelection = "Range";
	ops.OdtCursor.RegionSelection = "Region";
	ops.OdtCursor.signalCursorUpdated = "cursorUpdated";
	(function() {
	    var g = 0;
	    ops.StepsCache = function(k, d, b) {
	        function f(a, c) {
	            var d = this;
	            this.nodeId = a;
	            this.steps = -1;
	            this.node = c;
	            this.previousBookmark = this.nextBookmark = null;
	            this.setIteratorPosition = function(a) {
	                a.setPositionBeforeElement(c);
	                b(d.steps, a)
	            }
	        }
	        function n(a, c, d) {
	            var e = this;
	            this.nodeId = a;
	            this.steps = c;
	            this.node = d;
	            this.previousBookmark = this.nextBookmark = null;
	            this.setIteratorPosition = function(a) {
	                a.setUnfilteredPosition(d, 0);
	                b(e.steps, a)
	            }
	        }
	        function p(a, c) {
	            var b = "[" + a.nodeId;
	            c && (b += " => " + c.nodeId);
	            return b + "]"
	        }
	        function r() {
	            if (!0 === ops.StepsCache.ENABLE_CACHE_VERIFICATION) {
	                for (var a = x, c, b, d, e = new core.LoopWatchDog(0,1E5), h = {}; a; ) {
	                    e.check();
	                    (c = a.previousBookmark) ? runtime.assert(c.nextBookmark === a, "Broken bookmark link to previous @" + p(c, a)) : (runtime.assert(a === x, "Broken bookmark link @" + p(a)),
	                    runtime.assert(void 0 === z || x === x || x.steps <= z, "Base point is damaged @" + p(a)));
	                    (b = a.nextBookmark) && runtime.assert(b.previousBookmark === a, "Broken bookmark link to next @" + p(a, b));
	                    if (void 0 === z || a === x || a.steps <= z)
	                        runtime.assert(y.containsNode(k, a.node), "Disconnected node is being reported as undamaged @" + p(a)),
	                        c && (d = a.node.compareDocumentPosition(c.node),
	                        runtime.assert(0 === d || 0 !== (d & v), "Bookmark order with previous does not reflect DOM order @" + p(c, a))),
	                        b && y.containsNode(k, b.node) && (d = a.node.compareDocumentPosition(b.node),
	                        runtime.assert(0 === d || 0 !== (d & w), "Bookmark order with next does not reflect DOM order @" + p(a, b)));
	                    a = a.nextBookmark
	                }
	                Object.keys(m).forEach(function(a) {
	                    var c = m[a];
	                    (void 0 === z || a <= z) && runtime.assert(c.steps <= a, "Bookmark step of " + c.steps + " exceeds cached step lookup for " + a + " @" + p(c));
	                    runtime.assert(!1 === h.hasOwnProperty(c.nodeId), "Bookmark " + p(c) + " appears twice in cached step lookup at steps " + h[c.nodeId] + " and " + a);
	                    h[c.nodeId] = a
	                })
	            }
	        }
	        function q(a) {
	            var c = "";
	            a.nodeType === Node.ELEMENT_NODE && (c = a.getAttributeNS("urn:webodf:names:steps", "nodeId") || "");
	            return c
	        }
	        function e(a) {
	            var c = g.toString();
	            a.setAttributeNS("urn:webodf:names:steps", "nodeId", c);
	            g += 1;
	            return c
	        }
	        function l(a) {
	            var c, b, e = new core.LoopWatchDog(0,1E4);
	            void 0 !== z && a > z && (a = z);
	            for (c = Math.floor(a / d) * d; !b && 0 <= c; )
	                b = m[c],
	                c -= d;
	            for (b = b || x; b.nextBookmark && b.nextBookmark.steps <= a; )
	                e.check(),
	                b = b.nextBookmark;
	            runtime.assert(-1 === a || b.steps <= a, "Bookmark @" + p(b) + " at step " + b.steps + " exceeds requested step of " + a);
	            return b
	        }
	        function a(a) {
	            a.previousBookmark && (a.previousBookmark.nextBookmark = a.nextBookmark);
	            a.nextBookmark && (a.nextBookmark.previousBookmark = a.previousBookmark)
	        }
	        function c(a) {
	            for (var c, b = null; !b && a && a !== k; )
	                (c = q(a)) && (b = h[c]) && b.node !== a && (runtime.log("Cloned node detected. Creating new bookmark"),
	                b = null,
	                a.removeAttributeNS("urn:webodf:names:steps", "nodeId")),
	                a = a.parentNode;
	            return b
	        }
	        var m = {}, h = {}, y = core.DomUtils, x, z, w = Node.DOCUMENT_POSITION_FOLLOWING, v = Node.DOCUMENT_POSITION_PRECEDING;
	        this.updateBookmark = function(c, b) {
	            var g, n = Math.ceil(c / d) * d, p, v, E;
	            if (void 0 !== z && z < c) {
	                p = l(z);
	                for (v = p.nextBookmark; v && v.steps <= c; )
	                    g = v.nextBookmark,
	                    E = Math.ceil(v.steps / d) * d,
	                    m[E] === v && delete m[E],
	                    y.containsNode(k, v.node) ? v.steps = c + 1 : (a(v),
	                    delete h[v.nodeId]),
	                    v = g;
	                z = c
	            } else
	                p = l(c);
	            v = q(b) || e(b);
	            g = h[v];
	            g ? g.node !== b && (runtime.log("Cloned node detected. Creating new bookmark"),
	            v = e(b),
	            g = h[v] = new f(v,b)) : g = h[v] = new f(v,b);
	            v = g;
	            v.steps !== c && (g = Math.ceil(v.steps / d) * d,
	            g !== n && m[g] === v && delete m[g],
	            v.steps = c);
	            if (p !== v && p.nextBookmark !== v) {
	                if (p.steps === v.steps)
	                    for (; 0 !== (v.node.compareDocumentPosition(p.node) & w) && p !== x; )
	                        p = p.previousBookmark;
	                p !== v && p.nextBookmark !== v && (a(v),
	                g = p.nextBookmark,
	                v.nextBookmark = p.nextBookmark,
	                v.previousBookmark = p,
	                p.nextBookmark = v,
	                g && (g.previousBookmark = v))
	            }
	            p = m[n];
	            if (!p || v.steps > p.steps)
	                m[n] = v;
	            r()
	        }
	        ;
	        this.setToClosestStep = function(a, c) {
	            var b;
	            r();
	            b = l(a);
	            b.setIteratorPosition(c);
	            return b.steps
	        }
	        ;
	        this.setToClosestDomPoint = function(a, b, d) {
	            var e, h;
	            r();
	            if (a === k && 0 === b)
	                e = x;
	            else if (a === k && b === k.childNodes.length)
	                for (h in e = x,
	                m)
	                    m.hasOwnProperty(h) && (a = m[h],
	                    a.steps > e.steps && (e = a));
	            else if (e = c(a.childNodes.item(b) || a),
	            !e)
	                for (d.setUnfilteredPosition(a, b); !e && d.previousNode(); )
	                    e = c(d.getCurrentNode());
	            e = e || x;
	            void 0 !== z && e.steps > z && (e = l(z));
	            e.setIteratorPosition(d);
	            return e.steps
	        }
	        ;
	        this.damageCacheAfterStep = function(a) {
	            0 > a && (a = -1);
	            void 0 === z ? z = a : a < z && (z = a);
	            r()
	        }
	        ;
	        (function() {
	            var a = q(k) || e(k);
	            x = new n(a,0,k)
	        }
	        )()
	    }
	    ;
	    ops.StepsCache.ENABLE_CACHE_VERIFICATION = !1;
	    ops.StepsCache.Bookmark = function() {}
	    ;
	    ops.StepsCache.Bookmark.prototype.setIteratorPosition = function(g) {}
	}
	)();
	(function() {
	    ops.OdtStepsTranslator = function(g, k, d, b) {
	        function f(a, b, d) {
	            var e = b.getCurrentNode();
	            b.isBeforeNode() && r.isParagraph(e) && (d || (a += 1),
	            p.updateBookmark(a, e))
	        }
	        function n(c, b) {
	            if (!b || d.acceptPosition(c) === e)
	                return !0;
	            for (; c.previousPosition(); )
	                if (d.acceptPosition(c) === e) {
	                    if (b(l, c.container(), c.unfilteredDomOffset()))
	                        return !0;
	                    break
	                }
	            for (; c.nextPosition(); )
	                if (d.acceptPosition(c) === e) {
	                    if (b(a, c.container(), c.unfilteredDomOffset()))
	                        return !0;
	                    break
	                }
	            return !1
	        }
	        var p, r = odf.OdfUtils, q = core.DomUtils, e = core.PositionFilter.FilterResult.FILTER_ACCEPT, l = core.StepDirection.PREVIOUS, a = core.StepDirection.NEXT;
	        this.convertStepsToDomPoint = function(a) {
	            var b, h;
	            if (isNaN(a))
	                throw new TypeError("Requested steps is not numeric (" + a + ")");
	            if (0 > a)
	                throw new RangeError("Requested steps is negative (" + a + ")");
	            for (b = p.setToClosestStep(a, k); b < a && k.nextPosition(); )
	                (h = d.acceptPosition(k) === e) && (b += 1),
	                f(b, k, h);
	            if (b !== a)
	                throw new RangeError("Requested steps (" + a + ") exceeds available steps (" + b + ")");
	            return {
	                node: k.container(),
	                offset: k.unfilteredDomOffset()
	            }
	        }
	        ;
	        this.convertDomPointToSteps = function(a, b, h) {
	            var l;
	            q.containsNode(g, a) || (b = 0 > q.comparePoints(g, 0, a, b),
	            a = g,
	            b = b ? 0 : g.childNodes.length);
	            k.setUnfilteredPosition(a, b);
	            n(k, h) || k.setUnfilteredPosition(a, b);
	            h = k.container();
	            b = k.unfilteredDomOffset();
	            a = p.setToClosestDomPoint(h, b, k);
	            if (0 > q.comparePoints(k.container(), k.unfilteredDomOffset(), h, b))
	                return 0 < a ? a - 1 : a;
	            for (; (k.container() !== h || k.unfilteredDomOffset() !== b) && k.nextPosition(); )
	                (l = d.acceptPosition(k) === e) && (a += 1),
	                f(a, k, l);
	            return a + 0
	        }
	        ;
	        this.prime = function() {
	            var a, b;
	            for (a = p.setToClosestStep(0, k); k.nextPosition(); )
	                (b = d.acceptPosition(k) === e) && (a += 1),
	                f(a, k, b)
	        }
	        ;
	        this.handleStepsInserted = function(a) {
	            p.damageCacheAfterStep(a.position)
	        }
	        ;
	        this.handleStepsRemoved = function(a) {
	            p.damageCacheAfterStep(a.position - 1)
	        }
	        ;
	        p = new ops.StepsCache(g,b,function(a, b) {
	            do {
	                if (d.acceptPosition(b) === e) {
	                    f(a, b, !0);
	                    break
	                }
	                f(a - 1, b, !1)
	            } while (b.nextPosition())
	        }
	        )
	    }
	}
	)();
	ops.Operation = function() {}
	;
	ops.Operation.prototype.init = function(g) {}
	;
	ops.Operation.prototype.execute = function(g) {}
	;
	ops.Operation.prototype.spec = function() {}
	;
	ops.TextPositionFilter = function() {
	    function g(b, d) {
	        for (; b && d(b) !== n; )
	            b = b.previousSibling;
	        return b
	    }
	    function k(b, f, e, l) {
	        var a;
	        if (f) {
	            if (d.isInlineRoot(f) && d.isGroupingElement(e))
	                return p;
	            l = d.lookLeftForCharacter(f);
	            if (1 === l || 2 === l && (d.scanRightForAnyCharacter(e) || d.scanRightForAnyCharacter(d.nextNode(b))))
	                return n
	        } else if (d.isGroupingElement(b) && d.isInlineRoot(g(b.previousSibling, l)))
	            return n;
	        l = null === f && d.isParagraph(b);
	        a = d.lookRightForCharacter(e);
	        if (l)
	            return a ? n : d.scanRightForAnyCharacter(e) ? p : n;
	        if (!a)
	            return p;
	        f = f || d.previousNode(b);
	        return d.scanLeftForAnyCharacter(f) ? p : n
	    }
	    var d = odf.OdfUtils
	      , b = Node.ELEMENT_NODE
	      , f = Node.TEXT_NODE
	      , n = core.PositionFilter.FilterResult.FILTER_ACCEPT
	      , p = core.PositionFilter.FilterResult.FILTER_REJECT;
	    this.acceptPosition = function(g) {
	        var q = g.container(), e = q.nodeType, l, a, c;
	        if (e !== b && e !== f)
	            return p;
	        if (e === f) {
	            e = g.unfilteredDomOffset();
	            l = q.data;
	            runtime.assert(e !== l.length, "Unexpected offset.");
	            if (0 < e) {
	                g = l[e - 1];
	                if (!d.isODFWhitespace(g))
	                    return n;
	                if (1 < e)
	                    if (g = l[e - 2],
	                    !d.isODFWhitespace(g))
	                        c = n;
	                    else {
	                        if (!d.isODFWhitespace(l.substr(0, e)))
	                            return p
	                    }
	                else
	                    a = d.previousNode(q),
	                    d.scanLeftForNonSpace(a) && (c = n);
	                if (c === n)
	                    return d.isTrailingWhitespace(q, e) ? p : n;
	                g = l[e];
	                return d.isODFWhitespace(g) ? p : d.scanLeftForAnyCharacter(d.previousNode(q)) ? p : n
	            }
	            a = g.leftNode();
	            c = q;
	            q = q.parentNode;
	            c = k(q, a, c, g.getNodeFilter())
	        } else
	            d.isGroupingElement(q) ? (a = g.leftNode(),
	            c = g.rightNode(),
	            c = k(q, a, c, g.getNodeFilter())) : c = p;
	        return c
	    }
	}
	;
	function RootFilter(g, k, d) {
	    var b = core.PositionFilter.FilterResult.FILTER_ACCEPT
	      , f = core.PositionFilter.FilterResult.FILTER_REJECT;
	    this.acceptPosition = function(n) {
	        n = n.container();
	        var p;
	        p = "string" === typeof g ? k[g].getNode() : g;
	        return d(n) === d(p) ? b : f
	    }
	}
	ops.OdtDocument = function(g) {
	    function k(a) {
	        return new core.PositionIterator(a,A,L,!1)
	    }
	    function d() {
	        var a = g.odfContainer().getContentElement()
	          , c = a && a.localName;
	        runtime.assert("text" === c, "Unsupported content element type '" + c + "' for OdtDocument");
	        return a
	    }
	    function b() {
	        return a.getDocumentElement().ownerDocument
	    }
	    function f(a) {
	        for (; a && !(a.namespaceURI === odf.Namespaces.officens && "text" === a.localName || a.namespaceURI === odf.Namespaces.officens && "annotation" === a.localName); )
	            a = a.parentNode;
	        return a
	    }
	    function n(a, c, b, d) {
	        d = k(d);
	        var e;
	        1 === b.length ? e = b[0] : (e = new core.PositionFilterChain,
	        b.forEach(e.addFilter));
	        b = new core.StepIterator(e,d);
	        b.setPosition(a, c);
	        return b
	    }
	    function p(a) {
	        var c = k(d());
	        a = u.convertStepsToDomPoint(a);
	        c.setUnfilteredPosition(a.node, a.offset);
	        return c
	    }
	    function r(a) {
	        return a === w
	    }
	    function q(c) {
	        var b = c.spec()
	          , d = b.memberid
	          , e = (new Date(b.timestamp)).toISOString()
	          , b = g.odfContainer();
	        c.isEdit && (d = a.getMember(d).getProperties().fullName,
	        b.setMetadata({
	            "dc:creator": d,
	            "dc:date": e
	        }, null),
	        d = {
	            setProperties: {
	                "dc:creator": d,
	                "dc:date": e
	            },
	            removedProperties: []
	        },
	        t || (d.setProperties["meta:editing-cycles"] = b.incrementEditingCycles(),
	        b.setMetadata(null, ["meta:editing-duration", "meta:document-statistic"])),
	        t = c,
	        a.emit(ops.OdtDocument.signalMetadataUpdated, d))
	    }
	    function e(a) {
	        var b, d = [], e, f = 2;
	        runtime.assert(a.isStep(), "positionIterator is not at a step");
	        do {
	            if (b = c.getContentBounds(a))
	                if (b = b.container,
	                m.isDowngradableSpaceElement(b)) {
	                    for (e = b.lastChild; b.firstChild; )
	                        d.push(b.firstChild),
	                        b.parentNode.insertBefore(b.firstChild, b);
	                    b.parentNode.removeChild(b);
	                    a.setPosition(e, e.nodeType === Node.TEXT_NODE ? e.length : e.childNodes.length);
	                    a.roundToPreviousStep()
	                }
	            --f
	        } while (0 < f && a.nextStep());
	        d.forEach(h.normalizeTextNodes)
	    }
	    function l(a, c, b) {
	        a = a.childNodes.item(c) || a;
	        return (a = m.getParagraphElement(a)) && h.containsNode(b, a) ? a : b
	    }
	    var a = this, c, m = odf.OdfUtils, h = core.DomUtils, y = {}, x = {}, z = new core.EventNotifier([ops.Document.signalMemberAdded, ops.Document.signalMemberUpdated, ops.Document.signalMemberRemoved, ops.Document.signalCursorAdded, ops.Document.signalCursorRemoved, ops.Document.signalCursorMoved, ops.OdtDocument.signalParagraphChanged, ops.OdtDocument.signalParagraphStyleModified, ops.OdtDocument.signalCommonStyleCreated, ops.OdtDocument.signalCommonStyleDeleted, ops.OdtDocument.signalTableAdded, ops.OdtDocument.signalOperationStart, ops.OdtDocument.signalOperationEnd, ops.OdtDocument.signalProcessingBatchStart, ops.OdtDocument.signalProcessingBatchEnd, ops.OdtDocument.signalUndoStackChanged, ops.OdtDocument.signalStepsInserted, ops.OdtDocument.signalStepsRemoved, ops.OdtDocument.signalMetadataUpdated, ops.OdtDocument.signalAnnotationAdded]), w = core.StepDirection.NEXT, v, u, t, A = NodeFilter.SHOW_ALL, I = new gui.BlacklistNamespaceNodeFilter(["urn:webodf:names:cursor", "urn:webodf:names:editinfo"]), K = new gui.OdfTextBodyNodeFilter, L = new core.NodeFilterChain([I, K]);
	    this.createPositionIterator = k;
	    this.getDocumentElement = function() {
	        return g.odfContainer().rootElement
	    }
	    ;
	    this.cloneDocumentElement = function() {
	        var c = a.getDocumentElement()
	          , b = g.getAnnotationViewManager();
	        b && b.forgetAnnotations();
	        c = c.cloneNode(!0);
	        g.refreshAnnotations();
	        a.fixCursorPositions();
	        return c
	    }
	    ;
	    this.setDocumentElement = function(a) {
	        var c = g.odfContainer();
	        z.unsubscribe(ops.OdtDocument.signalStepsInserted, u.handleStepsInserted);
	        z.unsubscribe(ops.OdtDocument.signalStepsRemoved, u.handleStepsRemoved);
	        c.setRootElement(a);
	        g.setOdfContainer(c, !0);
	        g.refreshCSS();
	        a = d();
	        u = new ops.OdtStepsTranslator(a,k(a),v,500);
	        z.subscribe(ops.OdtDocument.signalStepsInserted, u.handleStepsInserted);
	        z.subscribe(ops.OdtDocument.signalStepsRemoved, u.handleStepsRemoved)
	    }
	    ;
	    this.getDOMDocument = b;
	    this.getRootElement = f;
	    this.createStepIterator = n;
	    this.getIteratorAtPosition = p;
	    this.convertCursorStepToDomPoint = function(a) {
	        return u.convertStepsToDomPoint(a)
	    }
	    ;
	    this.convertDomPointToCursorStep = function(a, c, b) {
	        var d;
	        b === w && (d = r);
	        return u.convertDomPointToSteps(a, c, d)
	    }
	    ;
	    this.convertDomToCursorRange = function(a) {
	        var c;
	        c = u.convertDomPointToSteps(a.anchorNode, a.anchorOffset);
	        a = a.anchorNode === a.focusNode && a.anchorOffset === a.focusOffset ? c : u.convertDomPointToSteps(a.focusNode, a.focusOffset);
	        return {
	            position: c,
	            length: a - c
	        }
	    }
	    ;
	    this.convertCursorToDomRange = function(a, c) {
	        var d = b().createRange(), e, h;
	        e = u.convertStepsToDomPoint(a);
	        c ? (h = u.convertStepsToDomPoint(a + c),
	        0 < c ? (d.setStart(e.node, e.offset),
	        d.setEnd(h.node, h.offset)) : (d.setStart(h.node, h.offset),
	        d.setEnd(e.node, e.offset))) : d.setStart(e.node, e.offset);
	        return d
	    }
	    ;
	    this.upgradeWhitespacesAtPosition = function(a) {
	        var b = p(a), b = new core.StepIterator(v,b), d, e = 2;
	        runtime.assert(b.isStep(), "positionIterator is not at a step (requested step: " + a + ")");
	        do {
	            if (d = c.getContentBounds(b))
	                if (a = d.container,
	                d = d.startOffset,
	                a.nodeType === Node.TEXT_NODE && m.isSignificantWhitespace(a, d)) {
	                    runtime.assert(" " === a.data[d], "upgradeWhitespaceToElement: textNode.data[offset] should be a literal space");
	                    var h = a.ownerDocument.createElementNS(odf.Namespaces.textns, "text:s")
	                      , f = a.parentNode
	                      , l = a;
	                    h.appendChild(a.ownerDocument.createTextNode(" "));
	                    1 === a.length ? f.replaceChild(h, a) : (a.deleteData(d, 1),
	                    0 < d && (d < a.length && a.splitText(d),
	                    l = a.nextSibling),
	                    f.insertBefore(h, l));
	                    a = h;
	                    b.setPosition(a, a.childNodes.length);
	                    b.roundToPreviousStep()
	                }
	            --e
	        } while (0 < e && b.nextStep())
	    }
	    ;
	    this.downgradeWhitespaces = e;
	    this.downgradeWhitespacesAtPosition = function(a) {
	        a = p(a);
	        a = new core.StepIterator(v,a);
	        e(a)
	    }
	    ;
	    this.getTextNodeAtStep = function(c, d) {
	        var e = p(c), h = e.container(), m, f = 0, l = null;
	        h.nodeType === Node.TEXT_NODE ? (m = h,
	        f = e.unfilteredDomOffset(),
	        0 < m.length && (0 < f && (m = m.splitText(f)),
	        m.parentNode.insertBefore(b().createTextNode(""), m),
	        m = m.previousSibling,
	        f = 0)) : (m = b().createTextNode(""),
	        f = 0,
	        h.insertBefore(m, e.rightNode()));
	        if (d) {
	            if (y[d] && a.getCursorPosition(d) === c) {
	                for (l = y[d].getNode(); l.nextSibling && "cursor" === l.nextSibling.localName; )
	                    l.parentNode.insertBefore(l.nextSibling, l);
	                0 < m.length && m.nextSibling !== l && (m = b().createTextNode(""),
	                f = 0);
	                l.parentNode.insertBefore(m, l)
	            }
	        } else
	            for (; m.nextSibling && "cursor" === m.nextSibling.localName; )
	                m.parentNode.insertBefore(m.nextSibling, m);
	        for (; m.previousSibling && m.previousSibling.nodeType === Node.TEXT_NODE; )
	            e = m.previousSibling,
	            e.appendData(m.data),
	            f = e.length,
	            m = e,
	            m.parentNode.removeChild(m.nextSibling);
	        for (; m.nextSibling && m.nextSibling.nodeType === Node.TEXT_NODE; )
	            e = m.nextSibling,
	            m.appendData(e.data),
	            m.parentNode.removeChild(e);
	        return {
	            textNode: m,
	            offset: f
	        }
	    }
	    ;
	    this.fixCursorPositions = function() {
	        Object.keys(y).forEach(function(c) {
	            var b = y[c], d = f(b.getNode()), e = a.createRootFilter(d), h, m, g, k = !1;
	            g = b.getSelectedRange();
	            h = l(g.startContainer, g.startOffset, d);
	            m = n(g.startContainer, g.startOffset, [v, e], h);
	            g.collapsed ? d = m : (h = l(g.endContainer, g.endOffset, d),
	            d = n(g.endContainer, g.endOffset, [v, e], h));
	            m.isStep() && d.isStep() ? m.container() !== d.container() || m.offset() !== d.offset() || g.collapsed && b.getAnchorNode() === b.getNode() || (k = !0,
	            g.setStart(m.container(), m.offset()),
	            g.collapse(!0)) : (k = !0,
	            runtime.assert(m.roundToClosestStep(), "No walkable step found for cursor owned by " + c),
	            g.setStart(m.container(), m.offset()),
	            runtime.assert(d.roundToClosestStep(), "No walkable step found for cursor owned by " + c),
	            g.setEnd(d.container(), d.offset()));
	            k && (b.setSelectedRange(g, b.hasForwardSelection()),
	            a.emit(ops.Document.signalCursorMoved, b))
	        })
	    }
	    ;
	    this.getCursorPosition = function(a) {
	        return (a = y[a]) ? u.convertDomPointToSteps(a.getNode(), 0) : 0
	    }
	    ;
	    this.getCursorSelection = function(a) {
	        a = y[a];
	        var c = 0
	          , b = 0;
	        a && (c = u.convertDomPointToSteps(a.getNode(), 0),
	        b = u.convertDomPointToSteps(a.getAnchorNode(), 0));
	        return {
	            position: b,
	            length: c - b
	        }
	    }
	    ;
	    this.getPositionFilter = function() {
	        return v
	    }
	    ;
	    this.getOdfCanvas = function() {
	        return g
	    }
	    ;
	    this.getCanvas = function() {
	        return g
	    }
	    ;
	    this.getRootNode = d;
	    this.addMember = function(a) {
	        runtime.assert(void 0 === x[a.getMemberId()], "This member already exists");
	        x[a.getMemberId()] = a
	    }
	    ;
	    this.getMember = function(a) {
	        return x.hasOwnProperty(a) ? x[a] : null
	    }
	    ;
	    this.removeMember = function(a) {
	        delete x[a]
	    }
	    ;
	    this.getCursor = function(a) {
	        return y[a]
	    }
	    ;
	    this.hasCursor = function(a) {
	        return y.hasOwnProperty(a)
	    }
	    ;
	    this.getMemberIds = function() {
	        return Object.keys(x)
	    }
	    ;
	    this.addCursor = function(c) {
	        runtime.assert(Boolean(c), "OdtDocument::addCursor without cursor");
	        var b = c.getMemberId()
	          , d = a.convertCursorToDomRange(0, 0);
	        runtime.assert("string" === typeof b, "OdtDocument::addCursor has cursor without memberid");
	        runtime.assert(!y[b], "OdtDocument::addCursor is adding a duplicate cursor with memberid " + b);
	        c.setSelectedRange(d, !0);
	        y[b] = c
	    }
	    ;
	    this.removeCursor = function(c) {
	        var b = y[c];
	        return b ? (b.removeFromDocument(),
	        delete y[c],
	        a.emit(ops.Document.signalCursorRemoved, c),
	        !0) : !1
	    }
	    ;
	    this.moveCursor = function(c, b, d, e) {
	        c = y[c];
	        b = a.convertCursorToDomRange(b, d);
	        c && (c.setSelectedRange(b, 0 <= d),
	        c.setSelectionType(e || ops.OdtCursor.RangeSelection))
	    }
	    ;
	    this.getFormatting = function() {
	        return g.getFormatting()
	    }
	    ;
	    this.emit = function(a, c) {
	        z.emit(a, c)
	    }
	    ;
	    this.subscribe = function(a, c) {
	        z.subscribe(a, c)
	    }
	    ;
	    this.unsubscribe = function(a, c) {
	        z.unsubscribe(a, c)
	    }
	    ;
	    this.createRootFilter = function(a) {
	        return new RootFilter(a,y,f)
	    }
	    ;
	    this.close = function(a) {
	        a()
	    }
	    ;
	    this.destroy = function(a) {
	        a()
	    }
	    ;
	    (function() {
	        var a = d();
	        v = new ops.TextPositionFilter;
	        c = new odf.StepUtils;
	        u = new ops.OdtStepsTranslator(a,k(a),v,500);
	        z.subscribe(ops.OdtDocument.signalStepsInserted, u.handleStepsInserted);
	        z.subscribe(ops.OdtDocument.signalStepsRemoved, u.handleStepsRemoved);
	        z.subscribe(ops.OdtDocument.signalOperationEnd, q);
	        z.subscribe(ops.OdtDocument.signalProcessingBatchEnd, core.Task.processTasks)
	    }
	    )()
	}
	;
	ops.OdtDocument.signalParagraphChanged = "paragraph/changed";
	ops.OdtDocument.signalTableAdded = "table/added";
	ops.OdtDocument.signalCommonStyleCreated = "style/created";
	ops.OdtDocument.signalCommonStyleDeleted = "style/deleted";
	ops.OdtDocument.signalParagraphStyleModified = "paragraphstyle/modified";
	ops.OdtDocument.signalOperationStart = "operation/start";
	ops.OdtDocument.signalOperationEnd = "operation/end";
	ops.OdtDocument.signalProcessingBatchStart = "router/batchstart";
	ops.OdtDocument.signalProcessingBatchEnd = "router/batchend";
	ops.OdtDocument.signalUndoStackChanged = "undo/changed";
	ops.OdtDocument.signalStepsInserted = "steps/inserted";
	ops.OdtDocument.signalStepsRemoved = "steps/removed";
	ops.OdtDocument.signalMetadataUpdated = "metadata/updated";
	ops.OdtDocument.signalAnnotationAdded = "annotation/added";
	ops.OpAddAnnotation = function() {
	    function g(b, d, e) {
	        var f = b.getTextNodeAtStep(e, k);
	        f && (b = f.textNode,
	        e = b.parentNode,
	        f.offset !== b.length && b.splitText(f.offset),
	        e.insertBefore(d, b.nextSibling),
	        0 === b.length && e.removeChild(b))
	    }
	    var k, d, b, f, n, p;
	    this.init = function(g) {
	        k = g.memberid;
	        d = parseInt(g.timestamp, 10);
	        b = parseInt(g.position, 10);
	        f = void 0 !== g.length ? parseInt(g.length, 10) || 0 : void 0;
	        n = g.name
	    }
	    ;
	    this.isEdit = !0;
	    this.group = void 0;
	    this.execute = function(r) {
	        var q = r.getCursor(k), e, l;
	        p = r.getDOMDocument();
	        var a = new Date(d), c, m, h;
	        c = p.createElementNS(odf.Namespaces.officens, "office:annotation");
	        c.setAttributeNS(odf.Namespaces.officens, "office:name", n);
	        e = p.createElementNS(odf.Namespaces.dcns, "dc:creator");
	        e.setAttributeNS("urn:webodf:names:editinfo", "editinfo:memberid", k);
	        e.textContent = r.getMember(k).getProperties().fullName;
	        l = p.createElementNS(odf.Namespaces.dcns, "dc:date");
	        l.appendChild(p.createTextNode(a.toISOString()));
	        a = p.createElementNS(odf.Namespaces.textns, "text:list");
	        m = p.createElementNS(odf.Namespaces.textns, "text:list-item");
	        h = p.createElementNS(odf.Namespaces.textns, "text:p");
	        m.appendChild(h);
	        a.appendChild(m);
	        c.appendChild(e);
	        c.appendChild(l);
	        c.appendChild(a);
	        void 0 !== f && (e = p.createElementNS(odf.Namespaces.officens, "office:annotation-end"),
	        e.setAttributeNS(odf.Namespaces.officens, "office:name", n),
	        c.annotationEndElement = e,
	        g(r, e, b + f));
	        g(r, c, b);
	        r.emit(ops.OdtDocument.signalStepsInserted, {
	            position: b
	        });
	        q && (e = p.createRange(),
	        l = c.getElementsByTagNameNS(odf.Namespaces.textns, "p")[0],
	        e.selectNodeContents(l),
	        q.setSelectedRange(e, !1),
	        q.setSelectionType(ops.OdtCursor.RangeSelection),
	        r.emit(ops.Document.signalCursorMoved, q));
	        r.getOdfCanvas().addAnnotation(c);
	        r.fixCursorPositions();
	        r.emit(ops.OdtDocument.signalAnnotationAdded, {
	            memberId: k,
	            annotation: c
	        });
	        return !0
	    }
	    ;
	    this.spec = function() {
	        return {
	            optype: "AddAnnotation",
	            memberid: k,
	            timestamp: d,
	            position: b,
	            length: f,
	            name: n
	        }
	    }
	}
	;
	ops.OpAddCursor = function() {
	    var g, k;
	    this.init = function(d) {
	        g = d.memberid;
	        k = d.timestamp
	    }
	    ;
	    this.isEdit = !1;
	    this.group = void 0;
	    this.execute = function(d) {
	        var b = d.getCursor(g);
	        if (b)
	            return !1;
	        b = new ops.OdtCursor(g,d);
	        d.addCursor(b);
	        d.emit(ops.Document.signalCursorAdded, b);
	        return !0
	    }
	    ;
	    this.spec = function() {
	        return {
	            optype: "AddCursor",
	            memberid: g,
	            timestamp: k
	        }
	    }
	}
	;
	ops.OpAddMember = function() {
	    var g, k, d;
	    this.init = function(b) {
	        g = b.memberid;
	        k = parseInt(b.timestamp, 10);
	        d = b.setProperties
	    }
	    ;
	    this.isEdit = !1;
	    this.group = void 0;
	    this.execute = function(b) {
	        var f;
	        if (b.getMember(g))
	            return !1;
	        f = new ops.Member(g,d);
	        b.addMember(f);
	        b.emit(ops.Document.signalMemberAdded, f);
	        return !0
	    }
	    ;
	    this.spec = function() {
	        return {
	            optype: "AddMember",
	            memberid: g,
	            timestamp: k,
	            setProperties: d
	        }
	    }
	}
	;
	ops.OpAddStyle = function() {
	    var g, k, d, b, f, n, p = odf.Namespaces.stylens;
	    this.init = function(p) {
	        g = p.memberid;
	        k = p.timestamp;
	        d = p.styleName;
	        b = p.styleFamily;
	        f = "true" === p.isAutomaticStyle || !0 === p.isAutomaticStyle;
	        n = p.setProperties
	    }
	    ;
	    this.isEdit = !0;
	    this.group = void 0;
	    this.execute = function(g) {
	        var k = g.getOdfCanvas().odfContainer()
	          , e = g.getFormatting()
	          , l = g.getDOMDocument().createElementNS(p, "style:style");
	        if (!l)
	            return !1;
	        n && e.updateStyle(l, n);
	        l.setAttributeNS(p, "style:family", b);
	        l.setAttributeNS(p, "style:name", d);
	        f ? k.rootElement.automaticStyles.appendChild(l) : k.rootElement.styles.appendChild(l);
	        g.getOdfCanvas().refreshCSS();
	        f || g.emit(ops.OdtDocument.signalCommonStyleCreated, {
	            name: d,
	            family: b
	        });
	        return !0
	    }
	    ;
	    this.spec = function() {
	        return {
	            optype: "AddStyle",
	            memberid: g,
	            timestamp: k,
	            styleName: d,
	            styleFamily: b,
	            isAutomaticStyle: f,
	            setProperties: n
	        }
	    }
	}
	;
	odf.ObjectNameGenerator = function(g, k) {
	    function d(a, c) {
	        var b = {};
	        this.generateName = function() {
	            var d = c(), e = 0, f;
	            do
	                f = a + e,
	                e += 1;
	            while (b[f] || d[f]);
	            b[f] = !0;
	            return f
	        }
	    }
	    function b() {
	        var a = {};
	        [g.rootElement.automaticStyles, g.rootElement.styles].forEach(function(c) {
	            for (c = c.firstElementChild; c; )
	                c.namespaceURI === f && "style" === c.localName && (a[c.getAttributeNS(f, "name")] = !0),
	                c = c.nextElementSibling
	        });
	        return a
	    }
	    var f = odf.Namespaces.stylens
	      , n = odf.Namespaces.drawns
	      , p = odf.Namespaces.xlinkns
	      , r = (new core.Utils).hashString(k)
	      , q = null
	      , e = null
	      , l = null
	      , a = {}
	      , c = {};
	    this.generateStyleName = function() {
	        null === q && (q = new d("auto" + r + "_",function() {
	            return b()
	        }
	        ));
	        return q.generateName()
	    }
	    ;
	    this.generateFrameName = function() {
	        var c, b, f;
	        if (null === e) {
	            b = g.rootElement.body.getElementsByTagNameNS(n, "frame");
	            for (c = 0; c < b.length; c += 1)
	                f = b.item(c),
	                a[f.getAttributeNS(n, "name")] = !0;
	            e = new d("fr" + r + "_",function() {
	                return a
	            }
	            )
	        }
	        return e.generateName()
	    }
	    ;
	    this.generateImageName = function() {
	        var a, b, e;
	        if (null === l) {
	            e = g.rootElement.body.getElementsByTagNameNS(n, "image");
	            for (a = 0; a < e.length; a += 1)
	                b = e.item(a),
	                b = b.getAttributeNS(p, "href"),
	                b = b.substring(9, b.lastIndexOf(".")),
	                c[b] = !0;
	            l = new d("img" + r + "_",function() {
	                return c
	            }
	            )
	        }
	        return l.generateName()
	    }
	}
	;
	odf.TextStyleApplicator = function(g, k, d) {
	    function b(b) {
	        function d(a, b) {
	            return "object" === typeof a && "object" === typeof b ? Object.keys(a).every(function(e) {
	                return d(a[e], b[e])
	            }) : a === b
	        }
	        var a = {};
	        this.isStyleApplied = function(c) {
	            c = k.getAppliedStylesForElement(c, a).styleProperties;
	            return d(b, c)
	        }
	    }
	    function f(b) {
	        var f = {};
	        this.applyStyleToContainer = function(a) {
	            var c;
	            c = a.getAttributeNS(r, "style-name");
	            var m = a.ownerDocument;
	            c = c || "";
	            if (!f.hasOwnProperty(c)) {
	                var h = c, n;
	                n = c ? k.createDerivedStyleObject(c, "text", b) : b;
	                m = m.createElementNS(q, "style:style");
	                k.updateStyle(m, n);
	                m.setAttributeNS(q, "style:name", g.generateStyleName());
	                m.setAttributeNS(q, "style:family", "text");
	                m.setAttributeNS("urn:webodf:names:scope", "scope", "document-content");
	                d.appendChild(m);
	                f[h] = m
	            }
	            c = f[c].getAttributeNS(q, "name");
	            a.setAttributeNS(r, "text:style-name", c)
	        }
	    }
	    function n(b, d) {
	        var a = b.ownerDocument, c = b.parentNode, m, h, f, g = new core.LoopWatchDog(1E4);
	        h = [];
	        h.push(b);
	        for (f = b.nextSibling; f && p.rangeContainsNode(d, f); )
	            g.check(),
	            h.push(f),
	            f = f.nextSibling;
	        "span" !== c.localName || c.namespaceURI !== r ? (m = a.createElementNS(r, "text:span"),
	        c.insertBefore(m, b),
	        a = !1) : (b.previousSibling && !p.rangeContainsNode(d, c.firstChild) ? (m = c.cloneNode(!1),
	        c.parentNode.insertBefore(m, c.nextSibling)) : m = c,
	        a = !0);
	        h.forEach(function(a) {
	            a.parentNode !== m && m.appendChild(a)
	        });
	        if (f && a)
	            for (h = m.cloneNode(!1),
	            m.parentNode.insertBefore(h, m.nextSibling); f; )
	                g.check(),
	                a = f.nextSibling,
	                h.appendChild(f),
	                f = a;
	        return m
	    }
	    var p = core.DomUtils
	      , r = odf.Namespaces.textns
	      , q = odf.Namespaces.stylens;
	    this.applyStyle = function(d, g, a) {
	        var c = {}, m, h, k, p;
	        runtime.assert(a && a.hasOwnProperty("style:text-properties"), "applyStyle without any text properties");
	        c["style:text-properties"] = a["style:text-properties"];
	        k = new f(c);
	        p = new b(c);
	        d.forEach(function(a) {
	            m = p.isStyleApplied(a);
	            !1 === m && (h = n(a, g),
	            k.applyStyleToContainer(h))
	        })
	    }
	}
	;
	ops.OpApplyDirectStyling = function() {
	    function g(b, d, f) {
	        var a = b.getOdfCanvas().odfContainer()
	          , c = r.splitBoundaries(d)
	          , m = p.getTextNodes(d, !1);
	        (new odf.TextStyleApplicator(new odf.ObjectNameGenerator(a,k),b.getFormatting(),a.rootElement.automaticStyles)).applyStyle(m, d, f);
	        c.forEach(r.normalizeTextNodes)
	    }
	    var k, d, b, f, n, p = odf.OdfUtils, r = core.DomUtils;
	    this.init = function(g) {
	        k = g.memberid;
	        d = g.timestamp;
	        b = parseInt(g.position, 10);
	        f = parseInt(g.length, 10);
	        n = g.setProperties
	    }
	    ;
	    this.isEdit = !0;
	    this.group = void 0;
	    this.execute = function(r) {
	        var e = r.convertCursorToDomRange(b, f)
	          , l = p.getParagraphElements(e);
	        g(r, e, n);
	        e.detach();
	        r.getOdfCanvas().refreshCSS();
	        r.fixCursorPositions();
	        l.forEach(function(a) {
	            r.emit(ops.OdtDocument.signalParagraphChanged, {
	                paragraphElement: a,
	                memberId: k,
	                timeStamp: d
	            })
	        });
	        r.getOdfCanvas().rerenderAnnotations();
	        return !0
	    }
	    ;
	    this.spec = function() {
	        return {
	            optype: "ApplyDirectStyling",
	            memberid: k,
	            timestamp: d,
	            position: b,
	            length: f,
	            setProperties: n
	        }
	    }
	}
	;
	ops.OpApplyHyperlink = function() {
	    function g(b) {
	        for (; b; ) {
	            if (r.isHyperlink(b))
	                return !0;
	            b = b.parentNode
	        }
	        return !1
	    }
	    var k, d, b, f, n, p = core.DomUtils, r = odf.OdfUtils;
	    this.init = function(g) {
	        k = g.memberid;
	        d = g.timestamp;
	        b = g.position;
	        f = g.length;
	        n = g.hyperlink
	    }
	    ;
	    this.isEdit = !0;
	    this.group = void 0;
	    this.execute = function(q) {
	        var e = q.getDOMDocument()
	          , l = q.convertCursorToDomRange(b, f)
	          , a = p.splitBoundaries(l)
	          , c = []
	          , m = r.getTextNodes(l, !1);
	        if (0 === m.length)
	            return !1;
	        m.forEach(function(a) {
	            var b = r.getParagraphElement(a);
	            runtime.assert(!1 === g(a), "The given range should not contain any link.");
	            var d = n
	              , m = e.createElementNS(odf.Namespaces.textns, "text:a");
	            m.setAttributeNS(odf.Namespaces.xlinkns, "xlink:type", "simple");
	            m.setAttributeNS(odf.Namespaces.xlinkns, "xlink:href", d);
	            a.parentNode.insertBefore(m, a);
	            m.appendChild(a);
	            -1 === c.indexOf(b) && c.push(b)
	        });
	        a.forEach(p.normalizeTextNodes);
	        l.detach();
	        q.fixCursorPositions();
	        q.getOdfCanvas().refreshSize();
	        q.getOdfCanvas().rerenderAnnotations();
	        c.forEach(function(a) {
	            q.emit(ops.OdtDocument.signalParagraphChanged, {
	                paragraphElement: a,
	                memberId: k,
	                timeStamp: d
	            })
	        });
	        return !0
	    }
	    ;
	    this.spec = function() {
	        return {
	            optype: "ApplyHyperlink",
	            memberid: k,
	            timestamp: d,
	            position: b,
	            length: f,
	            hyperlink: n
	        }
	    }
	}
	;
	ops.OpInsertImage = function() {
	    var g, k, d, b, f, n, p, r, q = odf.Namespaces.drawns, e = odf.Namespaces.svgns, l = odf.Namespaces.textns, a = odf.Namespaces.xlinkns, c = odf.OdfUtils;
	    this.init = function(a) {
	        g = a.memberid;
	        k = a.timestamp;
	        d = a.position;
	        b = a.filename;
	        f = a.frameWidth;
	        n = a.frameHeight;
	        p = a.frameStyleName;
	        r = a.frameName
	    }
	    ;
	    this.isEdit = !0;
	    this.group = void 0;
	    this.execute = function(m) {
	        var h = m.getOdfCanvas(), y = m.getTextNodeAtStep(d, g), x, z;
	        if (!y)
	            return !1;
	        x = y.textNode;
	        z = c.getParagraphElement(x);
	        var y = y.offset !== x.length ? x.splitText(y.offset) : x.nextSibling
	          , w = m.getDOMDocument()
	          , v = w.createElementNS(q, "draw:image")
	          , w = w.createElementNS(q, "draw:frame");
	        v.setAttributeNS(a, "xlink:href", b);
	        v.setAttributeNS(a, "xlink:type", "simple");
	        v.setAttributeNS(a, "xlink:show", "embed");
	        v.setAttributeNS(a, "xlink:actuate", "onLoad");
	        w.setAttributeNS(q, "draw:style-name", p);
	        w.setAttributeNS(q, "draw:name", r);
	        w.setAttributeNS(l, "text:anchor-type", "as-char");
	        w.setAttributeNS(e, "svg:width", f);
	        w.setAttributeNS(e, "svg:height", n);
	        w.appendChild(v);
	        x.parentNode.insertBefore(w, y);
	        m.emit(ops.OdtDocument.signalStepsInserted, {
	            position: d
	        });
	        0 === x.length && x.parentNode.removeChild(x);
	        h.addCssForFrameWithImage(w);
	        h.refreshCSS();
	        m.emit(ops.OdtDocument.signalParagraphChanged, {
	            paragraphElement: z,
	            memberId: g,
	            timeStamp: k
	        });
	        h.rerenderAnnotations();
	        return !0
	    }
	    ;
	    this.spec = function() {
	        return {
	            optype: "InsertImage",
	            memberid: g,
	            timestamp: k,
	            filename: b,
	            position: d,
	            frameWidth: f,
	            frameHeight: n,
	            frameStyleName: p,
	            frameName: r
	        }
	    }
	}
	;
	ops.OpInsertTable = function() {
	    function g(a, c) {
	        var d;
	        if (1 === e.length)
	            d = e[0];
	        else if (3 === e.length)
	            switch (a) {
	            case 0:
	                d = e[0];
	                break;
	            case b - 1:
	                d = e[2];
	                break;
	            default:
	                d = e[1]
	            }
	        else
	            d = e[a];
	        if (1 === d.length)
	            return d[0];
	        if (3 === d.length)
	            switch (c) {
	            case 0:
	                return d[0];
	            case f - 1:
	                return d[2];
	            default:
	                return d[1]
	            }
	        return d[c]
	    }
	    var k, d, b, f, n, p, r, q, e, l = odf.OdfUtils;
	    this.init = function(a) {
	        k = a.memberid;
	        d = a.timestamp;
	        n = a.position;
	        b = a.initialRows;
	        f = a.initialColumns;
	        p = a.tableName;
	        r = a.tableStyleName;
	        q = a.tableColumnStyleName;
	        e = a.tableCellStyleMatrix
	    }
	    ;
	    this.isEdit = !0;
	    this.group = void 0;
	    this.execute = function(a) {
	        var c = a.getTextNodeAtStep(n)
	          , e = a.getRootNode();
	        if (c) {
	            var h = a.getDOMDocument(), y = h.createElementNS("urn:oasis:names:tc:opendocument:xmlns:table:1.0", "table:table"), x = h.createElementNS("urn:oasis:names:tc:opendocument:xmlns:table:1.0", "table:table-column"), z, w, v, u;
	            r && y.setAttributeNS("urn:oasis:names:tc:opendocument:xmlns:table:1.0", "table:style-name", r);
	            p && y.setAttributeNS("urn:oasis:names:tc:opendocument:xmlns:table:1.0", "table:name", p);
	            x.setAttributeNS("urn:oasis:names:tc:opendocument:xmlns:table:1.0", "table:number-columns-repeated", f);
	            q && x.setAttributeNS("urn:oasis:names:tc:opendocument:xmlns:table:1.0", "table:style-name", q);
	            y.appendChild(x);
	            for (v = 0; v < b; v += 1) {
	                x = h.createElementNS("urn:oasis:names:tc:opendocument:xmlns:table:1.0", "table:table-row");
	                for (u = 0; u < f; u += 1)
	                    z = h.createElementNS("urn:oasis:names:tc:opendocument:xmlns:table:1.0", "table:table-cell"),
	                    (w = g(v, u)) && z.setAttributeNS("urn:oasis:names:tc:opendocument:xmlns:table:1.0", "table:style-name", w),
	                    w = h.createElementNS("urn:oasis:names:tc:opendocument:xmlns:text:1.0", "text:p"),
	                    z.appendChild(w),
	                    x.appendChild(z);
	                y.appendChild(x)
	            }
	            c = l.getParagraphElement(c.textNode);
	            e.insertBefore(y, c.nextSibling);
	            a.emit(ops.OdtDocument.signalStepsInserted, {
	                position: n
	            });
	            a.getOdfCanvas().refreshSize();
	            a.emit(ops.OdtDocument.signalTableAdded, {
	                tableElement: y,
	                memberId: k,
	                timeStamp: d
	            });
	            a.getOdfCanvas().rerenderAnnotations();
	            return !0
	        }
	        return !1
	    }
	    ;
	    this.spec = function() {
	        return {
	            optype: "InsertTable",
	            memberid: k,
	            timestamp: d,
	            position: n,
	            initialRows: b,
	            initialColumns: f,
	            tableName: p,
	            tableStyleName: r,
	            tableColumnStyleName: q,
	            tableCellStyleMatrix: e
	        }
	    }
	}
	;
	ops.OpInsertText = function() {
	    function g(b) {
	        return "\t" !== b && p.isODFWhitespace(b)
	    }
	    var k, d, b, f, n, p = odf.OdfUtils;
	    this.init = function(g) {
	        k = g.memberid;
	        d = g.timestamp;
	        b = g.position;
	        n = g.text;
	        f = "true" === g.moveCursor || !0 === g.moveCursor
	    }
	    ;
	    this.isEdit = !0;
	    this.group = void 0;
	    this.execute = function(r) {
	        var q, e, l, a = null, c = r.getDOMDocument(), m, h = 0, y, x = r.getCursor(k), z;
	        r.upgradeWhitespacesAtPosition(b);
	        if (q = r.getTextNodeAtStep(b)) {
	            e = q.textNode;
	            a = e.nextSibling;
	            l = e.parentNode;
	            m = p.getParagraphElement(e);
	            for (z = 0; z < n.length; z += 1) {
	                if (!(y = "\t" === n[z])) {
	                    y = n;
	                    var w = z;
	                    y = g(y[w]) && (0 === w || w === y.length - 1 || g(y[w - 1]))
	                }
	                y && (0 === h ? (q.offset !== e.length && (a = e.splitText(q.offset)),
	                0 < z && e.appendData(n.substring(0, z))) : h < z && (h = n.substring(h, z),
	                l.insertBefore(c.createTextNode(h), a)),
	                h = z + 1,
	                "\t" === n[z] ? (y = c.createElementNS("urn:oasis:names:tc:opendocument:xmlns:text:1.0", "text:tab"),
	                y.appendChild(c.createTextNode("\t"))) : (" " !== n[z] && runtime.log("WARN: InsertText operation contains non-tab, non-space whitespace character (character code " + n.charCodeAt(z) + ")"),
	                y = c.createElementNS("urn:oasis:names:tc:opendocument:xmlns:text:1.0", "text:s"),
	                y.appendChild(c.createTextNode(" "))),
	                l.insertBefore(y, a))
	            }
	            0 === h ? e.insertData(q.offset, n) : h < n.length && (q = n.substring(h),
	            l.insertBefore(c.createTextNode(q), a));
	            l = e.parentNode;
	            a = e.nextSibling;
	            l.removeChild(e);
	            l.insertBefore(e, a);
	            0 === e.length && e.parentNode.removeChild(e);
	            r.emit(ops.OdtDocument.signalStepsInserted, {
	                position: b
	            });
	            x && f && (r.moveCursor(k, b + n.length, 0),
	            r.emit(ops.Document.signalCursorMoved, x));
	            r.downgradeWhitespacesAtPosition(b);
	            r.downgradeWhitespacesAtPosition(b + n.length);
	            r.getOdfCanvas().refreshSize();
	            r.emit(ops.OdtDocument.signalParagraphChanged, {
	                paragraphElement: m,
	                memberId: k,
	                timeStamp: d
	            });
	            r.getOdfCanvas().rerenderAnnotations();
	            return !0
	        }
	        return !1
	    }
	    ;
	    this.spec = function() {
	        return {
	            optype: "InsertText",
	            memberid: k,
	            timestamp: d,
	            position: b,
	            text: n,
	            moveCursor: f
	        }
	    }
	}
	;
	odf.CollapsingRules = function(g) {
	    function k(d) {
	        return b.isODFNode(d) || "br" === d.localName && b.isLineBreak(d.parentNode) || d.nodeType === Node.TEXT_NODE && b.isODFNode(d.parentNode) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT
	    }
	    function d(n) {
	        var p;
	        n.nodeType === Node.TEXT_NODE ? (p = n.parentNode,
	        p.removeChild(n)) : p = f.removeUnwantedNodes(n, k);
	        if (n = p)
	            n = p,
	            n = !b.isParagraph(n) && n !== g && b.hasNoODFContent(n);
	        return n ? d(p) : p
	    }
	    var b = odf.OdfUtils
	      , f = core.DomUtils;
	    this.mergeChildrenIntoParent = d
	}
	;
	ops.OpMergeParagraph = function() {
	    function g(a) {
	        return odf.OdfUtils.isInlineRoot(a) ? NodeFilter.FILTER_SKIP : l.isGroupingElement(a) && l.hasNoODFContent(a) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT
	    }
	    function k(a) {
	        if (a.nodeType === Node.TEXT_NODE) {
	            if (0 === a.length)
	                return runtime.log("WARN: Empty text node found during merge operation"),
	                !0;
	            if (l.isODFWhitespace(a.data) && !1 === l.isSignificantWhitespace(a, 0))
	                return !0;
	            a = "#text"
	        } else
	            a = (a.prefix ? a.prefix + ":" : "") + a.localName;
	        runtime.log("WARN: Unexpected text element found near paragraph boundary [" + a + "]");
	        return !1
	    }
	    function d(c) {
	        c.collapsed || (a.splitBoundaries(c),
	        c = l.getTextElements(c, !1, !0).filter(k),
	        c.forEach(function(a) {
	            a.parentNode.removeChild(a)
	        }))
	    }
	    function b(a, c, b) {
	        a = a.convertCursorStepToDomPoint(c);
	        var d = l.getParagraphElement(a.node, a.offset);
	        runtime.assert(Boolean(d), "Paragraph not found at step " + c);
	        b && b.setPosition(a.node, a.offset);
	        return d
	    }
	    var f, n, p, r, q, e, l = odf.OdfUtils, a = core.DomUtils, c = odf.Namespaces.textns;
	    this.init = function(a) {
	        f = a.memberid;
	        n = a.timestamp;
	        p = a.moveCursor;
	        r = a.paragraphStyleName;
	        q = parseInt(a.sourceStartPosition, 10);
	        e = parseInt(a.destinationStartPosition, 10)
	    }
	    ;
	    this.isEdit = !0;
	    this.group = void 0;
	    this.execute = function(m) {
	        var h, l, k = m.getCursor(f);
	        h = m.getRootNode();
	        var z = new odf.CollapsingRules(h), w = m.createStepIterator(h, 0, [m.getPositionFilter()], h), v;
	        runtime.assert(e < q, "Destination paragraph (" + e + ") must be before source paragraph (" + q + ")");
	        l = b(m, e);
	        h = b(m, q, w);
	        w.previousStep();
	        runtime.assert(a.containsNode(l, w.container()), "Destination paragraph must be adjacent to the source paragraph");
	        v = l.ownerDocument.createRange();
	        w.setPosition(l, l.childNodes.length);
	        w.roundToPreviousStep();
	        v.setStart(w.container(), w.offset());
	        v.setEnd(l, l.childNodes.length);
	        d(v);
	        v = l.childNodes.length;
	        var u = h.ownerDocument.createRange();
	        w.setPosition(h, 0);
	        w.roundToNextStep();
	        u.setStart(h, 0);
	        u.setEnd(w.container(), w.offset());
	        d(u);
	        for (u = h.firstChild; u; )
	            "editinfo" === u.localName ? h.removeChild(u) : (l.appendChild(u),
	            a.removeUnwantedNodes(u, g)),
	            u = h.firstChild;
	        runtime.assert(0 === h.childNodes.length, "Source paragraph should be empty before it is removed");
	        z.mergeChildrenIntoParent(h);
	        m.emit(ops.OdtDocument.signalStepsRemoved, {
	            position: q - 1
	        });
	        w.setPosition(l, v);
	        w.roundToClosestStep();
	        w.previousStep() || w.roundToNextStep();
	        m.downgradeWhitespaces(w);
	        r ? l.setAttributeNS(c, "text:style-name", r) : l.removeAttributeNS(c, "style-name");
	        k && p && (m.moveCursor(f, q - 1, 0),
	        m.emit(ops.Document.signalCursorMoved, k));
	        m.fixCursorPositions();
	        m.getOdfCanvas().refreshSize();
	        m.emit(ops.OdtDocument.signalParagraphChanged, {
	            paragraphElement: l,
	            memberId: f,
	            timeStamp: n
	        });
	        m.getOdfCanvas().rerenderAnnotations();
	        return !0
	    }
	    ;
	    this.spec = function() {
	        return {
	            optype: "MergeParagraph",
	            memberid: f,
	            timestamp: n,
	            moveCursor: p,
	            paragraphStyleName: r,
	            sourceStartPosition: q,
	            destinationStartPosition: e
	        }
	    }
	}
	;
	ops.OpMoveCursor = function() {
	    var g, k, d, b, f;
	    this.init = function(n) {
	        g = n.memberid;
	        k = n.timestamp;
	        d = n.position;
	        b = n.length || 0;
	        f = n.selectionType || ops.OdtCursor.RangeSelection
	    }
	    ;
	    this.isEdit = !1;
	    this.group = void 0;
	    this.execute = function(n) {
	        var k = n.getCursor(g), r;
	        if (!k)
	            return !1;
	        r = n.convertCursorToDomRange(d, b);
	        k.setSelectedRange(r, 0 <= b);
	        k.setSelectionType(f);
	        n.emit(ops.Document.signalCursorMoved, k);
	        return !0
	    }
	    ;
	    this.spec = function() {
	        return {
	            optype: "MoveCursor",
	            memberid: g,
	            timestamp: k,
	            position: d,
	            length: b,
	            selectionType: f
	        }
	    }
	}
	;
	ops.OpRemoveAnnotation = function() {
	    var g, k, d, b, f = core.DomUtils;
	    this.init = function(f) {
	        g = f.memberid;
	        k = f.timestamp;
	        d = parseInt(f.position, 10);
	        b = parseInt(f.length, 10)
	    }
	    ;
	    this.isEdit = !0;
	    this.group = void 0;
	    this.execute = function(b) {
	        function g(b) {
	            q.parentNode.insertBefore(b, q)
	        }
	        for (var k = b.getIteratorAtPosition(d).container(), q; k.namespaceURI !== odf.Namespaces.officens || "annotation" !== k.localName; )
	            k = k.parentNode;
	        if (null === k)
	            return !1;
	        q = k;
	        k = q.annotationEndElement;
	        b.getOdfCanvas().forgetAnnotation(q);
	        f.getElementsByTagNameNS(q, "urn:webodf:names:cursor", "cursor").forEach(g);
	        f.getElementsByTagNameNS(q, "urn:webodf:names:cursor", "anchor").forEach(g);
	        q.parentNode.removeChild(q);
	        k && k.parentNode.removeChild(k);
	        b.emit(ops.OdtDocument.signalStepsRemoved, {
	            position: 0 < d ? d - 1 : d
	        });
	        b.getOdfCanvas().rerenderAnnotations();
	        b.fixCursorPositions();
	        return !0
	    }
	    ;
	    this.spec = function() {
	        return {
	            optype: "RemoveAnnotation",
	            memberid: g,
	            timestamp: k,
	            position: d,
	            length: b
	        }
	    }
	}
	;
	ops.OpRemoveBlob = function() {
	    var g, k, d;
	    this.init = function(b) {
	        g = b.memberid;
	        k = b.timestamp;
	        d = b.filename
	    }
	    ;
	    this.isEdit = !0;
	    this.group = void 0;
	    this.execute = function(b) {
	        b.getOdfCanvas().odfContainer().removeBlob(d);
	        return !0
	    }
	    ;
	    this.spec = function() {
	        return {
	            optype: "RemoveBlob",
	            memberid: g,
	            timestamp: k,
	            filename: d
	        }
	    }
	}
	;
	ops.OpRemoveCursor = function() {
	    var g, k;
	    this.init = function(d) {
	        g = d.memberid;
	        k = d.timestamp
	    }
	    ;
	    this.isEdit = !1;
	    this.group = void 0;
	    this.execute = function(d) {
	        return d.removeCursor(g) ? !0 : !1
	    }
	    ;
	    this.spec = function() {
	        return {
	            optype: "RemoveCursor",
	            memberid: g,
	            timestamp: k
	        }
	    }
	}
	;
	ops.OpRemoveHyperlink = function() {
	    var g, k, d, b, f = core.DomUtils, n = odf.OdfUtils;
	    this.init = function(f) {
	        g = f.memberid;
	        k = f.timestamp;
	        d = f.position;
	        b = f.length
	    }
	    ;
	    this.isEdit = !0;
	    this.group = void 0;
	    this.execute = function(p) {
	        var r = p.convertCursorToDomRange(d, b)
	          , q = n.getHyperlinkElements(r);
	        runtime.assert(1 === q.length, "The given range should only contain a single link.");
	        q = f.mergeIntoParent(q[0]);
	        r.detach();
	        p.fixCursorPositions();
	        p.getOdfCanvas().refreshSize();
	        p.getOdfCanvas().rerenderAnnotations();
	        p.emit(ops.OdtDocument.signalParagraphChanged, {
	            paragraphElement: n.getParagraphElement(q),
	            memberId: g,
	            timeStamp: k
	        });
	        return !0
	    }
	    ;
	    this.spec = function() {
	        return {
	            optype: "RemoveHyperlink",
	            memberid: g,
	            timestamp: k,
	            position: d,
	            length: b
	        }
	    }
	}
	;
	ops.OpRemoveMember = function() {
	    var g, k;
	    this.init = function(d) {
	        g = d.memberid;
	        k = parseInt(d.timestamp, 10)
	    }
	    ;
	    this.isEdit = !1;
	    this.group = void 0;
	    this.execute = function(d) {
	        if (!d.getMember(g))
	            return !1;
	        d.removeMember(g);
	        d.emit(ops.Document.signalMemberRemoved, g);
	        return !0
	    }
	    ;
	    this.spec = function() {
	        return {
	            optype: "RemoveMember",
	            memberid: g,
	            timestamp: k
	        }
	    }
	}
	;
	ops.OpRemoveStyle = function() {
	    var g, k, d, b;
	    this.init = function(f) {
	        g = f.memberid;
	        k = f.timestamp;
	        d = f.styleName;
	        b = f.styleFamily
	    }
	    ;
	    this.isEdit = !0;
	    this.group = void 0;
	    this.execute = function(f) {
	        var g = f.getFormatting().getStyleElement(d, b);
	        if (!g)
	            return !1;
	        g.parentNode.removeChild(g);
	        f.getOdfCanvas().refreshCSS();
	        f.emit(ops.OdtDocument.signalCommonStyleDeleted, {
	            name: d,
	            family: b
	        });
	        return !0
	    }
	    ;
	    this.spec = function() {
	        return {
	            optype: "RemoveStyle",
	            memberid: g,
	            timestamp: k,
	            styleName: d,
	            styleFamily: b
	        }
	    }
	}
	;
	ops.OpRemoveText = function() {
	    var g, k, d, b, f = odf.OdfUtils, n = core.DomUtils;
	    this.init = function(f) {
	        runtime.assert(0 <= f.length, "OpRemoveText only supports positive lengths");
	        g = f.memberid;
	        k = f.timestamp;
	        d = parseInt(f.position, 10);
	        b = parseInt(f.length, 10)
	    }
	    ;
	    this.isEdit = !0;
	    this.group = void 0;
	    this.execute = function(p) {
	        var r, q, e, l = p.getCursor(g), a = new odf.CollapsingRules(p.getRootNode());
	        p.upgradeWhitespacesAtPosition(d);
	        p.upgradeWhitespacesAtPosition(d + b);
	        r = p.convertCursorToDomRange(d, b);
	        n.splitBoundaries(r);
	        q = f.getTextElements(r, !1, !0);
	        e = f.getParagraphElement(r.startContainer, r.startOffset);
	        runtime.assert(void 0 !== e, "Attempting to remove text outside a paragraph element");
	        r.detach();
	        q.forEach(function(c) {
	            c.parentNode ? (runtime.assert(n.containsNode(e, c), "RemoveText only supports removing elements within the same paragraph"),
	            a.mergeChildrenIntoParent(c)) : runtime.log("WARN: text element has already been removed from it's container")
	        });
	        p.emit(ops.OdtDocument.signalStepsRemoved, {
	            position: d
	        });
	        p.downgradeWhitespacesAtPosition(d);
	        p.fixCursorPositions();
	        p.getOdfCanvas().refreshSize();
	        p.emit(ops.OdtDocument.signalParagraphChanged, {
	            paragraphElement: e,
	            memberId: g,
	            timeStamp: k
	        });
	        l && (l.resetSelectionType(),
	        p.emit(ops.Document.signalCursorMoved, l));
	        p.getOdfCanvas().rerenderAnnotations();
	        return !0
	    }
	    ;
	    this.spec = function() {
	        return {
	            optype: "RemoveText",
	            memberid: g,
	            timestamp: k,
	            position: d,
	            length: b
	        }
	    }
	}
	;
	ops.OpSetBlob = function() {
	    var g, k, d, b, f;
	    this.init = function(n) {
	        g = n.memberid;
	        k = n.timestamp;
	        d = n.filename;
	        b = n.mimetype;
	        f = n.content
	    }
	    ;
	    this.isEdit = !0;
	    this.group = void 0;
	    this.execute = function(g) {
	        g.getOdfCanvas().odfContainer().setBlob(d, b, f);
	        return !0
	    }
	    ;
	    this.spec = function() {
	        return {
	            optype: "SetBlob",
	            memberid: g,
	            timestamp: k,
	            filename: d,
	            mimetype: b,
	            content: f
	        }
	    }
	}
	;
	ops.OpSetParagraphStyle = function() {
	    function g(b, d, f) {
	        var e = [b.getPositionFilter()]
	          , g = f.container();
	        f = f.unfilteredDomOffset();
	        return !1 === b.createStepIterator(g, f, e, d).previousStep()
	    }
	    var k, d, b, f, n = odf.OdfUtils;
	    this.init = function(g) {
	        k = g.memberid;
	        d = g.timestamp;
	        b = g.position;
	        f = g.styleName
	    }
	    ;
	    this.isEdit = !0;
	    this.group = void 0;
	    this.execute = function(p) {
	        var r, q;
	        r = p.getIteratorAtPosition(b);
	        return (q = n.getParagraphElement(r.container())) ? (runtime.assert(g(p, q, r), "SetParagraphStyle position should be the first position in the paragraph"),
	        f ? q.setAttributeNS("urn:oasis:names:tc:opendocument:xmlns:text:1.0", "text:style-name", f) : q.removeAttributeNS("urn:oasis:names:tc:opendocument:xmlns:text:1.0", "style-name"),
	        p.getOdfCanvas().refreshSize(),
	        p.emit(ops.OdtDocument.signalParagraphChanged, {
	            paragraphElement: q,
	            timeStamp: d,
	            memberId: k
	        }),
	        p.getOdfCanvas().rerenderAnnotations(),
	        !0) : !1
	    }
	    ;
	    this.spec = function() {
	        return {
	            optype: "SetParagraphStyle",
	            memberid: k,
	            timestamp: d,
	            position: b,
	            styleName: f
	        }
	    }
	}
	;
	ops.OpSplitParagraph = function() {
	    var g, k, d, b, f, n, p = odf.OdfUtils, r = odf.Namespaces.textns;
	    this.init = function(p) {
	        g = p.memberid;
	        k = p.timestamp;
	        b = p.position;
	        d = p.sourceParagraphPosition;
	        n = p.paragraphStyleName;
	        f = "true" === p.moveCursor || !0 === p.moveCursor
	    }
	    ;
	    this.isEdit = !0;
	    this.group = void 0;
	    this.execute = function(d) {
	        var e, l, a, c, m, h, y, x = d.getCursor(g);
	        d.upgradeWhitespacesAtPosition(b);
	        e = d.getTextNodeAtStep(b);
	        if (!e)
	            return !1;
	        l = p.getParagraphElement(e.textNode);
	        if (!l)
	            return !1;
	        a = p.isListItem(l.parentNode) ? l.parentNode : l;
	        0 === e.offset ? (y = e.textNode.previousSibling,
	        h = null) : (y = e.textNode,
	        h = e.offset >= e.textNode.length ? null : e.textNode.splitText(e.offset));
	        for (c = e.textNode; c !== a; ) {
	            c = c.parentNode;
	            m = c.cloneNode(!1);
	            h && m.appendChild(h);
	            if (y)
	                for (; y && y.nextSibling; )
	                    m.appendChild(y.nextSibling);
	            else
	                for (; c.firstChild; )
	                    m.appendChild(c.firstChild);
	            c.parentNode.insertBefore(m, c.nextSibling);
	            y = c;
	            h = m
	        }
	        p.isListItem(h) && (h = h.childNodes.item(0));
	        n ? h.setAttributeNS(r, "text:style-name", n) : h.removeAttributeNS(r, "style-name");
	        0 === e.textNode.length && e.textNode.parentNode.removeChild(e.textNode);
	        d.emit(ops.OdtDocument.signalStepsInserted, {
	            position: b
	        });
	        x && f && (d.moveCursor(g, b + 1, 0),
	        d.emit(ops.Document.signalCursorMoved, x));
	        d.fixCursorPositions();
	        d.getOdfCanvas().refreshSize();
	        d.emit(ops.OdtDocument.signalParagraphChanged, {
	            paragraphElement: l,
	            memberId: g,
	            timeStamp: k
	        });
	        d.emit(ops.OdtDocument.signalParagraphChanged, {
	            paragraphElement: h,
	            memberId: g,
	            timeStamp: k
	        });
	        d.getOdfCanvas().rerenderAnnotations();
	        return !0
	    }
	    ;
	    this.spec = function() {
	        return {
	            optype: "SplitParagraph",
	            memberid: g,
	            timestamp: k,
	            position: b,
	            sourceParagraphPosition: d,
	            paragraphStyleName: n,
	            moveCursor: f
	        }
	    }
	}
	;
	ops.OpUpdateMember = function() {
	    function g(d) {
	        var f = "//dc:creator[@editinfo:memberid='" + k + "']";
	        d = xmldom.XPath.getODFElementsWithXPath(d.getRootNode(), f, function(b) {
	            return "editinfo" === b ? "urn:webodf:names:editinfo" : odf.Namespaces.lookupNamespaceURI(b)
	        });
	        for (f = 0; f < d.length; f += 1)
	            d[f].textContent = b.fullName
	    }
	    var k, d, b, f;
	    this.init = function(g) {
	        k = g.memberid;
	        d = parseInt(g.timestamp, 10);
	        b = g.setProperties;
	        f = g.removedProperties
	    }
	    ;
	    this.isEdit = !1;
	    this.group = void 0;
	    this.execute = function(d) {
	        var p = d.getMember(k);
	        if (!p)
	            return !1;
	        f && p.removeProperties(f);
	        b && (p.setProperties(b),
	        b.fullName && g(d));
	        d.emit(ops.Document.signalMemberUpdated, p);
	        return !0
	    }
	    ;
	    this.spec = function() {
	        return {
	            optype: "UpdateMember",
	            memberid: k,
	            timestamp: d,
	            setProperties: b,
	            removedProperties: f
	        }
	    }
	}
	;
	ops.OpUpdateMetadata = function() {
	    var g, k, d, b;
	    this.init = function(f) {
	        g = f.memberid;
	        k = parseInt(f.timestamp, 10);
	        d = f.setProperties;
	        b = f.removedProperties
	    }
	    ;
	    this.isEdit = !0;
	    this.group = void 0;
	    this.execute = function(f) {
	        var g = f.getOdfCanvas().odfContainer()
	          , k = null;
	        b && (k = b.attributes.split(","));
	        g.setMetadata(d, k);
	        f.emit(ops.OdtDocument.signalMetadataUpdated, {
	            setProperties: null !== d ? d : {},
	            removedProperties: null !== k ? k : []
	        });
	        return !0
	    }
	    ;
	    this.spec = function() {
	        return {
	            optype: "UpdateMetadata",
	            memberid: g,
	            timestamp: k,
	            setProperties: d,
	            removedProperties: b
	        }
	    }
	}
	;
	ops.OpUpdateParagraphStyle = function() {
	    function g(b, d) {
	        var e, f, a = d ? d.split(",") : [];
	        for (e = 0; e < a.length; e += 1)
	            f = a[e].split(":"),
	            b.removeAttributeNS(odf.Namespaces.lookupNamespaceURI(f[0]), f[1])
	    }
	    var k, d, b, f, n, p = odf.Namespaces.stylens;
	    this.init = function(g) {
	        k = g.memberid;
	        d = g.timestamp;
	        b = g.styleName;
	        f = g.setProperties;
	        n = g.removedProperties
	    }
	    ;
	    this.isEdit = !0;
	    this.group = void 0;
	    this.execute = function(d) {
	        var k = d.getFormatting(), e, l, a;
	        return (e = "" !== b ? k.getStyleElement(b, "paragraph") : k.getDefaultStyleElement("paragraph")) ? (l = e.getElementsByTagNameNS(p, "paragraph-properties").item(0),
	        a = e.getElementsByTagNameNS(p, "text-properties").item(0),
	        f && k.updateStyle(e, f),
	        n && (k = n["style:paragraph-properties"],
	        l && k && (g(l, k.attributes),
	        0 === l.attributes.length && e.removeChild(l)),
	        k = n["style:text-properties"],
	        a && k && (g(a, k.attributes),
	        0 === a.attributes.length && e.removeChild(a)),
	        g(e, n.attributes)),
	        d.getOdfCanvas().refreshCSS(),
	        d.emit(ops.OdtDocument.signalParagraphStyleModified, b),
	        d.getOdfCanvas().rerenderAnnotations(),
	        !0) : !1
	    }
	    ;
	    this.spec = function() {
	        return {
	            optype: "UpdateParagraphStyle",
	            memberid: k,
	            timestamp: d,
	            styleName: b,
	            setProperties: f,
	            removedProperties: n
	        }
	    }
	}
	;
	ops.OperationFactory = function() {
	    function g(d) {
	        return function(b) {
	            return new d
	        }
	    }
	    var k;
	    this.register = function(d, b) {
	        k[d] = b
	    }
	    ;
	    this.create = function(d) {
	        var b = null
	          , f = k[d.optype];
	        f && (b = f(d),
	        b.init(d));
	        return b
	    }
	    ;
	    k = {
	        AddMember: g(ops.OpAddMember),
	        UpdateMember: g(ops.OpUpdateMember),
	        RemoveMember: g(ops.OpRemoveMember),
	        AddCursor: g(ops.OpAddCursor),
	        ApplyDirectStyling: g(ops.OpApplyDirectStyling),
	        SetBlob: g(ops.OpSetBlob),
	        RemoveBlob: g(ops.OpRemoveBlob),
	        InsertImage: g(ops.OpInsertImage),
	        InsertTable: g(ops.OpInsertTable),
	        InsertText: g(ops.OpInsertText),
	        RemoveText: g(ops.OpRemoveText),
	        MergeParagraph: g(ops.OpMergeParagraph),
	        SplitParagraph: g(ops.OpSplitParagraph),
	        SetParagraphStyle: g(ops.OpSetParagraphStyle),
	        UpdateParagraphStyle: g(ops.OpUpdateParagraphStyle),
	        AddStyle: g(ops.OpAddStyle),
	        RemoveStyle: g(ops.OpRemoveStyle),
	        MoveCursor: g(ops.OpMoveCursor),
	        RemoveCursor: g(ops.OpRemoveCursor),
	        AddAnnotation: g(ops.OpAddAnnotation),
	        RemoveAnnotation: g(ops.OpRemoveAnnotation),
	        UpdateMetadata: g(ops.OpUpdateMetadata),
	        ApplyHyperlink: g(ops.OpApplyHyperlink),
	        RemoveHyperlink: g(ops.OpRemoveHyperlink)
	    }
	}
	;
	ops.OperationRouter = function() {}
	;
	ops.OperationRouter.prototype.setOperationFactory = function(g) {}
	;
	ops.OperationRouter.prototype.setPlaybackFunction = function(g) {}
	;
	ops.OperationRouter.prototype.push = function(g) {}
	;
	ops.OperationRouter.prototype.close = function(g) {}
	;
	ops.OperationRouter.prototype.subscribe = function(g, k) {}
	;
	ops.OperationRouter.prototype.unsubscribe = function(g, k) {}
	;
	ops.OperationRouter.prototype.hasLocalUnsyncedOps = function() {}
	;
	ops.OperationRouter.prototype.hasSessionHostConnection = function() {}
	;
	ops.OperationRouter.signalProcessingBatchStart = "router/batchstart";
	ops.OperationRouter.signalProcessingBatchEnd = "router/batchend";
	ops.TrivialOperationRouter = function() {
	    var g = new core.EventNotifier([ops.OperationRouter.signalProcessingBatchStart, ops.OperationRouter.signalProcessingBatchEnd]), k, d, b = 0;
	    this.setOperationFactory = function(b) {
	        k = b
	    }
	    ;
	    this.setPlaybackFunction = function(b) {
	        d = b
	    }
	    ;
	    this.push = function(f) {
	        b += 1;
	        g.emit(ops.OperationRouter.signalProcessingBatchStart, {});
	        f.forEach(function(f) {
	            f = f.spec();
	            f.timestamp = Date.now();
	            f = k.create(f);
	            f.group = "g" + b;
	            d(f)
	        });
	        g.emit(ops.OperationRouter.signalProcessingBatchEnd, {})
	    }
	    ;
	    this.close = function(b) {
	        b()
	    }
	    ;
	    this.subscribe = function(b, d) {
	        g.subscribe(b, d)
	    }
	    ;
	    this.unsubscribe = function(b, d) {
	        g.unsubscribe(b, d)
	    }
	    ;
	    this.hasLocalUnsyncedOps = function() {
	        return !1
	    }
	    ;
	    this.hasSessionHostConnection = function() {
	        return !0
	    }
	}
	;
	ops.Session = function(g) {
	    function k(b) {
	        f.emit(ops.OdtDocument.signalProcessingBatchStart, b)
	    }
	    function d(b) {
	        f.emit(ops.OdtDocument.signalProcessingBatchEnd, b)
	    }
	    var b = new ops.OperationFactory
	      , f = new ops.OdtDocument(g)
	      , n = null;
	    this.setOperationFactory = function(d) {
	        b = d;
	        n && n.setOperationFactory(b)
	    }
	    ;
	    this.setOperationRouter = function(g) {
	        n && (n.unsubscribe(ops.OperationRouter.signalProcessingBatchStart, k),
	        n.unsubscribe(ops.OperationRouter.signalProcessingBatchEnd, d));
	        n = g;
	        n.subscribe(ops.OperationRouter.signalProcessingBatchStart, k);
	        n.subscribe(ops.OperationRouter.signalProcessingBatchEnd, d);
	        g.setPlaybackFunction(function(b) {
	            f.emit(ops.OdtDocument.signalOperationStart, b);
	            return b.execute(f) ? (f.emit(ops.OdtDocument.signalOperationEnd, b),
	            !0) : !1
	        });
	        g.setOperationFactory(b)
	    }
	    ;
	    this.getOperationFactory = function() {
	        return b
	    }
	    ;
	    this.getOdtDocument = function() {
	        return f
	    }
	    ;
	    this.enqueue = function(b) {
	        n.push(b)
	    }
	    ;
	    this.close = function(b) {
	        n.close(function(d) {
	            d ? b(d) : f.close(b)
	        })
	    }
	    ;
	    this.destroy = function(b) {
	        f.destroy(b)
	    }
	    ;
	    this.setOperationRouter(new ops.TrivialOperationRouter)
	}
	;
	gui.AnnotationController = function(g, k, d) {
	    function b() {
	        var a = r.getCursor(d)
	          , a = a && a.getNode()
	          , b = !1;
	        a && (b = !l.isWithinAnnotation(a, r.getRootNode()));
	        b !== q && (q = b,
	        e.emit(gui.AnnotationController.annotatableChanged, q))
	    }
	    function f(a) {
	        a.getMemberId() === d && b()
	    }
	    function n(a) {
	        a === d && b()
	    }
	    function p(a) {
	        a.getMemberId() === d && b()
	    }
	    var r = g.getOdtDocument()
	      , q = !1
	      , e = new core.EventNotifier([gui.AnnotationController.annotatableChanged])
	      , l = odf.OdfUtils
	      , a = core.StepDirection.NEXT;
	    this.isAnnotatable = function() {
	        return q
	    }
	    ;
	    this.addAnnotation = function() {
	        var a = new ops.OpAddAnnotation
	          , b = r.getCursorSelection(d)
	          , e = b.length
	          , b = b.position;
	        q && (0 === e ? e = void 0 : (b = 0 <= e ? b : b + e,
	        e = Math.abs(e)),
	        a.init({
	            memberid: d,
	            position: b,
	            length: e,
	            name: d + Date.now()
	        }),
	        g.enqueue([a]))
	    }
	    ;
	    this.removeAnnotation = function(c) {
	        var b, e;
	        b = r.getMember(d).getProperties().fullName;
	        if (!0 !== k.getState(gui.CommonConstraints.EDIT.ANNOTATIONS.ONLY_DELETE_OWN) || b === l.getAnnotationCreator(c))
	            b = r.convertDomPointToCursorStep(c, 0, a),
	            e = r.convertDomPointToCursorStep(c, c.childNodes.length),
	            c = new ops.OpRemoveAnnotation,
	            c.init({
	                memberid: d,
	                position: b,
	                length: e - b
	            }),
	            e = new ops.OpMoveCursor,
	            e.init({
	                memberid: d,
	                position: 0 < b ? b - 1 : b,
	                length: 0
	            }),
	            g.enqueue([c, e])
	    }
	    ;
	    this.subscribe = function(a, b) {
	        e.subscribe(a, b)
	    }
	    ;
	    this.unsubscribe = function(a, b) {
	        e.unsubscribe(a, b)
	    }
	    ;
	    this.destroy = function(a) {
	        r.unsubscribe(ops.Document.signalCursorAdded, f);
	        r.unsubscribe(ops.Document.signalCursorRemoved, n);
	        r.unsubscribe(ops.Document.signalCursorMoved, p);
	        a()
	    }
	    ;
	    k.registerConstraint(gui.CommonConstraints.EDIT.ANNOTATIONS.ONLY_DELETE_OWN);
	    r.subscribe(ops.Document.signalCursorAdded, f);
	    r.subscribe(ops.Document.signalCursorRemoved, n);
	    r.subscribe(ops.Document.signalCursorMoved, p);
	    b()
	}
	;
	gui.AnnotationController.annotatableChanged = "annotatable/changed";
	gui.Avatar = function(g, k) {
	    var d = this, b, f, n;
	    this.setColor = function(b) {
	        f.style.borderColor = b
	    }
	    ;
	    this.setImageUrl = function(b) {
	        d.isVisible() ? f.src = b : n = b
	    }
	    ;
	    this.isVisible = function() {
	        return "block" === b.style.display
	    }
	    ;
	    this.show = function() {
	        n && (f.src = n,
	        n = void 0);
	        b.style.display = "block"
	    }
	    ;
	    this.hide = function() {
	        b.style.display = "none"
	    }
	    ;
	    this.markAsFocussed = function(d) {
	        d ? b.classList.add("active") : b.classList.remove("active")
	    }
	    ;
	    this.destroy = function(d) {
	        g.removeChild(b);
	        d()
	    }
	    ;
	    (function() {
	        var d = g.ownerDocument;
	        b = d.createElement("div");
	        f = d.createElement("img");
	        b.appendChild(f);
	        b.style.display = k ? "block" : "none";
	        b.className = "handle";
	        g.appendChild(b)
	    }
	    )()
	}
	;
	gui.StepInfo = function() {}
	;
	gui.StepInfo.VisualDirection = {
	    LEFT_TO_RIGHT: 0,
	    RIGHT_TO_LEFT: 1
	};
	gui.StepInfo.prototype.container = function() {}
	;
	gui.StepInfo.prototype.offset = function() {}
	;
	gui.VisualStepScanner = function() {}
	;
	gui.VisualStepScanner.prototype.process = function(g, k, d) {}
	;
	gui.GuiStepUtils = function() {
	    function g(f) {
	        f = d.getContentBounds(f);
	        var g, e = null;
	        if (f)
	            if (f.container.nodeType === Node.TEXT_NODE)
	                g = f.container.ownerDocument.createRange(),
	                g.setStart(f.container, f.startOffset),
	                g.setEnd(f.container, f.endOffset),
	                (e = 0 < g.getClientRects().length ? g.getBoundingClientRect() : null) && " " === f.container.data.substring(f.startOffset, f.endOffset) && 1 >= e.width && (e = null),
	                g.detach();
	            else if (k.isCharacterElement(f.container) || k.isCharacterFrame(f.container))
	                e = b.getBoundingClientRect(f.container);
	        return e
	    }
	    var k = odf.OdfUtils
	      , d = new odf.StepUtils
	      , b = core.DomUtils
	      , f = core.StepDirection.NEXT
	      , n = gui.StepInfo.VisualDirection.LEFT_TO_RIGHT
	      , p = gui.StepInfo.VisualDirection.RIGHT_TO_LEFT;
	    this.getContentRect = g;
	    this.moveToFilteredStep = function(b, d, e) {
	        function l(a, b) {
	            b.process(w, h, k) && (a = !0,
	            !x && b.token && (x = b.token));
	            return a
	        }
	        var a = d === f, c, m, h, k, x, z = b.snapshot();
	        c = !1;
	        var w;
	        do
	            c = g(b),
	            w = {
	                token: b.snapshot(),
	                container: b.container,
	                offset: b.offset,
	                direction: d,
	                visualDirection: d === f ? n : p
	            },
	            m = b.nextStep() ? g(b) : null,
	            b.restore(w.token),
	            a ? (h = c,
	            k = m) : (h = m,
	            k = c),
	            c = e.reduce(l, !1);
	        while (!c && b.advanceStep(d));
	        c || e.forEach(function(a) {
	            !x && a.token && (x = a.token)
	        });
	        b.restore(x || z);
	        return Boolean(x)
	    }
	}
	;
	gui.Caret = function(g, k, d, b) {
	    function f() {
	        a.style.opacity = "0" === a.style.opacity ? "1" : "0";
	        t.trigger()
	    }
	    function n() {
	        y.selectNodeContents(h);
	        return y.getBoundingClientRect()
	    }
	    function p(a) {
	        return E[a] !== L[a]
	    }
	    function r() {
	        Object.keys(L).forEach(function(a) {
	            E[a] = L[a]
	        })
	    }
	    function q() {
	        if (!1 === L.isShown || g.getSelectionType() !== ops.OdtCursor.RangeSelection || !b && !g.getSelectedRange().collapsed)
	            L.visibility = "hidden",
	            a.style.visibility = "hidden",
	            t.cancel();
	        else if (L.visibility = "visible",
	        a.style.visibility = "visible",
	        !1 === L.isFocused)
	            a.style.opacity = "1",
	            t.cancel();
	        else {
	            if (A || p("visibility"))
	                a.style.opacity = "1",
	                t.cancel();
	            t.trigger()
	        }
	        if (K || I) {
	            var d;
	            d = g.getNode();
	            var e, h, f = z.getBoundingClientRect(x.getSizer()), q = !1, y = 0;
	            d.removeAttributeNS("urn:webodf:names:cursor", "caret-sizer-active");
	            if (0 < d.getClientRects().length)
	                h = n(),
	                y = h.left - z.getBoundingClientRect(d).left,
	                q = !0;
	            else if (v.setPosition(d, 0),
	            h = w.getContentRect(v),
	            !h && v.nextStep() && (e = w.getContentRect(v)) && (h = e,
	            q = !0),
	            h || (d.setAttributeNS("urn:webodf:names:cursor", "caret-sizer-active", "true"),
	            h = n(),
	            q = !0),
	            !h)
	                for (runtime.log("WARN: No suitable client rectangle found for visual caret for " + g.getMemberId()); d; ) {
	                    if (0 < d.getClientRects().length) {
	                        h = z.getBoundingClientRect(d);
	                        q = !0;
	                        break
	                    }
	                    d = d.parentNode
	                }
	            h = z.translateRect(h, f, x.getZoomLevel());
	            d = {
	                top: h.top,
	                height: h.height,
	                right: q ? h.left : h.right,
	                width: z.adaptRangeDifferenceToZoomLevel(y, x.getZoomLevel())
	            };
	            8 > d.height && (d = {
	                top: d.top - (8 - d.height) / 2,
	                height: 8,
	                right: d.right
	            });
	            l.style.height = d.height + "px";
	            l.style.top = d.top + "px";
	            l.style.left = d.right - d.width + "px";
	            l.style.width = d.width ? d.width + "px" : "";
	            m && (d = runtime.getWindow().getComputedStyle(g.getNode(), null),
	            d.font ? m.style.font = d.font : (m.style.fontStyle = d.fontStyle,
	            m.style.fontVariant = d.fontVariant,
	            m.style.fontWeight = d.fontWeight,
	            m.style.fontSize = d.fontSize,
	            m.style.lineHeight = d.lineHeight,
	            m.style.fontFamily = d.fontFamily))
	        }
	        L.isShown && I && k.scrollIntoView(a.getBoundingClientRect());
	        p("isFocused") && c.markAsFocussed(L.isFocused);
	        r();
	        K = I = A = !1
	    }
	    function e(a) {
	        l.parentNode.removeChild(l);
	        h.parentNode.removeChild(h);
	        a()
	    }
	    var l, a, c, m, h, y, x = g.getDocument().getCanvas(), z = core.DomUtils, w = new gui.GuiStepUtils, v, u, t, A = !1, I = !1, K = !1, L = {
	        isFocused: !1,
	        isShown: !0,
	        visibility: "hidden"
	    }, E = {
	        isFocused: !L.isFocused,
	        isShown: !L.isShown,
	        visibility: "hidden"
	    };
	    this.handleUpdate = function() {
	        K = !0;
	        u.trigger()
	    }
	    ;
	    this.refreshCursorBlinking = function() {
	        A = !0;
	        u.trigger()
	    }
	    ;
	    this.setFocus = function() {
	        L.isFocused = !0;
	        u.trigger()
	    }
	    ;
	    this.removeFocus = function() {
	        L.isFocused = !1;
	        u.trigger()
	    }
	    ;
	    this.show = function() {
	        L.isShown = !0;
	        u.trigger()
	    }
	    ;
	    this.hide = function() {
	        L.isShown = !1;
	        u.trigger()
	    }
	    ;
	    this.setAvatarImageUrl = function(a) {
	        c.setImageUrl(a)
	    }
	    ;
	    this.setColor = function(b) {
	        a.style.borderColor = b;
	        c.setColor(b)
	    }
	    ;
	    this.getCursor = function() {
	        return g
	    }
	    ;
	    this.getFocusElement = function() {
	        return a
	    }
	    ;
	    this.toggleHandleVisibility = function() {
	        c.isVisible() ? c.hide() : c.show()
	    }
	    ;
	    this.showHandle = function() {
	        c.show()
	    }
	    ;
	    this.hideHandle = function() {
	        c.hide()
	    }
	    ;
	    this.setOverlayElement = function(a) {
	        m = a;
	        l.appendChild(a);
	        K = !0;
	        u.trigger()
	    }
	    ;
	    this.ensureVisible = function() {
	        I = !0;
	        u.trigger()
	    }
	    ;
	    this.getBoundingClientRect = function() {
	        return z.getBoundingClientRect(l)
	    }
	    ;
	    this.destroy = function(a) {
	        core.Async.destroyAll([u.destroy, t.destroy, c.destroy, e], a)
	    }
	    ;
	    (function() {
	        var b = g.getDocument()
	          , e = [b.createRootFilter(g.getMemberId()), b.getPositionFilter()]
	          , m = b.getDOMDocument();
	        y = m.createRange();
	        h = m.createElement("span");
	        h.className = "webodf-caretSizer";
	        h.textContent = "|";
	        g.getNode().appendChild(h);
	        l = m.createElement("div");
	        l.setAttributeNS("urn:webodf:names:editinfo", "editinfo:memberid", g.getMemberId());
	        l.className = "webodf-caretOverlay";
	        a = m.createElement("div");
	        a.className = "caret";
	        l.appendChild(a);
	        c = new gui.Avatar(l,d);
	        x.getSizer().appendChild(l);
	        v = b.createStepIterator(g.getNode(), 0, e, b.getRootNode());
	        u = core.Task.createRedrawTask(q);
	        t = core.Task.createTimeoutTask(f, 500);
	        u.triggerImmediate()
	    }
	    )()
	}
	;
	odf.TextSerializer = function() {
	    function g(b) {
	        var f = "", n = k.filter ? k.filter.acceptNode(b) : NodeFilter.FILTER_ACCEPT, p = b.nodeType, r;
	        if ((n === NodeFilter.FILTER_ACCEPT || n === NodeFilter.FILTER_SKIP) && d.isTextContentContainingNode(b))
	            for (r = b.firstChild; r; )
	                f += g(r),
	                r = r.nextSibling;
	        n === NodeFilter.FILTER_ACCEPT && (p === Node.ELEMENT_NODE && d.isParagraph(b) ? f += "\n" : p === Node.TEXT_NODE && b.textContent && (f += b.textContent));
	        return f
	    }
	    var k = this
	      , d = odf.OdfUtils;
	    this.filter = null;
	    this.writeToString = function(b) {
	        if (!b)
	            return "";
	        b = g(b);
	        "\n" === b[b.length - 1] && (b = b.substr(0, b.length - 1));
	        return b
	    }
	}
	;
	gui.MimeDataExporter = function() {
	    var g;
	    this.exportRangeToDataTransfer = function(k, d) {
	        var b;
	        b = d.startContainer.ownerDocument.createElement("span");
	        b.appendChild(d.cloneContents());
	        b = g.writeToString(b);
	        try {
	            k.setData("text/plain", b)
	        } catch (f) {
	            k.setData("Text", b)
	        }
	    }
	    ;
	    g = new odf.TextSerializer;
	    g.filter = new odf.OdfNodeFilter
	}
	;
	gui.Clipboard = function(g) {
	    this.setDataFromRange = function(k, d) {
	        var b, f = k.clipboardData;
	        b = runtime.getWindow();
	        !f && b && (f = b.clipboardData);
	        f ? (b = !0,
	        g.exportRangeToDataTransfer(f, d),
	        k.preventDefault()) : b = !1;
	        return b
	    }
	}
	;
	gui.SessionContext = function(g, k) {
	    var d = g.getOdtDocument()
	      , b = odf.OdfUtils;
	    this.isLocalCursorWithinOwnAnnotation = function() {
	        var f = d.getCursor(k), g;
	        if (!f)
	            return !1;
	        g = f && f.getNode();
	        f = d.getMember(k).getProperties().fullName;
	        return (g = b.getParentAnnotation(g, d.getRootNode())) && b.getAnnotationCreator(g) === f ? !0 : !1
	    }
	}
	;
	gui.StyleSummary = function(g) {
	    function k(b, d) {
	        var k = b + "|" + d, q;
	        f.hasOwnProperty(k) || (q = [],
	        g.forEach(function(e) {
	            e = (e = e.styleProperties[b]) && e[d];
	            -1 === q.indexOf(e) && q.push(e)
	        }),
	        f[k] = q);
	        return f[k]
	    }
	    function d(b, d, f) {
	        return function() {
	            var g = k(b, d);
	            return f.length >= g.length && g.every(function(b) {
	                return -1 !== f.indexOf(b)
	            })
	        }
	    }
	    function b(b, d) {
	        var f = k(b, d);
	        return 1 === f.length ? f[0] : void 0
	    }
	    var f = {};
	    this.getPropertyValues = k;
	    this.getCommonValue = b;
	    this.isBold = d("style:text-properties", "fo:font-weight", ["bold"]);
	    this.isItalic = d("style:text-properties", "fo:font-style", ["italic"]);
	    this.hasUnderline = d("style:text-properties", "style:text-underline-style", ["solid"]);
	    this.hasStrikeThrough = d("style:text-properties", "style:text-line-through-style", ["solid"]);
	    this.fontSize = function() {
	        var d = b("style:text-properties", "fo:font-size");
	        return d && parseFloat(d)
	    }
	    ;
	    this.fontName = function() {
	        return b("style:text-properties", "style:font-name")
	    }
	    ;
	    this.isAlignedLeft = d("style:paragraph-properties", "fo:text-align", ["left", "start"]);
	    this.isAlignedCenter = d("style:paragraph-properties", "fo:text-align", ["center"]);
	    this.isAlignedRight = d("style:paragraph-properties", "fo:text-align", ["right", "end"]);
	    this.isAlignedJustified = d("style:paragraph-properties", "fo:text-align", ["justify"]);
	    this.text = {
	        isBold: this.isBold,
	        isItalic: this.isItalic,
	        hasUnderline: this.hasUnderline,
	        hasStrikeThrough: this.hasStrikeThrough,
	        fontSize: this.fontSize,
	        fontName: this.fontName
	    };
	    this.paragraph = {
	        isAlignedLeft: this.isAlignedLeft,
	        isAlignedCenter: this.isAlignedCenter,
	        isAlignedRight: this.isAlignedRight,
	        isAlignedJustified: this.isAlignedJustified
	    }
	}
	;
	gui.DirectFormattingController = function(g, k, d, b, f, n, p) {
	    function r() {
	        return U.value().styleSummary
	    }
	    function q() {
	        return U.value().enabledFeatures
	    }
	    function e(a) {
	        var b;
	        a.collapsed ? (b = a.startContainer,
	        b.hasChildNodes() && a.startOffset < b.childNodes.length && (b = b.childNodes.item(a.startOffset)),
	        a = [b]) : a = S.getTextElements(a, !0, !1);
	        return a
	    }
	    function l() {
	        var a = P.getCursor(b)
	          , c = a && a.getSelectedRange()
	          , h = []
	          , h = []
	          , f = !0
	          , g = {
	            directTextStyling: !0,
	            directParagraphStyling: !0
	        };
	        c && (h = e(c),
	        0 === h.length && (h = [c.startContainer, c.endContainer],
	        f = !1),
	        h = P.getFormatting().getAppliedStyles(h));
	        void 0 !== h[0] && Z && (h[0].styleProperties = aa.mergeObjects(h[0].styleProperties, Z));
	        !0 === k.getState(gui.CommonConstraints.EDIT.REVIEW_MODE) && (g.directTextStyling = g.directParagraphStyling = d.isLocalCursorWithinOwnAnnotation());
	        g.directTextStyling && (g.directTextStyling = f && void 0 !== a && a.getSelectionType() === ops.OdtCursor.RangeSelection);
	        return {
	            enabledFeatures: g,
	            appliedStyles: h,
	            styleSummary: new gui.StyleSummary(h)
	        }
	    }
	    function a(a, b) {
	        var c = {};
	        Object.keys(a).forEach(function(d) {
	            var e = a[d]()
	              , h = b[d]();
	            e !== h && (c[d] = h)
	        });
	        return c
	    }
	    function c() {
	        var b, c;
	        c = ba.styleSummary;
	        var d = U.value()
	          , e = d.styleSummary
	          , h = ba.enabledFeatures
	          , f = d.enabledFeatures;
	        b = a(c.text, e.text);
	        c = a(c.paragraph, e.paragraph);
	        h = !(f.directTextStyling === h.directTextStyling && f.directParagraphStyling === h.directParagraphStyling);
	        ba = d;
	        h && fa.emit(gui.DirectFormattingController.enabledChanged, f);
	        0 < Object.keys(b).length && fa.emit(gui.DirectFormattingController.textStylingChanged, b);
	        0 < Object.keys(c).length && fa.emit(gui.DirectFormattingController.paragraphStylingChanged, c)
	    }
	    function m() {
	        U.reset();
	        c()
	    }
	    function h(a) {
	        ("string" === typeof a ? a : a.getMemberId()) === b && U.reset()
	    }
	    function y() {
	        U.reset()
	    }
	    function x(a) {
	        var c = P.getCursor(b);
	        a = a.paragraphElement;
	        c && S.getParagraphElement(c.getNode()) === a && U.reset()
	    }
	    function z(a, b) {
	        b(!a());
	        return !0
	    }
	    function w(a) {
	        if (q().directTextStyling) {
	            var c = P.getCursorSelection(b)
	              , d = {
	                "style:text-properties": a
	            };
	            0 !== c.length ? (a = new ops.OpApplyDirectStyling,
	            a.init({
	                memberid: b,
	                position: c.position,
	                length: c.length,
	                setProperties: d
	            }),
	            g.enqueue([a])) : (Z = aa.mergeObjects(Z || {}, d),
	            U.reset())
	        }
	    }
	    function v(a, b) {
	        var c = {};
	        c[a] = b;
	        w(c)
	    }
	    function u(a) {
	        a = a.spec();
	        Z && a.memberid === b && "SplitParagraph" !== a.optype && (Z = null,
	        U.reset())
	    }
	    function t(a) {
	        v("fo:font-weight", a ? "bold" : "normal")
	    }
	    function A(a) {
	        v("fo:font-style", a ? "italic" : "normal")
	    }
	    function I(a) {
	        v("style:text-underline-style", a ? "solid" : "none")
	    }
	    function K(a) {
	        v("style:text-line-through-style", a ? "solid" : "none")
	    }
	    function L(a) {
	        if (q().directParagraphStyling) {
	            var c = P.getCursor(b).getSelectedRange(), c = S.getParagraphElements(c), d = P.getFormatting(), e = [], h = {}, m;
	            c.forEach(function(c) {
	                var g = P.convertDomPointToCursorStep(c, 0, C), l = c.getAttributeNS(odf.Namespaces.textns, "style-name"), k;
	                c = l ? h.hasOwnProperty(l) ? h[l] : void 0 : m;
	                c || (c = f.generateStyleName(),
	                l ? (h[l] = c,
	                k = d.createDerivedStyleObject(l, "paragraph", {})) : (m = c,
	                k = {}),
	                k = a(k),
	                l = new ops.OpAddStyle,
	                l.init({
	                    memberid: b,
	                    styleName: c.toString(),
	                    styleFamily: "paragraph",
	                    isAutomaticStyle: !0,
	                    setProperties: k
	                }),
	                e.push(l));
	                l = new ops.OpSetParagraphStyle;
	                l.init({
	                    memberid: b,
	                    styleName: c.toString(),
	                    position: g
	                });
	                e.push(l)
	            });
	            g.enqueue(e)
	        }
	    }
	    function E(a) {
	        L(function(b) {
	            return aa.mergeObjects(b, a)
	        })
	    }
	    function N(a) {
	        E({
	            "style:paragraph-properties": {
	                "fo:text-align": a
	            }
	        })
	    }
	    function O(a, b) {
	        var c = P.getFormatting().getDefaultTabStopDistance(), d = b["style:paragraph-properties"], e;
	        d && (d = d["fo:margin-left"],
	        e = S.parseLength(d));
	        return aa.mergeObjects(b, {
	            "style:paragraph-properties": {
	                "fo:margin-left": e && e.unit === c.unit ? e.value + a * c.value + e.unit : a * c.value + c.unit
	            }
	        })
	    }
	    function D(a, b) {
	        var c = e(a)
	          , c = 0 === c.length ? [a.startContainer] : c
	          , c = P.getFormatting().getAppliedStyles(c)
	          , d = 0 < c.length ? c[0].styleProperties : void 0
	          , h = P.getFormatting().getAppliedStylesForElement(b).styleProperties;
	        if (!d || "text" !== d["style:family"] || !d["style:text-properties"])
	            return !1;
	        if (!h || !h["style:text-properties"])
	            return !0;
	        d = d["style:text-properties"];
	        h = h["style:text-properties"];
	        return !Object.keys(d).every(function(a) {
	            return d[a] === h[a]
	        })
	    }
	    function V() {}
	    function W() {
	        return !1
	    }
	    function J() {
	        return !1
	    }
	    var R = this, P = g.getOdtDocument(), aa = new core.Utils, S = odf.OdfUtils, fa = new core.EventNotifier([gui.DirectFormattingController.enabledChanged, gui.DirectFormattingController.textStylingChanged, gui.DirectFormattingController.paragraphStylingChanged]), ha = odf.Namespaces.textns, C = core.StepDirection.NEXT, Z = null, ba, U;
	    this.enabledFeatures = q;
	    this.formatTextSelection = w;
	    this.createCursorStyleOp = function(a, c, d) {
	        var e = null
	          , h = Z;
	        d && (h = (d = U.value().appliedStyles[0]) && d.styleProperties);
	        h && h["style:text-properties"] && (e = new ops.OpApplyDirectStyling,
	        e.init({
	            memberid: b,
	            position: a,
	            length: c,
	            setProperties: {
	                "style:text-properties": h["style:text-properties"]
	            }
	        }),
	        Z = null,
	        U.reset());
	        return e
	    }
	    ;
	    this.setBold = t;
	    this.setItalic = A;
	    this.setHasUnderline = I;
	    this.setHasStrikethrough = K;
	    this.setFontSize = function(a) {
	        v("fo:font-size", a + "pt")
	    }
	    ;
	    this.setFontName = function(a) {
	        v("style:font-name", a)
	    }
	    ;
	    this.getAppliedStyles = function() {
	        return U.value().appliedStyles
	    }
	    ;
	    this.toggleBold = z.bind(R, function() {
	        return r().isBold()
	    }, t);
	    this.toggleItalic = z.bind(R, function() {
	        return r().isItalic()
	    }, A);
	    this.toggleUnderline = z.bind(R, function() {
	        return r().hasUnderline()
	    }, I);
	    this.toggleStrikethrough = z.bind(R, function() {
	        return r().hasStrikeThrough()
	    }, K);
	    this.isBold = function() {
	        return r().isBold()
	    }
	    ;
	    this.isItalic = function() {
	        return r().isItalic()
	    }
	    ;
	    this.hasUnderline = function() {
	        return r().hasUnderline()
	    }
	    ;
	    this.hasStrikeThrough = function() {
	        return r().hasStrikeThrough()
	    }
	    ;
	    this.fontSize = function() {
	        return r().fontSize()
	    }
	    ;
	    this.fontName = function() {
	        return r().fontName()
	    }
	    ;
	    this.isAlignedLeft = function() {
	        return r().isAlignedLeft()
	    }
	    ;
	    this.isAlignedCenter = function() {
	        return r().isAlignedCenter()
	    }
	    ;
	    this.isAlignedRight = function() {
	        return r().isAlignedRight()
	    }
	    ;
	    this.isAlignedJustified = function() {
	        return r().isAlignedJustified()
	    }
	    ;
	    this.alignParagraphLeft = function() {
	        N("left");
	        return !0
	    }
	    ;
	    this.alignParagraphCenter = function() {
	        N("center");
	        return !0
	    }
	    ;
	    this.alignParagraphRight = function() {
	        N("right");
	        return !0
	    }
	    ;
	    this.alignParagraphJustified = function() {
	        N("justify");
	        return !0
	    }
	    ;
	    this.indent = function() {
	        L(O.bind(null, 1));
	        return !0
	    }
	    ;
	    this.outdent = function() {
	        L(O.bind(null, -1));
	        return !0
	    }
	    ;
	    this.createParagraphStyleOps = function(a) {
	        if (!q().directParagraphStyling)
	            return [];
	        var c = P.getCursor(b), d = c.getSelectedRange(), e = [], h, g;
	        c.hasForwardSelection() ? (h = c.getAnchorNode(),
	        g = c.getNode()) : (h = c.getNode(),
	        g = c.getAnchorNode());
	        c = S.getParagraphElement(g);
	        runtime.assert(Boolean(c), "DirectFormattingController: Cursor outside paragraph");
	        var m = c
	          , l = [P.getPositionFilter(), P.createRootFilter(b)];
	        if (!1 !== P.createStepIterator(d.endContainer, d.endOffset, l, m).nextStep())
	            return e;
	        g !== h && (c = S.getParagraphElement(h));
	        if (!Z && !D(d, c))
	            return e;
	        d = (d = U.value().appliedStyles[0]) && d.styleProperties;
	        if (!d)
	            return e;
	        if (c = c.getAttributeNS(ha, "style-name"))
	            d = {
	                "style:text-properties": d["style:text-properties"]
	            },
	            d = P.getFormatting().createDerivedStyleObject(c, "paragraph", d);
	        h = f.generateStyleName();
	        c = new ops.OpAddStyle;
	        c.init({
	            memberid: b,
	            styleName: h,
	            styleFamily: "paragraph",
	            isAutomaticStyle: !0,
	            setProperties: d
	        });
	        e.push(c);
	        c = new ops.OpSetParagraphStyle;
	        c.init({
	            memberid: b,
	            styleName: h,
	            position: a
	        });
	        e.push(c);
	        return e
	    }
	    ;
	    this.subscribe = function(a, c) {
	        fa.subscribe(a, c)
	    }
	    ;
	    this.unsubscribe = function(a, c) {
	        fa.unsubscribe(a, c)
	    }
	    ;
	    this.destroy = function(a) {
	        P.unsubscribe(ops.Document.signalCursorAdded, h);
	        P.unsubscribe(ops.Document.signalCursorRemoved, h);
	        P.unsubscribe(ops.Document.signalCursorMoved, h);
	        P.unsubscribe(ops.OdtDocument.signalParagraphStyleModified, y);
	        P.unsubscribe(ops.OdtDocument.signalParagraphChanged, x);
	        P.unsubscribe(ops.OdtDocument.signalOperationEnd, u);
	        P.unsubscribe(ops.OdtDocument.signalProcessingBatchEnd, c);
	        k.unsubscribe(gui.CommonConstraints.EDIT.REVIEW_MODE, m);
	        a()
	    }
	    ;
	    (function() {
	        P.subscribe(ops.Document.signalCursorAdded, h);
	        P.subscribe(ops.Document.signalCursorRemoved, h);
	        P.subscribe(ops.Document.signalCursorMoved, h);
	        P.subscribe(ops.OdtDocument.signalParagraphStyleModified, y);
	        P.subscribe(ops.OdtDocument.signalParagraphChanged, x);
	        P.subscribe(ops.OdtDocument.signalOperationEnd, u);
	        P.subscribe(ops.OdtDocument.signalProcessingBatchEnd, c);
	        k.subscribe(gui.CommonConstraints.EDIT.REVIEW_MODE, m);
	        U = new core.LazyProperty(l);
	        ba = U.value();
	        n || (R.formatTextSelection = V,
	        R.setBold = V,
	        R.setItalic = V,
	        R.setHasUnderline = V,
	        R.setHasStrikethrough = V,
	        R.setFontSize = V,
	        R.setFontName = V,
	        R.toggleBold = J,
	        R.toggleItalic = J,
	        R.toggleUnderline = J,
	        R.toggleStrikethrough = J);
	        p || (R.alignParagraphCenter = W,
	        R.alignParagraphJustified = W,
	        R.alignParagraphLeft = W,
	        R.alignParagraphRight = W,
	        R.createParagraphStyleOps = function() {
	            return []
	        }
	        ,
	        R.indent = W,
	        R.outdent = W)
	    }
	    )()
	}
	;
	gui.DirectFormattingController.enabledChanged = "enabled/changed";
	gui.DirectFormattingController.textStylingChanged = "textStyling/changed";
	gui.DirectFormattingController.paragraphStylingChanged = "paragraphStyling/changed";
	gui.DirectFormattingController.SelectionInfo = function() {}
	;
	gui.KeyboardHandler = function() {
	    function g(b, d) {
	        d || (d = k.None);
	        switch (b) {
	        case gui.KeyboardHandler.KeyCode.LeftMeta:
	        case gui.KeyboardHandler.KeyCode.RightMeta:
	        case gui.KeyboardHandler.KeyCode.MetaInMozilla:
	            d |= k.Meta;
	            break;
	        case gui.KeyboardHandler.KeyCode.Ctrl:
	            d |= k.Ctrl;
	            break;
	        case gui.KeyboardHandler.KeyCode.Alt:
	            d |= k.Alt;
	            break;
	        case gui.KeyboardHandler.KeyCode.Shift:
	            d |= k.Shift
	        }
	        return b + ":" + d
	    }
	    var k = gui.KeyboardHandler.Modifier
	      , d = null
	      , b = {};
	    this.setDefault = function(b) {
	        d = b
	    }
	    ;
	    this.bind = function(d, k, p, r) {
	        d = g(d, k);
	        runtime.assert(r || !1 === b.hasOwnProperty(d), "tried to overwrite the callback handler of key combo: " + d);
	        b[d] = p
	    }
	    ;
	    this.unbind = function(d, k) {
	        var p = g(d, k);
	        delete b[p]
	    }
	    ;
	    this.reset = function() {
	        d = null;
	        b = {}
	    }
	    ;
	    this.handleEvent = function(f) {
	        var n = f.keyCode
	          , p = k.None;
	        f.metaKey && (p |= k.Meta);
	        f.ctrlKey && (p |= k.Ctrl);
	        f.altKey && (p |= k.Alt);
	        f.shiftKey && (p |= k.Shift);
	        n = g(n, p);
	        n = b[n];
	        p = !1;
	        n ? p = n() : null !== d && (p = d(f));
	        p && (f.preventDefault ? f.preventDefault() : f.returnValue = !1)
	    }
	}
	;
	gui.KeyboardHandler.Modifier = {
	    None: 0,
	    Meta: 1,
	    Ctrl: 2,
	    Alt: 4,
	    CtrlAlt: 6,
	    Shift: 8,
	    MetaShift: 9,
	    CtrlShift: 10,
	    AltShift: 12
	};
	gui.KeyboardHandler.KeyCode = {
	    Backspace: 8,
	    Tab: 9,
	    Clear: 12,
	    Enter: 13,
	    Shift: 16,
	    Ctrl: 17,
	    Alt: 18,
	    End: 35,
	    Home: 36,
	    Left: 37,
	    Up: 38,
	    Right: 39,
	    Down: 40,
	    Delete: 46,
	    A: 65,
	    B: 66,
	    C: 67,
	    D: 68,
	    E: 69,
	    F: 70,
	    G: 71,
	    H: 72,
	    I: 73,
	    J: 74,
	    K: 75,
	    L: 76,
	    M: 77,
	    N: 78,
	    O: 79,
	    P: 80,
	    Q: 81,
	    R: 82,
	    S: 83,
	    T: 84,
	    U: 85,
	    V: 86,
	    W: 87,
	    X: 88,
	    Y: 89,
	    Z: 90,
	    LeftMeta: 91,
	    RightMeta: 93,
	    MetaInMozilla: 224
	};
	gui.HyperlinkClickHandler = function(g, k, d) {
	    function b() {
	        var a = g();
	        runtime.assert(Boolean(a.classList), "Document container has no classList element");
	        a.classList.remove("webodf-inactiveLinks")
	    }
	    function f() {
	        var a = g();
	        runtime.assert(Boolean(a.classList), "Document container has no classList element");
	        a.classList.add("webodf-inactiveLinks")
	    }
	    function n() {
	        a.removeEventListener("focus", f, !1);
	        m.forEach(function(a) {
	            k.unbind(a.keyCode, a.modifier);
	            d.unbind(a.keyCode, a.modifier)
	        });
	        m.length = 0
	    }
	    function p(c) {
	        n();
	        if (c !== r.None) {
	            a.addEventListener("focus", f, !1);
	            switch (c) {
	            case r.Ctrl:
	                m.push({
	                    keyCode: q.Ctrl,
	                    modifier: r.None
	                });
	                break;
	            case r.Meta:
	                m.push({
	                    keyCode: q.LeftMeta,
	                    modifier: r.None
	                }),
	                m.push({
	                    keyCode: q.RightMeta,
	                    modifier: r.None
	                }),
	                m.push({
	                    keyCode: q.MetaInMozilla,
	                    modifier: r.None
	                })
	            }
	            m.forEach(function(a) {
	                k.bind(a.keyCode, a.modifier, b);
	                d.bind(a.keyCode, a.modifier, f)
	            })
	        }
	    }
	    var r = gui.KeyboardHandler.Modifier
	      , q = gui.KeyboardHandler.KeyCode
	      , e = xmldom.XPath
	      , l = odf.OdfUtils
	      , a = runtime.getWindow()
	      , c = r.None
	      , m = [];
	    runtime.assert(null !== a, "Expected to be run in an environment which has a global window, like a browser.");
	    this.handleClick = function(b) {
	        var d = b.target || b.srcElement, f, m;
	        b.ctrlKey ? f = r.Ctrl : b.metaKey && (f = r.Meta);
	        if (c === r.None || c === f) {
	            a: {
	                for (; null !== d; ) {
	                    if (l.isHyperlink(d))
	                        break a;
	                    if (l.isParagraph(d))
	                        break;
	                    d = d.parentNode
	                }
	                d = null
	            }
	            d && (d = l.getHyperlinkTarget(d),
	            "" !== d && ("#" === d[0] ? (d = d.substring(1),
	            f = g(),
	            m = e.getODFElementsWithXPath(f, "//text:bookmark-start[@text:name='" + d + "']", odf.Namespaces.lookupNamespaceURI),
	            0 === m.length && (m = e.getODFElementsWithXPath(f, "//text:bookmark[@text:name='" + d + "']", odf.Namespaces.lookupNamespaceURI)),
	            0 < m.length && m[0].scrollIntoView(!0)) : /^\s*(javascript|data):/.test(d) ? runtime.log("WARN:", "potentially malicious URL ignored") : a.open(d),
	            b.preventDefault ? b.preventDefault() : b.returnValue = !1))
	        }
	    }
	    ;
	    this.setModifier = function(a) {
	        c !== a && (runtime.assert(a === r.None || a === r.Ctrl || a === r.Meta, "Unsupported KeyboardHandler.Modifier value: " + a),
	        c = a,
	        c !== r.None ? f() : b(),
	        p(c))
	    }
	    ;
	    this.getModifier = function() {
	        return c
	    }
	    ;
	    this.destroy = function(a) {
	        f();
	        n();
	        a()
	    }
	}
	;
	gui.EventManager = function(g) {
	    function k(a) {
	        function b(a, c, d) {
	            var e, h = !1;
	            e = "on" + c;
	            a.attachEvent && (a.attachEvent(e, d),
	            h = !0);
	            !h && a.addEventListener && (a.addEventListener(c, d, !1),
	            h = !0);
	            h && !u[c] || !a.hasOwnProperty(e) || (a[e] = d)
	        }
	        function c(a, b, d) {
	            var e = "on" + b;
	            a.detachEvent && a.detachEvent(e, d);
	            a.removeEventListener && a.removeEventListener(b, d, !1);
	            a[e] === d && (a[e] = null)
	        }
	        function d(c) {
	            if (-1 === h.indexOf(c)) {
	                h.push(c);
	                if (e.filters.every(function(a) {
	                    return a(c)
	                }))
	                    try {
	                        f.emit(a, c)
	                    } catch (b) {
	                        runtime.log("Error occurred while processing " + a + ":\n" + b.message + "\n" + b.stack)
	                    }
	                runtime.setTimeout(function() {
	                    h.splice(h.indexOf(c), 1)
	                }, 0)
	            }
	        }
	        var e = this
	          , h = []
	          , f = new core.EventNotifier([a]);
	        this.filters = [];
	        this.subscribe = function(c) {
	            f.subscribe(a, c)
	        }
	        ;
	        this.unsubscribe = function(c) {
	            f.unsubscribe(a, c)
	        }
	        ;
	        this.destroy = function() {
	            c(v, a, d);
	            c(K, a, d);
	            c(L, a, d)
	        }
	        ;
	        t[a] && b(v, a, d);
	        b(K, a, d);
	        b(L, a, d)
	    }
	    function d(a, c, b) {
	        function d(c) {
	            b(c, e, function(c) {
	                c.type = a;
	                h.emit(a, c)
	            })
	        }
	        var e = {}
	          , h = new core.EventNotifier([a]);
	        this.subscribe = function(c) {
	            h.subscribe(a, c)
	        }
	        ;
	        this.unsubscribe = function(c) {
	            h.unsubscribe(a, c)
	        }
	        ;
	        this.destroy = function() {
	            c.forEach(function(a) {
	                E.unsubscribe(a, d)
	            })
	        }
	        ;
	        (function() {
	            c.forEach(function(a) {
	                E.subscribe(a, d)
	            })
	        }
	        )()
	    }
	    function b(a) {
	        runtime.clearTimeout(a);
	        delete N[a]
	    }
	    function f(a, c) {
	        var d = runtime.setTimeout(function() {
	            a();
	            b(d)
	        }, c);
	        N[d] = !0;
	        return d
	    }
	    function n(a, c, d) {
	        var e = a.touches.length
	          , h = a.touches[0]
	          , g = c.timer;
	        "touchmove" === a.type || "touchend" === a.type ? g && b(g) : "touchstart" === a.type && (1 !== e ? runtime.clearTimeout(g) : g = f(function() {
	            d({
	                clientX: h.clientX,
	                clientY: h.clientY,
	                pageX: h.pageX,
	                pageY: h.pageY,
	                target: a.target || a.srcElement || null,
	                detail: 1
	            })
	        }, 400));
	        c.timer = g
	    }
	    function p(a, c, b) {
	        var d = a.touches[0]
	          , e = a.target || a.srcElement || null
	          , h = c.target;
	        1 !== a.touches.length || "touchend" === a.type ? h = null : "touchstart" === a.type && "webodf-draggable" === e.getAttribute("class") ? h = e : "touchmove" === a.type && h && (a.preventDefault(),
	        a.stopPropagation(),
	        b({
	            clientX: d.clientX,
	            clientY: d.clientY,
	            pageX: d.pageX,
	            pageY: d.pageY,
	            target: h,
	            detail: 1
	        }));
	        c.target = h
	    }
	    function r(a, c, b) {
	        var d = a.target || a.srcElement || null
	          , e = c.dragging;
	        "drag" === a.type ? e = !0 : "touchend" === a.type && e && (e = !1,
	        a = a.changedTouches[0],
	        b({
	            clientX: a.clientX,
	            clientY: a.clientY,
	            pageX: a.pageX,
	            pageY: a.pageY,
	            target: d,
	            detail: 1
	        }));
	        c.dragging = e
	    }
	    function q() {
	        L.classList.add("webodf-touchEnabled");
	        E.unsubscribe("touchstart", q)
	    }
	    function e(a) {
	        var c = a.scrollX
	          , b = a.scrollY;
	        this.restore = function() {
	            a.scrollX === c && a.scrollY === b || a.scrollTo(c, b)
	        }
	    }
	    function l(a) {
	        var c = a.scrollTop
	          , b = a.scrollLeft;
	        this.restore = function() {
	            if (a.scrollTop !== c || a.scrollLeft !== b)
	                a.scrollTop = c,
	                a.scrollLeft = b
	        }
	    }
	    function a(a, c) {
	        var b = I[a] || A[a] || null;
	        !b && c && (b = I[a] = new k(a));
	        return b
	    }
	    function c(c, b) {
	        a(c, !0).subscribe(b)
	    }
	    function m(c, b) {
	        var d = a(c, !1);
	        d && d.unsubscribe(b)
	    }
	    function h() {
	        return g.getDOMDocument().activeElement === K
	    }
	    function y() {
	        h() && K.blur();
	        K.setAttribute("disabled", "true")
	    }
	    function x() {
	        K.removeAttribute("disabled")
	    }
	    function z(a) {
	        for (var c = []; a; )
	            (a.scrollWidth > a.clientWidth || a.scrollHeight > a.clientHeight) && c.push(new l(a)),
	            a = a.parentNode;
	        c.push(new e(v));
	        return c
	    }
	    function w() {
	        var a;
	        h() || (a = z(K),
	        x(),
	        K.focus(),
	        a.forEach(function(a) {
	            a.restore()
	        }))
	    }
	    var v = runtime.getWindow(), u = {
	        beforecut: !0,
	        beforepaste: !0,
	        longpress: !0,
	        drag: !0,
	        dragstop: !0
	    }, t = {
	        mousedown: !0,
	        mouseup: !0,
	        focus: !0
	    }, A = {}, I = {}, K, L = g.getCanvas().getElement(), E = this, N = {};
	    this.addFilter = function(c, b) {
	        a(c, !0).filters.push(b)
	    }
	    ;
	    this.removeFilter = function(c, b) {
	        var d = a(c, !0)
	          , e = d.filters.indexOf(b);
	        -1 !== e && d.filters.splice(e, 1)
	    }
	    ;
	    this.subscribe = c;
	    this.unsubscribe = m;
	    this.hasFocus = h;
	    this.focus = w;
	    this.getEventTrap = function() {
	        return K
	    }
	    ;
	    this.setEditing = function(a) {
	        var c = h();
	        c && K.blur();
	        a ? K.removeAttribute("readOnly") : K.setAttribute("readOnly", "true");
	        c && w()
	    }
	    ;
	    this.destroy = function(a) {
	        m("touchstart", q);
	        Object.keys(N).forEach(function(a) {
	            b(parseInt(a, 10))
	        });
	        N.length = 0;
	        Object.keys(A).forEach(function(a) {
	            A[a].destroy()
	        });
	        A = {};
	        m("mousedown", y);
	        m("mouseup", x);
	        m("contextmenu", x);
	        Object.keys(I).forEach(function(a) {
	            I[a].destroy()
	        });
	        I = {};
	        K.parentNode.removeChild(K);
	        a()
	    }
	    ;
	    (function() {
	        var a = g.getOdfCanvas().getSizer()
	          , b = a.ownerDocument;
	        runtime.assert(Boolean(v), "EventManager requires a window object to operate correctly");
	        K = b.createElement("textarea");
	        K.id = "eventTrap";
	        K.setAttribute("tabindex", "-1");
	        K.setAttribute("readOnly", "true");
	        K.setAttribute("rows", "1");
	        a.appendChild(K);
	        c("mousedown", y);
	        c("mouseup", x);
	        c("contextmenu", x);
	        A.longpress = new d("longpress",["touchstart", "touchmove", "touchend"],n);
	        A.drag = new d("drag",["touchstart", "touchmove", "touchend"],p);
	        A.dragstop = new d("dragstop",["drag", "touchend"],r);
	        c("touchstart", q)
	    }
	    )()
	}
	;
	gui.IOSSafariSupport = function(g) {
	    function k() {
	        d.innerHeight !== d.outerHeight && (b.style.display = "none",
	        runtime.requestAnimationFrame(function() {
	            b.style.display = "block"
	        }))
	    }
	    var d = runtime.getWindow()
	      , b = g.getEventTrap();
	    this.destroy = function(d) {
	        g.unsubscribe("focus", k);
	        b.removeAttribute("autocapitalize");
	        b.style.WebkitTransform = "";
	        d()
	    }
	    ;
	    g.subscribe("focus", k);
	    b.setAttribute("autocapitalize", "off");
	    b.style.WebkitTransform = "translateX(-10000px)"
	}
	;
	gui.HyperlinkController = function(g, k, d, b) {
	    function f() {
	        var b = !0;
	        !0 === k.getState(gui.CommonConstraints.EDIT.REVIEW_MODE) && (b = d.isLocalCursorWithinOwnAnnotation());
	        b !== e && (e = b,
	        q.emit(gui.HyperlinkController.enabledChanged, e))
	    }
	    function n(d) {
	        d.getMemberId() === b && f()
	    }
	    var p = odf.OdfUtils
	      , r = g.getOdtDocument()
	      , q = new core.EventNotifier([gui.HyperlinkController.enabledChanged])
	      , e = !1;
	    this.isEnabled = function() {
	        return e
	    }
	    ;
	    this.subscribe = function(b, a) {
	        q.subscribe(b, a)
	    }
	    ;
	    this.unsubscribe = function(b, a) {
	        q.unsubscribe(b, a)
	    }
	    ;
	    this.addHyperlink = function(d, a) {
	        if (e) {
	            var c = r.getCursorSelection(b)
	              , f = new ops.OpApplyHyperlink
	              , h = [];
	            if (0 === c.length || a)
	                a = a || d,
	                f = new ops.OpInsertText,
	                f.init({
	                    memberid: b,
	                    position: c.position,
	                    text: a
	                }),
	                c.length = a.length,
	                h.push(f);
	            f = new ops.OpApplyHyperlink;
	            f.init({
	                memberid: b,
	                position: c.position,
	                length: c.length,
	                hyperlink: d
	            });
	            h.push(f);
	            g.enqueue(h)
	        }
	    }
	    ;
	    this.removeHyperlinks = function() {
	        if (e) {
	            var d = r.createPositionIterator(r.getRootNode()), a = r.getCursor(b).getSelectedRange(), c = p.getHyperlinkElements(a), f = a.collapsed && 1 === c.length, h = r.getDOMDocument().createRange(), k = [], n, q;
	            0 !== c.length && (c.forEach(function(a) {
	                h.selectNodeContents(a);
	                n = r.convertDomToCursorRange({
	                    anchorNode: h.startContainer,
	                    anchorOffset: h.startOffset,
	                    focusNode: h.endContainer,
	                    focusOffset: h.endOffset
	                });
	                q = new ops.OpRemoveHyperlink;
	                q.init({
	                    memberid: b,
	                    position: n.position,
	                    length: n.length
	                });
	                k.push(q)
	            }),
	            f || (f = c[0],
	            -1 === a.comparePoint(f, 0) && (h.setStart(f, 0),
	            h.setEnd(a.startContainer, a.startOffset),
	            n = r.convertDomToCursorRange({
	                anchorNode: h.startContainer,
	                anchorOffset: h.startOffset,
	                focusNode: h.endContainer,
	                focusOffset: h.endOffset
	            }),
	            0 < n.length && (q = new ops.OpApplyHyperlink,
	            q.init({
	                memberid: b,
	                position: n.position,
	                length: n.length,
	                hyperlink: p.getHyperlinkTarget(f)
	            }),
	            k.push(q))),
	            c = c[c.length - 1],
	            d.moveToEndOfNode(c),
	            d = d.unfilteredDomOffset(),
	            1 === a.comparePoint(c, d) && (h.setStart(a.endContainer, a.endOffset),
	            h.setEnd(c, d),
	            n = r.convertDomToCursorRange({
	                anchorNode: h.startContainer,
	                anchorOffset: h.startOffset,
	                focusNode: h.endContainer,
	                focusOffset: h.endOffset
	            }),
	            0 < n.length && (q = new ops.OpApplyHyperlink,
	            q.init({
	                memberid: b,
	                position: n.position,
	                length: n.length,
	                hyperlink: p.getHyperlinkTarget(c)
	            }),
	            k.push(q)))),
	            g.enqueue(k),
	            h.detach())
	        }
	    }
	    ;
	    this.destroy = function(b) {
	        r.unsubscribe(ops.Document.signalCursorMoved, n);
	        k.unsubscribe(gui.CommonConstraints.EDIT.REVIEW_MODE, f);
	        b()
	    }
	    ;
	    r.subscribe(ops.Document.signalCursorMoved, n);
	    k.subscribe(gui.CommonConstraints.EDIT.REVIEW_MODE, f);
	    f()
	}
	;
	gui.HyperlinkController.enabledChanged = "enabled/changed";
	gui.ImageController = function(g, k, d, b, f) {
	    function n() {
	        var a = !0;
	        !0 === k.getState(gui.CommonConstraints.EDIT.REVIEW_MODE) && (a = d.isLocalCursorWithinOwnAnnotation());
	        a !== m && (m = a,
	        c.emit(gui.ImageController.enabledChanged, m))
	    }
	    function p(a) {
	        a.getMemberId() === b && n()
	    }
	    var r = {
	        "image/gif": ".gif",
	        "image/jpeg": ".jpg",
	        "image/png": ".png"
	    }
	      , q = odf.Namespaces.textns
	      , e = g.getOdtDocument()
	      , l = odf.OdfUtils
	      , a = e.getFormatting()
	      , c = new core.EventNotifier([gui.HyperlinkController.enabledChanged])
	      , m = !1;
	    this.isEnabled = function() {
	        return m
	    }
	    ;
	    this.subscribe = function(a, b) {
	        c.subscribe(a, b)
	    }
	    ;
	    this.unsubscribe = function(a, b) {
	        c.unsubscribe(a, b)
	    }
	    ;
	    this.insertImage = function(c, d, k, n) {
	        if (m) {
	            var p = new core.CSSUnits;
	            runtime.assert(0 < k && 0 < n, "Both width and height of the image should be greater than 0px.");
	            n = {
	                width: k,
	                height: n
	            };
	            if (k = l.getParagraphElement(e.getCursor(b).getNode()).getAttributeNS(q, "style-name")) {
	                k = a.getContentSize(k, "paragraph");
	                var v = 1
	                  , u = 1;
	                n.width > k.width && (v = k.width / n.width);
	                n.height > k.height && (u = k.height / n.height);
	                k = Math.min(v, u);
	                n = {
	                    width: n.width * k,
	                    height: n.height * k
	                }
	            }
	            k = p.convert(n.width, "px", "cm") + "cm";
	            p = p.convert(n.height, "px", "cm") + "cm";
	            u = e.getOdfCanvas().odfContainer().rootElement.styles;
	            n = c.toLowerCase();
	            var v = r.hasOwnProperty(n) ? r[n] : null, t;
	            n = [];
	            runtime.assert(null !== v, "Image type is not supported: " + c);
	            v = "Pictures/" + f.generateImageName() + v;
	            t = new ops.OpSetBlob;
	            t.init({
	                memberid: b,
	                filename: v,
	                mimetype: c,
	                content: d
	            });
	            n.push(t);
	            a.getStyleElement("Graphics", "graphic", [u]) || (c = new ops.OpAddStyle,
	            c.init({
	                memberid: b,
	                styleName: "Graphics",
	                styleFamily: "graphic",
	                isAutomaticStyle: !1,
	                setProperties: {
	                    "style:graphic-properties": {
	                        "text:anchor-type": "paragraph",
	                        "svg:x": "0cm",
	                        "svg:y": "0cm",
	                        "style:wrap": "dynamic",
	                        "style:number-wrapped-paragraphs": "no-limit",
	                        "style:wrap-contour": "false",
	                        "style:vertical-pos": "top",
	                        "style:vertical-rel": "paragraph",
	                        "style:horizontal-pos": "center",
	                        "style:horizontal-rel": "paragraph"
	                    }
	                }
	            }),
	            n.push(c));
	            c = f.generateStyleName();
	            d = new ops.OpAddStyle;
	            d.init({
	                memberid: b,
	                styleName: c,
	                styleFamily: "graphic",
	                isAutomaticStyle: !0,
	                setProperties: {
	                    "style:parent-style-name": "Graphics",
	                    "style:graphic-properties": {
	                        "style:vertical-pos": "top",
	                        "style:vertical-rel": "baseline",
	                        "style:horizontal-pos": "center",
	                        "style:horizontal-rel": "paragraph",
	                        "fo:background-color": "transparent",
	                        "style:background-transparency": "100%",
	                        "style:shadow": "none",
	                        "style:mirror": "none",
	                        "fo:clip": "rect(0cm, 0cm, 0cm, 0cm)",
	                        "draw:luminance": "0%",
	                        "draw:contrast": "0%",
	                        "draw:red": "0%",
	                        "draw:green": "0%",
	                        "draw:blue": "0%",
	                        "draw:gamma": "100%",
	                        "draw:color-inversion": "false",
	                        "draw:image-opacity": "100%",
	                        "draw:color-mode": "standard"
	                    }
	                }
	            });
	            n.push(d);
	            t = new ops.OpInsertImage;
	            t.init({
	                memberid: b,
	                position: e.getCursorPosition(b),
	                filename: v,
	                frameWidth: k,
	                frameHeight: p,
	                frameStyleName: c,
	                frameName: f.generateFrameName()
	            });
	            n.push(t);
	            g.enqueue(n)
	        }
	    }
	    ;
	    this.destroy = function(a) {
	        e.unsubscribe(ops.Document.signalCursorMoved, p);
	        k.unsubscribe(gui.CommonConstraints.EDIT.REVIEW_MODE, n);
	        a()
	    }
	    ;
	    e.subscribe(ops.Document.signalCursorMoved, p);
	    k.subscribe(gui.CommonConstraints.EDIT.REVIEW_MODE, n);
	    n()
	}
	;
	gui.ImageController.enabledChanged = "enabled/changed";
	gui.ImageSelector = function(g) {
	    function k() {
	        var d = g.getSizer()
	          , k = f.createElement("div");
	        k.id = "imageSelector";
	        k.style.borderWidth = "1px";
	        d.appendChild(k);
	        b.forEach(function(b) {
	            var d = f.createElement("div");
	            d.className = b;
	            k.appendChild(d)
	        });
	        return k
	    }
	    var d = odf.Namespaces.svgns
	      , b = "topLeft topRight bottomRight bottomLeft topMiddle rightMiddle bottomMiddle leftMiddle".split(" ")
	      , f = g.getElement().ownerDocument
	      , n = !1;
	    this.select = function(b) {
	        var r, q, e = f.getElementById("imageSelector");
	        e || (e = k());
	        n = !0;
	        r = e.parentNode;
	        q = b.getBoundingClientRect();
	        var l = r.getBoundingClientRect()
	          , a = g.getZoomLevel();
	        r = (q.left - l.left) / a - 1;
	        q = (q.top - l.top) / a - 1;
	        e.style.display = "block";
	        e.style.left = r + "px";
	        e.style.top = q + "px";
	        e.style.width = b.getAttributeNS(d, "width");
	        e.style.height = b.getAttributeNS(d, "height")
	    }
	    ;
	    this.clearSelection = function() {
	        var b;
	        n && (b = f.getElementById("imageSelector")) && (b.style.display = "none");
	        n = !1
	    }
	    ;
	    this.isSelectorElement = function(b) {
	        var d = f.getElementById("imageSelector");
	        return d ? b === d || b.parentNode === d : !1
	    }
	}
	;
	(function() {
	    function g(g) {
	        function d(b) {
	            p = b.which && String.fromCharCode(b.which) === n;
	            n = void 0;
	            return !1 === p
	        }
	        function b() {
	            p = !1
	        }
	        function f(b) {
	            n = b.data;
	            p = !1
	        }
	        var n, p = !1;
	        this.destroy = function(n) {
	            g.unsubscribe("textInput", b);
	            g.unsubscribe("compositionend", f);
	            g.removeFilter("keypress", d);
	            n()
	        }
	        ;
	        g.subscribe("textInput", b);
	        g.subscribe("compositionend", f);
	        g.addFilter("keypress", d)
	    }
	    gui.InputMethodEditor = function(k, d) {
	        function b(c) {
	            a && (c ? a.getNode().setAttributeNS("urn:webodf:names:cursor", "composing", "true") : (a.getNode().removeAttributeNS("urn:webodf:names:cursor", "composing"),
	            h.textContent = ""))
	        }
	        function f() {
	            x && (x = !1,
	            b(!1),
	            w.emit(gui.InputMethodEditor.signalCompositionEnd, {
	                data: z
	            }),
	            z = "")
	        }
	        function n() {
	            I || (I = !0,
	            f(),
	            a && a.getSelectedRange().collapsed ? c.value = "" : c.value = u.writeToString(a.getSelectedRange().cloneContents()),
	            c.setSelectionRange(0, c.value.length),
	            I = !1)
	        }
	        function p() {
	            d.hasFocus() && y.trigger()
	        }
	        function r() {
	            v = void 0;
	            y.cancel();
	            b(!0);
	            x || w.emit(gui.InputMethodEditor.signalCompositionStart, {
	                data: ""
	            })
	        }
	        function q(a) {
	            a = v = a.data;
	            x = !0;
	            z += a;
	            y.trigger()
	        }
	        function e(a) {
	            a.data !== v && (a = a.data,
	            x = !0,
	            z += a,
	            y.trigger());
	            v = void 0
	        }
	        function l() {
	            h.textContent = c.value
	        }
	        var a = null, c = d.getEventTrap(), m = c.ownerDocument, h, y, x = !1, z = "", w = new core.EventNotifier([gui.InputMethodEditor.signalCompositionStart, gui.InputMethodEditor.signalCompositionEnd]), v, u, t = [], A, I = !1;
	        this.subscribe = w.subscribe;
	        this.unsubscribe = w.unsubscribe;
	        this.registerCursor = function(c) {
	            c.getMemberId() === k && (a = c,
	            a.getNode().appendChild(h),
	            c.subscribe(ops.OdtCursor.signalCursorUpdated, p),
	            d.subscribe("input", l),
	            d.subscribe("compositionupdate", l))
	        }
	        ;
	        this.removeCursor = function(c) {
	            a && c === k && (a.getNode().removeChild(h),
	            a.unsubscribe(ops.OdtCursor.signalCursorUpdated, p),
	            d.unsubscribe("input", l),
	            d.unsubscribe("compositionupdate", l),
	            a = null)
	        }
	        ;
	        this.destroy = function(a) {
	            d.unsubscribe("compositionstart", r);
	            d.unsubscribe("compositionend", q);
	            d.unsubscribe("textInput", e);
	            d.unsubscribe("keypress", f);
	            d.unsubscribe("focus", n);
	            core.Async.destroyAll(A, a)
	        }
	        ;
	        (function() {
	            u = new odf.TextSerializer;
	            u.filter = new odf.OdfNodeFilter;
	            d.subscribe("compositionstart", r);
	            d.subscribe("compositionend", q);
	            d.subscribe("textInput", e);
	            d.subscribe("keypress", f);
	            d.subscribe("focus", n);
	            t.push(new g(d));
	            A = t.map(function(a) {
	                return a.destroy
	            });
	            h = m.createElement("span");
	            h.setAttribute("id", "composer");
	            y = core.Task.createTimeoutTask(n, 1);
	            A.push(y.destroy)
	        }
	        )()
	    }
	    ;
	    gui.InputMethodEditor.signalCompositionStart = "input/compositionstart";
	    gui.InputMethodEditor.signalCompositionEnd = "input/compositionend"
	}
	)();
	gui.MetadataController = function(g, k) {
	    function d(b) {
	        n.emit(gui.MetadataController.signalMetadataChanged, b)
	    }
	    function b(b) {
	        var d = -1 === p.indexOf(b);
	        d || runtime.log("Setting " + b + " is restricted.");
	        return d
	    }
	    var f = g.getOdtDocument()
	      , n = new core.EventNotifier([gui.MetadataController.signalMetadataChanged])
	      , p = ["dc:creator", "dc:date", "meta:editing-cycles", "meta:editing-duration", "meta:document-statistic"];
	    this.setMetadata = function(d, f) {
	        var e = {}, l = "", a;
	        d && Object.keys(d).filter(b).forEach(function(a) {
	            e[a] = d[a]
	        });
	        f && (l = f.filter(b).join(","));
	        if (0 < l.length || 0 < Object.keys(e).length)
	            a = new ops.OpUpdateMetadata,
	            a.init({
	                memberid: k,
	                setProperties: e,
	                removedProperties: 0 < l.length ? {
	                    attributes: l
	                } : null
	            }),
	            g.enqueue([a])
	    }
	    ;
	    this.getMetadata = function(b) {
	        var d;
	        runtime.assert("string" === typeof b, "Property must be a string");
	        d = b.split(":");
	        runtime.assert(2 === d.length, "Property must be a namespace-prefixed string");
	        b = odf.Namespaces.lookupNamespaceURI(d[0]);
	        runtime.assert(Boolean(b), "Prefix must be for an ODF namespace.");
	        return f.getOdfCanvas().odfContainer().getMetadata(b, d[1])
	    }
	    ;
	    this.subscribe = function(b, d) {
	        n.subscribe(b, d)
	    }
	    ;
	    this.unsubscribe = function(b, d) {
	        n.unsubscribe(b, d)
	    }
	    ;
	    this.destroy = function(b) {
	        f.unsubscribe(ops.OdtDocument.signalMetadataUpdated, d);
	        b()
	    }
	    ;
	    f.subscribe(ops.OdtDocument.signalMetadataUpdated, d)
	}
	;
	gui.MetadataController.signalMetadataChanged = "metadata/changed";
	gui.PasteController = function(g, k, d, b) {
	    function f() {
	        r = !0 === k.getState(gui.CommonConstraints.EDIT.REVIEW_MODE) ? d.isLocalCursorWithinOwnAnnotation() : !0
	    }
	    function n(a) {
	        a.getMemberId() === b && f()
	    }
	    var p = g.getOdtDocument()
	      , r = !1
	      , q = odf.Namespaces.textns
	      , e = core.StepDirection.NEXT
	      , l = odf.OdfUtils;
	    this.isEnabled = function() {
	        return r
	    }
	    ;
	    this.paste = function(a) {
	        if (r) {
	            var c = p.getCursorPosition(b)
	              , d = p.getCursor(b).getNode()
	              , d = l.getParagraphElement(d)
	              , h = d.getAttributeNS(q, "style-name") || ""
	              , f = c
	              , k = []
	              , n = p.convertDomPointToCursorStep(d, 0, e);
	            a.replace(/\r/g, "").split("\n").forEach(function(a) {
	                var c = new ops.OpInsertText
	                  , d = new ops.OpSplitParagraph;
	                c.init({
	                    memberid: b,
	                    position: f,
	                    text: a,
	                    moveCursor: !0
	                });
	                k.push(c);
	                f += a.length;
	                d.init({
	                    memberid: b,
	                    position: f,
	                    paragraphStyleName: h,
	                    sourceParagraphPosition: n,
	                    moveCursor: !0
	                });
	                k.push(d);
	                n = f += 1
	            });
	            k.pop();
	            g.enqueue(k)
	        }
	    }
	    ;
	    this.destroy = function(a) {
	        p.unsubscribe(ops.Document.signalCursorMoved, n);
	        k.unsubscribe(gui.CommonConstraints.EDIT.REVIEW_MODE, f);
	        a()
	    }
	    ;
	    p.subscribe(ops.Document.signalCursorMoved, n);
	    k.subscribe(gui.CommonConstraints.EDIT.REVIEW_MODE, f);
	    f()
	}
	;
	gui.ClosestXOffsetScanner = function(g) {
	    function k(b) {
	        return null !== b && void 0 !== f ? Math.abs(b - g) > f : !1
	    }
	    function d(b) {
	        null !== b && !1 === k(b) && (f = Math.abs(b - g))
	    }
	    var b = this, f, n = gui.StepInfo.VisualDirection.LEFT_TO_RIGHT;
	    this.token = void 0;
	    this.process = function(f, g, q) {
	        var e, l;
	        f.visualDirection === n ? (e = g && g.right,
	        l = q && q.left) : (e = g && g.left,
	        l = q && q.right);
	        if (k(e) || k(l))
	            return !0;
	        if (g || q)
	            d(e),
	            d(l),
	            b.token = f.token;
	        return !1
	    }
	}
	;
	gui.LineBoundaryScanner = function() {
	    var g = this
	      , k = null;
	    this.token = void 0;
	    this.process = function(d, b, f) {
	        var n;
	        if (n = f)
	            if (k) {
	                var p = k;
	                n = Math.min(p.bottom - p.top, f.bottom - f.top);
	                var r = Math.max(p.top, f.top)
	                  , p = Math.min(p.bottom, f.bottom) - r;
	                n = .4 >= (0 < n ? p / n : 0)
	            } else
	                n = !1;
	        !b || f && !n || (g.token = d.token);
	        if (n)
	            return !0;
	        k = (d = k) && b ? {
	            left: Math.min(d.left, b.left),
	            right: Math.max(d.right, b.right),
	            top: Math.min(d.top, b.top),
	            bottom: Math.min(d.bottom, b.bottom)
	        } : d || b;
	        return !1
	    }
	}
	;
	gui.ParagraphBoundaryScanner = function() {
	    var g = this, k = !1, d, b = odf.OdfUtils;
	    this.token = void 0;
	    this.process = function(f) {
	        var n = b.getParagraphElement(f.container());
	        k || (d = n,
	        k = !0);
	        if (d !== n)
	            return !0;
	        g.token = f.token;
	        return !1
	    }
	}
	;
	odf.WordBoundaryFilter = function(g, k) {
	    function d(a, b, c) {
	        for (var d = null, e = g.getRootNode(), f; a !== e && null !== a && null === d; )
	            f = 0 > b ? a.previousSibling : a.nextSibling,
	            c(f) === NodeFilter.FILTER_ACCEPT && (d = f),
	            a = a.parentNode;
	        return d
	    }
	    function b(a, b) {
	        var c;
	        return null === a ? m.NO_NEIGHBOUR : p.isCharacterElement(a) ? m.SPACE_CHAR : a.nodeType === f || p.isTextSpan(a) || p.isHyperlink(a) ? (c = a.textContent.charAt(b()),
	        q.test(c) ? m.SPACE_CHAR : r.test(c) ? m.PUNCTUATION_CHAR : m.WORD_CHAR) : m.OTHER
	    }
	    var f = Node.TEXT_NODE
	      , n = Node.ELEMENT_NODE
	      , p = odf.OdfUtils
	      , r = /[!-#%-*,-\/:-;?-@\[-\]_{}\u00a1\u00ab\u00b7\u00bb\u00bf;\u00b7\u055a-\u055f\u0589-\u058a\u05be\u05c0\u05c3\u05c6\u05f3-\u05f4\u0609-\u060a\u060c-\u060d\u061b\u061e-\u061f\u066a-\u066d\u06d4\u0700-\u070d\u07f7-\u07f9\u0964-\u0965\u0970\u0df4\u0e4f\u0e5a-\u0e5b\u0f04-\u0f12\u0f3a-\u0f3d\u0f85\u0fd0-\u0fd4\u104a-\u104f\u10fb\u1361-\u1368\u166d-\u166e\u169b-\u169c\u16eb-\u16ed\u1735-\u1736\u17d4-\u17d6\u17d8-\u17da\u1800-\u180a\u1944-\u1945\u19de-\u19df\u1a1e-\u1a1f\u1b5a-\u1b60\u1c3b-\u1c3f\u1c7e-\u1c7f\u2000-\u206e\u207d-\u207e\u208d-\u208e\u3008-\u3009\u2768-\u2775\u27c5-\u27c6\u27e6-\u27ef\u2983-\u2998\u29d8-\u29db\u29fc-\u29fd\u2cf9-\u2cfc\u2cfe-\u2cff\u2e00-\u2e7e\u3000-\u303f\u30a0\u30fb\ua60d-\ua60f\ua673\ua67e\ua874-\ua877\ua8ce-\ua8cf\ua92e-\ua92f\ua95f\uaa5c-\uaa5f\ufd3e-\ufd3f\ufe10-\ufe19\ufe30-\ufe52\ufe54-\ufe61\ufe63\ufe68\ufe6a-\ufe6b\uff01-\uff03\uff05-\uff0a\uff0c-\uff0f\uff1a-\uff1b\uff1f-\uff20\uff3b-\uff3d\uff3f\uff5b\uff5d\uff5f-\uff65]|\ud800[\udd00-\udd01\udf9f\udfd0]|\ud802[\udd1f\udd3f\ude50-\ude58]|\ud809[\udc00-\udc7e]/
	      , q = /\s/
	      , e = core.PositionFilter.FilterResult.FILTER_ACCEPT
	      , l = core.PositionFilter.FilterResult.FILTER_REJECT
	      , a = odf.WordBoundaryFilter.IncludeWhitespace.TRAILING
	      , c = odf.WordBoundaryFilter.IncludeWhitespace.LEADING
	      , m = {
	        NO_NEIGHBOUR: 0,
	        SPACE_CHAR: 1,
	        PUNCTUATION_CHAR: 2,
	        WORD_CHAR: 3,
	        OTHER: 4
	    };
	    this.acceptPosition = function(f) {
	        var g = f.container()
	          , p = f.leftNode()
	          , r = f.rightNode()
	          , q = f.unfilteredDomOffset
	          , v = function() {
	            return f.unfilteredDomOffset() - 1
	        };
	        g.nodeType === n && (null === r && (r = d(g, 1, f.getNodeFilter())),
	        null === p && (p = d(g, -1, f.getNodeFilter())));
	        g !== r && (q = function() {
	            return 0
	        }
	        );
	        g !== p && null !== p && (v = function() {
	            return p.textContent.length - 1
	        }
	        );
	        g = b(p, v);
	        r = b(r, q);
	        return g === m.WORD_CHAR && r === m.WORD_CHAR || g === m.PUNCTUATION_CHAR && r === m.PUNCTUATION_CHAR || k === a && g !== m.NO_NEIGHBOUR && r === m.SPACE_CHAR || k === c && g === m.SPACE_CHAR && r !== m.NO_NEIGHBOUR ? l : e
	    }
	}
	;
	odf.WordBoundaryFilter.IncludeWhitespace = {
	    None: 0,
	    TRAILING: 1,
	    LEADING: 2
	};
	gui.SelectionController = function(g, k) {
	    function d(a) {
	        var b = a.spec();
	        if (a.isEdit || b.memberid === k)
	            I = void 0,
	            K.cancel()
	    }
	    function b() {
	        var a = x.getCursor(k).getNode();
	        return x.createStepIterator(a, 0, [v, t], x.getRootElement(a))
	    }
	    function f(a, b, c) {
	        c = new odf.WordBoundaryFilter(x,c);
	        var d = x.getRootElement(a) || x.getRootNode()
	          , e = x.createRootFilter(d);
	        return x.createStepIterator(a, b, [v, e, c], d)
	    }
	    function n(a, b) {
	        return b ? {
	            anchorNode: a.startContainer,
	            anchorOffset: a.startOffset,
	            focusNode: a.endContainer,
	            focusOffset: a.endOffset
	        } : {
	            anchorNode: a.endContainer,
	            anchorOffset: a.endOffset,
	            focusNode: a.startContainer,
	            focusOffset: a.startOffset
	        }
	    }
	    function p(a, b, c) {
	        var d = new ops.OpMoveCursor;
	        d.init({
	            memberid: k,
	            position: a,
	            length: b || 0,
	            selectionType: c
	        });
	        return d
	    }
	    function r(a, b, c) {
	        var d;
	        d = x.getCursor(k);
	        d = n(d.getSelectedRange(), d.hasForwardSelection());
	        d.focusNode = a;
	        d.focusOffset = b;
	        c || (d.anchorNode = d.focusNode,
	        d.anchorOffset = d.focusOffset);
	        a = x.convertDomToCursorRange(d);
	        g.enqueue([p(a.position, a.length)])
	    }
	    function q(a) {
	        var b;
	        b = f(a.startContainer, a.startOffset, L);
	        b.roundToPreviousStep() && a.setStart(b.container(), b.offset());
	        b = f(a.endContainer, a.endOffset, E);
	        b.roundToNextStep() && a.setEnd(b.container(), b.offset())
	    }
	    function e(a) {
	        var b = w.getParagraphElements(a)
	          , c = b[0]
	          , b = b[b.length - 1];
	        c && a.setStart(c, 0);
	        b && (w.isParagraph(a.endContainer) && 0 === a.endOffset ? a.setEndBefore(b) : a.setEnd(b, b.childNodes.length))
	    }
	    function l(a, b, c, d) {
	        var e, f;
	        d ? (e = c.startContainer,
	        f = c.startOffset) : (e = c.endContainer,
	        f = c.endOffset);
	        z.containsNode(a, e) || (f = 0 > z.comparePoints(a, 0, e, f) ? 0 : a.childNodes.length,
	        e = a);
	        a = x.createStepIterator(e, f, b, w.getParagraphElement(e) || a);
	        a.roundToClosestStep() || runtime.assert(!1, "No step found in requested range");
	        d ? c.setStart(a.container(), a.offset()) : c.setEnd(a.container(), a.offset())
	    }
	    function a(a, c) {
	        var d = b();
	        d.advanceStep(a) && r(d.container(), d.offset(), c)
	    }
	    function c(a, c) {
	        var d, e = I, f = [new gui.LineBoundaryScanner, new gui.ParagraphBoundaryScanner];
	        void 0 === e && A && (e = A());
	        isNaN(e) || (d = b(),
	        u.moveToFilteredStep(d, a, f) && d.advanceStep(a) && (f = [new gui.ClosestXOffsetScanner(e), new gui.LineBoundaryScanner, new gui.ParagraphBoundaryScanner],
	        u.moveToFilteredStep(d, a, f) && (r(d.container(), d.offset(), c),
	        I = e,
	        K.restart())))
	    }
	    function m(a, c) {
	        var d = b()
	          , e = [new gui.LineBoundaryScanner, new gui.ParagraphBoundaryScanner];
	        u.moveToFilteredStep(d, a, e) && r(d.container(), d.offset(), c)
	    }
	    function h(a, b) {
	        var c = x.getCursor(k)
	          , c = n(c.getSelectedRange(), c.hasForwardSelection())
	          , c = f(c.focusNode, c.focusOffset, L);
	        c.advanceStep(a) && r(c.container(), c.offset(), b)
	    }
	    function y(a, b, c) {
	        var d = !1
	          , e = x.getCursor(k)
	          , e = n(e.getSelectedRange(), e.hasForwardSelection())
	          , d = x.getRootElement(e.focusNode);
	        runtime.assert(Boolean(d), "SelectionController: Cursor outside root");
	        e = x.createStepIterator(e.focusNode, e.focusOffset, [v, t], d);
	        e.roundToClosestStep();
	        e.advanceStep(a) && (c = c(e.container())) && (a === N ? (e.setPosition(c, 0),
	        d = e.roundToNextStep()) : (e.setPosition(c, c.childNodes.length),
	        d = e.roundToPreviousStep()),
	        d && r(e.container(), e.offset(), b))
	    }
	    var x = g.getOdtDocument(), z = core.DomUtils, w = odf.OdfUtils, v = x.getPositionFilter(), u = new gui.GuiStepUtils, t = x.createRootFilter(k), A = null, I, K, L = odf.WordBoundaryFilter.IncludeWhitespace.TRAILING, E = odf.WordBoundaryFilter.IncludeWhitespace.LEADING, N = core.StepDirection.PREVIOUS, O = core.StepDirection.NEXT;
	    this.selectionToRange = function(a) {
	        var b = 0 <= z.comparePoints(a.anchorNode, a.anchorOffset, a.focusNode, a.focusOffset)
	          , c = a.focusNode.ownerDocument.createRange();
	        b ? (c.setStart(a.anchorNode, a.anchorOffset),
	        c.setEnd(a.focusNode, a.focusOffset)) : (c.setStart(a.focusNode, a.focusOffset),
	        c.setEnd(a.anchorNode, a.anchorOffset));
	        return {
	            range: c,
	            hasForwardSelection: b
	        }
	    }
	    ;
	    this.rangeToSelection = n;
	    this.selectImage = function(a) {
	        var c = x.getRootElement(a), b = x.createRootFilter(c), c = x.createStepIterator(a, 0, [b, x.getPositionFilter()], c), d;
	        c.roundToPreviousStep() || runtime.assert(!1, "No walkable position before frame");
	        b = c.container();
	        d = c.offset();
	        c.setPosition(a, a.childNodes.length);
	        c.roundToNextStep() || runtime.assert(!1, "No walkable position after frame");
	        a = x.convertDomToCursorRange({
	            anchorNode: b,
	            anchorOffset: d,
	            focusNode: c.container(),
	            focusOffset: c.offset()
	        });
	        a = p(a.position, a.length, ops.OdtCursor.RegionSelection);
	        g.enqueue([a])
	    }
	    ;
	    this.expandToWordBoundaries = q;
	    this.expandToParagraphBoundaries = e;
	    this.selectRange = function(a, c, b) {
	        var d = x.getOdfCanvas().getElement(), f, h = [v];
	        f = z.containsNode(d, a.startContainer);
	        d = z.containsNode(d, a.endContainer);
	        if (f || d)
	            if (f && d && (2 === b ? q(a) : 3 <= b && e(a)),
	            (b = c ? x.getRootElement(a.startContainer) : x.getRootElement(a.endContainer)) || (b = x.getRootNode()),
	            h.push(x.createRootFilter(b)),
	            l(b, h, a, !0),
	            l(b, h, a, !1),
	            a = n(a, c),
	            c = x.convertDomToCursorRange(a),
	            a = x.getCursorSelection(k),
	            c.position !== a.position || c.length !== a.length)
	                a = p(c.position, c.length, ops.OdtCursor.RangeSelection),
	                g.enqueue([a])
	    }
	    ;
	    this.moveCursorToLeft = function() {
	        a(N, !1);
	        return !0
	    }
	    ;
	    this.moveCursorToRight = function() {
	        a(O, !1);
	        return !0
	    }
	    ;
	    this.extendSelectionToLeft = function() {
	        a(N, !0);
	        return !0
	    }
	    ;
	    this.extendSelectionToRight = function() {
	        a(O, !0);
	        return !0
	    }
	    ;
	    this.setCaretXPositionLocator = function(a) {
	        A = a
	    }
	    ;
	    this.moveCursorUp = function() {
	        c(N, !1);
	        return !0
	    }
	    ;
	    this.moveCursorDown = function() {
	        c(O, !1);
	        return !0
	    }
	    ;
	    this.extendSelectionUp = function() {
	        c(N, !0);
	        return !0
	    }
	    ;
	    this.extendSelectionDown = function() {
	        c(O, !0);
	        return !0
	    }
	    ;
	    this.moveCursorBeforeWord = function() {
	        h(N, !1);
	        return !0
	    }
	    ;
	    this.moveCursorPastWord = function() {
	        h(O, !1);
	        return !0
	    }
	    ;
	    this.extendSelectionBeforeWord = function() {
	        h(N, !0);
	        return !0
	    }
	    ;
	    this.extendSelectionPastWord = function() {
	        h(O, !0);
	        return !0
	    }
	    ;
	    this.moveCursorToLineStart = function() {
	        m(N, !1);
	        return !0
	    }
	    ;
	    this.moveCursorToLineEnd = function() {
	        m(O, !1);
	        return !0
	    }
	    ;
	    this.extendSelectionToLineStart = function() {
	        m(N, !0);
	        return !0
	    }
	    ;
	    this.extendSelectionToLineEnd = function() {
	        m(O, !0);
	        return !0
	    }
	    ;
	    this.extendSelectionToParagraphStart = function() {
	        y(N, !0, w.getParagraphElement);
	        return !0
	    }
	    ;
	    this.extendSelectionToParagraphEnd = function() {
	        y(O, !0, w.getParagraphElement);
	        return !0
	    }
	    ;
	    this.moveCursorToParagraphStart = function() {
	        y(N, !1, w.getParagraphElement);
	        return !0
	    }
	    ;
	    this.moveCursorToParagraphEnd = function() {
	        y(O, !1, w.getParagraphElement);
	        return !0
	    }
	    ;
	    this.moveCursorToDocumentStart = function() {
	        y(N, !1, x.getRootElement);
	        return !0
	    }
	    ;
	    this.moveCursorToDocumentEnd = function() {
	        y(O, !1, x.getRootElement);
	        return !0
	    }
	    ;
	    this.extendSelectionToDocumentStart = function() {
	        y(N, !0, x.getRootElement);
	        return !0
	    }
	    ;
	    this.extendSelectionToDocumentEnd = function() {
	        y(O, !0, x.getRootElement);
	        return !0
	    }
	    ;
	    this.extendSelectionToEntireDocument = function() {
	        var a = x.getCursor(k), a = x.getRootElement(a.getNode()), c, b, d;
	        runtime.assert(Boolean(a), "SelectionController: Cursor outside root");
	        d = x.createStepIterator(a, 0, [v, t], a);
	        d.roundToClosestStep();
	        c = d.container();
	        b = d.offset();
	        d.setPosition(a, a.childNodes.length);
	        d.roundToClosestStep();
	        a = x.convertDomToCursorRange({
	            anchorNode: c,
	            anchorOffset: b,
	            focusNode: d.container(),
	            focusOffset: d.offset()
	        });
	        g.enqueue([p(a.position, a.length)]);
	        return !0
	    }
	    ;
	    this.destroy = function(a) {
	        x.unsubscribe(ops.OdtDocument.signalOperationStart, d);
	        core.Async.destroyAll([K.destroy], a)
	    }
	    ;
	    (function() {
	        K = core.Task.createTimeoutTask(function() {
	            I = void 0
	        }, 2E3);
	        x.subscribe(ops.OdtDocument.signalOperationStart, d)
	    }
	    )()
	}
	;
	gui.TextController = function(g, k, d, b, f, n) {
	    function p() {
	        y = !0 === k.getState(gui.CommonConstraints.EDIT.REVIEW_MODE) ? d.isLocalCursorWithinOwnAnnotation() : !0
	    }
	    function r(a) {
	        a.getMemberId() === b && p()
	    }
	    function q(a, b, d) {
	        var e = [c.getPositionFilter()];
	        d && e.push(c.createRootFilter(a.startContainer));
	        d = c.createStepIterator(a.startContainer, a.startOffset, e, b);
	        d.roundToClosestStep() || runtime.assert(!1, "No walkable step found in paragraph element at range start");
	        b = c.convertDomPointToCursorStep(d.container(), d.offset());
	        a.collapsed ? a = b : (d.setPosition(a.endContainer, a.endOffset),
	        d.roundToClosestStep() || runtime.assert(!1, "No walkable step found in paragraph element at range end"),
	        a = c.convertDomPointToCursorStep(d.container(), d.offset()));
	        return {
	            position: b,
	            length: a - b
	        }
	    }
	    function e(a) {
	        var c, d, e, f = m.getParagraphElements(a), g = a.cloneRange(), l = [];
	        c = f[0];
	        1 < f.length && (m.hasNoODFContent(c) && (c = f[f.length - 1]),
	        d = c.getAttributeNS(odf.Namespaces.textns, "style-name") || "");
	        f.forEach(function(c, f) {
	            var m, k;
	            g.setStart(c, 0);
	            g.collapse(!0);
	            m = q(g, c, !1).position;
	            0 < f && (k = new ops.OpMergeParagraph,
	            k.init({
	                memberid: b,
	                paragraphStyleName: d,
	                destinationStartPosition: e,
	                sourceStartPosition: m,
	                moveCursor: 1 === f
	            }),
	            l.unshift(k));
	            e = m;
	            g.selectNodeContents(c);
	            if (m = h.rangeIntersection(g, a))
	                m = q(m, c, !0),
	                0 < m.length && (k = new ops.OpRemoveText,
	                k.init({
	                    memberid: b,
	                    position: m.position,
	                    length: m.length
	                }),
	                l.unshift(k))
	        });
	        return l
	    }
	    function l(a) {
	        0 > a.length && (a.position += a.length,
	        a.length = -a.length);
	        return a
	    }
	    function a(a) {
	        if (!y)
	            return !1;
	        var d, f = c.getCursor(b).getSelectedRange().cloneRange(), h = l(c.getCursorSelection(b)), m;
	        if (0 === h.length) {
	            h = void 0;
	            d = c.getCursor(b).getNode();
	            m = c.getRootElement(d);
	            var k = [c.getPositionFilter(), c.createRootFilter(m)];
	            m = c.createStepIterator(d, 0, k, m);
	            m.roundToClosestStep() && (a ? m.nextStep() : m.previousStep()) && (h = l(c.convertDomToCursorRange({
	                anchorNode: d,
	                anchorOffset: 0,
	                focusNode: m.container(),
	                focusOffset: m.offset()
	            })),
	            a ? (f.setStart(d, 0),
	            f.setEnd(m.container(), m.offset())) : (f.setStart(m.container(), m.offset()),
	            f.setEnd(d, 0)))
	        }
	        h && g.enqueue(e(f));
	        return void 0 !== h
	    }
	    var c = g.getOdtDocument()
	      , m = odf.OdfUtils
	      , h = core.DomUtils
	      , y = !1
	      , x = odf.Namespaces.textns
	      , z = core.StepDirection.NEXT;
	    this.isEnabled = function() {
	        return y
	    }
	    ;
	    this.enqueueParagraphSplittingOps = function() {
	        if (!y)
	            return !1;
	        var a = c.getCursor(b)
	          , d = a.getSelectedRange()
	          , f = l(c.getCursorSelection(b))
	          , h = []
	          , a = m.getParagraphElement(a.getNode())
	          , k = a.getAttributeNS(x, "style-name") || "";
	        0 < f.length && (h = h.concat(e(d)));
	        d = new ops.OpSplitParagraph;
	        d.init({
	            memberid: b,
	            position: f.position,
	            paragraphStyleName: k,
	            sourceParagraphPosition: c.convertDomPointToCursorStep(a, 0, z),
	            moveCursor: !0
	        });
	        h.push(d);
	        n && (f = n(f.position + 1),
	        h = h.concat(f));
	        g.enqueue(h);
	        return !0
	    }
	    ;
	    this.removeTextByBackspaceKey = function() {
	        return a(!1)
	    }
	    ;
	    this.removeTextByDeleteKey = function() {
	        return a(!0)
	    }
	    ;
	    this.removeCurrentSelection = function() {
	        if (!y)
	            return !1;
	        var a = c.getCursor(b).getSelectedRange();
	        g.enqueue(e(a));
	        return !0
	    }
	    ;
	    this.insertText = function(a) {
	        if (y) {
	            var d = c.getCursor(b).getSelectedRange()
	              , h = l(c.getCursorSelection(b))
	              , m = []
	              , k = !1;
	            0 < h.length && (m = m.concat(e(d)),
	            k = !0);
	            d = new ops.OpInsertText;
	            d.init({
	                memberid: b,
	                position: h.position,
	                text: a,
	                moveCursor: !0
	            });
	            m.push(d);
	            f && (a = f(h.position, a.length, k)) && m.push(a);
	            g.enqueue(m)
	        }
	    }
	    ;
	    this.destroy = function(a) {
	        c.unsubscribe(ops.Document.signalCursorMoved, r);
	        k.unsubscribe(gui.CommonConstraints.EDIT.REVIEW_MODE, p);
	        a()
	    }
	    ;
	    c.subscribe(ops.Document.signalCursorMoved, r);
	    k.subscribe(gui.CommonConstraints.EDIT.REVIEW_MODE, p);
	    p()
	}
	;
	gui.UndoManager = function() {}
	;
	gui.UndoManager.prototype.subscribe = function(g, k) {}
	;
	gui.UndoManager.prototype.unsubscribe = function(g, k) {}
	;
	gui.UndoManager.prototype.setDocument = function(g) {}
	;
	gui.UndoManager.prototype.setInitialState = function() {}
	;
	gui.UndoManager.prototype.initialize = function() {}
	;
	gui.UndoManager.prototype.purgeInitialState = function() {}
	;
	gui.UndoManager.prototype.setPlaybackFunction = function(g) {}
	;
	gui.UndoManager.prototype.hasUndoStates = function() {}
	;
	gui.UndoManager.prototype.hasRedoStates = function() {}
	;
	gui.UndoManager.prototype.moveForward = function(g) {}
	;
	gui.UndoManager.prototype.moveBackward = function(g) {}
	;
	gui.UndoManager.prototype.onOperationExecuted = function(g) {}
	;
	gui.UndoManager.prototype.isDocumentModified = function() {}
	;
	gui.UndoManager.prototype.setDocumentModified = function(g) {}
	;
	gui.UndoManager.signalUndoStackChanged = "undoStackChanged";
	gui.UndoManager.signalUndoStateCreated = "undoStateCreated";
	gui.UndoManager.signalUndoStateModified = "undoStateModified";
	gui.UndoManager.signalDocumentModifiedChanged = "documentModifiedChanged";
	gui.SessionControllerOptions = function() {
	    this.annotationsEnabled = this.directParagraphStylingEnabled = this.directTextStylingEnabled = !1
	}
	;
	(function() {
	    var g = core.PositionFilter.FilterResult.FILTER_ACCEPT;
	    gui.SessionController = function(k, d, b, f) {
	        function n(a, c) {
	            var b = J.getDOMDocument()
	              , d = null;
	            b.caretRangeFromPoint ? (b = b.caretRangeFromPoint(a, c),
	            d = {
	                container: b.startContainer,
	                offset: b.startOffset
	            }) : b.caretPositionFromPoint && (b = b.caretPositionFromPoint(a, c)) && b.offsetNode && (d = {
	                container: b.offsetNode,
	                offset: b.offset
	            });
	            return d
	        }
	        function p(a) {
	            var c = J.getCursor(d).getSelectedRange();
	            c.collapsed ? a.preventDefault() : ha.setDataFromRange(a, c) ? da.removeCurrentSelection() : runtime.log("Cut operation failed")
	        }
	        function r() {
	            return !1 !== J.getCursor(d).getSelectedRange().collapsed
	        }
	        function q(a) {
	            var c = J.getCursor(d).getSelectedRange();
	            c.collapsed ? a.preventDefault() : ha.setDataFromRange(a, c) || runtime.log("Copy operation failed")
	        }
	        function e(a) {
	            var c;
	            W.clipboardData && W.clipboardData.getData ? c = W.clipboardData.getData("Text") : a.clipboardData && a.clipboardData.getData && (c = a.clipboardData.getData("text/plain"));
	            c && (da.removeCurrentSelection(),
	            ea.paste(c));
	            a.preventDefault ? a.preventDefault() : a.returnValue = !1
	        }
	        function l() {
	            return !1
	        }
	        function a(a) {
	            if (Q)
	                Q.onOperationExecuted(a)
	        }
	        function c(a) {
	            J.emit(ops.OdtDocument.signalUndoStackChanged, a)
	        }
	        function m() {
	            var a;
	            return Q ? (a = F.hasFocus(),
	            Q.moveBackward(1),
	            a && F.focus(),
	            !0) : !1
	        }
	        function h() {
	            var a;
	            return Q ? (a = F.hasFocus(),
	            Q.moveForward(1),
	            a && F.focus(),
	            !0) : !1
	        }
	        function y(a) {
	            var c = J.getCursor(d).getSelectedRange()
	              , e = (a.target || a.srcElement || null).getAttribute("end");
	            c && e && (a = n(a.clientX, a.clientY)) && (ia.setUnfilteredPosition(a.container, a.offset),
	            Y.acceptPosition(ia) === g && (c = c.cloneRange(),
	            "left" === e ? c.setStart(ia.container(), ia.unfilteredDomOffset()) : c.setEnd(ia.container(), ia.unfilteredDomOffset()),
	            b.setSelectedRange(c, "right" === e),
	            J.emit(ops.Document.signalCursorMoved, b)))
	        }
	        function x() {
	            T.selectRange(b.getSelectedRange(), b.hasForwardSelection(), 1)
	        }
	        function z() {
	            var a = W.getSelection()
	              , c = 0 < a.rangeCount && T.selectionToRange(a);
	            U && c && (B = !0,
	            la.clearSelection(),
	            ia.setUnfilteredPosition(a.focusNode, a.focusOffset),
	            Y.acceptPosition(ia) === g && (2 === oa ? T.expandToWordBoundaries(c.range) : 3 <= oa && T.expandToParagraphBoundaries(c.range),
	            b.setSelectedRange(c.range, c.hasForwardSelection),
	            J.emit(ops.Document.signalCursorMoved, b)))
	        }
	        function w(a) {
	            var c = a.target || a.srcElement || null
	              , b = J.getCursor(d);
	            if (U = null !== c && aa.containsNode(J.getOdfCanvas().getElement(), c))
	                B = !1,
	                c = J.getRootElement(c) || J.getRootNode(),
	                Y = J.createRootFilter(c),
	                oa = 0 === a.button ? a.detail : 0,
	                b && a.shiftKey ? W.getSelection().collapse(b.getAnchorNode(), 0) : (a = W.getSelection(),
	                c = b.getSelectedRange(),
	                a.extend ? b.hasForwardSelection() ? (a.collapse(c.startContainer, c.startOffset),
	                a.extend(c.endContainer, c.endOffset)) : (a.collapse(c.endContainer, c.endOffset),
	                a.extend(c.startContainer, c.startOffset)) : (a.removeAllRanges(),
	                a.addRange(c.cloneRange()))),
	                1 < oa && z()
	        }
	        function v(a) {
	            var c = J.getRootElement(a)
	              , b = J.createRootFilter(c)
	              , c = J.createStepIterator(a, 0, [b, J.getPositionFilter()], c);
	            c.setPosition(a, a.childNodes.length);
	            return c.roundToNextStep() ? {
	                container: c.container(),
	                offset: c.offset()
	            } : null
	        }
	        function u(a) {
	            var c;
	            c = (c = W.getSelection()) ? {
	                anchorNode: c.anchorNode,
	                anchorOffset: c.anchorOffset,
	                focusNode: c.focusNode,
	                focusOffset: c.focusOffset
	            } : null;
	            var b = W.getSelection().isCollapsed, d, e;
	            c.anchorNode || c.focusNode || !(d = n(a.clientX, a.clientY)) || (c.anchorNode = d.container,
	            c.anchorOffset = d.offset,
	            c.focusNode = c.anchorNode,
	            c.focusOffset = c.anchorOffset);
	            if (S.isImage(c.focusNode) && 0 === c.focusOffset && S.isCharacterFrame(c.focusNode.parentNode)) {
	                if (e = c.focusNode.parentNode,
	                d = e.getBoundingClientRect(),
	                a.clientX > d.left && (d = v(e)))
	                    c.focusNode = d.container,
	                    c.focusOffset = d.offset,
	                    b && (c.anchorNode = c.focusNode,
	                    c.anchorOffset = c.focusOffset)
	            } else
	                S.isImage(c.focusNode.firstChild) && 1 === c.focusOffset && S.isCharacterFrame(c.focusNode) && (d = v(c.focusNode)) && (c.anchorNode = c.focusNode = d.container,
	                c.anchorOffset = c.focusOffset = d.offset);
	            c.anchorNode && c.focusNode && (c = T.selectionToRange(c),
	            T.selectRange(c.range, c.hasForwardSelection, 0 === a.button ? a.detail : 0));
	            F.focus()
	        }
	        function t(a) {
	            var c;
	            if (c = n(a.clientX, a.clientY))
	                a = c.container,
	                c = c.offset,
	                a = {
	                    anchorNode: a,
	                    anchorOffset: c,
	                    focusNode: a,
	                    focusOffset: c
	                },
	                a = T.selectionToRange(a),
	                T.selectRange(a.range, a.hasForwardSelection, 2),
	                F.focus()
	        }
	        function A(a) {
	            var c = a.target || a.srcElement || null, d, e, f;
	            ma.processRequests();
	            U && (S.isImage(c) && S.isCharacterFrame(c.parentNode) && W.getSelection().isCollapsed ? (T.selectImage(c.parentNode),
	            F.focus()) : la.isSelectorElement(c) ? F.focus() : B ? (c = b.getSelectedRange(),
	            e = c.collapsed,
	            S.isImage(c.endContainer) && 0 === c.endOffset && S.isCharacterFrame(c.endContainer.parentNode) && (f = c.endContainer.parentNode,
	            f = v(f)) && (c.setEnd(f.container, f.offset),
	            e && c.collapse(!1)),
	            T.selectRange(c, b.hasForwardSelection(), 0 === a.button ? a.detail : 0),
	            F.focus()) : ua ? u(a) : (d = aa.cloneEvent(a),
	            M = runtime.setTimeout(function() {
	                u(d)
	            }, 0)),
	            oa = 0,
	            B = U = !1)
	        }
	        function I(a) {
	            var c = J.getCursor(d).getSelectedRange();
	            c.collapsed || fa.exportRangeToDataTransfer(a.dataTransfer, c)
	        }
	        function K() {
	            U && F.focus();
	            oa = 0;
	            B = U = !1
	        }
	        function L(a) {
	            A(a)
	        }
	        function E(a) {
	            var c = a.target || a.srcElement || null
	              , b = null;
	            "annotationRemoveButton" === c.className ? (runtime.assert(ja, "Remove buttons are displayed on annotations while annotation editing is disabled in the controller."),
	            b = c.parentNode.getElementsByTagNameNS(odf.Namespaces.officens, "annotation").item(0),
	            ca.removeAnnotation(b),
	            F.focus()) : "webodf-draggable" !== c.getAttribute("class") && A(a)
	        }
	        function N(a) {
	            (a = a.data) && (-1 === a.indexOf("\n") ? da.insertText(a) : ea.paste(a))
	        }
	        function O(a) {
	            return function() {
	                a();
	                return !0
	            }
	        }
	        function D(a) {
	            return function(c) {
	                return J.getCursor(d).getSelectionType() === ops.OdtCursor.RangeSelection ? a(c) : !0
	            }
	        }
	        function V(c) {
	            F.unsubscribe("keydown", C.handleEvent);
	            F.unsubscribe("keypress", Z.handleEvent);
	            F.unsubscribe("keyup", ba.handleEvent);
	            F.unsubscribe("copy", q);
	            F.unsubscribe("mousedown", w);
	            F.unsubscribe("mousemove", ma.trigger);
	            F.unsubscribe("mouseup", E);
	            F.unsubscribe("contextmenu", L);
	            F.unsubscribe("dragstart", I);
	            F.unsubscribe("dragend", K);
	            F.unsubscribe("click", pa.handleClick);
	            F.unsubscribe("longpress", t);
	            F.unsubscribe("drag", y);
	            F.unsubscribe("dragstop", x);
	            J.unsubscribe(ops.OdtDocument.signalOperationEnd, na.trigger);
	            J.unsubscribe(ops.Document.signalCursorAdded, ka.registerCursor);
	            J.unsubscribe(ops.Document.signalCursorRemoved, ka.removeCursor);
	            J.unsubscribe(ops.OdtDocument.signalOperationEnd, a);
	            c()
	        }
	        var W = runtime.getWindow(), J = k.getOdtDocument(), R = new gui.SessionConstraints, P = new gui.SessionContext(k,d), aa = core.DomUtils, S = odf.OdfUtils, fa = new gui.MimeDataExporter, ha = new gui.Clipboard(fa), C = new gui.KeyboardHandler, Z = new gui.KeyboardHandler, ba = new gui.KeyboardHandler, U = !1, ga = new odf.ObjectNameGenerator(J.getOdfCanvas().odfContainer(),d), B = !1, Y = null, M, Q = null, F = new gui.EventManager(J), ja = f.annotationsEnabled, ca = new gui.AnnotationController(k,R,d), X = new gui.DirectFormattingController(k,R,P,d,ga,f.directTextStylingEnabled,f.directParagraphStylingEnabled), da = new gui.TextController(k,R,P,d,X.createCursorStyleOp,X.createParagraphStyleOps), qa = new gui.ImageController(k,R,P,d,ga), la = new gui.ImageSelector(J.getOdfCanvas()), ia = J.createPositionIterator(J.getRootNode()), ma, na, ea = new gui.PasteController(k,R,P,d), ka = new gui.InputMethodEditor(d,F), oa = 0, pa = new gui.HyperlinkClickHandler(J.getOdfCanvas().getElement,C,ba), ta = new gui.HyperlinkController(k,R,P,d), T = new gui.SelectionController(k,d), va = new gui.MetadataController(k,d), G = gui.KeyboardHandler.Modifier, H = gui.KeyboardHandler.KeyCode, ra = -1 !== W.navigator.appVersion.toLowerCase().indexOf("mac"), ua = -1 !== ["iPad", "iPod", "iPhone"].indexOf(W.navigator.platform), sa;
	        runtime.assert(null !== W, "Expected to be run in an environment which has a global window, like a browser.");
	        this.undo = m;
	        this.redo = h;
	        this.insertLocalCursor = function() {
	            runtime.assert(void 0 === k.getOdtDocument().getCursor(d), "Inserting local cursor a second time.");
	            var a = new ops.OpAddCursor;
	            a.init({
	                memberid: d
	            });
	            k.enqueue([a]);
	            F.focus()
	        }
	        ;
	        this.removeLocalCursor = function() {
	            runtime.assert(void 0 !== k.getOdtDocument().getCursor(d), "Removing local cursor without inserting before.");
	            var a = new ops.OpRemoveCursor;
	            a.init({
	                memberid: d
	            });
	            k.enqueue([a])
	        }
	        ;
	        this.startEditing = function() {
	            ka.subscribe(gui.InputMethodEditor.signalCompositionStart, da.removeCurrentSelection);
	            ka.subscribe(gui.InputMethodEditor.signalCompositionEnd, N);
	            F.subscribe("beforecut", r);
	            F.subscribe("cut", p);
	            F.subscribe("beforepaste", l);
	            F.subscribe("paste", e);
	            Q && Q.initialize();
	            F.setEditing(!0);
	            pa.setModifier(ra ? G.Meta : G.Ctrl);
	            C.bind(H.Backspace, G.None, O(da.removeTextByBackspaceKey), !0);
	            C.bind(H.Delete, G.None, da.removeTextByDeleteKey);
	            C.bind(H.Tab, G.None, D(function() {
	                da.insertText("\t");
	                return !0
	            }));
	            ra ? (C.bind(H.Clear, G.None, da.removeCurrentSelection),
	            C.bind(H.B, G.Meta, D(X.toggleBold)),
	            C.bind(H.I, G.Meta, D(X.toggleItalic)),
	            C.bind(H.U, G.Meta, D(X.toggleUnderline)),
	            C.bind(H.L, G.MetaShift, D(X.alignParagraphLeft)),
	            C.bind(H.E, G.MetaShift, D(X.alignParagraphCenter)),
	            C.bind(H.R, G.MetaShift, D(X.alignParagraphRight)),
	            C.bind(H.J, G.MetaShift, D(X.alignParagraphJustified)),
	            ja && C.bind(H.C, G.MetaShift, ca.addAnnotation),
	            C.bind(H.Z, G.Meta, m),
	            C.bind(H.Z, G.MetaShift, h)) : (C.bind(H.B, G.Ctrl, D(X.toggleBold)),
	            C.bind(H.I, G.Ctrl, D(X.toggleItalic)),
	            C.bind(H.U, G.Ctrl, D(X.toggleUnderline)),
	            C.bind(H.L, G.CtrlShift, D(X.alignParagraphLeft)),
	            C.bind(H.E, G.CtrlShift, D(X.alignParagraphCenter)),
	            C.bind(H.R, G.CtrlShift, D(X.alignParagraphRight)),
	            C.bind(H.J, G.CtrlShift, D(X.alignParagraphJustified)),
	            ja && C.bind(H.C, G.CtrlAlt, ca.addAnnotation),
	            C.bind(H.Z, G.Ctrl, m),
	            C.bind(H.Z, G.CtrlShift, h));
	            Z.setDefault(D(function(a) {
	                var c;
	                c = null === a.which || void 0 === a.which ? String.fromCharCode(a.keyCode) : 0 !== a.which && 0 !== a.charCode ? String.fromCharCode(a.which) : null;
	                return !c || a.altKey || a.ctrlKey || a.metaKey ? !1 : (da.insertText(c),
	                !0)
	            }));
	            Z.bind(H.Enter, G.None, D(da.enqueueParagraphSplittingOps))
	        }
	        ;
	        this.endEditing = function() {
	            ka.unsubscribe(gui.InputMethodEditor.signalCompositionStart, da.removeCurrentSelection);
	            ka.unsubscribe(gui.InputMethodEditor.signalCompositionEnd, N);
	            F.unsubscribe("cut", p);
	            F.unsubscribe("beforecut", r);
	            F.unsubscribe("paste", e);
	            F.unsubscribe("beforepaste", l);
	            F.setEditing(!1);
	            pa.setModifier(G.None);
	            C.bind(H.Backspace, G.None, function() {
	                return !0
	            }, !0);
	            C.unbind(H.Delete, G.None);
	            C.unbind(H.Tab, G.None);
	            ra ? (C.unbind(H.Clear, G.None),
	            C.unbind(H.B, G.Meta),
	            C.unbind(H.I, G.Meta),
	            C.unbind(H.U, G.Meta),
	            C.unbind(H.L, G.MetaShift),
	            C.unbind(H.E, G.MetaShift),
	            C.unbind(H.R, G.MetaShift),
	            C.unbind(H.J, G.MetaShift),
	            ja && C.unbind(H.C, G.MetaShift),
	            C.unbind(H.Z, G.Meta),
	            C.unbind(H.Z, G.MetaShift)) : (C.unbind(H.B, G.Ctrl),
	            C.unbind(H.I, G.Ctrl),
	            C.unbind(H.U, G.Ctrl),
	            C.unbind(H.L, G.CtrlShift),
	            C.unbind(H.E, G.CtrlShift),
	            C.unbind(H.R, G.CtrlShift),
	            C.unbind(H.J, G.CtrlShift),
	            ja && C.unbind(H.C, G.CtrlAlt),
	            C.unbind(H.Z, G.Ctrl),
	            C.unbind(H.Z, G.CtrlShift));
	            Z.setDefault(null);
	            Z.unbind(H.Enter, G.None)
	        }
	        ;
	        this.getInputMemberId = function() {
	            return d
	        }
	        ;
	        this.getSession = function() {
	            return k
	        }
	        ;
	        this.getSessionConstraints = function() {
	            return R
	        }
	        ;
	        this.setUndoManager = function(a) {
	            Q && Q.unsubscribe(gui.UndoManager.signalUndoStackChanged, c);
	            if (Q = a)
	                Q.setDocument(J),
	                Q.setPlaybackFunction(k.enqueue),
	                Q.subscribe(gui.UndoManager.signalUndoStackChanged, c)
	        }
	        ;
	        this.getUndoManager = function() {
	            return Q
	        }
	        ;
	        this.getMetadataController = function() {
	            return va
	        }
	        ;
	        this.getAnnotationController = function() {
	            return ca
	        }
	        ;
	        this.getDirectFormattingController = function() {
	            return X
	        }
	        ;
	        this.getHyperlinkClickHandler = function() {
	            return pa
	        }
	        ;
	        this.getHyperlinkController = function() {
	            return ta
	        }
	        ;
	        this.getImageController = function() {
	            return qa
	        }
	        ;
	        this.getSelectionController = function() {
	            return T
	        }
	        ;
	        this.getTextController = function() {
	            return da
	        }
	        ;
	        this.getEventManager = function() {
	            return F
	        }
	        ;
	        this.getKeyboardHandlers = function() {
	            return {
	                keydown: C,
	                keypress: Z
	            }
	        }
	        ;
	        this.destroy = function(a) {
	            var c = [ma.destroy, na.destroy, X.destroy, ka.destroy, F.destroy, pa.destroy, ta.destroy, va.destroy, T.destroy, da.destroy, V];
	            sa && c.unshift(sa.destroy);
	            runtime.clearTimeout(M);
	            core.Async.destroyAll(c, a)
	        }
	        ;
	        ma = core.Task.createRedrawTask(z);
	        na = core.Task.createRedrawTask(function() {
	            var a = J.getCursor(d);
	            if (a && a.getSelectionType() === ops.OdtCursor.RegionSelection && (a = S.getImageElements(a.getSelectedRange())[0])) {
	                la.select(a.parentNode);
	                return
	            }
	            la.clearSelection()
	        });
	        C.bind(H.Left, G.None, D(T.moveCursorToLeft));
	        C.bind(H.Right, G.None, D(T.moveCursorToRight));
	        C.bind(H.Up, G.None, D(T.moveCursorUp));
	        C.bind(H.Down, G.None, D(T.moveCursorDown));
	        C.bind(H.Left, G.Shift, D(T.extendSelectionToLeft));
	        C.bind(H.Right, G.Shift, D(T.extendSelectionToRight));
	        C.bind(H.Up, G.Shift, D(T.extendSelectionUp));
	        C.bind(H.Down, G.Shift, D(T.extendSelectionDown));
	        C.bind(H.Home, G.None, D(T.moveCursorToLineStart));
	        C.bind(H.End, G.None, D(T.moveCursorToLineEnd));
	        C.bind(H.Home, G.Ctrl, D(T.moveCursorToDocumentStart));
	        C.bind(H.End, G.Ctrl, D(T.moveCursorToDocumentEnd));
	        C.bind(H.Home, G.Shift, D(T.extendSelectionToLineStart));
	        C.bind(H.End, G.Shift, D(T.extendSelectionToLineEnd));
	        C.bind(H.Up, G.CtrlShift, D(T.extendSelectionToParagraphStart));
	        C.bind(H.Down, G.CtrlShift, D(T.extendSelectionToParagraphEnd));
	        C.bind(H.Home, G.CtrlShift, D(T.extendSelectionToDocumentStart));
	        C.bind(H.End, G.CtrlShift, D(T.extendSelectionToDocumentEnd));
	        ra ? (C.bind(H.Left, G.Alt, D(T.moveCursorBeforeWord)),
	        C.bind(H.Right, G.Alt, D(T.moveCursorPastWord)),
	        C.bind(H.Left, G.Meta, D(T.moveCursorToLineStart)),
	        C.bind(H.Right, G.Meta, D(T.moveCursorToLineEnd)),
	        C.bind(H.Home, G.Meta, D(T.moveCursorToDocumentStart)),
	        C.bind(H.End, G.Meta, D(T.moveCursorToDocumentEnd)),
	        C.bind(H.Left, G.AltShift, D(T.extendSelectionBeforeWord)),
	        C.bind(H.Right, G.AltShift, D(T.extendSelectionPastWord)),
	        C.bind(H.Left, G.MetaShift, D(T.extendSelectionToLineStart)),
	        C.bind(H.Right, G.MetaShift, D(T.extendSelectionToLineEnd)),
	        C.bind(H.Up, G.AltShift, D(T.extendSelectionToParagraphStart)),
	        C.bind(H.Down, G.AltShift, D(T.extendSelectionToParagraphEnd)),
	        C.bind(H.Up, G.MetaShift, D(T.extendSelectionToDocumentStart)),
	        C.bind(H.Down, G.MetaShift, D(T.extendSelectionToDocumentEnd)),
	        C.bind(H.A, G.Meta, D(T.extendSelectionToEntireDocument))) : (C.bind(H.Left, G.Ctrl, D(T.moveCursorBeforeWord)),
	        C.bind(H.Right, G.Ctrl, D(T.moveCursorPastWord)),
	        C.bind(H.Left, G.CtrlShift, D(T.extendSelectionBeforeWord)),
	        C.bind(H.Right, G.CtrlShift, D(T.extendSelectionPastWord)),
	        C.bind(H.A, G.Ctrl, D(T.extendSelectionToEntireDocument)));
	        ua && (sa = new gui.IOSSafariSupport(F));
	        F.subscribe("keydown", C.handleEvent);
	        F.subscribe("keypress", Z.handleEvent);
	        F.subscribe("keyup", ba.handleEvent);
	        F.subscribe("copy", q);
	        F.subscribe("mousedown", w);
	        F.subscribe("mousemove", ma.trigger);
	        F.subscribe("mouseup", E);
	        F.subscribe("contextmenu", L);
	        F.subscribe("dragstart", I);
	        F.subscribe("dragend", K);
	        F.subscribe("click", pa.handleClick);
	        F.subscribe("longpress", t);
	        F.subscribe("drag", y);
	        F.subscribe("dragstop", x);
	        J.subscribe(ops.OdtDocument.signalOperationEnd, na.trigger);
	        J.subscribe(ops.Document.signalCursorAdded, ka.registerCursor);
	        J.subscribe(ops.Document.signalCursorRemoved, ka.removeCursor);
	        J.subscribe(ops.OdtDocument.signalOperationEnd, a)
	    }
	}
	)();
	gui.CaretManager = function(g, k) {
	    function d(b) {
	        return n.hasOwnProperty(b) ? n[b] : null
	    }
	    function b() {
	        return Object.keys(n).map(function(b) {
	            return n[b]
	        })
	    }
	    function f(b) {
	        var d = n[b];
	        d && (delete n[b],
	        b === g.getInputMemberId() ? (r.unsubscribe(ops.OdtDocument.signalProcessingBatchEnd, d.ensureVisible),
	        r.unsubscribe(ops.Document.signalCursorMoved, d.refreshCursorBlinking),
	        q.unsubscribe("compositionupdate", d.handleUpdate),
	        q.unsubscribe("compositionend", d.handleUpdate),
	        q.unsubscribe("focus", d.setFocus),
	        q.unsubscribe("blur", d.removeFocus),
	        p.removeEventListener("focus", d.show, !1),
	        p.removeEventListener("blur", d.hide, !1)) : r.unsubscribe(ops.OdtDocument.signalProcessingBatchEnd, d.handleUpdate),
	        d.destroy(function() {}))
	    }
	    var n = {}
	      , p = runtime.getWindow()
	      , r = g.getSession().getOdtDocument()
	      , q = g.getEventManager();
	    this.registerCursor = function(b, d, a) {
	        var c = b.getMemberId();
	        b = new gui.Caret(b,k,d,a);
	        n[c] = b;
	        c === g.getInputMemberId() ? (runtime.log("Starting to track input on new cursor of " + c),
	        r.subscribe(ops.OdtDocument.signalProcessingBatchEnd, b.ensureVisible),
	        r.subscribe(ops.Document.signalCursorMoved, b.refreshCursorBlinking),
	        q.subscribe("compositionupdate", b.handleUpdate),
	        q.subscribe("compositionend", b.handleUpdate),
	        q.subscribe("focus", b.setFocus),
	        q.subscribe("blur", b.removeFocus),
	        p.addEventListener("focus", b.show, !1),
	        p.addEventListener("blur", b.hide, !1),
	        b.setOverlayElement(q.getEventTrap())) : r.subscribe(ops.OdtDocument.signalProcessingBatchEnd, b.handleUpdate);
	        return b
	    }
	    ;
	    this.getCaret = d;
	    this.getCarets = b;
	    this.destroy = function(d) {
	        var l = b().map(function(a) {
	            return a.destroy
	        });
	        g.getSelectionController().setCaretXPositionLocator(null);
	        r.unsubscribe(ops.Document.signalCursorRemoved, f);
	        n = {};
	        core.Async.destroyAll(l, d)
	    }
	    ;
	    g.getSelectionController().setCaretXPositionLocator(function() {
	        var b = d(g.getInputMemberId()), f;
	        b && (f = b.getBoundingClientRect());
	        return f ? f.right : void 0
	    });
	    r.subscribe(ops.Document.signalCursorRemoved, f)
	}
	;
	gui.EditInfoHandle = function(g) {
	    var k = [], d, b = g.ownerDocument, f = b.documentElement.namespaceURI;
	    this.setEdits = function(g) {
	        k = g;
	        var p, r, q, e;
	        core.DomUtils.removeAllChildNodes(d);
	        for (g = 0; g < k.length; g += 1)
	            p = b.createElementNS(f, "div"),
	            p.className = "editInfo",
	            r = b.createElementNS(f, "span"),
	            r.className = "editInfoColor",
	            r.setAttributeNS("urn:webodf:names:editinfo", "editinfo:memberid", k[g].memberid),
	            q = b.createElementNS(f, "span"),
	            q.className = "editInfoAuthor",
	            q.setAttributeNS("urn:webodf:names:editinfo", "editinfo:memberid", k[g].memberid),
	            e = b.createElementNS(f, "span"),
	            e.className = "editInfoTime",
	            e.setAttributeNS("urn:webodf:names:editinfo", "editinfo:memberid", k[g].memberid),
	            e.appendChild(b.createTextNode(k[g].time.toString())),
	            p.appendChild(r),
	            p.appendChild(q),
	            p.appendChild(e),
	            d.appendChild(p)
	    }
	    ;
	    this.show = function() {
	        d.style.display = "block"
	    }
	    ;
	    this.hide = function() {
	        d.style.display = "none"
	    }
	    ;
	    this.destroy = function(b) {
	        g.removeChild(d);
	        b()
	    }
	    ;
	    d = b.createElementNS(f, "div");
	    d.setAttribute("class", "editInfoHandle");
	    d.style.display = "none";
	    g.appendChild(d)
	}
	;
	ops.EditInfo = function(g, k) {
	    function d() {
	        var b = [], d;
	        for (d in f)
	            f.hasOwnProperty(d) && b.push({
	                memberid: d,
	                time: f[d].time
	            });
	        b.sort(function(b, d) {
	            return b.time - d.time
	        });
	        return b
	    }
	    var b, f = {};
	    this.getNode = function() {
	        return b
	    }
	    ;
	    this.getOdtDocument = function() {
	        return k
	    }
	    ;
	    this.getEdits = function() {
	        return f
	    }
	    ;
	    this.getSortedEdits = function() {
	        return d()
	    }
	    ;
	    this.addEdit = function(b, d) {
	        f[b] = {
	            time: d
	        }
	    }
	    ;
	    this.clearEdits = function() {
	        f = {}
	    }
	    ;
	    this.destroy = function(d) {
	        g.parentNode && g.removeChild(b);
	        d()
	    }
	    ;
	    b = k.getDOMDocument().createElementNS("urn:webodf:names:editinfo", "editinfo");
	    g.insertBefore(b, g.firstChild)
	}
	;
	gui.EditInfoMarker = function(g, k) {
	    function d(b, a) {
	        return runtime.setTimeout(function() {
	            p.style.opacity = b
	        }, a)
	    }
	    var b = this, f, n, p, r, q, e;
	    this.addEdit = function(b, a) {
	        var c = Date.now() - a;
	        g.addEdit(b, a);
	        n.setEdits(g.getSortedEdits());
	        p.setAttributeNS("urn:webodf:names:editinfo", "editinfo:memberid", b);
	        runtime.clearTimeout(q);
	        runtime.clearTimeout(e);
	        1E4 > c ? (r = d(1, 0),
	        q = d(.5, 1E4 - c),
	        e = d(.2, 2E4 - c)) : 1E4 <= c && 2E4 > c ? (r = d(.5, 0),
	        e = d(.2, 2E4 - c)) : r = d(.2, 0)
	    }
	    ;
	    this.getEdits = function() {
	        return g.getEdits()
	    }
	    ;
	    this.clearEdits = function() {
	        g.clearEdits();
	        n.setEdits([]);
	        p.hasAttributeNS("urn:webodf:names:editinfo", "editinfo:memberid") && p.removeAttributeNS("urn:webodf:names:editinfo", "editinfo:memberid")
	    }
	    ;
	    this.getEditInfo = function() {
	        return g
	    }
	    ;
	    this.show = function() {
	        p.style.display = "block"
	    }
	    ;
	    this.hide = function() {
	        b.hideHandle();
	        p.style.display = "none"
	    }
	    ;
	    this.showHandle = function() {
	        n.show()
	    }
	    ;
	    this.hideHandle = function() {
	        n.hide()
	    }
	    ;
	    this.destroy = function(b) {
	        runtime.clearTimeout(r);
	        runtime.clearTimeout(q);
	        runtime.clearTimeout(e);
	        f.removeChild(p);
	        n.destroy(function(a) {
	            a ? b(a) : g.destroy(b)
	        })
	    }
	    ;
	    (function() {
	        var d = g.getOdtDocument().getDOMDocument();
	        p = d.createElementNS(d.documentElement.namespaceURI, "div");
	        p.setAttribute("class", "editInfoMarker");
	        p.onmouseover = function() {
	            b.showHandle()
	        }
	        ;
	        p.onmouseout = function() {
	            b.hideHandle()
	        }
	        ;
	        f = g.getNode();
	        f.appendChild(p);
	        n = new gui.EditInfoHandle(f);
	        k || b.hide()
	    }
	    )()
	}
	;
	gui.HyperlinkTooltipView = function(g, k) {
	    var d = core.DomUtils, b = odf.OdfUtils, f = runtime.getWindow(), n, p, r;
	    runtime.assert(null !== f, "Expected to be run in an environment which has a global window, like a browser.");
	    this.showTooltip = function(q) {
	        var e = q.target || q.srcElement, l = g.getSizer(), a = g.getZoomLevel(), c;
	        a: {
	            for (; e; ) {
	                if (b.isHyperlink(e))
	                    break a;
	                if (b.isParagraph(e) || b.isInlineRoot(e))
	                    break;
	                e = e.parentNode
	            }
	            e = null
	        }
	        if (e) {
	            d.containsNode(l, r) || l.appendChild(r);
	            c = p;
	            var m;
	            switch (k()) {
	            case gui.KeyboardHandler.Modifier.Ctrl:
	                m = runtime.tr("Ctrl-click to follow link");
	                break;
	            case gui.KeyboardHandler.Modifier.Meta:
	                m = runtime.tr("\u2318-click to follow link");
	                break;
	            default:
	                m = ""
	            }
	            c.textContent = m;
	            n.textContent = b.getHyperlinkTarget(e);
	            r.style.display = "block";
	            c = f.innerWidth - r.offsetWidth - 15;
	            e = q.clientX > c ? c : q.clientX + 15;
	            c = f.innerHeight - r.offsetHeight - 10;
	            q = q.clientY > c ? c : q.clientY + 10;
	            l = l.getBoundingClientRect();
	            e = (e - l.left) / a;
	            q = (q - l.top) / a;
	            r.style.left = e + "px";
	            r.style.top = q + "px"
	        }
	    }
	    ;
	    this.hideTooltip = function() {
	        r.style.display = "none"
	    }
	    ;
	    this.destroy = function(b) {
	        r.parentNode && r.parentNode.removeChild(r);
	        b()
	    }
	    ;
	    (function() {
	        var b = g.getElement().ownerDocument;
	        n = b.createElement("span");
	        p = b.createElement("span");
	        n.className = "webodf-hyperlinkTooltipLink";
	        p.className = "webodf-hyperlinkTooltipText";
	        r = b.createElement("div");
	        r.className = "webodf-hyperlinkTooltip";
	        r.appendChild(n);
	        r.appendChild(p);
	        g.getElement().appendChild(r)
	    }
	    )()
	}
	;
	gui.OdfFieldView = function(g) {
	    function k() {
	        var b = odf.OdfSchema.getFields().map(function(b) {
	            return b.replace(":", "|")
	        })
	          , d = b.join(",\n") + "\n{ background-color: #D0D0D0; }\n"
	          , b = b.map(function(b) {
	            return b + ":empty::after"
	        }).join(",\n") + "\n{ content:' '; white-space: pre; }\n";
	        return d + "\n" + b
	    }
	    var d, b = g.getElement().ownerDocument;
	    this.showFieldHighlight = function() {
	        d.appendChild(b.createTextNode(k()))
	    }
	    ;
	    this.hideFieldHighlight = function() {
	        for (var b = d.sheet, g = b.cssRules; g.length; )
	            b.deleteRule(g.length - 1)
	    }
	    ;
	    this.destroy = function(b) {
	        d.parentNode && d.parentNode.removeChild(d);
	        b()
	    }
	    ;
	    d = function() {
	        var d = b.getElementsByTagName("head").item(0)
	          , g = b.createElement("style")
	          , k = "";
	        g.type = "text/css";
	        g.media = "screen, print, handheld, projection";
	        odf.Namespaces.forEachPrefix(function(b, d) {
	            k += "@namespace " + b + " url(" + d + ");\n"
	        });
	        g.appendChild(b.createTextNode(k));
	        d.appendChild(g);
	        return g
	    }()
	}
	;
	gui.ShadowCursor = function(g) {
	    var k = g.getDOMDocument().createRange()
	      , d = !0;
	    this.removeFromDocument = function() {}
	    ;
	    this.getMemberId = function() {
	        return gui.ShadowCursor.ShadowCursorMemberId
	    }
	    ;
	    this.getSelectedRange = function() {
	        return k
	    }
	    ;
	    this.setSelectedRange = function(b, f) {
	        k = b;
	        d = !1 !== f
	    }
	    ;
	    this.hasForwardSelection = function() {
	        return d
	    }
	    ;
	    this.getDocument = function() {
	        return g
	    }
	    ;
	    this.getSelectionType = function() {
	        return ops.OdtCursor.RangeSelection
	    }
	    ;
	    k.setStart(g.getRootNode(), 0)
	}
	;
	gui.ShadowCursor.ShadowCursorMemberId = "";
	gui.SelectionView = function(g) {}
	;
	gui.SelectionView.prototype.rerender = function() {}
	;
	gui.SelectionView.prototype.show = function() {}
	;
	gui.SelectionView.prototype.hide = function() {}
	;
	gui.SelectionView.prototype.destroy = function(g) {}
	;
	gui.SelectionViewManager = function(g) {
	    function k() {
	        return Object.keys(d).map(function(b) {
	            return d[b]
	        })
	    }
	    var d = {};
	    this.getSelectionView = function(b) {
	        return d.hasOwnProperty(b) ? d[b] : null
	    }
	    ;
	    this.getSelectionViews = k;
	    this.removeSelectionView = function(b) {
	        d.hasOwnProperty(b) && (d[b].destroy(function() {}),
	        delete d[b])
	    }
	    ;
	    this.hideSelectionView = function(b) {
	        d.hasOwnProperty(b) && d[b].hide()
	    }
	    ;
	    this.showSelectionView = function(b) {
	        d.hasOwnProperty(b) && d[b].show()
	    }
	    ;
	    this.rerenderSelectionViews = function() {
	        Object.keys(d).forEach(function(b) {
	            d[b].rerender()
	        })
	    }
	    ;
	    this.registerCursor = function(b, f) {
	        var k = b.getMemberId()
	          , p = new g(b);
	        f ? p.show() : p.hide();
	        return d[k] = p
	    }
	    ;
	    this.destroy = function(b) {
	        function d(k, r) {
	            r ? b(r) : k < g.length ? g[k].destroy(function(b) {
	                d(k + 1, b)
	            }) : b()
	        }
	        var g = k();
	        d(0, void 0)
	    }
	}
	;
	gui.SessionViewOptions = function() {
	    this.caretBlinksOnRangeSelect = this.caretAvatarsInitiallyVisible = this.editInfoMarkersInitiallyVisible = !0
	}
	;
	(function() {
	    function g(g, d) {
	        return void 0 !== g ? Boolean(g) : d
	    }
	    gui.SessionView = function(k, d, b, f, n, p) {
	        function r(a) {
	            a.memberId === d && I.getViewport().scrollIntoView(a.annotation.getBoundingClientRect())
	        }
	        function q() {
	            var a = document.getElementsByTagName("head").item(0)
	              , c = document.createElement("style");
	            c.type = "text/css";
	            c.media = "screen, print, handheld, projection";
	            a.appendChild(c);
	            return c
	        }
	        function e(a, c, b) {
	            function e(c, b, d) {
	                b = c + '[editinfo|memberid="' + a + '"]' + d + b;
	                a: {
	                    var f = v.firstChild;
	                    for (c = c + '[editinfo|memberid="' + a + '"]' + d + "{"; f; ) {
	                        if (f.nodeType === Node.TEXT_NODE && 0 === f.data.indexOf(c)) {
	                            c = f;
	                            break a
	                        }
	                        f = f.nextSibling
	                    }
	                    c = null
	                }
	                c ? c.data = b : v.appendChild(document.createTextNode(b))
	            }
	            e("div.editInfoMarker", "{ background-color: " + b + "; }", "");
	            e("span.editInfoColor", "{ background-color: " + b + "; }", "");
	            e("span.editInfoAuthor", '{ content: "' + c + '"; }', ":before");
	            e("dc|creator", "{ background-color: " + b + "; }", "");
	            e(".webodf-selectionOverlay", "{ fill: " + b + "; stroke: " + b + ";}", "");
	            a === d && (e(".webodf-touchEnabled .webodf-selectionOverlay", "{ display: block; }", " > .webodf-draggable"),
	            a = gui.ShadowCursor.ShadowCursorMemberId,
	            e(".webodf-selectionOverlay", "{ fill: " + b + "; stroke: " + b + ";}", ""),
	            e(".webodf-touchEnabled .webodf-selectionOverlay", "{ display: block; }", " > .webodf-draggable"))
	        }
	        function l(a) {
	            var c, b;
	            for (b in t)
	                t.hasOwnProperty(b) && (c = t[b],
	                a ? c.show() : c.hide())
	        }
	        function a(a) {
	            n.getCarets().forEach(function(c) {
	                a ? c.showHandle() : c.hideHandle()
	            })
	        }
	        function c(a) {
	            var c = a.getMemberId();
	            a = a.getProperties();
	            e(c, a.fullName, a.color)
	        }
	        function m(a) {
	            var c = a.getMemberId()
	              , d = b.getOdtDocument().getMember(c).getProperties();
	            n.registerCursor(a, E, N);
	            p.registerCursor(a, !0);
	            if (a = n.getCaret(c))
	                a.setAvatarImageUrl(d.imageUrl),
	                a.setColor(d.color);
	            runtime.log("+++ View here +++ eagerly created an Caret for '" + c + "'! +++")
	        }
	        function h(a) {
	            a = a.getMemberId();
	            var c = p.getSelectionView(d)
	              , b = p.getSelectionView(gui.ShadowCursor.ShadowCursorMemberId)
	              , e = n.getCaret(d);
	            a === d ? (b.hide(),
	            c && c.show(),
	            e && e.show()) : a === gui.ShadowCursor.ShadowCursorMemberId && (b.show(),
	            c && c.hide(),
	            e && e.hide())
	        }
	        function y(a) {
	            p.removeSelectionView(a)
	        }
	        function x(a) {
	            var c = a.paragraphElement
	              , d = a.memberId;
	            a = a.timeStamp;
	            var e, f = "", h = c.getElementsByTagNameNS("urn:webodf:names:editinfo", "editinfo").item(0);
	            h ? (f = h.getAttributeNS("urn:webodf:names:editinfo", "id"),
	            e = t[f]) : (f = Math.random().toString(),
	            e = new ops.EditInfo(c,b.getOdtDocument()),
	            e = new gui.EditInfoMarker(e,L),
	            h = c.getElementsByTagNameNS("urn:webodf:names:editinfo", "editinfo").item(0),
	            h.setAttributeNS("urn:webodf:names:editinfo", "id", f),
	            t[f] = e);
	            e.addEdit(d, new Date(a));
	            K.trigger()
	        }
	        function z() {
	            var a;
	            u.hasChildNodes() && core.DomUtils.removeAllChildNodes(u);
	            !0 === f.getState(gui.CommonConstraints.EDIT.ANNOTATIONS.ONLY_DELETE_OWN) && (a = b.getOdtDocument().getMember(d)) && (a = a.getProperties().fullName,
	            u.appendChild(document.createTextNode(".annotationWrapper:not([creator = '" + a + "']) .annotationRemoveButton { display: none; }")))
	        }
	        function w(a) {
	            var b = Object.keys(t).map(function(a) {
	                return t[a]
	            });
	            A.unsubscribe(ops.Document.signalMemberAdded, c);
	            A.unsubscribe(ops.Document.signalMemberUpdated, c);
	            A.unsubscribe(ops.Document.signalCursorAdded, m);
	            A.unsubscribe(ops.Document.signalCursorRemoved, y);
	            A.unsubscribe(ops.OdtDocument.signalParagraphChanged, x);
	            A.unsubscribe(ops.Document.signalCursorMoved, h);
	            A.unsubscribe(ops.OdtDocument.signalParagraphChanged, p.rerenderSelectionViews);
	            A.unsubscribe(ops.OdtDocument.signalTableAdded, p.rerenderSelectionViews);
	            A.unsubscribe(ops.OdtDocument.signalParagraphStyleModified, p.rerenderSelectionViews);
	            f.unsubscribe(gui.CommonConstraints.EDIT.ANNOTATIONS.ONLY_DELETE_OWN, z);
	            A.unsubscribe(ops.Document.signalMemberAdded, z);
	            A.unsubscribe(ops.Document.signalMemberUpdated, z);
	            v.parentNode.removeChild(v);
	            u.parentNode.removeChild(u);
	            (function W(c, d) {
	                d ? a(d) : c < b.length ? b[c].destroy(function(a) {
	                    W(c + 1, a)
	                }) : a()
	            }
	            )(0, void 0)
	        }
	        var v, u, t = {}, A, I, K, L = g(k.editInfoMarkersInitiallyVisible, !0), E = g(k.caretAvatarsInitiallyVisible, !0), N = g(k.caretBlinksOnRangeSelect, !0);
	        this.showEditInfoMarkers = function() {
	            L || (L = !0,
	            l(L))
	        }
	        ;
	        this.hideEditInfoMarkers = function() {
	            L && (L = !1,
	            l(L))
	        }
	        ;
	        this.showCaretAvatars = function() {
	            E || (E = !0,
	            a(E))
	        }
	        ;
	        this.hideCaretAvatars = function() {
	            E && (E = !1,
	            a(E))
	        }
	        ;
	        this.getSession = function() {
	            return b
	        }
	        ;
	        this.getCaret = function(a) {
	            return n.getCaret(a)
	        }
	        ;
	        this.destroy = function(a) {
	            var c = [K.destroy, w];
	            A.unsubscribe(ops.OdtDocument.signalAnnotationAdded, r);
	            core.Async.destroyAll(c, a)
	        }
	        ;
	        A = b.getOdtDocument();
	        I = A.getOdfCanvas();
	        A.subscribe(ops.OdtDocument.signalAnnotationAdded, r);
	        A.subscribe(ops.Document.signalMemberAdded, c);
	        A.subscribe(ops.Document.signalMemberUpdated, c);
	        A.subscribe(ops.Document.signalCursorAdded, m);
	        A.subscribe(ops.Document.signalCursorRemoved, y);
	        A.subscribe(ops.OdtDocument.signalParagraphChanged, x);
	        A.subscribe(ops.Document.signalCursorMoved, h);
	        A.subscribe(ops.OdtDocument.signalParagraphChanged, p.rerenderSelectionViews);
	        A.subscribe(ops.OdtDocument.signalTableAdded, p.rerenderSelectionViews);
	        A.subscribe(ops.OdtDocument.signalParagraphStyleModified, p.rerenderSelectionViews);
	        f.subscribe(gui.CommonConstraints.EDIT.ANNOTATIONS.ONLY_DELETE_OWN, z);
	        A.subscribe(ops.Document.signalMemberAdded, z);
	        A.subscribe(ops.Document.signalMemberUpdated, z);
	        v = q();
	        v.appendChild(document.createTextNode("@namespace editinfo url(urn:webodf:names:editinfo);"));
	        v.appendChild(document.createTextNode("@namespace dc url(http://purl.org/dc/elements/1.1/);"));
	        u = q();
	        z();
	        K = core.Task.createRedrawTask(function() {
	            var a = I.getAnnotationViewManager();
	            a && (a.rehighlightAnnotations(),
	            A.fixCursorPositions())
	        })
	    }
	}
	)();
	gui.SvgSelectionView = function(g) {
	    function k() {
	        var a = c.getRootNode();
	        m !== a && (m = a,
	        h = c.getCanvas().getSizer(),
	        h.appendChild(x),
	        x.setAttribute("class", "webodf-selectionOverlay"),
	        w.setAttribute("class", "webodf-draggable"),
	        v.setAttribute("class", "webodf-draggable"),
	        w.setAttribute("end", "left"),
	        v.setAttribute("end", "right"),
	        w.setAttribute("r", 8),
	        v.setAttribute("r", 8),
	        x.appendChild(z),
	        x.appendChild(w),
	        x.appendChild(v))
	    }
	    function d(a) {
	        a = a.getBoundingClientRect();
	        return Boolean(a && 0 !== a.height)
	    }
	    function b(a) {
	        var c = u.getTextElements(a, !0, !1)
	          , b = a.cloneRange()
	          , e = a.cloneRange();
	        a = a.cloneRange();
	        if (!c.length)
	            return null;
	        var f;
	        a: {
	            f = 0;
	            var h = c[f]
	              , g = b.startContainer === h ? b.startOffset : 0
	              , m = g;
	            b.setStart(h, g);
	            for (b.setEnd(h, m); !d(b); ) {
	                if (h.nodeType === Node.ELEMENT_NODE && m < h.childNodes.length)
	                    m = h.childNodes.length;
	                else if (h.nodeType === Node.TEXT_NODE && m < h.length)
	                    m += 1;
	                else if (c[f])
	                    h = c[f],
	                    f += 1,
	                    g = m = 0;
	                else {
	                    f = !1;
	                    break a
	                }
	                b.setStart(h, g);
	                b.setEnd(h, m)
	            }
	            f = !0
	        }
	        if (!f)
	            return null;
	        a: {
	            f = c.length - 1;
	            h = c[f];
	            m = g = e.endContainer === h ? e.endOffset : h.nodeType === Node.TEXT_NODE ? h.length : h.childNodes.length;
	            e.setStart(h, g);
	            for (e.setEnd(h, m); !d(e); ) {
	                if (h.nodeType === Node.ELEMENT_NODE && 0 < g)
	                    g = 0;
	                else if (h.nodeType === Node.TEXT_NODE && 0 < g)
	                    --g;
	                else if (c[f])
	                    h = c[f],
	                    --f,
	                    g = m = h.length || h.childNodes.length;
	                else {
	                    c = !1;
	                    break a
	                }
	                e.setStart(h, g);
	                e.setEnd(h, m)
	            }
	            c = !0
	        }
	        if (!c)
	            return null;
	        a.setStart(b.startContainer, b.startOffset);
	        a.setEnd(e.endContainer, e.endOffset);
	        return {
	            firstRange: b,
	            lastRange: e,
	            fillerRange: a
	        }
	    }
	    function f(a, c) {
	        var b = {};
	        b.top = Math.min(a.top, c.top);
	        b.left = Math.min(a.left, c.left);
	        b.right = Math.max(a.right, c.right);
	        b.bottom = Math.max(a.bottom, c.bottom);
	        b.width = b.right - b.left;
	        b.height = b.bottom - b.top;
	        return b
	    }
	    function n(a, c) {
	        c && 0 < c.width && 0 < c.height && (a = a ? f(a, c) : c);
	        return a
	    }
	    function p(a) {
	        function b(a) {
	            K.setUnfilteredPosition(a, 0);
	            return v.acceptNode(a) === L && x.acceptPosition(K) === L ? L : E
	        }
	        function d(a) {
	            var c = null;
	            b(a) === L && (c = t.getBoundingClientRect(a));
	            return c
	        }
	        var e = a.commonAncestorContainer, f = a.startContainer, h = a.endContainer, g = a.startOffset, m = a.endOffset, k, l, p = null, r, q = y.createRange(), x, v = new odf.OdfNodeFilter, w;
	        if (f === e || h === e)
	            return q = a.cloneRange(),
	            p = q.getBoundingClientRect(),
	            q.detach(),
	            p;
	        for (a = f; a.parentNode !== e; )
	            a = a.parentNode;
	        for (l = h; l.parentNode !== e; )
	            l = l.parentNode;
	        x = c.createRootFilter(f);
	        for (e = a.nextSibling; e && e !== l; )
	            r = d(e),
	            p = n(p, r),
	            e = e.nextSibling;
	        if (u.isParagraph(a))
	            p = n(p, t.getBoundingClientRect(a));
	        else if (a.nodeType === Node.TEXT_NODE)
	            e = a,
	            q.setStart(e, g),
	            q.setEnd(e, e === l ? m : e.length),
	            r = q.getBoundingClientRect(),
	            p = n(p, r);
	        else
	            for (w = y.createTreeWalker(a, NodeFilter.SHOW_TEXT, b, !1),
	            e = w.currentNode = f; e && e !== h; )
	                q.setStart(e, g),
	                q.setEnd(e, e.length),
	                r = q.getBoundingClientRect(),
	                p = n(p, r),
	                k = e,
	                g = 0,
	                e = w.nextNode();
	        k || (k = f);
	        if (u.isParagraph(l))
	            p = n(p, t.getBoundingClientRect(l));
	        else if (l.nodeType === Node.TEXT_NODE)
	            e = l,
	            q.setStart(e, e === a ? g : 0),
	            q.setEnd(e, m),
	            r = q.getBoundingClientRect(),
	            p = n(p, r);
	        else
	            for (w = y.createTreeWalker(l, NodeFilter.SHOW_TEXT, b, !1),
	            e = w.currentNode = h; e && e !== k; )
	                if (q.setStart(e, 0),
	                q.setEnd(e, m),
	                r = q.getBoundingClientRect(),
	                p = n(p, r),
	                e = w.previousNode())
	                    m = e.length;
	        return p
	    }
	    function r(a, c) {
	        var b = a.getBoundingClientRect()
	          , d = {
	            width: 0
	        };
	        d.top = b.top;
	        d.bottom = b.bottom;
	        d.height = b.height;
	        d.left = d.right = c ? b.right : b.left;
	        return d
	    }
	    function q() {
	        var a = g.getSelectedRange(), c;
	        if (c = I && g.getSelectionType() === ops.OdtCursor.RangeSelection && !a.collapsed) {
	            k();
	            var d = t.getBoundingClientRect(h), e = A.getZoomLevel(), a = b(a), m, l, n, q, y, u;
	            if (a) {
	                c = a.firstRange;
	                m = a.lastRange;
	                l = a.fillerRange;
	                n = t.translateRect(r(c, !1), d, e);
	                y = t.translateRect(r(m, !0), d, e);
	                q = (q = p(l)) ? t.translateRect(q, d, e) : f(n, y);
	                u = q.left;
	                q = n.left + Math.max(0, q.width - (n.left - q.left));
	                d = Math.min(n.top, y.top);
	                e = y.top + y.height;
	                u = [{
	                    x: n.left,
	                    y: d + n.height
	                }, {
	                    x: n.left,
	                    y: d
	                }, {
	                    x: q,
	                    y: d
	                }, {
	                    x: q,
	                    y: e - y.height
	                }, {
	                    x: y.right,
	                    y: e - y.height
	                }, {
	                    x: y.right,
	                    y: e
	                }, {
	                    x: u,
	                    y: e
	                }, {
	                    x: u,
	                    y: d + n.height
	                }, {
	                    x: n.left,
	                    y: d + n.height
	                }];
	                q = "";
	                var E;
	                for (E = 0; E < u.length; E += 1)
	                    q += u[E].x + "," + u[E].y + " ";
	                z.setAttribute("points", q);
	                w.setAttribute("cx", n.left);
	                w.setAttribute("cy", d + n.height / 2);
	                v.setAttribute("cx", y.right);
	                v.setAttribute("cy", e - y.height / 2);
	                c.detach();
	                m.detach();
	                l.detach()
	            }
	            c = Boolean(a)
	        }
	        x.style.display = c ? "block" : "none"
	    }
	    function e(a) {
	        I && a === g && N.trigger()
	    }
	    function l(a) {
	        a = 8 / a;
	        w.setAttribute("r", a);
	        v.setAttribute("r", a)
	    }
	    function a(a) {
	        h.removeChild(x);
	        h.classList.remove("webodf-virtualSelections");
	        g.getDocument().unsubscribe(ops.Document.signalCursorMoved, e);
	        A.unsubscribe(gui.ZoomHelper.signalZoomChanged, l);
	        a()
	    }
	    var c = g.getDocument(), m, h, y = c.getDOMDocument(), x = y.createElementNS("http://www.w3.org/2000/svg", "svg"), z = y.createElementNS("http://www.w3.org/2000/svg", "polygon"), w = y.createElementNS("http://www.w3.org/2000/svg", "circle"), v = y.createElementNS("http://www.w3.org/2000/svg", "circle"), u = odf.OdfUtils, t = core.DomUtils, A = c.getCanvas().getZoomHelper(), I = !0, K = g.getDocument().createPositionIterator(c.getRootNode()), L = NodeFilter.FILTER_ACCEPT, E = NodeFilter.FILTER_REJECT, N;
	    this.rerender = function() {
	        I && N.trigger()
	    }
	    ;
	    this.show = function() {
	        I = !0;
	        N.trigger()
	    }
	    ;
	    this.hide = function() {
	        I = !1;
	        N.trigger()
	    }
	    ;
	    this.destroy = function(c) {
	        core.Async.destroyAll([N.destroy, a], c)
	    }
	    ;
	    (function() {
	        var a = g.getMemberId();
	        N = core.Task.createRedrawTask(q);
	        k();
	        x.setAttributeNS("urn:webodf:names:editinfo", "editinfo:memberid", a);
	        h.classList.add("webodf-virtualSelections");
	        g.getDocument().subscribe(ops.Document.signalCursorMoved, e);
	        A.subscribe(gui.ZoomHelper.signalZoomChanged, l);
	        l(A.getZoomLevel())
	    }
	    )()
	}
	;
	gui.UndoStateRules = function() {
	    function g(b, d) {
	        var g = b.length;
	        this.previous = function() {
	            for (--g; 0 <= g; --g)
	                if (d(b[g]))
	                    return b[g];
	            return null
	        }
	    }
	    function k(b) {
	        b = b.spec();
	        var d;
	        b.hasOwnProperty("position") && (d = b.position);
	        return d
	    }
	    function d(b) {
	        return b.isEdit
	    }
	    function b(b, d, g) {
	        if (!g)
	            return g = k(b) - k(d),
	            0 === g || 1 === Math.abs(g);
	        b = k(b);
	        d = k(d);
	        g = k(g);
	        return b - d === d - g
	    }
	    this.isEditOperation = d;
	    this.isPartOfOperationSet = function(f, k) {
	        var p = void 0 !== f.group, r;
	        if (!f.isEdit || 0 === k.length)
	            return !0;
	        r = k[k.length - 1];
	        if (p && f.group === r.group)
	            return !0;
	        a: switch (f.spec().optype) {
	        case "RemoveText":
	        case "InsertText":
	            r = !0;
	            break a;
	        default:
	            r = !1
	        }
	        if (r && k.some(d)) {
	            if (p) {
	                var q;
	                p = f.spec().optype;
	                r = new g(k,d);
	                var e = r.previous(), l = null, a, c;
	                runtime.assert(Boolean(e), "No edit operations found in state");
	                c = e.group;
	                runtime.assert(void 0 !== c, "Operation has no group");
	                for (a = 1; e && e.group === c; ) {
	                    if (p === e.spec().optype) {
	                        q = e;
	                        break
	                    }
	                    e = r.previous()
	                }
	                if (q) {
	                    for (e = r.previous(); e; ) {
	                        if (e.group !== c) {
	                            if (2 === a)
	                                break;
	                            c = e.group;
	                            a += 1
	                        }
	                        if (p === e.spec().optype) {
	                            l = e;
	                            break
	                        }
	                        e = r.previous()
	                    }
	                    q = b(f, q, l)
	                } else
	                    q = !1;
	                return q
	            }
	            q = f.spec().optype;
	            p = new g(k,d);
	            r = p.previous();
	            runtime.assert(Boolean(r), "No edit operations found in state");
	            q = q === r.spec().optype ? b(f, r, p.previous()) : !1;
	            return q
	        }
	        return !1
	    }
	}
	;
	(function() {
	    function g(b, d) {
	        this.mainId = void 0 !== b ? b : -1;
	        this.subId = void 0 !== d ? d : -1
	    }
	    function k(b, f, k) {
	        function p(d, a) {
	            return d + (b.isEditOperation(a) ? 1 : 0)
	        }
	        var r, q, e;
	        this.addOperation = function(d) {
	            b.isEditOperation(d) && (e += 1);
	            q.push(d)
	        }
	        ;
	        this.isNextStateId = function(b) {
	            return b.mainId === r && b.subId === e
	        }
	        ;
	        this.getNextStateId = function() {
	            return new g(r,e)
	        }
	        ;
	        this.getOperations = function() {
	            return q
	        }
	        ;
	        r = d += 1;
	        q = f || [];
	        e = f && k ? f.reduce(p, 0) : 0
	    }
	    var d = 0;
	    gui.TrivialUndoManager = function(b) {
	        function d() {
	            return !0 !== u.isNextStateId(v)
	        }
	        function n(a) {
	            a = a.getOperations();
	            0 < a.length && (L = !0,
	            z(a),
	            L = !1)
	        }
	        function p() {
	            I.emit(gui.UndoManager.signalUndoStackChanged, {
	                undoAvailable: m.hasUndoStates(),
	                redoAvailable: m.hasRedoStates()
	            })
	        }
	        function r(a) {
	            var c = d();
	            a !== c && I.emit(gui.UndoManager.signalDocumentModifiedChanged, c)
	        }
	        function q() {
	            u !== x && u !== t[t.length - 1] && t.push(u)
	        }
	        function e(a) {
	            var c = a.previousSibling || a.nextSibling;
	            a.parentNode.removeChild(a);
	            h.normalizeTextNodes(c)
	        }
	        function l(a) {
	            return Object.keys(a).map(function(c) {
	                return a[c]
	            })
	        }
	        function a(a) {
	            function c(a) {
	                var h = a.spec();
	                if (e[h.memberid])
	                    switch (h.optype) {
	                    case "AddCursor":
	                        b[h.memberid] || (b[h.memberid] = a,
	                        delete e[h.memberid],
	                        --f);
	                        break;
	                    case "MoveCursor":
	                        d[h.memberid] || (d[h.memberid] = a)
	                    }
	            }
	            var b = {}, d = {}, e = {}, f, h;
	            h = a.pop();
	            w.getMemberIds().forEach(function(a) {
	                e[a] = !0
	            });
	            for (f = Object.keys(e).length; h && 0 < f; )
	                h = h.getOperations(),
	                h.reverse(),
	                h.forEach(c),
	                h = a.pop();
	            return new k(K,l(b).concat(l(d)))
	        }
	        function c() {
	            var c = d()
	              , b = y = w.cloneDocumentElement();
	            h.getElementsByTagNameNS(b, "urn:webodf:names:cursor", "cursor").forEach(e);
	            h.getElementsByTagNameNS(b, "urn:webodf:names:cursor", "anchor").forEach(e);
	            q();
	            u = x = a([x].concat(t));
	            t.length = 0;
	            A.length = 0;
	            c || (v = u.getNextStateId());
	            p();
	            r(c)
	        }
	        var m = this, h = core.DomUtils, y, x, z, w, v, u, t = [], A = [], I = new core.EventNotifier([gui.UndoManager.signalUndoStackChanged, gui.UndoManager.signalUndoStateCreated, gui.UndoManager.signalUndoStateModified, gui.UndoManager.signalDocumentModifiedChanged, gui.TrivialUndoManager.signalDocumentRootReplaced]), K = b || new gui.UndoStateRules, L = !1;
	        this.subscribe = function(a, c) {
	            I.subscribe(a, c)
	        }
	        ;
	        this.unsubscribe = function(a, c) {
	            I.unsubscribe(a, c)
	        }
	        ;
	        this.isDocumentModified = d;
	        this.setDocumentModified = function(a) {
	            d() !== a && (v = a ? new g : u.getNextStateId(),
	            I.emit(gui.UndoManager.signalDocumentModifiedChanged, a))
	        }
	        ;
	        this.hasUndoStates = function() {
	            return 0 < t.length
	        }
	        ;
	        this.hasRedoStates = function() {
	            return 0 < A.length
	        }
	        ;
	        this.setDocument = function(a) {
	            w = a
	        }
	        ;
	        this.purgeInitialState = function() {
	            var a = d();
	            t.length = 0;
	            A.length = 0;
	            u = x = new k(K);
	            v = u.getNextStateId();
	            y = null;
	            p();
	            r(a)
	        }
	        ;
	        this.setInitialState = c;
	        this.initialize = function() {
	            y || c()
	        }
	        ;
	        this.setPlaybackFunction = function(a) {
	            z = a
	        }
	        ;
	        this.onOperationExecuted = function(a) {
	            if (!L) {
	                var c = d();
	                K.isEditOperation(a) && (u === x || 0 < A.length) || !K.isPartOfOperationSet(a, u.getOperations()) ? (A.length = 0,
	                q(),
	                u = new k(K,[a],!0),
	                t.push(u),
	                I.emit(gui.UndoManager.signalUndoStateCreated, {
	                    operations: u.getOperations()
	                }),
	                p()) : (u.addOperation(a),
	                I.emit(gui.UndoManager.signalUndoStateModified, {
	                    operations: u.getOperations()
	                }));
	                r(c)
	            }
	        }
	        ;
	        this.moveForward = function(a) {
	            for (var c = 0, b = d(), e; a && A.length; )
	                e = A.pop(),
	                t.push(e),
	                n(e),
	                --a,
	                c += 1;
	            c && (u = t[t.length - 1],
	            p(),
	            r(b));
	            return c
	        }
	        ;
	        this.moveBackward = function(a) {
	            for (var c = 0, b = d(); a && t.length; )
	                A.push(t.pop()),
	                --a,
	                c += 1;
	            c && (w.getMemberIds().forEach(function(a) {
	                w.hasCursor(a) && w.removeCursor(a)
	            }),
	            w.setDocumentElement(y.cloneNode(!0)),
	            I.emit(gui.TrivialUndoManager.signalDocumentRootReplaced, {}),
	            n(x),
	            t.forEach(n),
	            u = t[t.length - 1] || x,
	            p(),
	            r(b));
	            return c
	        }
	        ;
	        u = x = new k(K);
	        v = u.getNextStateId()
	    }
	    ;
	    gui.TrivialUndoManager.signalDocumentRootReplaced = "documentRootReplaced"
	}
	)();
	odf.GraphicProperties = function(g, k, d) {
	    var b = this
	      , f = odf.Namespaces.stylens
	      , n = odf.Namespaces.svgns;
	    this.verticalPos = function() {
	        return b.data.value("verticalPos")
	    }
	    ;
	    this.verticalRel = function() {
	        return b.data.value("verticalRel")
	    }
	    ;
	    this.horizontalPos = function() {
	        return b.data.value("horizontalPos")
	    }
	    ;
	    this.horizontalRel = function() {
	        return b.data.value("horizontalRel")
	    }
	    ;
	    this.strokeWidth = function() {
	        return b.data.value("strokeWidth")
	    }
	    ;
	    b.data = new odf.LazyStyleProperties(void 0 === d ? void 0 : d.data,{
	        verticalPos: function() {
	            var b = g.getAttributeNS(f, "vertical-pos");
	            return "" === b ? void 0 : b
	        },
	        verticalRel: function() {
	            var b = g.getAttributeNS(f, "vertical-rel");
	            return "" === b ? void 0 : b
	        },
	        horizontalPos: function() {
	            var b = g.getAttributeNS(f, "horizontal-pos");
	            return "" === b ? void 0 : b
	        },
	        horizontalRel: function() {
	            var b = g.getAttributeNS(f, "horizontal-rel");
	            return "" === b ? void 0 : b
	        },
	        strokeWidth: function() {
	            var b = g.getAttributeNS(n, "stroke-width");
	            return k.parseLength(b)
	        }
	    })
	}
	;
	odf.ComputedGraphicProperties = function() {
	    var g;
	    this.setGraphicProperties = function(k) {
	        g = k
	    }
	    ;
	    this.verticalPos = function() {
	        return g && g.verticalPos() || "from-top"
	    }
	    ;
	    this.verticalRel = function() {
	        return g && g.verticalRel() || "page"
	    }
	    ;
	    this.horizontalPos = function() {
	        return g && g.horizontalPos() || "from-left"
	    }
	    ;
	    this.horizontalRel = function() {
	        return g && g.horizontalRel() || "page"
	    }
	}
	;
	odf.PageLayoutProperties = function(g, k, d) {
	    var b = this
	      , f = odf.Namespaces.fons;
	    this.pageHeight = function() {
	        return b.data.value("pageHeight") || 1123
	    }
	    ;
	    this.pageWidth = function() {
	        return b.data.value("pageWidth") || 794
	    }
	    ;
	    b.data = new odf.LazyStyleProperties(void 0 === d ? void 0 : d.data,{
	        pageHeight: function() {
	            var b;
	            g && (b = g.getAttributeNS(f, "page-height"),
	            b = k.parseLength(b));
	            return b
	        },
	        pageWidth: function() {
	            var b;
	            g && (b = g.getAttributeNS(f, "page-width"),
	            b = k.parseLength(b));
	            return b
	        }
	    })
	}
	;
	odf.PageLayout = function(g, k, d) {
	    var b = null;
	    g && (b = k.getPropertiesElement("page-layout-properties", g));
	    this.pageLayout = new odf.PageLayoutProperties(b,k,d && d.pageLayout)
	}
	;
	odf.PageLayoutCache = function() {}
	;
	odf.PageLayoutCache.prototype.getPageLayout = function(g) {}
	;
	odf.PageLayoutCache.prototype.getDefaultPageLayout = function() {}
	;
	odf.ParagraphProperties = function(g, k, d) {
	    var b = this
	      , f = odf.Namespaces.fons;
	    this.marginTop = function() {
	        return b.data.value("marginTop")
	    }
	    ;
	    b.data = new odf.LazyStyleProperties(void 0 === d ? void 0 : d.data,{
	        marginTop: function() {
	            var b = g.getAttributeNS(f, "margin-top");
	            return k.parsePositiveLengthOrPercent(b, "marginTop", d && d.data)
	        }
	    })
	}
	;
	odf.ComputedParagraphProperties = function() {
	    var g = {}
	      , k = [];
	    this.setStyleChain = function(d) {
	        k = d;
	        g = {}
	    }
	    ;
	    this.marginTop = function() {
	        var d, b;
	        if (g.hasOwnProperty("marginTop"))
	            d = g.marginTop;
	        else {
	            for (b = 0; void 0 === d && b < k.length; b += 1)
	                d = k[b].marginTop();
	            g.marginTop = d
	        }
	        return d || 0
	    }
	}
	;
	odf.TextProperties = function(g, k, d) {
	    var b = this
	      , f = odf.Namespaces.fons;
	    this.fontSize = function() {
	        return b.data.value("fontSize")
	    }
	    ;
	    b.data = new odf.LazyStyleProperties(void 0 === d ? void 0 : d.data,{
	        fontSize: function() {
	            var b = g.getAttributeNS(f, "font-size");
	            return k.parsePositiveLengthOrPercent(b, "fontSize", d && d.data)
	        }
	    })
	}
	;
	odf.ComputedTextProperties = function() {
	    var g = {}
	      , k = [];
	    this.setStyleChain = function(d) {
	        k = d;
	        g = {}
	    }
	    ;
	    this.fontSize = function() {
	        var d, b;
	        if (g.hasOwnProperty("fontSize"))
	            d = g.fontSize;
	        else {
	            for (b = 0; void 0 === d && b < k.length; b += 1)
	                d = k[b].fontSize();
	            g.fontSize = d
	        }
	        return d || 12
	    }
	}
	;
	odf.MasterPage = function(g, k) {
	    var d;
	    g ? (d = g.getAttributeNS(odf.Namespaces.stylens, "page-layout-name"),
	    this.pageLayout = k.getPageLayout(d)) : this.pageLayout = k.getDefaultPageLayout()
	}
	;
	odf.MasterPageCache = function() {}
	;
	odf.MasterPageCache.prototype.getMasterPage = function(g) {}
	;
	odf.StylePileEntry = function(g, k, d, b) {
	    this.masterPage = function() {
	        var b = g.getAttributeNS(odf.Namespaces.stylens, "master-page-name")
	          , k = null;
	        b && (k = d.getMasterPage(b));
	        return k
	    }
	    ;
	    (function(d) {
	        var n = g.getAttributeNS(odf.Namespaces.stylens, "family")
	          , p = null;
	        if ("graphic" === n || "chart" === n)
	            d.graphic = void 0 === b ? void 0 : b.graphic,
	            p = k.getPropertiesElement("graphic-properties", g, p),
	            null !== p && (d.graphic = new odf.GraphicProperties(p,k,d.graphic));
	        if ("paragraph" === n || "table-cell" === n || "graphic" === n || "presentation" === n || "chart" === n)
	            d.paragraph = void 0 === b ? void 0 : b.paragraph,
	            p = k.getPropertiesElement("paragraph-properties", g, p),
	            null !== p && (d.paragraph = new odf.ParagraphProperties(p,k,d.paragraph));
	        if ("text" === n || "paragraph" === n || "table-cell" === n || "graphic" === n || "presentation" === n || "chart" === n)
	            d.text = void 0 === b ? void 0 : b.text,
	            p = k.getPropertiesElement("text-properties", g, p),
	            null !== p && (d.text = new odf.TextProperties(p,k,d.text))
	    }
	    )(this)
	}
	;
	odf.StylePile = function(g, k) {
	    function d(d, a) {
	        var c, f;
	        d.hasAttributeNS(b, "parent-style-name") && (f = d.getAttributeNS(b, "parent-style-name"),
	        -1 === a.indexOf(f) && (c = e(f, a)));
	        return new odf.StylePileEntry(d,g,k,c)
	    }
	    var b = odf.Namespaces.stylens, f = {}, n = {}, p, r = {}, q = {}, e;
	    e = function(b, a) {
	        var c = r[b], e;
	        !c && (e = f[b]) && (a.push(b),
	        c = d(e, a),
	        r[b] = c);
	        return c
	    }
	    ;
	    this.getStyle = function(b) {
	        var a = q[b] || r[b], c, e = [];
	        a || (c = n[b],
	        c || (c = f[b]) && e.push(b),
	        c && (a = d(c, e)));
	        return a
	    }
	    ;
	    this.addCommonStyle = function(d) {
	        var a;
	        d.hasAttributeNS(b, "name") && (a = d.getAttributeNS(b, "name"),
	        f.hasOwnProperty(a) || (f[a] = d))
	    }
	    ;
	    this.addAutomaticStyle = function(d) {
	        var a;
	        d.hasAttributeNS(b, "name") && (a = d.getAttributeNS(b, "name"),
	        n.hasOwnProperty(a) || (n[a] = d))
	    }
	    ;
	    this.setDefaultStyle = function(b) {
	        void 0 === p && (p = d(b, []))
	    }
	    ;
	    this.getDefaultStyle = function() {
	        return p
	    }
	}
	;
	odf.ComputedGraphicStyle = function() {
	    this.text = new odf.ComputedTextProperties;
	    this.paragraph = new odf.ComputedParagraphProperties;
	    this.graphic = new odf.ComputedGraphicProperties
	}
	;
	odf.ComputedParagraphStyle = function() {
	    this.text = new odf.ComputedTextProperties;
	    this.paragraph = new odf.ComputedParagraphProperties
	}
	;
	odf.ComputedTextStyle = function() {
	    this.text = new odf.ComputedTextProperties
	}
	;
	odf.StyleCache = function(g) {
	    function k(a, c, b, d) {
	        c = b.getAttributeNS(c, "class-names");
	        var e;
	        if (c)
	            for (c = c.split(" "),
	            e = 0; e < c.length; e += 1)
	                if (b = c[e])
	                    d.push(a),
	                    d.push(b)
	    }
	    function d(a, c) {
	        var b = x.getStyleName("paragraph", a);
	        void 0 !== b && (c.push("paragraph"),
	        c.push(b));
	        a.namespaceURI !== h || "h" !== a.localName && "p" !== a.localName || k("paragraph", h, a, c);
	        return c
	    }
	    function b(a, c, b) {
	        var d = [], e, h, f, g;
	        for (e = 0; e < a.length; e += 2)
	            f = a[e],
	            g = a[e + 1],
	            f = r[f],
	            g = f.getStyle(g),
	            void 0 !== g && (g = g[c],
	            void 0 !== g && g !== h && (d.push(g),
	            h = g));
	        f = r[b];
	        if (g = f.getDefaultStyle())
	            g = g[c],
	            void 0 !== g && g !== h && d.push(g);
	        return d
	    }
	    function f(a, c) {
	        var b = x.getStyleName("text", a)
	          , e = a.parentNode;
	        void 0 !== b && (c.push("text"),
	        c.push(b));
	        "span" === a.localName && a.namespaceURI === h && k("text", h, a, c);
	        if (!e || e === g)
	            return c;
	        e.namespaceURI !== h || "p" !== e.localName && "h" !== e.localName ? f(e, c) : d(e, c);
	        return c
	    }
	    function n(a) {
	        a = a.getAttributeNS(y, "family");
	        return r[a]
	    }
	    var p = this, r, q, e, l, a, c, m, h = odf.Namespaces.textns, y = odf.Namespaces.stylens, x = new odf.StyleInfo, z = new odf.StyleParseUtils, w, v, u, t, A, I;
	    this.getComputedGraphicStyle = function(a) {
	        var c = [];
	        a = x.getStyleName("graphic", a);
	        void 0 !== a && (c.push("graphic"),
	        c.push(a));
	        a = c.join("/");
	        var d = l[a];
	        runtime.assert(0 === c.length % 2, "Invalid style chain.");
	        void 0 === d && (d = new odf.ComputedGraphicStyle,
	        d.graphic.setGraphicProperties(b(c, "graphic", "graphic")[0]),
	        d.text.setStyleChain(b(c, "text", "graphic")),
	        d.paragraph.setStyleChain(b(c, "paragraph", "graphic")),
	        l[a] = d);
	        return d
	    }
	    ;
	    this.getComputedParagraphStyle = function(a) {
	        a = d(a, []);
	        var c = a.join("/")
	          , f = e[c];
	        runtime.assert(0 === a.length % 2, "Invalid style chain.");
	        void 0 === f && (f = new odf.ComputedParagraphStyle,
	        f.text.setStyleChain(b(a, "text", "paragraph")),
	        f.paragraph.setStyleChain(b(a, "paragraph", "paragraph")),
	        e[c] = f);
	        return f
	    }
	    ;
	    this.getComputedTextStyle = function(a) {
	        a = f(a, []);
	        var c = a.join("/")
	          , d = q[c];
	        runtime.assert(0 === a.length % 2, "Invalid style chain.");
	        void 0 === d && (d = new odf.ComputedTextStyle,
	        d.text.setStyleChain(b(a, "text", "text")),
	        q[c] = d);
	        return d
	    }
	    ;
	    this.getPageLayout = function(a) {
	        var c = I[a];
	        c || ((c = A[a]) ? (c = new odf.PageLayout(c,z,t),
	        I[a] = c) : c = t);
	        return c
	    }
	    ;
	    this.getDefaultPageLayout = function() {
	        return t
	    }
	    ;
	    this.getMasterPage = function(a) {
	        var c = v[a];
	        void 0 === c && ((c = w[a]) ? (c = new odf.MasterPage(c,p),
	        v[a] = c) : c = null);
	        return c
	    }
	    ;
	    this.getDefaultMasterPage = function() {
	        return u
	    }
	    ;
	    this.update = function() {
	        var b, d, f = null, h = null;
	        q = {};
	        e = {};
	        l = {};
	        w = {};
	        v = {};
	        I = {};
	        A = {};
	        a = new odf.StylePile(z,p);
	        c = new odf.StylePile(z,p);
	        m = new odf.StylePile(z,p);
	        r = {
	            text: a,
	            paragraph: c,
	            graphic: m
	        };
	        for (b = g.styles.firstElementChild; b; )
	            b.namespaceURI === y && ((d = n(b)) ? "style" === b.localName ? d.addCommonStyle(b) : "default-style" === b.localName && d.setDefaultStyle(b) : "default-page-layout" === b.localName && (f = b)),
	            b = b.nextElementSibling;
	        t = new odf.PageLayout(f,z);
	        for (b = g.automaticStyles.firstElementChild; b; )
	            b.namespaceURI === y && ((d = n(b)) && "style" === b.localName ? d.addAutomaticStyle(b) : "page-layout" === b.localName && (A[b.getAttributeNS(y, "name")] = b)),
	            b = b.nextElementSibling;
	        for (b = g.masterStyles.firstElementChild; b; )
	            b.namespaceURI === y && "master-page" === b.localName && (h = h || b,
	            d = b,
	            f = d.getAttributeNS(y, "name"),
	            0 < f.length && !w.hasOwnProperty(f) && (w[f] = d)),
	            b = b.nextElementSibling;
	        u = new odf.MasterPage(h,p)
	    }
	}
	;
	ops.OperationTransformMatrix = function() {
	    function g(a) {
	        a.position += a.length;
	        a.length *= -1
	    }
	    function k(a) {
	        var c = 0 > a.length;
	        c && g(a);
	        return c
	    }
	    function d(a, c) {
	        function b(e) {
	            a[e] === c && d.push(e)
	        }
	        var d = [];
	        a && ["style:parent-style-name", "style:next-style-name"].forEach(b);
	        return d
	    }
	    function b(a, c) {
	        function b(d) {
	            a[d] === c && delete a[d]
	        }
	        a && ["style:parent-style-name", "style:next-style-name"].forEach(b)
	    }
	    function f(a) {
	        var c = {};
	        Object.keys(a).forEach(function(b) {
	            c[b] = "object" === typeof a[b] ? f(a[b]) : a[b]
	        });
	        return c
	    }
	    function n(a, c, b, d) {
	        var e, f = !1, g = !1, k, l = [];
	        d && d.attributes && (l = d.attributes.split(","));
	        a && (b || 0 < l.length) && Object.keys(a).forEach(function(c) {
	            var d = a[c], e;
	            "object" !== typeof d && (b && (e = b[c]),
	            void 0 !== e ? (delete a[c],
	            g = !0,
	            e === d && (delete b[c],
	            f = !0)) : -1 !== l.indexOf(c) && (delete a[c],
	            g = !0))
	        });
	        if (c && c.attributes && (b || 0 < l.length)) {
	            k = c.attributes.split(",");
	            for (d = 0; d < k.length; d += 1)
	                if (e = k[d],
	                b && void 0 !== b[e] || l && -1 !== l.indexOf(e))
	                    k.splice(d, 1),
	                    --d,
	                    g = !0;
	            0 < k.length ? c.attributes = k.join(",") : delete c.attributes
	        }
	        return {
	            majorChanged: f,
	            minorChanged: g
	        }
	    }
	    function p(a) {
	        for (var c in a)
	            if (a.hasOwnProperty(c))
	                return !0;
	        return !1
	    }
	    function r(a) {
	        for (var c in a)
	            if (a.hasOwnProperty(c) && ("attributes" !== c || 0 < a.attributes.length))
	                return !0;
	        return !1
	    }
	    function q(a, c, b, d, e) {
	        var f = a ? a[e] : null, g = c ? c[e] : null, k = b ? b[e] : null, l = d ? d[e] : null, q;
	        q = n(f, g, k, l);
	        f && !p(f) && delete a[e];
	        g && !r(g) && delete c[e];
	        k && !p(k) && delete b[e];
	        l && !r(l) && delete d[e];
	        return q
	    }
	    function e(a, c) {
	        return {
	            opSpecsA: [a],
	            opSpecsB: [c]
	        }
	    }
	    var l;
	    l = {
	        AddAnnotation: {
	            AddAnnotation: function(a, c, b) {
	                var d;
	                a.position < c.position ? (d = a,
	                b = c) : c.position < a.position ? (d = c,
	                b = a) : (d = b ? a : c,
	                b = b ? c : a);
	                b.position < d.position + d.length && (d.length += 2);
	                b.position += 2;
	                return {
	                    opSpecsA: [a],
	                    opSpecsB: [c]
	                }
	            },
	            AddCursor: e,
	            AddMember: e,
	            AddStyle: e,
	            ApplyDirectStyling: function(a, c) {
	                a.position <= c.position ? c.position += 2 : a.position <= c.position + c.length && (c.length += 2);
	                return {
	                    opSpecsA: [a],
	                    opSpecsB: [c]
	                }
	            },
	            InsertText: function(a, c) {
	                c.position <= a.position ? a.position += c.text.length : (void 0 !== a.length && c.position <= a.position + a.length && (a.length += c.text.length),
	                c.position += 2);
	                return {
	                    opSpecsA: [a],
	                    opSpecsB: [c]
	                }
	            },
	            MergeParagraph: function(a, c) {
	                c.sourceStartPosition <= a.position ? --a.position : (void 0 !== a.length && c.sourceStartPosition <= a.position + a.length && --a.length,
	                c.sourceStartPosition += 2,
	                a.position < c.destinationStartPosition && (c.destinationStartPosition += 2));
	                return {
	                    opSpecsA: [a],
	                    opSpecsB: [c]
	                }
	            },
	            MoveCursor: function(a, c) {
	                var b = k(c);
	                a.position < c.position ? c.position += 2 : a.position < c.position + c.length && (c.length += 2);
	                b && g(c);
	                return {
	                    opSpecsA: [a],
	                    opSpecsB: [c]
	                }
	            },
	            RemoveAnnotation: function(a, c) {
	                a.position < c.position ? (c.position < a.position + a.length && (a.length -= c.length + 2),
	                c.position += 2) : a.position -= c.length + 2;
	                return {
	                    opSpecsA: [a],
	                    opSpecsB: [c]
	                }
	            },
	            RemoveCursor: e,
	            RemoveMember: e,
	            RemoveStyle: e,
	            RemoveText: function(a, c) {
	                var b = c.position, d = c.position + c.length, e, f = [a], g = [c];
	                a.position <= c.position ? c.position += 2 : a.position < d && (c.length = a.position - c.position,
	                e = {
	                    optype: "RemoveText",
	                    memberid: c.memberid,
	                    timestamp: c.timestamp,
	                    position: a.position + 2,
	                    length: d - a.position
	                },
	                g.unshift(e));
	                c.position + c.length <= a.position ? (a.position -= c.length,
	                void 0 !== a.length && e && (a.length = e.length >= a.length ? 0 : a.length - e.length)) : void 0 !== a.length && (e = a.position + a.length,
	                d <= e ? a.length -= c.length : b < e && (a.length = b - a.position));
	                return {
	                    opSpecsA: f,
	                    opSpecsB: g
	                }
	            },
	            SetParagraphStyle: function(a, c) {
	                a.position < c.position && (c.position += 2);
	                return {
	                    opSpecsA: [a],
	                    opSpecsB: [c]
	                }
	            },
	            SplitParagraph: function(a, c) {
	                a.position < c.sourceParagraphPosition && (c.sourceParagraphPosition += 2);
	                c.position <= a.position ? a.position += 1 : (void 0 !== a.length && c.position <= a.position + a.length && (a.length += 1),
	                c.position += 2);
	                return {
	                    opSpecsA: [a],
	                    opSpecsB: [c]
	                }
	            },
	            UpdateMember: e,
	            UpdateMetadata: e,
	            UpdateParagraphStyle: e
	        },
	        AddCursor: {
	            AddCursor: e,
	            AddMember: e,
	            AddStyle: e,
	            ApplyDirectStyling: e,
	            InsertText: e,
	            MergeParagraph: e,
	            MoveCursor: e,
	            RemoveAnnotation: e,
	            RemoveCursor: e,
	            RemoveMember: e,
	            RemoveStyle: e,
	            RemoveText: e,
	            SetParagraphStyle: e,
	            SplitParagraph: e,
	            UpdateMember: e,
	            UpdateMetadata: e,
	            UpdateParagraphStyle: e
	        },
	        AddMember: {
	            AddStyle: e,
	            ApplyDirectStyling: e,
	            InsertText: e,
	            MergeParagraph: e,
	            MoveCursor: e,
	            RemoveAnnotation: e,
	            RemoveCursor: e,
	            RemoveStyle: e,
	            RemoveText: e,
	            SetParagraphStyle: e,
	            SplitParagraph: e,
	            UpdateMetadata: e,
	            UpdateParagraphStyle: e
	        },
	        AddStyle: {
	            AddStyle: e,
	            ApplyDirectStyling: e,
	            InsertText: e,
	            MergeParagraph: e,
	            MoveCursor: e,
	            RemoveAnnotation: e,
	            RemoveCursor: e,
	            RemoveMember: e,
	            RemoveStyle: function(a, c) {
	                var e, f = [a], g = [c];
	                a.styleFamily === c.styleFamily && (e = d(a.setProperties, c.styleName),
	                0 < e.length && (e = {
	                    optype: "UpdateParagraphStyle",
	                    memberid: c.memberid,
	                    timestamp: c.timestamp,
	                    styleName: a.styleName,
	                    removedProperties: {
	                        attributes: e.join(",")
	                    }
	                },
	                g.unshift(e)),
	                b(a.setProperties, c.styleName));
	                return {
	                    opSpecsA: f,
	                    opSpecsB: g
	                }
	            },
	            RemoveText: e,
	            SetParagraphStyle: e,
	            SplitParagraph: e,
	            UpdateMember: e,
	            UpdateMetadata: e,
	            UpdateParagraphStyle: e
	        },
	        ApplyDirectStyling: {
	            ApplyDirectStyling: function(a, c, b) {
	                var d, e, g, k, l, n, r, t;
	                k = [a];
	                g = [c];
	                if (!(a.position + a.length <= c.position || a.position >= c.position + c.length)) {
	                    d = b ? a : c;
	                    e = b ? c : a;
	                    if (a.position !== c.position || a.length !== c.length)
	                        n = f(d),
	                        r = f(e);
	                    c = q(e.setProperties, null, d.setProperties, null, "style:text-properties");
	                    if (c.majorChanged || c.minorChanged)
	                        g = [],
	                        a = [],
	                        k = d.position + d.length,
	                        l = e.position + e.length,
	                        e.position < d.position ? c.minorChanged && (t = f(r),
	                        t.length = d.position - e.position,
	                        a.push(t),
	                        e.position = d.position,
	                        e.length = l - e.position) : d.position < e.position && c.majorChanged && (t = f(n),
	                        t.length = e.position - d.position,
	                        g.push(t),
	                        d.position = e.position,
	                        d.length = k - d.position),
	                        l > k ? c.minorChanged && (n = r,
	                        n.position = k,
	                        n.length = l - k,
	                        a.push(n),
	                        e.length = k - e.position) : k > l && c.majorChanged && (n.position = l,
	                        n.length = k - l,
	                        g.push(n),
	                        d.length = l - d.position),
	                        d.setProperties && p(d.setProperties) && g.push(d),
	                        e.setProperties && p(e.setProperties) && a.push(e),
	                        b ? (k = g,
	                        g = a) : k = a
	                }
	                return {
	                    opSpecsA: k,
	                    opSpecsB: g
	                }
	            },
	            InsertText: function(a, c) {
	                c.position <= a.position ? a.position += c.text.length : c.position <= a.position + a.length && (a.length += c.text.length);
	                return {
	                    opSpecsA: [a],
	                    opSpecsB: [c]
	                }
	            },
	            MergeParagraph: function(a, c) {
	                var b = a.position
	                  , d = a.position + a.length;
	                b >= c.sourceStartPosition && --b;
	                d >= c.sourceStartPosition && --d;
	                a.position = b;
	                a.length = d - b;
	                return {
	                    opSpecsA: [a],
	                    opSpecsB: [c]
	                }
	            },
	            MoveCursor: e,
	            RemoveAnnotation: function(a, b) {
	                var d = a.position
	                  , e = a.position + a.length
	                  , f = b.position + b.length
	                  , g = [a]
	                  , k = [b];
	                b.position <= d && e <= f ? g = [] : (f < d && (d -= b.length + 2),
	                f < e && (e -= b.length + 2),
	                a.position = d,
	                a.length = e - d);
	                return {
	                    opSpecsA: g,
	                    opSpecsB: k
	                }
	            },
	            RemoveCursor: e,
	            RemoveMember: e,
	            RemoveStyle: e,
	            RemoveText: function(a, b) {
	                var d = a.position + a.length
	                  , e = b.position + b.length
	                  , f = [a]
	                  , g = [b];
	                e <= a.position ? a.position -= b.length : b.position < d && (a.position < b.position ? a.length = e < d ? a.length - b.length : b.position - a.position : (a.position = b.position,
	                e < d ? a.length = d - e : f = []));
	                return {
	                    opSpecsA: f,
	                    opSpecsB: g
	                }
	            },
	            SetParagraphStyle: e,
	            SplitParagraph: function(a, b) {
	                b.position < a.position ? a.position += 1 : b.position < a.position + a.length && (a.length += 1);
	                return {
	                    opSpecsA: [a],
	                    opSpecsB: [b]
	                }
	            },
	            UpdateMember: e,
	            UpdateMetadata: e,
	            UpdateParagraphStyle: e
	        },
	        InsertText: {
	            InsertText: function(a, b, d) {
	                a.position < b.position ? b.position += a.text.length : a.position > b.position ? a.position += b.text.length : d ? b.position += a.text.length : a.position += b.text.length;
	                return {
	                    opSpecsA: [a],
	                    opSpecsB: [b]
	                }
	            },
	            MergeParagraph: function(a, b) {
	                a.position >= b.sourceStartPosition ? --a.position : (a.position < b.sourceStartPosition && (b.sourceStartPosition += a.text.length),
	                a.position < b.destinationStartPosition && (b.destinationStartPosition += a.text.length));
	                return {
	                    opSpecsA: [a],
	                    opSpecsB: [b]
	                }
	            },
	            MoveCursor: function(a, b) {
	                var d = k(b);
	                a.position < b.position ? b.position += a.text.length : a.position < b.position + b.length && (b.length += a.text.length);
	                d && g(b);
	                return {
	                    opSpecsA: [a],
	                    opSpecsB: [b]
	                }
	            },
	            RemoveAnnotation: function(a, b) {
	                var d = a.position
	                  , e = b.position + b.length
	                  , f = [a]
	                  , g = [b];
	                b.position <= d && d <= e ? (f = [],
	                b.length += a.text.length) : e < a.position ? a.position -= b.length + 2 : b.position += a.text.length;
	                return {
	                    opSpecsA: f,
	                    opSpecsB: g
	                }
	            },
	            RemoveCursor: e,
	            RemoveMember: e,
	            RemoveStyle: e,
	            RemoveText: function(a, b) {
	                var d;
	                d = b.position + b.length;
	                var e = [a]
	                  , f = [b];
	                d <= a.position ? a.position -= b.length : a.position <= b.position ? b.position += a.text.length : (b.length = a.position - b.position,
	                d = {
	                    optype: "RemoveText",
	                    memberid: b.memberid,
	                    timestamp: b.timestamp,
	                    position: a.position + a.text.length,
	                    length: d - a.position
	                },
	                f.unshift(d),
	                a.position = b.position);
	                return {
	                    opSpecsA: e,
	                    opSpecsB: f
	                }
	            },
	            SetParagraphStyle: function(a, b) {
	                b.position > a.position && (b.position += a.text.length);
	                return {
	                    opSpecsA: [a],
	                    opSpecsB: [b]
	                }
	            },
	            SplitParagraph: function(a, b) {
	                a.position < b.sourceParagraphPosition && (b.sourceParagraphPosition += a.text.length);
	                a.position <= b.position ? b.position += a.text.length : a.position += 1;
	                return {
	                    opSpecsA: [a],
	                    opSpecsB: [b]
	                }
	            },
	            UpdateMember: e,
	            UpdateMetadata: e,
	            UpdateParagraphStyle: e
	        },
	        MergeParagraph: {
	            MergeParagraph: function(a, b, d) {
	                var e = [a], f = [b], g;
	                a.destinationStartPosition === b.destinationStartPosition ? (e = [],
	                f = [],
	                a.moveCursor && (g = {
	                    optype: "MoveCursor",
	                    memberid: a.memberid,
	                    timestamp: a.timestamp,
	                    position: a.sourceStartPosition - 1
	                },
	                e.push(g)),
	                b.moveCursor && (g = {
	                    optype: "MoveCursor",
	                    memberid: b.memberid,
	                    timestamp: b.timestamp,
	                    position: b.sourceStartPosition - 1
	                },
	                f.push(g)),
	                a = d ? a : b,
	                a = {
	                    optype: "SetParagraphStyle",
	                    memberid: a.memberid,
	                    timestamp: a.timestamp,
	                    position: a.destinationStartPosition,
	                    styleName: a.paragraphStyleName
	                },
	                d ? e.push(a) : f.push(a)) : b.sourceStartPosition === a.destinationStartPosition ? (a.destinationStartPosition = b.destinationStartPosition,
	                --a.sourceStartPosition,
	                a.paragraphStyleName = b.paragraphStyleName) : a.sourceStartPosition === b.destinationStartPosition ? (b.destinationStartPosition = a.destinationStartPosition,
	                --b.sourceStartPosition,
	                b.paragraphStyleName = a.paragraphStyleName) : a.destinationStartPosition < b.destinationStartPosition ? (--b.destinationStartPosition,
	                --b.sourceStartPosition) : (--a.destinationStartPosition,
	                --a.sourceStartPosition);
	                return {
	                    opSpecsA: e,
	                    opSpecsB: f
	                }
	            },
	            MoveCursor: function(a, b) {
	                var d = b.position
	                  , e = b.position + b.length
	                  , f = Math.min(d, e)
	                  , d = Math.max(d, e);
	                f >= a.sourceStartPosition && --f;
	                d >= a.sourceStartPosition && --d;
	                0 <= b.length ? (b.position = f,
	                b.length = d - f) : (b.position = d,
	                b.length = f - d);
	                return {
	                    opSpecsA: [a],
	                    opSpecsB: [b]
	                }
	            },
	            RemoveAnnotation: function(a, b) {
	                var d = b.position + b.length
	                  , e = [a]
	                  , f = [b];
	                b.position <= a.destinationStartPosition && a.sourceStartPosition <= d ? (e = [],
	                --b.length) : a.sourceStartPosition < b.position ? --b.position : (d < a.destinationStartPosition && (a.destinationStartPosition -= b.length + 2),
	                d < a.sourceStartPosition && (a.sourceStartPosition -= b.length + 2));
	                return {
	                    opSpecsA: e,
	                    opSpecsB: f
	                }
	            },
	            RemoveCursor: e,
	            RemoveMember: e,
	            RemoveStyle: e,
	            RemoveText: function(a, b) {
	                b.position >= a.sourceStartPosition ? --b.position : (b.position < a.destinationStartPosition && (a.destinationStartPosition -= b.length),
	                b.position < a.sourceStartPosition && (a.sourceStartPosition -= b.length));
	                return {
	                    opSpecsA: [a],
	                    opSpecsB: [b]
	                }
	            },
	            SetParagraphStyle: function(a, b) {
	                var d = [a]
	                  , e = [b];
	                if (b.position > a.sourceStartPosition)
	                    --b.position;
	                else if (b.position === a.destinationStartPosition || b.position === a.sourceStartPosition)
	                    b.position = a.destinationStartPosition,
	                    a.paragraphStyleName = b.styleName;
	                return {
	                    opSpecsA: d,
	                    opSpecsB: e
	                }
	            },
	            SplitParagraph: function(a, b) {
	                var d, e = [a], f = [b];
	                b.position < a.destinationStartPosition ? (a.destinationStartPosition += 1,
	                a.sourceStartPosition += 1) : b.position >= a.destinationStartPosition && b.position < a.sourceStartPosition ? (b.paragraphStyleName = a.paragraphStyleName,
	                d = {
	                    optype: "SetParagraphStyle",
	                    memberid: a.memberid,
	                    timestamp: a.timestamp,
	                    position: a.destinationStartPosition,
	                    styleName: a.paragraphStyleName
	                },
	                e.push(d),
	                b.position === a.sourceStartPosition - 1 && a.moveCursor && (d = {
	                    optype: "MoveCursor",
	                    memberid: a.memberid,
	                    timestamp: a.timestamp,
	                    position: b.position,
	                    length: 0
	                },
	                e.push(d)),
	                a.destinationStartPosition = b.position + 1,
	                a.sourceStartPosition += 1) : b.position >= a.sourceStartPosition && (--b.position,
	                --b.sourceParagraphPosition);
	                return {
	                    opSpecsA: e,
	                    opSpecsB: f
	                }
	            },
	            UpdateMember: e,
	            UpdateMetadata: e,
	            UpdateParagraphStyle: e
	        },
	        MoveCursor: {
	            MoveCursor: e,
	            RemoveAnnotation: function(a, b) {
	                var d = k(a)
	                  , e = a.position + a.length
	                  , f = b.position + b.length;
	                b.position <= a.position && e <= f ? (a.position = b.position - 1,
	                a.length = 0) : (f < a.position ? a.position -= b.length + 2 : f < e && (a.length -= b.length + 2),
	                d && g(a));
	                return {
	                    opSpecsA: [a],
	                    opSpecsB: [b]
	                }
	            },
	            RemoveCursor: function(a, b) {
	                return {
	                    opSpecsA: a.memberid === b.memberid ? [] : [a],
	                    opSpecsB: [b]
	                }
	            },
	            RemoveMember: e,
	            RemoveStyle: e,
	            RemoveText: function(a, b) {
	                var d = k(a)
	                  , e = a.position + a.length
	                  , f = b.position + b.length;
	                f <= a.position ? a.position -= b.length : b.position < e && (a.position < b.position ? a.length = f < e ? a.length - b.length : b.position - a.position : (a.position = b.position,
	                a.length = f < e ? e - f : 0));
	                d && g(a);
	                return {
	                    opSpecsA: [a],
	                    opSpecsB: [b]
	                }
	            },
	            SetParagraphStyle: e,
	            SplitParagraph: function(a, b) {
	                var d = k(a);
	                b.position < a.position ? a.position += 1 : b.position < a.position + a.length && (a.length += 1);
	                d && g(a);
	                return {
	                    opSpecsA: [a],
	                    opSpecsB: [b]
	                }
	            },
	            UpdateMember: e,
	            UpdateMetadata: e,
	            UpdateParagraphStyle: e
	        },
	        RemoveAnnotation: {
	            RemoveAnnotation: function(a, b) {
	                var d = [a]
	                  , e = [b];
	                a.position === b.position && a.length === b.length ? (d = [],
	                e = []) : a.position < b.position ? b.position -= a.length + 2 : a.position -= b.length + 2;
	                return {
	                    opSpecsA: d,
	                    opSpecsB: e
	                }
	            },
	            RemoveCursor: e,
	            RemoveMember: e,
	            RemoveStyle: e,
	            RemoveText: function(a, b) {
	                var d = a.position + a.length
	                  , e = b.position + b.length
	                  , f = [a]
	                  , g = [b];
	                a.position <= b.position && e <= d ? (g = [],
	                a.length -= b.length) : e < a.position ? a.position -= b.length : b.position < a.position ? (a.position = b.position + 1,
	                b.length -= a.length + 2) : b.position -= a.length + 2;
	                return {
	                    opSpecsA: f,
	                    opSpecsB: g
	                }
	            },
	            SetParagraphStyle: function(a, b) {
	                var d = b.position
	                  , e = a.position + a.length
	                  , f = [a]
	                  , g = [b];
	                a.position <= d && d <= e ? g = [] : e < d && (b.position -= a.length + 2);
	                return {
	                    opSpecsA: f,
	                    opSpecsB: g
	                }
	            },
	            SplitParagraph: function(a, b) {
	                var d = b.position
	                  , e = a.position + a.length
	                  , f = [a]
	                  , g = [b];
	                a.position <= d && d <= e ? (g = [],
	                a.length += 1) : (e < b.sourceParagraphPosition && (b.sourceParagraphPosition -= a.length + 2),
	                e < d ? b.position -= a.length + 2 : a.position += 1);
	                return {
	                    opSpecsA: f,
	                    opSpecsB: g
	                }
	            },
	            UpdateMember: e,
	            UpdateMetadata: e,
	            UpdateParagraphStyle: e
	        },
	        RemoveCursor: {
	            RemoveCursor: function(a, b) {
	                var d = a.memberid === b.memberid;
	                return {
	                    opSpecsA: d ? [] : [a],
	                    opSpecsB: d ? [] : [b]
	                }
	            },
	            RemoveMember: e,
	            RemoveStyle: e,
	            RemoveText: e,
	            SetParagraphStyle: e,
	            SplitParagraph: e,
	            UpdateMember: e,
	            UpdateMetadata: e,
	            UpdateParagraphStyle: e
	        },
	        RemoveMember: {
	            RemoveStyle: e,
	            RemoveText: e,
	            SetParagraphStyle: e,
	            SplitParagraph: e,
	            UpdateMetadata: e,
	            UpdateParagraphStyle: e
	        },
	        RemoveStyle: {
	            RemoveStyle: function(a, b) {
	                var d = a.styleName === b.styleName && a.styleFamily === b.styleFamily;
	                return {
	                    opSpecsA: d ? [] : [a],
	                    opSpecsB: d ? [] : [b]
	                }
	            },
	            RemoveText: e,
	            SetParagraphStyle: function(a, b) {
	                var d, e = [a], f = [b];
	                "paragraph" === a.styleFamily && a.styleName === b.styleName && (d = {
	                    optype: "SetParagraphStyle",
	                    memberid: a.memberid,
	                    timestamp: a.timestamp,
	                    position: b.position,
	                    styleName: ""
	                },
	                e.unshift(d),
	                b.styleName = "");
	                return {
	                    opSpecsA: e,
	                    opSpecsB: f
	                }
	            },
	            SplitParagraph: e,
	            UpdateMember: e,
	            UpdateMetadata: e,
	            UpdateParagraphStyle: function(a, c) {
	                var e, f = [a], g = [c];
	                "paragraph" === a.styleFamily && (e = d(c.setProperties, a.styleName),
	                0 < e.length && (e = {
	                    optype: "UpdateParagraphStyle",
	                    memberid: a.memberid,
	                    timestamp: a.timestamp,
	                    styleName: c.styleName,
	                    removedProperties: {
	                        attributes: e.join(",")
	                    }
	                },
	                f.unshift(e)),
	                a.styleName === c.styleName ? g = [] : b(c.setProperties, a.styleName));
	                return {
	                    opSpecsA: f,
	                    opSpecsB: g
	                }
	            }
	        },
	        RemoveText: {
	            RemoveText: function(a, b) {
	                var d = a.position + a.length
	                  , e = b.position + b.length
	                  , f = [a]
	                  , g = [b];
	                e <= a.position ? a.position -= b.length : d <= b.position ? b.position -= a.length : b.position < d && (a.position < b.position ? (a.length = e < d ? a.length - b.length : b.position - a.position,
	                d < e ? (b.position = a.position,
	                b.length = e - d) : g = []) : (d < e ? b.length -= a.length : b.position < a.position ? b.length = a.position - b.position : g = [],
	                e < d ? (a.position = b.position,
	                a.length = d - e) : f = []));
	                return {
	                    opSpecsA: f,
	                    opSpecsB: g
	                }
	            },
	            SetParagraphStyle: function(a, b) {
	                a.position < b.position && (b.position -= a.length);
	                return {
	                    opSpecsA: [a],
	                    opSpecsB: [b]
	                }
	            },
	            SplitParagraph: function(a, b) {
	                var d = a.position + a.length
	                  , e = [a]
	                  , f = [b];
	                b.position <= a.position ? a.position += 1 : b.position < d && (a.length = b.position - a.position,
	                d = {
	                    optype: "RemoveText",
	                    memberid: a.memberid,
	                    timestamp: a.timestamp,
	                    position: b.position + 1,
	                    length: d - b.position
	                },
	                e.unshift(d));
	                a.position + a.length <= b.position ? b.position -= a.length : a.position < b.position && (b.position = a.position);
	                a.position + a.length < b.sourceParagraphPosition && (b.sourceParagraphPosition -= a.length);
	                return {
	                    opSpecsA: e,
	                    opSpecsB: f
	                }
	            },
	            UpdateMember: e,
	            UpdateMetadata: e,
	            UpdateParagraphStyle: e
	        },
	        SetParagraphStyle: {
	            SetParagraphStyle: function(a, b, d) {
	                a.position === b.position && (d ? b.styleName = a.styleName : a.styleName = b.styleName);
	                return {
	                    opSpecsA: [a],
	                    opSpecsB: [b]
	                }
	            },
	            SplitParagraph: function(a, b) {
	                var d = [a], e = [b], g;
	                a.position > b.position ? a.position += 1 : a.position === b.sourceParagraphPosition && (b.paragraphStyleName = a.styleName,
	                g = f(a),
	                g.position = b.position + 1,
	                d.push(g));
	                return {
	                    opSpecsA: d,
	                    opSpecsB: e
	                }
	            },
	            UpdateMember: e,
	            UpdateMetadata: e,
	            UpdateParagraphStyle: e
	        },
	        SplitParagraph: {
	            SplitParagraph: function(a, b, d) {
	                var e, f;
	                a.position < b.position ? e = !0 : b.position < a.position ? f = !0 : a.position === b.position && (d ? e = !0 : f = !0);
	                e ? (b.position += 1,
	                b.sourceParagraphPosition = a.position < b.sourceParagraphPosition ? b.sourceParagraphPosition + 1 : a.position + 1) : f && (a.position += 1,
	                a.sourceParagraphPosition = b.position < b.sourceParagraphPosition ? a.sourceParagraphPosition + 1 : b.position + 1);
	                return {
	                    opSpecsA: [a],
	                    opSpecsB: [b]
	                }
	            },
	            UpdateMember: e,
	            UpdateMetadata: e,
	            UpdateParagraphStyle: e
	        },
	        UpdateMember: {
	            UpdateMetadata: e,
	            UpdateParagraphStyle: e
	        },
	        UpdateMetadata: {
	            UpdateMetadata: function(a, b, d) {
	                var e, f = [a], g = [b];
	                e = d ? a : b;
	                a = d ? b : a;
	                n(a.setProperties || null, a.removedProperties || null, e.setProperties || null, e.removedProperties || null);
	                e.setProperties && p(e.setProperties) || e.removedProperties && r(e.removedProperties) || (d ? f = [] : g = []);
	                a.setProperties && p(a.setProperties) || a.removedProperties && r(a.removedProperties) || (d ? g = [] : f = []);
	                return {
	                    opSpecsA: f,
	                    opSpecsB: g
	                }
	            },
	            UpdateParagraphStyle: e
	        },
	        UpdateParagraphStyle: {
	            UpdateParagraphStyle: function(a, b, d) {
	                var e, f = [a], g = [b];
	                a.styleName === b.styleName && (e = d ? a : b,
	                a = d ? b : a,
	                q(a.setProperties, a.removedProperties, e.setProperties, e.removedProperties, "style:paragraph-properties"),
	                q(a.setProperties, a.removedProperties, e.setProperties, e.removedProperties, "style:text-properties"),
	                n(a.setProperties || null, a.removedProperties || null, e.setProperties || null, e.removedProperties || null),
	                e.setProperties && p(e.setProperties) || e.removedProperties && r(e.removedProperties) || (d ? f = [] : g = []),
	                a.setProperties && p(a.setProperties) || a.removedProperties && r(a.removedProperties) || (d ? g = [] : f = []));
	                return {
	                    opSpecsA: f,
	                    opSpecsB: g
	                }
	            }
	        }
	    };
	    this.passUnchanged = e;
	    this.extendTransformations = function(a) {
	        Object.keys(a).forEach(function(b) {
	            var d = a[b], e, f = l.hasOwnProperty(b);
	            runtime.log((f ? "Extending" : "Adding") + " map for optypeA: " + b);
	            f || (l[b] = {});
	            e = l[b];
	            Object.keys(d).forEach(function(a) {
	                var f = e.hasOwnProperty(a);
	                runtime.assert(b <= a, "Wrong order:" + b + ", " + a);
	                runtime.log("  " + (f ? "Overwriting" : "Adding") + " entry for optypeB: " + a);
	                e[a] = d[a]
	            })
	        })
	    }
	    ;
	    this.transformOpspecVsOpspec = function(a, b) {
	        var d = a.optype <= b.optype, e;
	        runtime.log("Crosstransforming:");
	        runtime.log(runtime.toJson(a));
	        runtime.log(runtime.toJson(b));
	        d || (e = a,
	        a = b,
	        b = e);
	        (e = (e = l[a.optype]) && e[b.optype]) ? (e = e(a, b, !d),
	        d || null === e || (e = {
	            opSpecsA: e.opSpecsB,
	            opSpecsB: e.opSpecsA
	        })) : e = null;
	        runtime.log("result:");
	        e ? (runtime.log(runtime.toJson(e.opSpecsA)),
	        runtime.log(runtime.toJson(e.opSpecsB))) : runtime.log("null");
	        return e
	    }
	}
	;
	ops.OperationTransformer = function() {
	    function g(d, b) {
	        for (var f, n, p = [], r = []; 0 < d.length && b; ) {
	            f = d.shift();
	            f = k.transformOpspecVsOpspec(f, b);
	            if (!f)
	                return null;
	            p = p.concat(f.opSpecsA);
	            if (0 === f.opSpecsB.length) {
	                p = p.concat(d);
	                b = null;
	                break
	            }
	            for (; 1 < f.opSpecsB.length; ) {
	                n = g(d, f.opSpecsB.shift());
	                if (!n)
	                    return null;
	                r = r.concat(n.opSpecsB);
	                d = n.opSpecsA
	            }
	            b = f.opSpecsB.pop()
	        }
	        b && r.push(b);
	        return {
	            opSpecsA: p,
	            opSpecsB: r
	        }
	    }
	    var k = new ops.OperationTransformMatrix;
	    this.getOperationTransformMatrix = function() {
	        return k
	    }
	    ;
	    this.transform = function(d, b) {
	        for (var f, k = []; 0 < b.length; ) {
	            f = g(d, b.shift());
	            if (!f)
	                return null;
	            d = f.opSpecsA;
	            k = k.concat(f.opSpecsB)
	        }
	        return {
	            opSpecsA: d,
	            opSpecsB: k
	        }
	    }
	}
	;
	var webodf_css = '@namespace draw url(urn:oasis:names:tc:opendocument:xmlns:drawing:1.0);@namespace fo url(urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0);@namespace office url(urn:oasis:names:tc:opendocument:xmlns:office:1.0);@namespace presentation url(urn:oasis:names:tc:opendocument:xmlns:presentation:1.0);@namespace style url(urn:oasis:names:tc:opendocument:xmlns:style:1.0);@namespace svg url(urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0);@namespace table url(urn:oasis:names:tc:opendocument:xmlns:table:1.0);@namespace text url(urn:oasis:names:tc:opendocument:xmlns:text:1.0);@namespace webodfhelper url(urn:webodf:names:helper);@namespace cursor url(urn:webodf:names:cursor);@namespace editinfo url(urn:webodf:names:editinfo);@namespace annotation url(urn:webodf:names:annotation);@namespace dc url(http://purl.org/dc/elements/1.1/);@namespace svgns url(http://www.w3.org/2000/svg);office|document > *, office|document-content > * {display: none;}office|body, office|document {display: inline-block;position: relative;}text|p, text|h {display: block;padding: 0;margin: 0;line-height: normal;position: relative;}text|p::after, text|h::after {content: "\\200B";white-space: pre;}*[webodfhelper|containsparagraphanchor] {position: relative;}text|s {white-space: pre;}text|tab {display: inline;white-space: pre;}text|tracked-changes {display: none;}office|binary-data {display: none;}office|text {display: block;text-align: left;overflow: visible;word-wrap: break-word;}office|text::selection {background: transparent;}.webodf-virtualSelections *::selection {background: transparent;}.webodf-virtualSelections *::-moz-selection {background: transparent;}office|text * draw|text-box {display: block;border: 1px solid #d3d3d3;}office|text draw|frame {z-index: 1;}office|spreadsheet {display: block;border-collapse: collapse;empty-cells: show;font-family: sans-serif;font-size: 10pt;text-align: left;page-break-inside: avoid;overflow: hidden;}office|presentation {display: inline-block;text-align: left;}#shadowContent {display: inline-block;text-align: left;}draw|page {display: block;position: relative;overflow: hidden;}presentation|notes, presentation|footer-decl, presentation|date-time-decl {display: none;}@media print {draw|page {border: 1pt solid black;page-break-inside: avoid;}presentation|notes {}}office|spreadsheet text|p {border: 0px;padding: 1px;margin: 0px;}office|spreadsheet table|table {margin: 3px;}office|spreadsheet table|table:after {}office|spreadsheet table|table-row {counter-increment: row;}office|spreadsheet table|table-row:before {width: 3em;background: #cccccc;border: 1px solid black;text-align: center;content: counter(row);display: table-cell;}office|spreadsheet table|table-cell {border: 1px solid #cccccc;}table|table {display: table;}draw|frame table|table {width: 100%;height: 100%;background: white;}table|table-header-rows {display: table-header-group;}table|table-row {display: table-row;}table|table-column {display: table-column;}table|table-cell {width: 0.889in;display: table-cell;word-break: break-all;}draw|frame {display: block;}draw|image {display: block;width: 100%;height: 100%;top: 0px;left: 0px;background-repeat: no-repeat;background-size: 100% 100%;-moz-background-size: 100% 100%;}draw|frame > draw|image:nth-of-type(n+2) {display: none;}text|list:before {display: none;content:"";}text|list {display: block;}text|list-item {display: block;}text|number {display:none;}text|a {color: blue;text-decoration: underline;cursor: pointer;}.webodf-inactiveLinks text|a {cursor: text;}text|note-citation {vertical-align: super;font-size: smaller;}text|note-body {display: none;}text|note:hover text|note-citation {background: #dddddd;}text|note:hover text|note-body {display: block;left:1em;max-width: 80%;position: absolute;background: #ffffaa;}text|bibliography-source {display: none;}svg|title, svg|desc {display: none;}video {width: 100%;height: 100%}cursor|anchor {display: none;}cursor|cursor {display: none;}.webodf-caretOverlay {position: absolute;top: 5%;height: 1em;z-index: 10;padding-left: 1px;pointer-events: none;}.webodf-caretOverlay .caret {position: absolute;border-left: 2px solid black;top: 0;bottom: 0;right: 0;}.webodf-caretOverlay .handle {position: absolute;margin-top: 5px;padding-top: 3px;margin-left: auto;margin-right: auto;width: 64px;height: 68px;border-radius: 5px;opacity: 0.3;text-align: center;background-color: black;box-shadow: 0px 0px 5px rgb(90, 90, 90);border: 1px solid black;top: -85px;right: -32px;}.webodf-caretOverlay .handle > img {box-shadow: 0px 0px 5px rgb(90, 90, 90) inset;background-color: rgb(200, 200, 200);border-radius: 5px;border: 2px solid;height: 60px;width: 60px;display: block;margin: auto;}.webodf-caretOverlay .handle.active {opacity: 0.8;}.webodf-caretOverlay .handle:after {content: " ";position: absolute;width: 0px;height: 0px;border-style: solid;border-width: 8.7px 5px 0 5px;border-color: black transparent transparent transparent;top: 100%;left: 43%;}.webodf-caretSizer {display: inline-block;width: 0;visibility: hidden;}#eventTrap {display: block;position: absolute;bottom: 0;left: 0;outline: none;opacity: 0;color: rgba(255, 255, 255, 0);pointer-events: none;white-space: pre;overflow: hidden;}cursor|cursor > #composer {text-decoration: underline;}cursor|cursor[cursor|caret-sizer-active="true"],cursor|cursor[cursor|composing="true"] {display: inline;}editinfo|editinfo {display: inline-block;}.editInfoMarker {position: absolute;width: 10px;height: 100%;left: -20px;opacity: 0.8;top: 0;border-radius: 5px;background-color: transparent;box-shadow: 0px 0px 5px rgba(50, 50, 50, 0.75);}.editInfoMarker:hover {box-shadow: 0px 0px 8px rgba(0, 0, 0, 1);}.editInfoHandle {position: absolute;background-color: black;padding: 5px;border-radius: 5px;opacity: 0.8;box-shadow: 0px 0px 5px rgba(50, 50, 50, 0.75);bottom: 100%;margin-bottom: 10px;z-index: 3;left: -25px;}.editInfoHandle:after {content: " ";position: absolute;width: 0px;height: 0px;border-style: solid;border-width: 8.7px 5px 0 5px;border-color: black transparent transparent transparent;top: 100%;left: 5px;}.editInfo {font-family: sans-serif;font-weight: normal;font-style: normal;text-decoration: none;color: white;width: 100%;height: 12pt;}.editInfoColor {float: left;width: 10pt;height: 10pt;border: 1px solid white;}.editInfoAuthor {float: left;margin-left: 5pt;font-size: 10pt;text-align: left;height: 12pt;line-height: 12pt;}.editInfoTime {float: right;margin-left: 30pt;font-size: 8pt;font-style: italic;color: yellow;height: 12pt;line-height: 12pt;}.annotationWrapper {display: inline;position: relative;}.annotationRemoveButton:before {content: "\u00d7";color: white;padding: 5px;line-height: 1em;}.annotationRemoveButton {width: 20px;height: 20px;border-radius: 10px;background-color: black;box-shadow: 0px 0px 5px rgba(50, 50, 50, 0.75);position: absolute;top: -10px;left: -10px;z-index: 3;text-align: center;font-family: sans-serif;font-style: normal;font-weight: normal;text-decoration: none;font-size: 15px;}.annotationRemoveButton:hover {cursor: pointer;box-shadow: 0px 0px 5px rgba(0, 0, 0, 1);}.annotationNote {width: 4cm;position: absolute;display: inline;z-index: 10;top: 0;}.annotationNote > office|annotation {display: block;text-align: left;}.annotationConnector {position: absolute;display: inline;top: 0;z-index: 2;border-top: 1px dashed brown;}.annotationConnector.angular {-moz-transform-origin: left top;-webkit-transform-origin: left top;-ms-transform-origin: left top;transform-origin: left top;}.annotationConnector.horizontal {left: 0;}.annotationConnector.horizontal:before {content: "";display: inline;position: absolute;width: 0px;height: 0px;border-style: solid;border-width: 8.7px 5px 0 5px;border-color: brown transparent transparent transparent;top: -1px;left: -5px;}office|annotation {width: 100%;height: 100%;display: none;background: rgb(198, 238, 184);background: -moz-linear-gradient(90deg, rgb(198, 238, 184) 30%, rgb(180, 196, 159) 100%);background: -webkit-linear-gradient(90deg, rgb(198, 238, 184) 30%, rgb(180, 196, 159) 100%);background: -o-linear-gradient(90deg, rgb(198, 238, 184) 30%, rgb(180, 196, 159) 100%);background: -ms-linear-gradient(90deg, rgb(198, 238, 184) 30%, rgb(180, 196, 159) 100%);background: linear-gradient(180deg, rgb(198, 238, 184) 30%, rgb(180, 196, 159) 100%);box-shadow: 0 3px 4px -3px #ccc;}office|annotation > dc|creator {display: block;font-size: 10pt;font-weight: normal;font-style: normal;font-family: sans-serif;color: white;background-color: brown;padding: 4px;}office|annotation > dc|date {display: block;font-size: 10pt;font-weight: normal;font-style: normal;font-family: sans-serif;border: 4px solid transparent;color: black;}office|annotation > text|list {display: block;padding: 5px;}office|annotation text|p {font-size: 10pt;color: black;font-weight: normal;font-style: normal;text-decoration: none;font-family: sans-serif;}#annotationsPane {background-color: #EAEAEA;width: 4cm;height: 100%;display: none;position: absolute;outline: 1px solid #ccc;}.webodf-annotationHighlight {background-color: yellow;position: relative;}.webodf-selectionOverlay {position: absolute;pointer-events: none;top: 0;left: 0;top: 0;left: 0;width: 100%;height: 100%;z-index: 15;}.webodf-selectionOverlay > polygon {fill-opacity: 0.3;stroke-opacity: 0.8;stroke-width: 1;fill-rule: evenodd;}.webodf-selectionOverlay > .webodf-draggable {fill-opacity: 0.8;stroke-opacity: 0;stroke-width: 8;pointer-events: all;display: none;-moz-transform-origin: center center;-webkit-transform-origin: center center;-ms-transform-origin: center center;transform-origin: center center;}#imageSelector {display: none;position: absolute;border-style: solid;border-color: black;}#imageSelector > div {width: 5px;height: 5px;display: block;position: absolute;border: 1px solid black;background-color: #ffffff;}#imageSelector > .topLeft {top: -4px;left: -4px;}#imageSelector > .topRight {top: -4px;right: -4px;}#imageSelector > .bottomRight {right: -4px;bottom: -4px;}#imageSelector > .bottomLeft {bottom: -4px;left: -4px;}#imageSelector > .topMiddle {top: -4px;left: 50%;margin-left: -2.5px;}#imageSelector > .rightMiddle {top: 50%;right: -4px;margin-top: -2.5px;}#imageSelector > .bottomMiddle {bottom: -4px;left: 50%;margin-left: -2.5px;}#imageSelector > .leftMiddle {top: 50%;left: -4px;margin-top: -2.5px;}div.webodf-customScrollbars::-webkit-scrollbar{width: 8px;height: 8px;background-color: transparent;}div.webodf-customScrollbars::-webkit-scrollbar-track{background-color: transparent;}div.webodf-customScrollbars::-webkit-scrollbar-thumb{background-color: #444;border-radius: 4px;}.webodf-hyperlinkTooltip {display: none;color: white;background-color: black;border-radius: 5px;box-shadow: 2px 2px 5px gray;padding: 3px;position: absolute;max-width: 210px;text-align: left;word-break: break-all;z-index: 16;}.webodf-hyperlinkTooltipText {display: block;font-weight: bold;}';
	/*

	 @licstart
	JSZip - A Javascript class for generating and reading zip files
	<http://stuartk.com/jszip>

	(c) 2009-2014 Stuart Knightley <stuart [at] stuartk.com>
	Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.

	JSZip uses the library pako released under the MIT license :
	https://github.com/nodeca/pako/blob/master/LICENSE
	 @licend
	*/
	!function(e) {
	    var globalScope = typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {}
	      , externs = globalScope.externs || (globalScope.externs = {});
	    externs.JSZip = e()
	}(function() {
	    var define, module, exports;
	    return function e(t, n, r) {
	        function s(o, u) {
	            if (!n[o]) {
	                if (!t[o]) {
	                    var a = typeof require == "function" && require;
	                    if (!u && a)
	                        return a(o, !0);
	                    if (i)
	                        return i(o, !0);
	                    throw new Error("Cannot find module '" + o + "'");
	                }
	                var f = n[o] = {
	                    exports: {}
	                };
	                t[o][0].call(f.exports, function(e) {
	                    var n = t[o][1][e];
	                    return s(n ? n : e)
	                }, f, f.exports, e, t, n, r)
	            }
	            return n[o].exports
	        }
	        var i = typeof require == "function" && require;
	        for (var o = 0; o < r.length; o++)
	            s(r[o]);
	        return s
	    }({
	        1: [function(_dereq_, module, exports) {
	            var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
	            exports.encode = function(input, utf8) {
	                var output = "";
	                var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
	                var i = 0;
	                while (i < input.length) {
	                    chr1 = input.charCodeAt(i++);
	                    chr2 = input.charCodeAt(i++);
	                    chr3 = input.charCodeAt(i++);
	                    enc1 = chr1 >> 2;
	                    enc2 = (chr1 & 3) << 4 | chr2 >> 4;
	                    enc3 = (chr2 & 15) << 2 | chr3 >> 6;
	                    enc4 = chr3 & 63;
	                    if (isNaN(chr2))
	                        enc3 = enc4 = 64;
	                    else if (isNaN(chr3))
	                        enc4 = 64;
	                    output = output + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4)
	                }
	                return output
	            }
	            ;
	            exports.decode = function(input, utf8) {
	                var output = "";
	                var chr1, chr2, chr3;
	                var enc1, enc2, enc3, enc4;
	                var i = 0;
	                input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
	                while (i < input.length) {
	                    enc1 = _keyStr.indexOf(input.charAt(i++));
	                    enc2 = _keyStr.indexOf(input.charAt(i++));
	                    enc3 = _keyStr.indexOf(input.charAt(i++));
	                    enc4 = _keyStr.indexOf(input.charAt(i++));
	                    chr1 = enc1 << 2 | enc2 >> 4;
	                    chr2 = (enc2 & 15) << 4 | enc3 >> 2;
	                    chr3 = (enc3 & 3) << 6 | enc4;
	                    output = output + String.fromCharCode(chr1);
	                    if (enc3 != 64)
	                        output = output + String.fromCharCode(chr2);
	                    if (enc4 != 64)
	                        output = output + String.fromCharCode(chr3)
	                }
	                return output
	            }
	        }
	        , {}],
	        2: [function(_dereq_, module, exports) {
	            function CompressedObject() {
	                this.compressedSize = 0;
	                this.uncompressedSize = 0;
	                this.crc32 = 0;
	                this.compressionMethod = null;
	                this.compressedContent = null
	            }
	            CompressedObject.prototype = {
	                getContent: function() {
	                    return null
	                },
	                getCompressedContent: function() {
	                    return null
	                }
	            };
	            module.exports = CompressedObject
	        }
	        , {}],
	        3: [function(_dereq_, module, exports) {
	            exports.STORE = {
	                magic: "\x00\x00",
	                compress: function(content) {
	                    return content
	                },
	                uncompress: function(content) {
	                    return content
	                },
	                compressInputType: null,
	                uncompressInputType: null
	            };
	            exports.DEFLATE = _dereq_("./flate")
	        }
	        , {
	            "./flate": 8
	        }],
	        4: [function(_dereq_, module, exports) {
	            var utils = _dereq_("./utils");
	            var table = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918E3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117];
	            module.exports = function crc32(input, crc) {
	                if (typeof input === "undefined" || !input.length)
	                    return 0;
	                var isArray = utils.getTypeOf(input) !== "string";
	                if (typeof crc == "undefined")
	                    crc = 0;
	                var x = 0;
	                var y = 0;
	                var b = 0;
	                crc = crc ^ -1;
	                for (var i = 0, iTop = input.length; i < iTop; i++) {
	                    b = isArray ? input[i] : input.charCodeAt(i);
	                    y = (crc ^ b) & 255;
	                    x = table[y];
	                    crc = crc >>> 8 ^ x
	                }
	                return crc ^ -1
	            }
	        }
	        , {
	            "./utils": 21
	        }],
	        5: [function(_dereq_, module, exports) {
	            var utils = _dereq_("./utils");
	            function DataReader(data) {
	                this.data = null;
	                this.length = 0;
	                this.index = 0
	            }
	            DataReader.prototype = {
	                checkOffset: function(offset) {
	                    this.checkIndex(this.index + offset)
	                },
	                checkIndex: function(newIndex) {
	                    if (this.length < newIndex || newIndex < 0)
	                        throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?");
	                },
	                setIndex: function(newIndex) {
	                    this.checkIndex(newIndex);
	                    this.index = newIndex
	                },
	                skip: function(n) {
	                    this.setIndex(this.index + n)
	                },
	                byteAt: function(i) {},
	                readInt: function(size) {
	                    var result = 0, i;
	                    this.checkOffset(size);
	                    for (i = this.index + size - 1; i >= this.index; i--)
	                        result = (result << 8) + this.byteAt(i);
	                    this.index += size;
	                    return result
	                },
	                readString: function(size) {
	                    return utils.transformTo("string", this.readData(size))
	                },
	                readData: function(size) {},
	                lastIndexOfSignature: function(sig) {},
	                readDate: function() {
	                    var dostime = this.readInt(4);
	                    return new Date((dostime >> 25 & 127) + 1980,(dostime >> 21 & 15) - 1,dostime >> 16 & 31,dostime >> 11 & 31,dostime >> 5 & 63,(dostime & 31) << 1)
	                }
	            };
	            module.exports = DataReader
	        }
	        , {
	            "./utils": 21
	        }],
	        6: [function(_dereq_, module, exports) {
	            exports.base64 = false;
	            exports.binary = false;
	            exports.dir = false;
	            exports.createFolders = false;
	            exports.date = null;
	            exports.compression = null;
	            exports.comment = null
	        }
	        , {}],
	        7: [function(_dereq_, module, exports) {
	            var utils = _dereq_("./utils");
	            exports.string2binary = function(str) {
	                return utils.string2binary(str)
	            }
	            ;
	            exports.string2Uint8Array = function(str) {
	                return utils.transformTo("uint8array", str)
	            }
	            ;
	            exports.uint8Array2String = function(array) {
	                return utils.transformTo("string", array)
	            }
	            ;
	            exports.string2Blob = function(str) {
	                var buffer = utils.transformTo("arraybuffer", str);
	                return utils.arrayBuffer2Blob(buffer)
	            }
	            ;
	            exports.arrayBuffer2Blob = function(buffer) {
	                return utils.arrayBuffer2Blob(buffer)
	            }
	            ;
	            exports.transformTo = function(outputType, input) {
	                return utils.transformTo(outputType, input)
	            }
	            ;
	            exports.getTypeOf = function(input) {
	                return utils.getTypeOf(input)
	            }
	            ;
	            exports.checkSupport = function(type) {
	                return utils.checkSupport(type)
	            }
	            ;
	            exports.MAX_VALUE_16BITS = utils.MAX_VALUE_16BITS;
	            exports.MAX_VALUE_32BITS = utils.MAX_VALUE_32BITS;
	            exports.pretty = function(str) {
	                return utils.pretty(str)
	            }
	            ;
	            exports.findCompression = function(compressionMethod) {
	                return utils.findCompression(compressionMethod)
	            }
	            ;
	            exports.isRegExp = function(object) {
	                return utils.isRegExp(object)
	            }
	        }
	        , {
	            "./utils": 21
	        }],
	        8: [function(_dereq_, module, exports) {
	            var USE_TYPEDARRAY = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Uint32Array !== "undefined";
	            var pako = _dereq_("pako");
	            exports.uncompressInputType = USE_TYPEDARRAY ? "uint8array" : "array";
	            exports.compressInputType = USE_TYPEDARRAY ? "uint8array" : "array";
	            exports.magic = "\b\x00";
	            exports.compress = function(input) {
	                return pako.deflateRaw(input)
	            }
	            ;
	            exports.uncompress = function(input) {
	                return pako.inflateRaw(input)
	            }
	        }
	        , {
	            "pako": 24
	        }],
	        9: [function(_dereq_, module, exports) {
	            var base64 = _dereq_("./base64");
	            function JSZip(data, options) {
	                if (!(this instanceof JSZip))
	                    return new JSZip(data,options);
	                this.files = {};
	                this.comment = null;
	                this.root = "";
	                if (data)
	                    this.load(data, options);
	                this.clone = function() {
	                    var newObj = new JSZip;
	                    for (var i in this)
	                        if (typeof this[i] !== "function")
	                            newObj[i] = this[i];
	                    return newObj
	                }
	            }
	            JSZip.prototype = _dereq_("./object");
	            JSZip.prototype.load = _dereq_("./load");
	            JSZip.support = _dereq_("./support");
	            JSZip.defaults = _dereq_("./defaults");
	            JSZip.utils = _dereq_("./deprecatedPublicUtils");
	            JSZip.base64 = {
	                encode: function(input) {
	                    return base64.encode(input)
	                },
	                decode: function(input) {
	                    return base64.decode(input)
	                }
	            };
	            JSZip.compressions = _dereq_("./compressions");
	            module.exports = JSZip
	        }
	        , {
	            "./base64": 1,
	            "./compressions": 3,
	            "./defaults": 6,
	            "./deprecatedPublicUtils": 7,
	            "./load": 10,
	            "./object": 13,
	            "./support": 17
	        }],
	        10: [function(_dereq_, module, exports) {
	            var base64 = _dereq_("./base64");
	            var ZipEntries = _dereq_("./zipEntries");
	            module.exports = function(data, options) {
	                var files, zipEntries, i, input;
	                options = options || {};
	                if (options.base64)
	                    data = base64.decode(data);
	                zipEntries = new ZipEntries(data,options);
	                files = zipEntries.files;
	                for (i = 0; i < files.length; i++) {
	                    input = files[i];
	                    this.file(input.fileName, input.decompressed, {
	                        binary: true,
	                        optimizedBinaryString: true,
	                        date: input.date,
	                        dir: input.dir,
	                        comment: input.fileComment.length ? input.fileComment : null,
	                        createFolders: options.createFolders
	                    })
	                }
	                if (zipEntries.zipComment.length)
	                    this.comment = zipEntries.zipComment;
	                return this
	            }
	        }
	        , {
	            "./base64": 1,
	            "./zipEntries": 22
	        }],
	        11: [function(_dereq_, module, exports) {
	            (function(Buffer) {
	                module.exports = function(data, encoding) {
	                    return new Buffer(data,encoding)
	                }
	                ;
	                module.exports.test = function(b) {
	                    return Buffer.isBuffer(b)
	                }
	            }
	            ).call(this, typeof Buffer !== "undefined" ? Buffer : undefined)
	        }
	        , {}],
	        12: [function(_dereq_, module, exports) {
	            var Uint8ArrayReader = _dereq_("./uint8ArrayReader");
	            function NodeBufferReader(data) {
	                this.data = data;
	                this.length = this.data.length;
	                this.index = 0
	            }
	            NodeBufferReader.prototype = new Uint8ArrayReader;
	            NodeBufferReader.prototype.readData = function(size) {
	                this.checkOffset(size);
	                var result = this.data.slice(this.index, this.index + size);
	                this.index += size;
	                return result
	            }
	            ;
	            module.exports = NodeBufferReader
	        }
	        , {
	            "./uint8ArrayReader": 18
	        }],
	        13: [function(_dereq_, module, exports) {
	            var support = _dereq_("./support");
	            var utils = _dereq_("./utils");
	            var crc32 = _dereq_("./crc32");
	            var signature = _dereq_("./signature");
	            var defaults = _dereq_("./defaults");
	            var base64 = _dereq_("./base64");
	            var compressions = _dereq_("./compressions");
	            var CompressedObject = _dereq_("./compressedObject");
	            var nodeBuffer = _dereq_("./nodeBuffer");
	            var utf8 = _dereq_("./utf8");
	            var StringWriter = _dereq_("./stringWriter");
	            var Uint8ArrayWriter = _dereq_("./uint8ArrayWriter");
	            var getRawData = function(file) {
	                if (file._data instanceof CompressedObject) {
	                    file._data = file._data.getContent();
	                    file.options.binary = true;
	                    file.options.base64 = false;
	                    if (utils.getTypeOf(file._data) === "uint8array") {
	                        var copy = file._data;
	                        file._data = new Uint8Array(copy.length);
	                        if (copy.length !== 0)
	                            file._data.set(copy, 0)
	                    }
	                }
	                return file._data
	            };
	            var getBinaryData = function(file) {
	                var result = getRawData(file)
	                  , type = utils.getTypeOf(result);
	                if (type === "string") {
	                    if (!file.options.binary)
	                        if (support.nodebuffer)
	                            return nodeBuffer(result, "utf-8");
	                    return file.asBinary()
	                }
	                return result
	            };
	            var dataToString = function(asUTF8) {
	                var result = getRawData(this);
	                if (result === null || typeof result === "undefined")
	                    return "";
	                if (this.options.base64)
	                    result = base64.decode(result);
	                if (asUTF8 && this.options.binary)
	                    result = out.utf8decode(result);
	                else
	                    result = utils.transformTo("string", result);
	                if (!asUTF8 && !this.options.binary)
	                    result = utils.transformTo("string", out.utf8encode(result));
	                return result
	            };
	            var ZipObject = function(name, data, options) {
	                this.name = name;
	                this.dir = options.dir;
	                this.date = options.date;
	                this.comment = options.comment;
	                this._data = data;
	                this.options = options;
	                this._initialMetadata = {
	                    dir: options.dir,
	                    date: options.date
	                }
	            };
	            ZipObject.prototype = {
	                asText: function() {
	                    return dataToString.call(this, true)
	                },
	                asBinary: function() {
	                    return dataToString.call(this, false)
	                },
	                asNodeBuffer: function() {
	                    var result = getBinaryData(this);
	                    return utils.transformTo("nodebuffer", result)
	                },
	                asUint8Array: function() {
	                    var result = getBinaryData(this);
	                    return utils.transformTo("uint8array", result)
	                },
	                asArrayBuffer: function() {
	                    return this.asUint8Array().buffer
	                }
	            };
	            var decToHex = function(dec, bytes) {
	                var hex = "", i;
	                for (i = 0; i < bytes; i++) {
	                    hex += String.fromCharCode(dec & 255);
	                    dec = dec >>> 8
	                }
	                return hex
	            };
	            var extend = function() {
	                var result = {}, i, attr;
	                for (i = 0; i < arguments.length; i++)
	                    for (attr in arguments[i])
	                        if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === "undefined")
	                            result[attr] = arguments[i][attr];
	                return result
	            };
	            var prepareFileAttrs = function(o) {
	                o = o || {};
	                if (o.base64 === true && (o.binary === null || o.binary === undefined))
	                    o.binary = true;
	                o = extend(o, defaults);
	                o.date = o.date || new Date;
	                if (o.compression !== null)
	                    o.compression = o.compression.toUpperCase();
	                return o
	            };
	            var fileAdd = function(name, data, o) {
	                var dataType = utils.getTypeOf(data), parent;
	                o = prepareFileAttrs(o);
	                if (o.createFolders && (parent = parentFolder(name)))
	                    folderAdd.call(this, parent, true);
	                if (o.dir || data === null || typeof data === "undefined") {
	                    o.base64 = false;
	                    o.binary = false;
	                    data = null
	                } else if (dataType === "string") {
	                    if (o.binary && !o.base64)
	                        if (o.optimizedBinaryString !== true)
	                            data = utils.string2binary(data)
	                } else {
	                    o.base64 = false;
	                    o.binary = true;
	                    if (!dataType && !(data instanceof CompressedObject))
	                        throw new Error("The data of '" + name + "' is in an unsupported format !");
	                    if (dataType === "arraybuffer")
	                        data = utils.transformTo("uint8array", data)
	                }
	                var object = new ZipObject(name,data,o);
	                this.files[name] = object;
	                return object
	            };
	            var parentFolder = function(path) {
	                if (path.slice(-1) == "/")
	                    path = path.substring(0, path.length - 1);
	                var lastSlash = path.lastIndexOf("/");
	                return lastSlash > 0 ? path.substring(0, lastSlash) : ""
	            };
	            var folderAdd = function(name, createFolders) {
	                if (name.slice(-1) != "/")
	                    name += "/";
	                createFolders = typeof createFolders !== "undefined" ? createFolders : false;
	                if (!this.files[name])
	                    fileAdd.call(this, name, null, {
	                        dir: true,
	                        createFolders: createFolders
	                    });
	                return this.files[name]
	            };
	            var generateCompressedObjectFrom = function(file, compression) {
	                var result = new CompressedObject, content;
	                if (file._data instanceof CompressedObject) {
	                    result.uncompressedSize = file._data.uncompressedSize;
	                    result.crc32 = file._data.crc32;
	                    if (result.uncompressedSize === 0 || file.dir) {
	                        compression = compressions["STORE"];
	                        result.compressedContent = "";
	                        result.crc32 = 0
	                    } else if (file._data.compressionMethod === compression.magic)
	                        result.compressedContent = file._data.getCompressedContent();
	                    else {
	                        content = file._data.getContent();
	                        result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content))
	                    }
	                } else {
	                    content = getBinaryData(file);
	                    if (!content || content.length === 0 || file.dir) {
	                        compression = compressions["STORE"];
	                        content = ""
	                    }
	                    result.uncompressedSize = content.length;
	                    result.crc32 = crc32(content);
	                    result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content))
	                }
	                result.compressedSize = result.compressedContent.length;
	                result.compressionMethod = compression.magic;
	                return result
	            };
	            var generateZipParts = function(name, file, compressedObject, offset) {
	                var data = compressedObject.compressedContent, utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)), comment = file.comment || "", utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)), useUTF8ForFileName = utfEncodedFileName.length !== file.name.length, useUTF8ForComment = utfEncodedComment.length !== comment.length, o = file.options, dosTime, dosDate, extraFields = "", unicodePathExtraField = "", unicodeCommentExtraField = "", dir, date;
	                if (file._initialMetadata.dir !== file.dir)
	                    dir = file.dir;
	                else
	                    dir = o.dir;
	                if (file._initialMetadata.date !== file.date)
	                    date = file.date;
	                else
	                    date = o.date;
	                dosTime = date.getHours();
	                dosTime = dosTime << 6;
	                dosTime = dosTime | date.getMinutes();
	                dosTime = dosTime << 5;
	                dosTime = dosTime | date.getSeconds() / 2;
	                dosDate = date.getFullYear() - 1980;
	                dosDate = dosDate << 4;
	                dosDate = dosDate | date.getMonth() + 1;
	                dosDate = dosDate << 5;
	                dosDate = dosDate | date.getDate();
	                if (useUTF8ForFileName) {
	                    unicodePathExtraField = decToHex(1, 1) + decToHex(crc32(utfEncodedFileName), 4) + utfEncodedFileName;
	                    extraFields += "up" + decToHex(unicodePathExtraField.length, 2) + unicodePathExtraField
	                }
	                if (useUTF8ForComment) {
	                    unicodeCommentExtraField = decToHex(1, 1) + decToHex(this.crc32(utfEncodedComment), 4) + utfEncodedComment;
	                    extraFields += "uc" + decToHex(unicodeCommentExtraField.length, 2) + unicodeCommentExtraField
	                }
	                var header = "";
	                header += "\n\x00";
	                header += useUTF8ForFileName || useUTF8ForComment ? "\x00\b" : "\x00\x00";
	                header += compressedObject.compressionMethod;
	                header += decToHex(dosTime, 2);
	                header += decToHex(dosDate, 2);
	                header += decToHex(compressedObject.crc32, 4);
	                header += decToHex(compressedObject.compressedSize, 4);
	                header += decToHex(compressedObject.uncompressedSize, 4);
	                header += decToHex(utfEncodedFileName.length, 2);
	                header += decToHex(extraFields.length, 2);
	                var fileRecord = signature.LOCAL_FILE_HEADER + header + utfEncodedFileName + extraFields;
	                var dirRecord = signature.CENTRAL_FILE_HEADER + "\u0014\x00" + header + decToHex(utfEncodedComment.length, 2) + "\x00\x00" + "\x00\x00" + (dir === true ? "\u0010\x00\x00\x00" : "\x00\x00\x00\x00") + decToHex(offset, 4) + utfEncodedFileName + extraFields + utfEncodedComment;
	                return {
	                    fileRecord: fileRecord,
	                    dirRecord: dirRecord,
	                    compressedObject: compressedObject
	                }
	            };
	            var out = {
	                load: function(stream, options) {
	                    throw new Error("Load method is not defined. Is the file jszip-load.js included ?");
	                },
	                filter: function(search) {
	                    var result = [], filename, relativePath, file, fileClone;
	                    for (filename in this.files) {
	                        if (!this.files.hasOwnProperty(filename))
	                            continue;
	                        file = this.files[filename];
	                        fileClone = new ZipObject(file.name,file._data,extend(file.options));
	                        relativePath = filename.slice(this.root.length, filename.length);
	                        if (filename.slice(0, this.root.length) === this.root && search(relativePath, fileClone))
	                            result.push(fileClone)
	                    }
	                    return result
	                },
	                file: function(name, data, o) {
	                    if (arguments.length === 1)
	                        if (utils.isRegExp(name)) {
	                            var regexp = name;
	                            return this.filter(function(relativePath, file) {
	                                return !file.dir && regexp.test(relativePath)
	                            })
	                        } else
	                            return this.filter(function(relativePath, file) {
	                                return !file.dir && relativePath === name
	                            })[0] || null;
	                    else {
	                        name = this.root + name;
	                        fileAdd.call(this, name, data, o)
	                    }
	                    return this
	                },
	                folder: function(arg) {
	                    if (!arg)
	                        return this;
	                    if (utils.isRegExp(arg))
	                        return this.filter(function(relativePath, file) {
	                            return file.dir && arg.test(relativePath)
	                        });
	                    var name = this.root + arg;
	                    var newFolder = folderAdd.call(this, name);
	                    var ret = this.clone();
	                    ret.root = newFolder.name;
	                    return ret
	                },
	                remove: function(name) {
	                    name = this.root + name;
	                    var file = this.files[name];
	                    if (!file) {
	                        if (name.slice(-1) != "/")
	                            name += "/";
	                        file = this.files[name]
	                    }
	                    if (file && !file.dir)
	                        delete this.files[name];
	                    else {
	                        var kids = this.filter(function(relativePath, file) {
	                            return file.name.slice(0, name.length) === name
	                        });
	                        for (var i = 0; i < kids.length; i++)
	                            delete this.files[kids[i].name]
	                    }
	                    return this
	                },
	                generate: function(options) {
	                    options = extend(options || {}, {
	                        base64: true,
	                        compression: "STORE",
	                        type: "base64",
	                        comment: null
	                    });
	                    utils.checkSupport(options.type);
	                    var zipData = [], localDirLength = 0, centralDirLength = 0, writer, i, utfEncodedComment = utils.transformTo("string", this.utf8encode(options.comment || this.comment || ""));
	                    for (var name in this.files) {
	                        if (!this.files.hasOwnProperty(name))
	                            continue;
	                        var file = this.files[name];
	                        var compressionName = file.options.compression || options.compression.toUpperCase();
	                        var compression = compressions[compressionName];
	                        if (!compression)
	                            throw new Error(compressionName + " is not a valid compression method !");
	                        var compressedObject = generateCompressedObjectFrom.call(this, file, compression);
	                        var zipPart = generateZipParts.call(this, name, file, compressedObject, localDirLength);
	                        localDirLength += zipPart.fileRecord.length + compressedObject.compressedSize;
	                        centralDirLength += zipPart.dirRecord.length;
	                        zipData.push(zipPart)
	                    }
	                    var dirEnd = "";
	                    dirEnd = signature.CENTRAL_DIRECTORY_END + "\x00\x00" + "\x00\x00" + decToHex(zipData.length, 2) + decToHex(zipData.length, 2) + decToHex(centralDirLength, 4) + decToHex(localDirLength, 4) + decToHex(utfEncodedComment.length, 2) + utfEncodedComment;
	                    var typeName = options.type.toLowerCase();
	                    if (typeName === "uint8array" || typeName === "arraybuffer" || typeName === "blob" || typeName === "nodebuffer")
	                        writer = new Uint8ArrayWriter(localDirLength + centralDirLength + dirEnd.length);
	                    else
	                        writer = new StringWriter(localDirLength + centralDirLength + dirEnd.length);
	                    for (i = 0; i < zipData.length; i++) {
	                        writer.append(zipData[i].fileRecord);
	                        writer.append(zipData[i].compressedObject.compressedContent)
	                    }
	                    for (i = 0; i < zipData.length; i++)
	                        writer.append(zipData[i].dirRecord);
	                    writer.append(dirEnd);
	                    var zip = writer.finalize();
	                    switch (options.type.toLowerCase()) {
	                    case "uint8array":
	                    case "arraybuffer":
	                    case "nodebuffer":
	                        return utils.transformTo(options.type.toLowerCase(), zip);
	                    case "blob":
	                        return utils.arrayBuffer2Blob(utils.transformTo("arraybuffer", zip));
	                    case "base64":
	                        return options.base64 ? base64.encode(zip) : zip;
	                    default:
	                        return zip
	                    }
	                },
	                crc32: function(input, crc) {
	                    return crc32(input, crc)
	                },
	                utf8encode: function(string) {
	                    return utils.transformTo("string", utf8.utf8encode(string))
	                },
	                utf8decode: function(input) {
	                    return utf8.utf8decode(input)
	                }
	            };
	            module.exports = out
	        }
	        , {
	            "./base64": 1,
	            "./compressedObject": 2,
	            "./compressions": 3,
	            "./crc32": 4,
	            "./defaults": 6,
	            "./nodeBuffer": 11,
	            "./signature": 14,
	            "./stringWriter": 16,
	            "./support": 17,
	            "./uint8ArrayWriter": 19,
	            "./utf8": 20,
	            "./utils": 21
	        }],
	        14: [function(_dereq_, module, exports) {
	            exports.LOCAL_FILE_HEADER = "PK\u0003\u0004";
	            exports.CENTRAL_FILE_HEADER = "PK\u0001\u0002";
	            exports.CENTRAL_DIRECTORY_END = "PK\u0005\u0006";
	            exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\u0006\u0007";
	            exports.ZIP64_CENTRAL_DIRECTORY_END = "PK\u0006\u0006";
	            exports.DATA_DESCRIPTOR = "PK\u0007\b"
	        }
	        , {}],
	        15: [function(_dereq_, module, exports) {
	            var DataReader = _dereq_("./dataReader");
	            var utils = _dereq_("./utils");
	            function StringReader(data, optimizedBinaryString) {
	                this.data = data;
	                if (!optimizedBinaryString)
	                    this.data = utils.string2binary(this.data);
	                this.length = this.data.length;
	                this.index = 0
	            }
	            StringReader.prototype = new DataReader;
	            StringReader.prototype.byteAt = function(i) {
	                return this.data.charCodeAt(i)
	            }
	            ;
	            StringReader.prototype.lastIndexOfSignature = function(sig) {
	                return this.data.lastIndexOf(sig)
	            }
	            ;
	            StringReader.prototype.readData = function(size) {
	                this.checkOffset(size);
	                var result = this.data.slice(this.index, this.index + size);
	                this.index += size;
	                return result
	            }
	            ;
	            module.exports = StringReader
	        }
	        , {
	            "./dataReader": 5,
	            "./utils": 21
	        }],
	        16: [function(_dereq_, module, exports) {
	            var utils = _dereq_("./utils");
	            var StringWriter = function() {
	                this.data = []
	            };
	            StringWriter.prototype = {
	                append: function(input) {
	                    input = utils.transformTo("string", input);
	                    this.data.push(input)
	                },
	                finalize: function() {
	                    return this.data.join("")
	                }
	            };
	            module.exports = StringWriter
	        }
	        , {
	            "./utils": 21
	        }],
	        17: [function(_dereq_, module, exports) {
	            (function(Buffer) {
	                exports.base64 = true;
	                exports.array = true;
	                exports.string = true;
	                exports.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
	                exports.nodebuffer = typeof Buffer !== "undefined";
	                exports.uint8array = typeof Uint8Array !== "undefined";
	                if (typeof ArrayBuffer === "undefined")
	                    exports.blob = false;
	                else {
	                    var buffer = new ArrayBuffer(0);
	                    try {
	                        exports.blob = (new Blob([buffer],{
	                            type: "application/zip"
	                        })).size === 0
	                    } catch (e) {
	                        try {
	                            var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
	                            var builder = new Builder;
	                            builder.append(buffer);
	                            exports.blob = builder.getBlob("application/zip").size === 0
	                        } catch (e) {
	                            exports.blob = false
	                        }
	                    }
	                }
	            }
	            ).call(this, typeof Buffer !== "undefined" ? Buffer : undefined)
	        }
	        , {}],
	        18: [function(_dereq_, module, exports) {
	            var DataReader = _dereq_("./dataReader");
	            function Uint8ArrayReader(data) {
	                if (data) {
	                    this.data = data;
	                    this.length = this.data.length;
	                    this.index = 0
	                }
	            }
	            Uint8ArrayReader.prototype = new DataReader;
	            Uint8ArrayReader.prototype.byteAt = function(i) {
	                return this.data[i]
	            }
	            ;
	            Uint8ArrayReader.prototype.lastIndexOfSignature = function(sig) {
	                var sig0 = sig.charCodeAt(0)
	                  , sig1 = sig.charCodeAt(1)
	                  , sig2 = sig.charCodeAt(2)
	                  , sig3 = sig.charCodeAt(3);
	                for (var i = this.length - 4; i >= 0; --i)
	                    if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3)
	                        return i;
	                return -1
	            }
	            ;
	            Uint8ArrayReader.prototype.readData = function(size) {
	                this.checkOffset(size);
	                if (size === 0)
	                    return new Uint8Array(0);
	                var result = this.data.subarray(this.index, this.index + size);
	                this.index += size;
	                return result
	            }
	            ;
	            module.exports = Uint8ArrayReader
	        }
	        , {
	            "./dataReader": 5
	        }],
	        19: [function(_dereq_, module, exports) {
	            var utils = _dereq_("./utils");
	            var Uint8ArrayWriter = function(length) {
	                this.data = new Uint8Array(length);
	                this.index = 0
	            };
	            Uint8ArrayWriter.prototype = {
	                append: function(input) {
	                    if (input.length !== 0) {
	                        input = utils.transformTo("uint8array", input);
	                        this.data.set(input, this.index);
	                        this.index += input.length
	                    }
	                },
	                finalize: function() {
	                    return this.data
	                }
	            };
	            module.exports = Uint8ArrayWriter
	        }
	        , {
	            "./utils": 21
	        }],
	        20: [function(_dereq_, module, exports) {
	            var utils = _dereq_("./utils");
	            var support = _dereq_("./support");
	            var nodeBuffer = _dereq_("./nodeBuffer");
	            var _utf8len = new Array(256);
	            for (var i = 0; i < 256; i++)
	                _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;
	            _utf8len[254] = _utf8len[254] = 1;
	            var string2buf = function(str) {
	                var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
	                for (m_pos = 0; m_pos < str_len; m_pos++) {
	                    c = str.charCodeAt(m_pos);
	                    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
	                        c2 = str.charCodeAt(m_pos + 1);
	                        if ((c2 & 64512) === 56320) {
	                            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
	                            m_pos++
	                        }
	                    }
	                    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4
	                }
	                if (support.uint8array)
	                    buf = new Uint8Array(buf_len);
	                else
	                    buf = new Array(buf_len);
	                for (i = 0,
	                m_pos = 0; i < buf_len; m_pos++) {
	                    c = str.charCodeAt(m_pos);
	                    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
	                        c2 = str.charCodeAt(m_pos + 1);
	                        if ((c2 & 64512) === 56320) {
	                            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
	                            m_pos++
	                        }
	                    }
	                    if (c < 128)
	                        buf[i++] = c;
	                    else if (c < 2048) {
	                        buf[i++] = 192 | c >>> 6;
	                        buf[i++] = 128 | c & 63
	                    } else if (c < 65536) {
	                        buf[i++] = 224 | c >>> 12;
	                        buf[i++] = 128 | c >>> 6 & 63;
	                        buf[i++] = 128 | c & 63
	                    } else {
	                        buf[i++] = 240 | c >>> 18;
	                        buf[i++] = 128 | c >>> 12 & 63;
	                        buf[i++] = 128 | c >>> 6 & 63;
	                        buf[i++] = 128 | c & 63
	                    }
	                }
	                return buf
	            };
	            var utf8border = function(buf, max) {
	                var pos;
	                max = max || buf.length;
	                if (max > buf.length)
	                    max = buf.length;
	                pos = max - 1;
	                while (pos >= 0 && (buf[pos] & 192) === 128)
	                    pos--;
	                if (pos < 0)
	                    return max;
	                if (pos === 0)
	                    return max;
	                return pos + _utf8len[buf[pos]] > max ? pos : max
	            };
	            var buf2string = function(buf) {
	                var str, i, out, c, c_len;
	                var len = buf.length;
	                var utf16buf = new Array(len * 2);
	                for (out = 0,
	                i = 0; i < len; ) {
	                    c = buf[i++];
	                    if (c < 128) {
	                        utf16buf[out++] = c;
	                        continue
	                    }
	                    c_len = _utf8len[c];
	                    if (c_len > 4) {
	                        utf16buf[out++] = 65533;
	                        i += c_len - 1;
	                        continue
	                    }
	                    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
	                    while (c_len > 1 && i < len) {
	                        c = c << 6 | buf[i++] & 63;
	                        c_len--
	                    }
	                    if (c_len > 1) {
	                        utf16buf[out++] = 65533;
	                        continue
	                    }
	                    if (c < 65536)
	                        utf16buf[out++] = c;
	                    else {
	                        c -= 65536;
	                        utf16buf[out++] = 55296 | c >> 10 & 1023;
	                        utf16buf[out++] = 56320 | c & 1023
	                    }
	                }
	                if (utf16buf.length !== out)
	                    if (utf16buf.subarray)
	                        utf16buf = utf16buf.subarray(0, out);
	                    else
	                        utf16buf.length = out;
	                return utils.applyFromCharCode(utf16buf)
	            };
	            exports.utf8encode = function utf8encode(str) {
	                if (support.nodebuffer)
	                    return nodeBuffer(str, "utf-8");
	                return string2buf(str)
	            }
	            ;
	            exports.utf8decode = function utf8decode(buf) {
	                if (support.nodebuffer)
	                    return utils.transformTo("nodebuffer", buf).toString("utf-8");
	                buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);
	                var result = []
	                  , k = 0
	                  , len = buf.length
	                  , chunk = 65536;
	                while (k < len) {
	                    var nextBoundary = utf8border(buf, Math.min(k + chunk, len));
	                    if (support.uint8array)
	                        result.push(buf2string(buf.subarray(k, nextBoundary)));
	                    else
	                        result.push(buf2string(buf.slice(k, nextBoundary)));
	                    k = nextBoundary
	                }
	                return result.join("")
	            }
	        }
	        , {
	            "./nodeBuffer": 11,
	            "./support": 17,
	            "./utils": 21
	        }],
	        21: [function(_dereq_, module, exports) {
	            var support = _dereq_("./support");
	            var compressions = _dereq_("./compressions");
	            var nodeBuffer = _dereq_("./nodeBuffer");
	            exports.string2binary = function(str) {
	                var result = "";
	                for (var i = 0; i < str.length; i++)
	                    result += String.fromCharCode(str.charCodeAt(i) & 255);
	                return result
	            }
	            ;
	            exports.arrayBuffer2Blob = function(buffer) {
	                exports.checkSupport("blob");
	                try {
	                    return new Blob([buffer],{
	                        type: "application/zip"
	                    })
	                } catch (e) {
	                    try {
	                        var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
	                        var builder = new Builder;
	                        builder.append(buffer);
	                        return builder.getBlob("application/zip")
	                    } catch (e) {
	                        throw new Error("Bug : can't construct the Blob.");
	                    }
	                }
	            }
	            ;
	            function identity(input) {
	                return input
	            }
	            function stringToArrayLike(str, array) {
	                for (var i = 0; i < str.length; ++i)
	                    array[i] = str.charCodeAt(i) & 255;
	                return array
	            }
	            function arrayLikeToString(array) {
	                var chunk = 65536;
	                var result = []
	                  , len = array.length
	                  , type = exports.getTypeOf(array)
	                  , k = 0
	                  , canUseApply = true;
	                try {
	                    switch (type) {
	                    case "uint8array":
	                        String.fromCharCode.apply(null, new Uint8Array(0));
	                        break;
	                    case "nodebuffer":
	                        String.fromCharCode.apply(null, nodeBuffer(0));
	                        break
	                    }
	                } catch (e) {
	                    canUseApply = false
	                }
	                if (!canUseApply) {
	                    var resultStr = "";
	                    for (var i = 0; i < array.length; i++)
	                        resultStr += String.fromCharCode(array[i]);
	                    return resultStr
	                }
	                while (k < len && chunk > 1)
	                    try {
	                        if (type === "array" || type === "nodebuffer")
	                            result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
	                        else
	                            result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
	                        k += chunk
	                    } catch (e) {
	                        chunk = Math.floor(chunk / 2)
	                    }
	                return result.join("")
	            }
	            exports.applyFromCharCode = arrayLikeToString;
	            function arrayLikeToArrayLike(arrayFrom, arrayTo) {
	                for (var i = 0; i < arrayFrom.length; i++)
	                    arrayTo[i] = arrayFrom[i];
	                return arrayTo
	            }
	            var transform = {};
	            transform["string"] = {
	                "string": identity,
	                "array": function(input) {
	                    return stringToArrayLike(input, new Array(input.length))
	                },
	                "arraybuffer": function(input) {
	                    return transform["string"]["uint8array"](input).buffer
	                },
	                "uint8array": function(input) {
	                    return stringToArrayLike(input, new Uint8Array(input.length))
	                },
	                "nodebuffer": function(input) {
	                    return stringToArrayLike(input, nodeBuffer(input.length))
	                }
	            };
	            transform["array"] = {
	                "string": arrayLikeToString,
	                "array": identity,
	                "arraybuffer": function(input) {
	                    return (new Uint8Array(input)).buffer
	                },
	                "uint8array": function(input) {
	                    return new Uint8Array(input)
	                },
	                "nodebuffer": function(input) {
	                    return nodeBuffer(input)
	                }
	            };
	            transform["arraybuffer"] = {
	                "string": function(input) {
	                    return arrayLikeToString(new Uint8Array(input))
	                },
	                "array": function(input) {
	                    return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength))
	                },
	                "arraybuffer": identity,
	                "uint8array": function(input) {
	                    return new Uint8Array(input)
	                },
	                "nodebuffer": function(input) {
	                    return nodeBuffer(new Uint8Array(input))
	                }
	            };
	            transform["uint8array"] = {
	                "string": arrayLikeToString,
	                "array": function(input) {
	                    return arrayLikeToArrayLike(input, new Array(input.length))
	                },
	                "arraybuffer": function(input) {
	                    return input.buffer
	                },
	                "uint8array": identity,
	                "nodebuffer": function(input) {
	                    return nodeBuffer(input)
	                }
	            };
	            transform["nodebuffer"] = {
	                "string": arrayLikeToString,
	                "array": function(input) {
	                    return arrayLikeToArrayLike(input, new Array(input.length))
	                },
	                "arraybuffer": function(input) {
	                    return transform["nodebuffer"]["uint8array"](input).buffer
	                },
	                "uint8array": function(input) {
	                    return arrayLikeToArrayLike(input, new Uint8Array(input.length))
	                },
	                "nodebuffer": identity
	            };
	            exports.transformTo = function(outputType, input) {
	                if (!input)
	                    input = "";
	                if (!outputType)
	                    return input;
	                exports.checkSupport(outputType);
	                var inputType = exports.getTypeOf(input);
	                var result = transform[inputType][outputType](input);
	                return result
	            }
	            ;
	            exports.getTypeOf = function(input) {
	                if (typeof input === "string")
	                    return "string";
	                if (Object.prototype.toString.call(input) === "[object Array]")
	                    return "array";
	                if (support.nodebuffer && nodeBuffer.test(input))
	                    return "nodebuffer";
	                if (support.uint8array && input instanceof Uint8Array)
	                    return "uint8array";
	                if (support.arraybuffer && input instanceof ArrayBuffer)
	                    return "arraybuffer"
	            }
	            ;
	            exports.checkSupport = function(type) {
	                var supported = support[type.toLowerCase()];
	                if (!supported)
	                    throw new Error(type + " is not supported by this browser");
	            }
	            ;
	            exports.MAX_VALUE_16BITS = 65535;
	            exports.MAX_VALUE_32BITS = -1;
	            exports.pretty = function(str) {
	                var res = "", code, i;
	                for (i = 0; i < (str || "").length; i++) {
	                    code = str.charCodeAt(i);
	                    res += "\\x" + (code < 16 ? "0" : "") + code.toString(16).toUpperCase()
	                }
	                return res
	            }
	            ;
	            exports.findCompression = function(compressionMethod) {
	                for (var method in compressions) {
	                    if (!compressions.hasOwnProperty(method))
	                        continue;
	                    if (compressions[method].magic === compressionMethod)
	                        return compressions[method]
	                }
	                return null
	            }
	            ;
	            exports.isRegExp = function(object) {
	                return Object.prototype.toString.call(object) === "[object RegExp]"
	            }
	        }
	        , {
	            "./compressions": 3,
	            "./nodeBuffer": 11,
	            "./support": 17
	        }],
	        22: [function(_dereq_, module, exports) {
	            var StringReader = _dereq_("./stringReader");
	            var NodeBufferReader = _dereq_("./nodeBufferReader");
	            var Uint8ArrayReader = _dereq_("./uint8ArrayReader");
	            var utils = _dereq_("./utils");
	            var sig = _dereq_("./signature");
	            var ZipEntry = _dereq_("./zipEntry");
	            var support = _dereq_("./support");
	            var jszipProto = _dereq_("./object");
	            function ZipEntries(data, loadOptions) {
	                this.files = [];
	                this.loadOptions = loadOptions;
	                if (data)
	                    this.load(data)
	            }
	            ZipEntries.prototype = {
	                checkSignature: function(expectedSignature) {
	                    var signature = this.reader.readString(4);
	                    if (signature !== expectedSignature)
	                        throw new Error("Corrupted zip or bug : unexpected signature " + "(" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
	                },
	                readBlockEndOfCentral: function() {
	                    this.diskNumber = this.reader.readInt(2);
	                    this.diskWithCentralDirStart = this.reader.readInt(2);
	                    this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
	                    this.centralDirRecords = this.reader.readInt(2);
	                    this.centralDirSize = this.reader.readInt(4);
	                    this.centralDirOffset = this.reader.readInt(4);
	                    this.zipCommentLength = this.reader.readInt(2);
	                    this.zipComment = this.reader.readString(this.zipCommentLength);
	                    this.zipComment = jszipProto.utf8decode(this.zipComment)
	                },
	                readBlockZip64EndOfCentral: function() {
	                    this.zip64EndOfCentralSize = this.reader.readInt(8);
	                    this.versionMadeBy = this.reader.readString(2);
	                    this.versionNeeded = this.reader.readInt(2);
	                    this.diskNumber = this.reader.readInt(4);
	                    this.diskWithCentralDirStart = this.reader.readInt(4);
	                    this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
	                    this.centralDirRecords = this.reader.readInt(8);
	                    this.centralDirSize = this.reader.readInt(8);
	                    this.centralDirOffset = this.reader.readInt(8);
	                    this.zip64ExtensibleData = {};
	                    var extraDataSize = this.zip64EndOfCentralSize - 44, index = 0, extraFieldId, extraFieldLength, extraFieldValue;
	                    while (index < extraDataSize) {
	                        extraFieldId = this.reader.readInt(2);
	                        extraFieldLength = this.reader.readInt(4);
	                        extraFieldValue = this.reader.readString(extraFieldLength);
	                        this.zip64ExtensibleData[extraFieldId] = {
	                            id: extraFieldId,
	                            length: extraFieldLength,
	                            value: extraFieldValue
	                        }
	                    }
	                },
	                readBlockZip64EndOfCentralLocator: function() {
	                    this.diskWithZip64CentralDirStart = this.reader.readInt(4);
	                    this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
	                    this.disksCount = this.reader.readInt(4);
	                    if (this.disksCount > 1)
	                        throw new Error("Multi-volumes zip are not supported");
	                },
	                readLocalFiles: function() {
	                    var i, file;
	                    for (i = 0; i < this.files.length; i++) {
	                        file = this.files[i];
	                        this.reader.setIndex(file.localHeaderOffset);
	                        this.checkSignature(sig.LOCAL_FILE_HEADER);
	                        file.readLocalPart(this.reader);
	                        file.handleUTF8()
	                    }
	                },
	                readCentralDir: function() {
	                    var file;
	                    this.reader.setIndex(this.centralDirOffset);
	                    while (this.reader.readString(4) === sig.CENTRAL_FILE_HEADER) {
	                        file = new ZipEntry({
	                            zip64: this.zip64
	                        },this.loadOptions);
	                        file.readCentralPart(this.reader);
	                        this.files.push(file)
	                    }
	                },
	                readEndOfCentral: function() {
	                    var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
	                    if (offset === -1)
	                        throw new Error("Corrupted zip : can't find end of central directory");
	                    this.reader.setIndex(offset);
	                    this.checkSignature(sig.CENTRAL_DIRECTORY_END);
	                    this.readBlockEndOfCentral();
	                    if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
	                        this.zip64 = true;
	                        offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
	                        if (offset === -1)
	                            throw new Error("Corrupted zip : can't find the ZIP64 end of central directory locator");
	                        this.reader.setIndex(offset);
	                        this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
	                        this.readBlockZip64EndOfCentralLocator();
	                        this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
	                        this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
	                        this.readBlockZip64EndOfCentral()
	                    }
	                },
	                prepareReader: function(data) {
	                    var type = utils.getTypeOf(data);
	                    if (type === "string" && !support.uint8array)
	                        this.reader = new StringReader(data,this.loadOptions.optimizedBinaryString);
	                    else if (type === "nodebuffer")
	                        this.reader = new NodeBufferReader(data);
	                    else
	                        this.reader = new Uint8ArrayReader(utils.transformTo("uint8array", data))
	                },
	                load: function(data) {
	                    this.prepareReader(data);
	                    this.readEndOfCentral();
	                    this.readCentralDir();
	                    this.readLocalFiles()
	                }
	            };
	            module.exports = ZipEntries
	        }
	        , {
	            "./nodeBufferReader": 12,
	            "./object": 13,
	            "./signature": 14,
	            "./stringReader": 15,
	            "./support": 17,
	            "./uint8ArrayReader": 18,
	            "./utils": 21,
	            "./zipEntry": 23
	        }],
	        23: [function(_dereq_, module, exports) {
	            var StringReader = _dereq_("./stringReader");
	            var utils = _dereq_("./utils");
	            var CompressedObject = _dereq_("./compressedObject");
	            var jszipProto = _dereq_("./object");
	            function ZipEntry(options, loadOptions) {
	                this.options = options;
	                this.loadOptions = loadOptions
	            }
	            ZipEntry.prototype = {
	                isEncrypted: function() {
	                    return (this.bitFlag & 1) === 1
	                },
	                useUTF8: function() {
	                    return (this.bitFlag & 2048) === 2048
	                },
	                prepareCompressedContent: function(reader, from, length) {
	                    return function() {
	                        var previousIndex = reader.index;
	                        reader.setIndex(from);
	                        var compressedFileData = reader.readData(length);
	                        reader.setIndex(previousIndex);
	                        return compressedFileData
	                    }
	                },
	                prepareContent: function(reader, from, length, compression, uncompressedSize) {
	                    return function() {
	                        var compressedFileData = utils.transformTo(compression.uncompressInputType, this.getCompressedContent());
	                        var uncompressedFileData = compression.uncompress(compressedFileData);
	                        if (uncompressedFileData.length !== uncompressedSize)
	                            throw new Error("Bug : uncompressed data size mismatch");
	                        return uncompressedFileData
	                    }
	                },
	                readLocalPart: function(reader) {
	                    var compression, localExtraFieldsLength;
	                    reader.skip(22);
	                    this.fileNameLength = reader.readInt(2);
	                    localExtraFieldsLength = reader.readInt(2);
	                    this.fileName = reader.readString(this.fileNameLength);
	                    reader.skip(localExtraFieldsLength);
	                    if (this.compressedSize == -1 || this.uncompressedSize == -1)
	                        throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory " + "(compressedSize == -1 || uncompressedSize == -1)");
	                    compression = utils.findCompression(this.compressionMethod);
	                    if (compression === null)
	                        throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + this.fileName + ")");
	                    this.decompressed = new CompressedObject;
	                    this.decompressed.compressedSize = this.compressedSize;
	                    this.decompressed.uncompressedSize = this.uncompressedSize;
	                    this.decompressed.crc32 = this.crc32;
	                    this.decompressed.compressionMethod = this.compressionMethod;
	                    this.decompressed.getCompressedContent = this.prepareCompressedContent(reader, reader.index, this.compressedSize, compression);
	                    this.decompressed.getContent = this.prepareContent(reader, reader.index, this.compressedSize, compression, this.uncompressedSize);
	                    if (this.loadOptions.checkCRC32) {
	                        this.decompressed = utils.transformTo("string", this.decompressed.getContent());
	                        if (jszipProto.crc32(this.decompressed) !== this.crc32)
	                            throw new Error("Corrupted zip : CRC32 mismatch");
	                    }
	                },
	                readCentralPart: function(reader) {
	                    this.versionMadeBy = reader.readString(2);
	                    this.versionNeeded = reader.readInt(2);
	                    this.bitFlag = reader.readInt(2);
	                    this.compressionMethod = reader.readString(2);
	                    this.date = reader.readDate();
	                    this.crc32 = reader.readInt(4);
	                    this.compressedSize = reader.readInt(4);
	                    this.uncompressedSize = reader.readInt(4);
	                    this.fileNameLength = reader.readInt(2);
	                    this.extraFieldsLength = reader.readInt(2);
	                    this.fileCommentLength = reader.readInt(2);
	                    this.diskNumberStart = reader.readInt(2);
	                    this.internalFileAttributes = reader.readInt(2);
	                    this.externalFileAttributes = reader.readInt(4);
	                    this.localHeaderOffset = reader.readInt(4);
	                    if (this.isEncrypted())
	                        throw new Error("Encrypted zip are not supported");
	                    this.fileName = reader.readString(this.fileNameLength);
	                    this.readExtraFields(reader);
	                    this.parseZIP64ExtraField(reader);
	                    this.fileComment = reader.readString(this.fileCommentLength);
	                    this.dir = this.externalFileAttributes & 16 ? true : false
	                },
	                parseZIP64ExtraField: function(reader) {
	                    if (!this.extraFields[1])
	                        return;
	                    var extraReader = new StringReader(this.extraFields[1].value);
	                    if (this.uncompressedSize === utils.MAX_VALUE_32BITS)
	                        this.uncompressedSize = extraReader.readInt(8);
	                    if (this.compressedSize === utils.MAX_VALUE_32BITS)
	                        this.compressedSize = extraReader.readInt(8);
	                    if (this.localHeaderOffset === utils.MAX_VALUE_32BITS)
	                        this.localHeaderOffset = extraReader.readInt(8);
	                    if (this.diskNumberStart === utils.MAX_VALUE_32BITS)
	                        this.diskNumberStart = extraReader.readInt(4)
	                },
	                readExtraFields: function(reader) {
	                    var start = reader.index, extraFieldId, extraFieldLength, extraFieldValue;
	                    this.extraFields = this.extraFields || {};
	                    while (reader.index < start + this.extraFieldsLength) {
	                        extraFieldId = reader.readInt(2);
	                        extraFieldLength = reader.readInt(2);
	                        extraFieldValue = reader.readString(extraFieldLength);
	                        this.extraFields[extraFieldId] = {
	                            id: extraFieldId,
	                            length: extraFieldLength,
	                            value: extraFieldValue
	                        }
	                    }
	                },
	                handleUTF8: function() {
	                    if (this.useUTF8()) {
	                        this.fileName = jszipProto.utf8decode(this.fileName);
	                        this.fileComment = jszipProto.utf8decode(this.fileComment)
	                    } else {
	                        var upath = this.findExtraFieldUnicodePath();
	                        if (upath !== null)
	                            this.fileName = upath;
	                        var ucomment = this.findExtraFieldUnicodeComment();
	                        if (ucomment !== null)
	                            this.fileComment = ucomment
	                    }
	                },
	                findExtraFieldUnicodePath: function() {
	                    var upathField = this.extraFields[28789];
	                    if (upathField) {
	                        var extraReader = new StringReader(upathField.value);
	                        if (extraReader.readInt(1) !== 1)
	                            return null;
	                        if (jszipProto.crc32(this.fileName) !== extraReader.readInt(4))
	                            return null;
	                        return jszipProto.utf8decode(extraReader.readString(upathField.length - 5))
	                    }
	                    return null
	                },
	                findExtraFieldUnicodeComment: function() {
	                    var ucommentField = this.extraFields[25461];
	                    if (ucommentField) {
	                        var extraReader = new StringReader(ucommentField.value);
	                        if (extraReader.readInt(1) !== 1)
	                            return null;
	                        if (jszipProto.crc32(this.fileComment) !== extraReader.readInt(4))
	                            return null;
	                        return jszipProto.utf8decode(extraReader.readString(ucommentField.length - 5))
	                    }
	                    return null
	                }
	            };
	            module.exports = ZipEntry
	        }
	        , {
	            "./compressedObject": 2,
	            "./object": 13,
	            "./stringReader": 15,
	            "./utils": 21
	        }],
	        24: [function(_dereq_, module, exports) {
	            var assign = _dereq_("./lib/utils/common").assign;
	            var deflate = _dereq_("./lib/deflate");
	            var inflate = _dereq_("./lib/inflate");
	            var constants = _dereq_("./lib/zlib/constants");
	            var pako = {};
	            assign(pako, deflate, inflate, constants);
	            module.exports = pako
	        }
	        , {
	            "./lib/deflate": 25,
	            "./lib/inflate": 26,
	            "./lib/utils/common": 27,
	            "./lib/zlib/constants": 30
	        }],
	        25: [function(_dereq_, module, exports) {
	            var zlib_deflate = _dereq_("./zlib/deflate.js");
	            var utils = _dereq_("./utils/common");
	            var strings = _dereq_("./utils/strings");
	            var msg = _dereq_("./zlib/messages");
	            var zstream = _dereq_("./zlib/zstream");
	            var Z_NO_FLUSH = 0;
	            var Z_FINISH = 4;
	            var Z_OK = 0;
	            var Z_STREAM_END = 1;
	            var Z_DEFAULT_COMPRESSION = -1;
	            var Z_DEFAULT_STRATEGY = 0;
	            var Z_DEFLATED = 8;
	            var Deflate = function(options) {
	                this.options = utils.assign({
	                    level: Z_DEFAULT_COMPRESSION,
	                    method: Z_DEFLATED,
	                    chunkSize: 16384,
	                    windowBits: 15,
	                    memLevel: 8,
	                    strategy: Z_DEFAULT_STRATEGY,
	                    to: ""
	                }, options || {});
	                var opt = this.options;
	                if (opt.raw && opt.windowBits > 0)
	                    opt.windowBits = -opt.windowBits;
	                else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16)
	                    opt.windowBits += 16;
	                this.err = 0;
	                this.msg = "";
	                this.ended = false;
	                this.chunks = [];
	                this.strm = new zstream;
	                this.strm.avail_out = 0;
	                var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
	                if (status !== Z_OK)
	                    throw new Error(msg[status]);
	                if (opt.header)
	                    zlib_deflate.deflateSetHeader(this.strm, opt.header)
	            };
	            Deflate.prototype.push = function(data, mode) {
	                var strm = this.strm;
	                var chunkSize = this.options.chunkSize;
	                var status, _mode;
	                if (this.ended)
	                    return false;
	                _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
	                if (typeof data === "string")
	                    strm.input = strings.string2buf(data);
	                else
	                    strm.input = data;
	                strm.next_in = 0;
	                strm.avail_in = strm.input.length;
	                do {
	                    if (strm.avail_out === 0) {
	                        strm.output = new utils.Buf8(chunkSize);
	                        strm.next_out = 0;
	                        strm.avail_out = chunkSize
	                    }
	                    status = zlib_deflate.deflate(strm, _mode);
	                    if (status !== Z_STREAM_END && status !== Z_OK) {
	                        this.onEnd(status);
	                        this.ended = true;
	                        return false
	                    }
	                    if (strm.avail_out === 0 || strm.avail_in === 0 && _mode === Z_FINISH)
	                        if (this.options.to === "string")
	                            this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
	                        else
	                            this.onData(utils.shrinkBuf(strm.output, strm.next_out))
	                } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
	                if (_mode === Z_FINISH) {
	                    status = zlib_deflate.deflateEnd(this.strm);
	                    this.onEnd(status);
	                    this.ended = true;
	                    return status === Z_OK
	                }
	                return true
	            }
	            ;
	            Deflate.prototype.onData = function(chunk) {
	                this.chunks.push(chunk)
	            }
	            ;
	            Deflate.prototype.onEnd = function(status) {
	                if (status === Z_OK)
	                    if (this.options.to === "string")
	                        this.result = this.chunks.join("");
	                    else
	                        this.result = utils.flattenChunks(this.chunks);
	                this.chunks = [];
	                this.err = status;
	                this.msg = this.strm.msg
	            }
	            ;
	            function deflate(input, options) {
	                var deflator = new Deflate(options);
	                deflator.push(input, true);
	                if (deflator.err)
	                    throw deflator.msg;
	                return deflator.result
	            }
	            function deflateRaw(input, options) {
	                options = options || {};
	                options.raw = true;
	                return deflate(input, options)
	            }
	            function gzip(input, options) {
	                options = options || {};
	                options.gzip = true;
	                return deflate(input, options)
	            }
	            exports.Deflate = Deflate;
	            exports.deflate = deflate;
	            exports.deflateRaw = deflateRaw;
	            exports.gzip = gzip
	        }
	        , {
	            "./utils/common": 27,
	            "./utils/strings": 28,
	            "./zlib/deflate.js": 32,
	            "./zlib/messages": 37,
	            "./zlib/zstream": 39
	        }],
	        26: [function(_dereq_, module, exports) {
	            var zlib_inflate = _dereq_("./zlib/inflate.js");
	            var utils = _dereq_("./utils/common");
	            var strings = _dereq_("./utils/strings");
	            var c = _dereq_("./zlib/constants");
	            var msg = _dereq_("./zlib/messages");
	            var zstream = _dereq_("./zlib/zstream");
	            var gzheader = _dereq_("./zlib/gzheader");
	            var Inflate = function(options) {
	                this.options = utils.assign({
	                    chunkSize: 16384,
	                    windowBits: 0,
	                    to: ""
	                }, options || {});
	                var opt = this.options;
	                if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
	                    opt.windowBits = -opt.windowBits;
	                    if (opt.windowBits === 0)
	                        opt.windowBits = -15
	                }
	                if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits))
	                    opt.windowBits += 32;
	                if (opt.windowBits > 15 && opt.windowBits < 48)
	                    if ((opt.windowBits & 15) === 0)
	                        opt.windowBits |= 15;
	                this.err = 0;
	                this.msg = "";
	                this.ended = false;
	                this.chunks = [];
	                this.strm = new zstream;
	                this.strm.avail_out = 0;
	                var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
	                if (status !== c.Z_OK)
	                    throw new Error(msg[status]);
	                this.header = new gzheader;
	                zlib_inflate.inflateGetHeader(this.strm, this.header)
	            };
	            Inflate.prototype.push = function(data, mode) {
	                var strm = this.strm;
	                var chunkSize = this.options.chunkSize;
	                var status, _mode;
	                var next_out_utf8, tail, utf8str;
	                if (this.ended)
	                    return false;
	                _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
	                if (typeof data === "string")
	                    strm.input = strings.binstring2buf(data);
	                else
	                    strm.input = data;
	                strm.next_in = 0;
	                strm.avail_in = strm.input.length;
	                do {
	                    if (strm.avail_out === 0) {
	                        strm.output = new utils.Buf8(chunkSize);
	                        strm.next_out = 0;
	                        strm.avail_out = chunkSize
	                    }
	                    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
	                    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
	                        this.onEnd(status);
	                        this.ended = true;
	                        return false
	                    }
	                    if (strm.next_out)
	                        if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && _mode === c.Z_FINISH)
	                            if (this.options.to === "string") {
	                                next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
	                                tail = strm.next_out - next_out_utf8;
	                                utf8str = strings.buf2string(strm.output, next_out_utf8);
	                                strm.next_out = tail;
	                                strm.avail_out = chunkSize - tail;
	                                if (tail)
	                                    utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
	                                this.onData(utf8str)
	                            } else
	                                this.onData(utils.shrinkBuf(strm.output, strm.next_out))
	                } while (strm.avail_in > 0 && status !== c.Z_STREAM_END);
	                if (status === c.Z_STREAM_END)
	                    _mode = c.Z_FINISH;
	                if (_mode === c.Z_FINISH) {
	                    status = zlib_inflate.inflateEnd(this.strm);
	                    this.onEnd(status);
	                    this.ended = true;
	                    return status === c.Z_OK
	                }
	                return true
	            }
	            ;
	            Inflate.prototype.onData = function(chunk) {
	                this.chunks.push(chunk)
	            }
	            ;
	            Inflate.prototype.onEnd = function(status) {
	                if (status === c.Z_OK)
	                    if (this.options.to === "string")
	                        this.result = this.chunks.join("");
	                    else
	                        this.result = utils.flattenChunks(this.chunks);
	                this.chunks = [];
	                this.err = status;
	                this.msg = this.strm.msg
	            }
	            ;
	            function inflate(input, options) {
	                var inflator = new Inflate(options);
	                inflator.push(input, true);
	                if (inflator.err)
	                    throw inflator.msg;
	                return inflator.result
	            }
	            function inflateRaw(input, options) {
	                options = options || {};
	                options.raw = true;
	                return inflate(input, options)
	            }
	            exports.Inflate = Inflate;
	            exports.inflate = inflate;
	            exports.inflateRaw = inflateRaw;
	            exports.ungzip = inflate
	        }
	        , {
	            "./utils/common": 27,
	            "./utils/strings": 28,
	            "./zlib/constants": 30,
	            "./zlib/gzheader": 33,
	            "./zlib/inflate.js": 35,
	            "./zlib/messages": 37,
	            "./zlib/zstream": 39
	        }],
	        27: [function(_dereq_, module, exports) {
	            var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
	            exports.assign = function(obj) {
	                var sources = Array.prototype.slice.call(arguments, 1);
	                while (sources.length) {
	                    var source = sources.shift();
	                    if (!source)
	                        continue;
	                    if (typeof source !== "object")
	                        throw new TypeError(source + "must be non-object");
	                    for (var p in source)
	                        if (source.hasOwnProperty(p))
	                            obj[p] = source[p]
	                }
	                return obj
	            }
	            ;
	            exports.shrinkBuf = function(buf, size) {
	                if (buf.length === size)
	                    return buf;
	                if (buf.subarray)
	                    return buf.subarray(0, size);
	                buf.length = size;
	                return buf
	            }
	            ;
	            var fnTyped = {
	                arraySet: function(dest, src, src_offs, len, dest_offs) {
	                    if (src.subarray && dest.subarray) {
	                        dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
	                        return
	                    }
	                    for (var i = 0; i < len; i++)
	                        dest[dest_offs + i] = src[src_offs + i]
	                },
	                flattenChunks: function(chunks) {
	                    var i, l, len, pos, chunk, result;
	                    len = 0;
	                    for (i = 0,
	                    l = chunks.length; i < l; i++)
	                        len += chunks[i].length;
	                    result = new Uint8Array(len);
	                    pos = 0;
	                    for (i = 0,
	                    l = chunks.length; i < l; i++) {
	                        chunk = chunks[i];
	                        result.set(chunk, pos);
	                        pos += chunk.length
	                    }
	                    return result
	                }
	            };
	            var fnUntyped = {
	                arraySet: function(dest, src, src_offs, len, dest_offs) {
	                    for (var i = 0; i < len; i++)
	                        dest[dest_offs + i] = src[src_offs + i]
	                },
	                flattenChunks: function(chunks) {
	                    return [].concat.apply([], chunks)
	                }
	            };
	            exports.setTyped = function(on) {
	                if (on) {
	                    exports.Buf8 = Uint8Array;
	                    exports.Buf16 = Uint16Array;
	                    exports.Buf32 = Int32Array;
	                    exports.assign(exports, fnTyped)
	                } else {
	                    exports.Buf8 = Array;
	                    exports.Buf16 = Array;
	                    exports.Buf32 = Array;
	                    exports.assign(exports, fnUntyped)
	                }
	            }
	            ;
	            exports.setTyped(TYPED_OK)
	        }
	        , {}],
	        28: [function(_dereq_, module, exports) {
	            var utils = _dereq_("./common");
	            var STR_APPLY_OK = true;
	            var STR_APPLY_UIA_OK = true;
	            try {
	                String.fromCharCode.apply(null, [0])
	            } catch (__) {
	                STR_APPLY_OK = false
	            }
	            try {
	                String.fromCharCode.apply(null, new Uint8Array(1))
	            } catch (__) {
	                STR_APPLY_UIA_OK = false
	            }
	            var _utf8len = new utils.Buf8(256);
	            for (var i = 0; i < 256; i++)
	                _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;
	            _utf8len[254] = _utf8len[254] = 1;
	            exports.string2buf = function(str) {
	                var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
	                for (m_pos = 0; m_pos < str_len; m_pos++) {
	                    c = str.charCodeAt(m_pos);
	                    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
	                        c2 = str.charCodeAt(m_pos + 1);
	                        if ((c2 & 64512) === 56320) {
	                            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
	                            m_pos++
	                        }
	                    }
	                    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4
	                }
	                buf = new utils.Buf8(buf_len);
	                for (i = 0,
	                m_pos = 0; i < buf_len; m_pos++) {
	                    c = str.charCodeAt(m_pos);
	                    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
	                        c2 = str.charCodeAt(m_pos + 1);
	                        if ((c2 & 64512) === 56320) {
	                            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
	                            m_pos++
	                        }
	                    }
	                    if (c < 128)
	                        buf[i++] = c;
	                    else if (c < 2048) {
	                        buf[i++] = 192 | c >>> 6;
	                        buf[i++] = 128 | c & 63
	                    } else if (c < 65536) {
	                        buf[i++] = 224 | c >>> 12;
	                        buf[i++] = 128 | c >>> 6 & 63;
	                        buf[i++] = 128 | c & 63
	                    } else {
	                        buf[i++] = 240 | c >>> 18;
	                        buf[i++] = 128 | c >>> 12 & 63;
	                        buf[i++] = 128 | c >>> 6 & 63;
	                        buf[i++] = 128 | c & 63
	                    }
	                }
	                return buf
	            }
	            ;
	            function buf2binstring(buf, len) {
	                if (len < 65537)
	                    if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK)
	                        return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
	                var result = "";
	                for (var i = 0; i < len; i++)
	                    result += String.fromCharCode(buf[i]);
	                return result
	            }
	            exports.buf2binstring = function(buf) {
	                return buf2binstring(buf, buf.length)
	            }
	            ;
	            exports.binstring2buf = function(str) {
	                var buf = new utils.Buf8(str.length);
	                for (var i = 0, len = buf.length; i < len; i++)
	                    buf[i] = str.charCodeAt(i);
	                return buf
	            }
	            ;
	            exports.buf2string = function(buf, max) {
	                var i, out, c, c_len;
	                var len = max || buf.length;
	                var utf16buf = new Array(len * 2);
	                for (out = 0,
	                i = 0; i < len; ) {
	                    c = buf[i++];
	                    if (c < 128) {
	                        utf16buf[out++] = c;
	                        continue
	                    }
	                    c_len = _utf8len[c];
	                    if (c_len > 4) {
	                        utf16buf[out++] = 65533;
	                        i += c_len - 1;
	                        continue
	                    }
	                    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
	                    while (c_len > 1 && i < len) {
	                        c = c << 6 | buf[i++] & 63;
	                        c_len--
	                    }
	                    if (c_len > 1) {
	                        utf16buf[out++] = 65533;
	                        continue
	                    }
	                    if (c < 65536)
	                        utf16buf[out++] = c;
	                    else {
	                        c -= 65536;
	                        utf16buf[out++] = 55296 | c >> 10 & 1023;
	                        utf16buf[out++] = 56320 | c & 1023
	                    }
	                }
	                return buf2binstring(utf16buf, out)
	            }
	            ;
	            exports.utf8border = function(buf, max) {
	                var pos;
	                max = max || buf.length;
	                if (max > buf.length)
	                    max = buf.length;
	                pos = max - 1;
	                while (pos >= 0 && (buf[pos] & 192) === 128)
	                    pos--;
	                if (pos < 0)
	                    return max;
	                if (pos === 0)
	                    return max;
	                return pos + _utf8len[buf[pos]] > max ? pos : max
	            }
	        }
	        , {
	            "./common": 27
	        }],
	        29: [function(_dereq_, module, exports) {
	            function adler32(adler, buf, len, pos) {
	                var s1 = adler & 65535 | 0
	                  , s2 = adler >>> 16 & 65535 | 0
	                  , n = 0;
	                while (len !== 0) {
	                    n = len > 2E3 ? 2E3 : len;
	                    len -= n;
	                    do {
	                        s1 = s1 + buf[pos++] | 0;
	                        s2 = s2 + s1 | 0
	                    } while (--n);
	                    s1 %= 65521;
	                    s2 %= 65521
	                }
	                return s1 | s2 << 16 | 0
	            }
	            module.exports = adler32
	        }
	        , {}],
	        30: [function(_dereq_, module, exports) {
	            module.exports = {
	                Z_NO_FLUSH: 0,
	                Z_PARTIAL_FLUSH: 1,
	                Z_SYNC_FLUSH: 2,
	                Z_FULL_FLUSH: 3,
	                Z_FINISH: 4,
	                Z_BLOCK: 5,
	                Z_TREES: 6,
	                Z_OK: 0,
	                Z_STREAM_END: 1,
	                Z_NEED_DICT: 2,
	                Z_ERRNO: -1,
	                Z_STREAM_ERROR: -2,
	                Z_DATA_ERROR: -3,
	                Z_BUF_ERROR: -5,
	                Z_NO_COMPRESSION: 0,
	                Z_BEST_SPEED: 1,
	                Z_BEST_COMPRESSION: 9,
	                Z_DEFAULT_COMPRESSION: -1,
	                Z_FILTERED: 1,
	                Z_HUFFMAN_ONLY: 2,
	                Z_RLE: 3,
	                Z_FIXED: 4,
	                Z_DEFAULT_STRATEGY: 0,
	                Z_BINARY: 0,
	                Z_TEXT: 1,
	                Z_UNKNOWN: 2,
	                Z_DEFLATED: 8
	            }
	        }
	        , {}],
	        31: [function(_dereq_, module, exports) {
	            function makeTable() {
	                var c, table = [];
	                for (var n = 0; n < 256; n++) {
	                    c = n;
	                    for (var k = 0; k < 8; k++)
	                        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
	                    table[n] = c
	                }
	                return table
	            }
	            var crcTable = makeTable();
	            function crc32(crc, buf, len, pos) {
	                var t = crcTable
	                  , end = pos + len;
	                crc = crc ^ -1;
	                for (var i = pos; i < end; i++)
	                    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
	                return crc ^ -1
	            }
	            module.exports = crc32
	        }
	        , {}],
	        32: [function(_dereq_, module, exports) {
	            var utils = _dereq_("../utils/common");
	            var trees = _dereq_("./trees");
	            var adler32 = _dereq_("./adler32");
	            var crc32 = _dereq_("./crc32");
	            var msg = _dereq_("./messages");
	            var Z_NO_FLUSH = 0;
	            var Z_PARTIAL_FLUSH = 1;
	            var Z_FULL_FLUSH = 3;
	            var Z_FINISH = 4;
	            var Z_BLOCK = 5;
	            var Z_OK = 0;
	            var Z_STREAM_END = 1;
	            var Z_STREAM_ERROR = -2;
	            var Z_DATA_ERROR = -3;
	            var Z_BUF_ERROR = -5;
	            var Z_DEFAULT_COMPRESSION = -1;
	            var Z_FILTERED = 1;
	            var Z_HUFFMAN_ONLY = 2;
	            var Z_RLE = 3;
	            var Z_FIXED = 4;
	            var Z_DEFAULT_STRATEGY = 0;
	            var Z_UNKNOWN = 2;
	            var Z_DEFLATED = 8;
	            var MAX_MEM_LEVEL = 9;
	            var MAX_WBITS = 15;
	            var DEF_MEM_LEVEL = 8;
	            var LENGTH_CODES = 29;
	            var LITERALS = 256;
	            var L_CODES = LITERALS + 1 + LENGTH_CODES;
	            var D_CODES = 30;
	            var BL_CODES = 19;
	            var HEAP_SIZE = 2 * L_CODES + 1;
	            var MAX_BITS = 15;
	            var MIN_MATCH = 3;
	            var MAX_MATCH = 258;
	            var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
	            var PRESET_DICT = 32;
	            var INIT_STATE = 42;
	            var EXTRA_STATE = 69;
	            var NAME_STATE = 73;
	            var COMMENT_STATE = 91;
	            var HCRC_STATE = 103;
	            var BUSY_STATE = 113;
	            var FINISH_STATE = 666;
	            var BS_NEED_MORE = 1;
	            var BS_BLOCK_DONE = 2;
	            var BS_FINISH_STARTED = 3;
	            var BS_FINISH_DONE = 4;
	            var OS_CODE = 3;
	            function err(strm, errorCode) {
	                strm.msg = msg[errorCode];
	                return errorCode
	            }
	            function rank(f) {
	                return (f << 1) - (f > 4 ? 9 : 0)
	            }
	            function zero(buf) {
	                var len = buf.length;
	                while (--len >= 0)
	                    buf[len] = 0
	            }
	            function flush_pending(strm) {
	                var s = strm.state;
	                var len = s.pending;
	                if (len > strm.avail_out)
	                    len = strm.avail_out;
	                if (len === 0)
	                    return;
	                utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
	                strm.next_out += len;
	                s.pending_out += len;
	                strm.total_out += len;
	                strm.avail_out -= len;
	                s.pending -= len;
	                if (s.pending === 0)
	                    s.pending_out = 0
	            }
	            function flush_block_only(s, last) {
	                trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
	                s.block_start = s.strstart;
	                flush_pending(s.strm)
	            }
	            function put_byte(s, b) {
	                s.pending_buf[s.pending++] = b
	            }
	            function putShortMSB(s, b) {
	                s.pending_buf[s.pending++] = b >>> 8 & 255;
	                s.pending_buf[s.pending++] = b & 255
	            }
	            function read_buf(strm, buf, start, size) {
	                var len = strm.avail_in;
	                if (len > size)
	                    len = size;
	                if (len === 0)
	                    return 0;
	                strm.avail_in -= len;
	                utils.arraySet(buf, strm.input, strm.next_in, len, start);
	                if (strm.state.wrap === 1)
	                    strm.adler = adler32(strm.adler, buf, len, start);
	                else if (strm.state.wrap === 2)
	                    strm.adler = crc32(strm.adler, buf, len, start);
	                strm.next_in += len;
	                strm.total_in += len;
	                return len
	            }
	            function longest_match(s, cur_match) {
	                var chain_length = s.max_chain_length;
	                var scan = s.strstart;
	                var match;
	                var len;
	                var best_len = s.prev_length;
	                var nice_match = s.nice_match;
	                var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
	                var _win = s.window;
	                var wmask = s.w_mask;
	                var prev = s.prev;
	                var strend = s.strstart + MAX_MATCH;
	                var scan_end1 = _win[scan + best_len - 1];
	                var scan_end = _win[scan + best_len];
	                if (s.prev_length >= s.good_match)
	                    chain_length >>= 2;
	                if (nice_match > s.lookahead)
	                    nice_match = s.lookahead;
	                do {
	                    match = cur_match;
	                    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1])
	                        continue;
	                    scan += 2;
	                    match++;
	                    do
	                        ;
	                    while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
	                    len = MAX_MATCH - (strend - scan);
	                    scan = strend - MAX_MATCH;
	                    if (len > best_len) {
	                        s.match_start = cur_match;
	                        best_len = len;
	                        if (len >= nice_match)
	                            break;
	                        scan_end1 = _win[scan + best_len - 1];
	                        scan_end = _win[scan + best_len]
	                    }
	                } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
	                if (best_len <= s.lookahead)
	                    return best_len;
	                return s.lookahead
	            }
	            function fill_window(s) {
	                var _w_size = s.w_size;
	                var p, n, m, more, str;
	                do {
	                    more = s.window_size - s.lookahead - s.strstart;
	                    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
	                        utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
	                        s.match_start -= _w_size;
	                        s.strstart -= _w_size;
	                        s.block_start -= _w_size;
	                        n = s.hash_size;
	                        p = n;
	                        do {
	                            m = s.head[--p];
	                            s.head[p] = m >= _w_size ? m - _w_size : 0
	                        } while (--n);
	                        n = _w_size;
	                        p = n;
	                        do {
	                            m = s.prev[--p];
	                            s.prev[p] = m >= _w_size ? m - _w_size : 0
	                        } while (--n);
	                        more += _w_size
	                    }
	                    if (s.strm.avail_in === 0)
	                        break;
	                    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
	                    s.lookahead += n;
	                    if (s.lookahead + s.insert >= MIN_MATCH) {
	                        str = s.strstart - s.insert;
	                        s.ins_h = s.window[str];
	                        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
	                        while (s.insert) {
	                            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
	                            s.prev[str & s.w_mask] = s.head[s.ins_h];
	                            s.head[s.ins_h] = str;
	                            str++;
	                            s.insert--;
	                            if (s.lookahead + s.insert < MIN_MATCH)
	                                break
	                        }
	                    }
	                } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0)
	            }
	            function deflate_stored(s, flush) {
	                var max_block_size = 65535;
	                if (max_block_size > s.pending_buf_size - 5)
	                    max_block_size = s.pending_buf_size - 5;
	                for (; ; ) {
	                    if (s.lookahead <= 1) {
	                        fill_window(s);
	                        if (s.lookahead === 0 && flush === Z_NO_FLUSH)
	                            return BS_NEED_MORE;
	                        if (s.lookahead === 0)
	                            break
	                    }
	                    s.strstart += s.lookahead;
	                    s.lookahead = 0;
	                    var max_start = s.block_start + max_block_size;
	                    if (s.strstart === 0 || s.strstart >= max_start) {
	                        s.lookahead = s.strstart - max_start;
	                        s.strstart = max_start;
	                        flush_block_only(s, false);
	                        if (s.strm.avail_out === 0)
	                            return BS_NEED_MORE
	                    }
	                    if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
	                        flush_block_only(s, false);
	                        if (s.strm.avail_out === 0)
	                            return BS_NEED_MORE
	                    }
	                }
	                s.insert = 0;
	                if (flush === Z_FINISH) {
	                    flush_block_only(s, true);
	                    if (s.strm.avail_out === 0)
	                        return BS_FINISH_STARTED;
	                    return BS_FINISH_DONE
	                }
	                if (s.strstart > s.block_start) {
	                    flush_block_only(s, false);
	                    if (s.strm.avail_out === 0)
	                        return BS_NEED_MORE
	                }
	                return BS_NEED_MORE
	            }
	            function deflate_fast(s, flush) {
	                var hash_head;
	                var bflush;
	                for (; ; ) {
	                    if (s.lookahead < MIN_LOOKAHEAD) {
	                        fill_window(s);
	                        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH)
	                            return BS_NEED_MORE;
	                        if (s.lookahead === 0)
	                            break
	                    }
	                    hash_head = 0;
	                    if (s.lookahead >= MIN_MATCH) {
	                        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	                        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	                        s.head[s.ins_h] = s.strstart
	                    }
	                    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD)
	                        s.match_length = longest_match(s, hash_head);
	                    if (s.match_length >= MIN_MATCH) {
	                        bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
	                        s.lookahead -= s.match_length;
	                        if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
	                            s.match_length--;
	                            do {
	                                s.strstart++;
	                                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	                                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	                                s.head[s.ins_h] = s.strstart
	                            } while (--s.match_length !== 0);
	                            s.strstart++
	                        } else {
	                            s.strstart += s.match_length;
	                            s.match_length = 0;
	                            s.ins_h = s.window[s.strstart];
	                            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask
	                        }
	                    } else {
	                        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
	                        s.lookahead--;
	                        s.strstart++
	                    }
	                    if (bflush) {
	                        flush_block_only(s, false);
	                        if (s.strm.avail_out === 0)
	                            return BS_NEED_MORE
	                    }
	                }
	                s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
	                if (flush === Z_FINISH) {
	                    flush_block_only(s, true);
	                    if (s.strm.avail_out === 0)
	                        return BS_FINISH_STARTED;
	                    return BS_FINISH_DONE
	                }
	                if (s.last_lit) {
	                    flush_block_only(s, false);
	                    if (s.strm.avail_out === 0)
	                        return BS_NEED_MORE
	                }
	                return BS_BLOCK_DONE
	            }
	            function deflate_slow(s, flush) {
	                var hash_head;
	                var bflush;
	                var max_insert;
	                for (; ; ) {
	                    if (s.lookahead < MIN_LOOKAHEAD) {
	                        fill_window(s);
	                        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH)
	                            return BS_NEED_MORE;
	                        if (s.lookahead === 0)
	                            break
	                    }
	                    hash_head = 0;
	                    if (s.lookahead >= MIN_MATCH) {
	                        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	                        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	                        s.head[s.ins_h] = s.strstart
	                    }
	                    s.prev_length = s.match_length;
	                    s.prev_match = s.match_start;
	                    s.match_length = MIN_MATCH - 1;
	                    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
	                        s.match_length = longest_match(s, hash_head);
	                        if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096))
	                            s.match_length = MIN_MATCH - 1
	                    }
	                    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
	                        max_insert = s.strstart + s.lookahead - MIN_MATCH;
	                        bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
	                        s.lookahead -= s.prev_length - 1;
	                        s.prev_length -= 2;
	                        do
	                            if (++s.strstart <= max_insert) {
	                                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	                                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	                                s.head[s.ins_h] = s.strstart
	                            }
	                        while (--s.prev_length !== 0);
	                        s.match_available = 0;
	                        s.match_length = MIN_MATCH - 1;
	                        s.strstart++;
	                        if (bflush) {
	                            flush_block_only(s, false);
	                            if (s.strm.avail_out === 0)
	                                return BS_NEED_MORE
	                        }
	                    } else if (s.match_available) {
	                        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
	                        if (bflush)
	                            flush_block_only(s, false);
	                        s.strstart++;
	                        s.lookahead--;
	                        if (s.strm.avail_out === 0)
	                            return BS_NEED_MORE
	                    } else {
	                        s.match_available = 1;
	                        s.strstart++;
	                        s.lookahead--
	                    }
	                }
	                if (s.match_available) {
	                    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
	                    s.match_available = 0
	                }
	                s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
	                if (flush === Z_FINISH) {
	                    flush_block_only(s, true);
	                    if (s.strm.avail_out === 0)
	                        return BS_FINISH_STARTED;
	                    return BS_FINISH_DONE
	                }
	                if (s.last_lit) {
	                    flush_block_only(s, false);
	                    if (s.strm.avail_out === 0)
	                        return BS_NEED_MORE
	                }
	                return BS_BLOCK_DONE
	            }
	            function deflate_rle(s, flush) {
	                var bflush;
	                var prev;
	                var scan, strend;
	                var _win = s.window;
	                for (; ; ) {
	                    if (s.lookahead <= MAX_MATCH) {
	                        fill_window(s);
	                        if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH)
	                            return BS_NEED_MORE;
	                        if (s.lookahead === 0)
	                            break
	                    }
	                    s.match_length = 0;
	                    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
	                        scan = s.strstart - 1;
	                        prev = _win[scan];
	                        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
	                            strend = s.strstart + MAX_MATCH;
	                            do
	                                ;
	                            while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
	                            s.match_length = MAX_MATCH - (strend - scan);
	                            if (s.match_length > s.lookahead)
	                                s.match_length = s.lookahead
	                        }
	                    }
	                    if (s.match_length >= MIN_MATCH) {
	                        bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
	                        s.lookahead -= s.match_length;
	                        s.strstart += s.match_length;
	                        s.match_length = 0
	                    } else {
	                        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
	                        s.lookahead--;
	                        s.strstart++
	                    }
	                    if (bflush) {
	                        flush_block_only(s, false);
	                        if (s.strm.avail_out === 0)
	                            return BS_NEED_MORE
	                    }
	                }
	                s.insert = 0;
	                if (flush === Z_FINISH) {
	                    flush_block_only(s, true);
	                    if (s.strm.avail_out === 0)
	                        return BS_FINISH_STARTED;
	                    return BS_FINISH_DONE
	                }
	                if (s.last_lit) {
	                    flush_block_only(s, false);
	                    if (s.strm.avail_out === 0)
	                        return BS_NEED_MORE
	                }
	                return BS_BLOCK_DONE
	            }
	            function deflate_huff(s, flush) {
	                var bflush;
	                for (; ; ) {
	                    if (s.lookahead === 0) {
	                        fill_window(s);
	                        if (s.lookahead === 0) {
	                            if (flush === Z_NO_FLUSH)
	                                return BS_NEED_MORE;
	                            break
	                        }
	                    }
	                    s.match_length = 0;
	                    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
	                    s.lookahead--;
	                    s.strstart++;
	                    if (bflush) {
	                        flush_block_only(s, false);
	                        if (s.strm.avail_out === 0)
	                            return BS_NEED_MORE
	                    }
	                }
	                s.insert = 0;
	                if (flush === Z_FINISH) {
	                    flush_block_only(s, true);
	                    if (s.strm.avail_out === 0)
	                        return BS_FINISH_STARTED;
	                    return BS_FINISH_DONE
	                }
	                if (s.last_lit) {
	                    flush_block_only(s, false);
	                    if (s.strm.avail_out === 0)
	                        return BS_NEED_MORE
	                }
	                return BS_BLOCK_DONE
	            }
	            var Config = function(good_length, max_lazy, nice_length, max_chain, func) {
	                this.good_length = good_length;
	                this.max_lazy = max_lazy;
	                this.nice_length = nice_length;
	                this.max_chain = max_chain;
	                this.func = func
	            };
	            var configuration_table;
	            configuration_table = [new Config(0,0,0,0,deflate_stored), new Config(4,4,8,4,deflate_fast), new Config(4,5,16,8,deflate_fast), new Config(4,6,32,32,deflate_fast), new Config(4,4,16,16,deflate_slow), new Config(8,16,32,32,deflate_slow), new Config(8,16,128,128,deflate_slow), new Config(8,32,128,256,deflate_slow), new Config(32,128,258,1024,deflate_slow), new Config(32,258,258,4096,deflate_slow)];
	            function lm_init(s) {
	                s.window_size = 2 * s.w_size;
	                zero(s.head);
	                s.max_lazy_match = configuration_table[s.level].max_lazy;
	                s.good_match = configuration_table[s.level].good_length;
	                s.nice_match = configuration_table[s.level].nice_length;
	                s.max_chain_length = configuration_table[s.level].max_chain;
	                s.strstart = 0;
	                s.block_start = 0;
	                s.lookahead = 0;
	                s.insert = 0;
	                s.match_length = s.prev_length = MIN_MATCH - 1;
	                s.match_available = 0;
	                s.ins_h = 0
	            }
	            function DeflateState() {
	                this.strm = null;
	                this.status = 0;
	                this.pending_buf = null;
	                this.pending_buf_size = 0;
	                this.pending_out = 0;
	                this.pending = 0;
	                this.wrap = 0;
	                this.gzhead = null;
	                this.gzindex = 0;
	                this.method = Z_DEFLATED;
	                this.last_flush = -1;
	                this.w_size = 0;
	                this.w_bits = 0;
	                this.w_mask = 0;
	                this.window = null;
	                this.window_size = 0;
	                this.prev = null;
	                this.head = null;
	                this.ins_h = 0;
	                this.hash_size = 0;
	                this.hash_bits = 0;
	                this.hash_mask = 0;
	                this.hash_shift = 0;
	                this.block_start = 0;
	                this.match_length = 0;
	                this.prev_match = 0;
	                this.match_available = 0;
	                this.strstart = 0;
	                this.match_start = 0;
	                this.lookahead = 0;
	                this.prev_length = 0;
	                this.max_chain_length = 0;
	                this.max_lazy_match = 0;
	                this.level = 0;
	                this.strategy = 0;
	                this.good_match = 0;
	                this.nice_match = 0;
	                this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
	                this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
	                this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
	                zero(this.dyn_ltree);
	                zero(this.dyn_dtree);
	                zero(this.bl_tree);
	                this.l_desc = null;
	                this.d_desc = null;
	                this.bl_desc = null;
	                this.bl_count = new utils.Buf16(MAX_BITS + 1);
	                this.heap = new utils.Buf16(2 * L_CODES + 1);
	                zero(this.heap);
	                this.heap_len = 0;
	                this.heap_max = 0;
	                this.depth = new utils.Buf16(2 * L_CODES + 1);
	                zero(this.depth);
	                this.l_buf = 0;
	                this.lit_bufsize = 0;
	                this.last_lit = 0;
	                this.d_buf = 0;
	                this.opt_len = 0;
	                this.static_len = 0;
	                this.matches = 0;
	                this.insert = 0;
	                this.bi_buf = 0;
	                this.bi_valid = 0
	            }
	            function deflateResetKeep(strm) {
	                var s;
	                if (!strm || !strm.state)
	                    return err(strm, Z_STREAM_ERROR);
	                strm.total_in = strm.total_out = 0;
	                strm.data_type = Z_UNKNOWN;
	                s = strm.state;
	                s.pending = 0;
	                s.pending_out = 0;
	                if (s.wrap < 0)
	                    s.wrap = -s.wrap;
	                s.status = s.wrap ? INIT_STATE : BUSY_STATE;
	                strm.adler = s.wrap === 2 ? 0 : 1;
	                s.last_flush = Z_NO_FLUSH;
	                trees._tr_init(s);
	                return Z_OK
	            }
	            function deflateReset(strm) {
	                var ret = deflateResetKeep(strm);
	                if (ret === Z_OK)
	                    lm_init(strm.state);
	                return ret
	            }
	            function deflateSetHeader(strm, head) {
	                if (!strm || !strm.state)
	                    return Z_STREAM_ERROR;
	                if (strm.state.wrap !== 2)
	                    return Z_STREAM_ERROR;
	                strm.state.gzhead = head;
	                return Z_OK
	            }
	            function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
	                if (!strm)
	                    return Z_STREAM_ERROR;
	                var wrap = 1;
	                if (level === Z_DEFAULT_COMPRESSION)
	                    level = 6;
	                if (windowBits < 0) {
	                    wrap = 0;
	                    windowBits = -windowBits
	                } else if (windowBits > 15) {
	                    wrap = 2;
	                    windowBits -= 16
	                }
	                if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED)
	                    return err(strm, Z_STREAM_ERROR);
	                if (windowBits === 8)
	                    windowBits = 9;
	                var s = new DeflateState;
	                strm.state = s;
	                s.strm = strm;
	                s.wrap = wrap;
	                s.gzhead = null;
	                s.w_bits = windowBits;
	                s.w_size = 1 << s.w_bits;
	                s.w_mask = s.w_size - 1;
	                s.hash_bits = memLevel + 7;
	                s.hash_size = 1 << s.hash_bits;
	                s.hash_mask = s.hash_size - 1;
	                s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
	                s.window = new utils.Buf8(s.w_size * 2);
	                s.head = new utils.Buf16(s.hash_size);
	                s.prev = new utils.Buf16(s.w_size);
	                s.lit_bufsize = 1 << memLevel + 6;
	                s.pending_buf_size = s.lit_bufsize * 4;
	                s.pending_buf = new utils.Buf8(s.pending_buf_size);
	                s.d_buf = s.lit_bufsize >> 1;
	                s.l_buf = (1 + 2) * s.lit_bufsize;
	                s.level = level;
	                s.strategy = strategy;
	                s.method = method;
	                return deflateReset(strm)
	            }
	            function deflateInit(strm, level) {
	                return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY)
	            }
	            function deflate(strm, flush) {
	                var old_flush, s;
	                var beg, val;
	                if (!strm || !strm.state || flush > Z_BLOCK || flush < 0)
	                    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
	                s = strm.state;
	                if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH)
	                    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
	                s.strm = strm;
	                old_flush = s.last_flush;
	                s.last_flush = flush;
	                if (s.status === INIT_STATE)
	                    if (s.wrap === 2) {
	                        strm.adler = 0;
	                        put_byte(s, 31);
	                        put_byte(s, 139);
	                        put_byte(s, 8);
	                        if (!s.gzhead) {
	                            put_byte(s, 0);
	                            put_byte(s, 0);
	                            put_byte(s, 0);
	                            put_byte(s, 0);
	                            put_byte(s, 0);
	                            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
	                            put_byte(s, OS_CODE);
	                            s.status = BUSY_STATE
	                        } else {
	                            put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
	                            put_byte(s, s.gzhead.time & 255);
	                            put_byte(s, s.gzhead.time >> 8 & 255);
	                            put_byte(s, s.gzhead.time >> 16 & 255);
	                            put_byte(s, s.gzhead.time >> 24 & 255);
	                            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
	                            put_byte(s, s.gzhead.os & 255);
	                            if (s.gzhead.extra && s.gzhead.extra.length) {
	                                put_byte(s, s.gzhead.extra.length & 255);
	                                put_byte(s, s.gzhead.extra.length >> 8 & 255)
	                            }
	                            if (s.gzhead.hcrc)
	                                strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
	                            s.gzindex = 0;
	                            s.status = EXTRA_STATE
	                        }
	                    } else {
	                        var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
	                        var level_flags = -1;
	                        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2)
	                            level_flags = 0;
	                        else if (s.level < 6)
	                            level_flags = 1;
	                        else if (s.level === 6)
	                            level_flags = 2;
	                        else
	                            level_flags = 3;
	                        header |= level_flags << 6;
	                        if (s.strstart !== 0)
	                            header |= PRESET_DICT;
	                        header += 31 - header % 31;
	                        s.status = BUSY_STATE;
	                        putShortMSB(s, header);
	                        if (s.strstart !== 0) {
	                            putShortMSB(s, strm.adler >>> 16);
	                            putShortMSB(s, strm.adler & 65535)
	                        }
	                        strm.adler = 1
	                    }
	                if (s.status === EXTRA_STATE)
	                    if (s.gzhead.extra) {
	                        beg = s.pending;
	                        while (s.gzindex < (s.gzhead.extra.length & 65535)) {
	                            if (s.pending === s.pending_buf_size) {
	                                if (s.gzhead.hcrc && s.pending > beg)
	                                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	                                flush_pending(strm);
	                                beg = s.pending;
	                                if (s.pending === s.pending_buf_size)
	                                    break
	                            }
	                            put_byte(s, s.gzhead.extra[s.gzindex] & 255);
	                            s.gzindex++
	                        }
	                        if (s.gzhead.hcrc && s.pending > beg)
	                            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	                        if (s.gzindex === s.gzhead.extra.length) {
	                            s.gzindex = 0;
	                            s.status = NAME_STATE
	                        }
	                    } else
	                        s.status = NAME_STATE;
	                if (s.status === NAME_STATE)
	                    if (s.gzhead.name) {
	                        beg = s.pending;
	                        do {
	                            if (s.pending === s.pending_buf_size) {
	                                if (s.gzhead.hcrc && s.pending > beg)
	                                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	                                flush_pending(strm);
	                                beg = s.pending;
	                                if (s.pending === s.pending_buf_size) {
	                                    val = 1;
	                                    break
	                                }
	                            }
	                            if (s.gzindex < s.gzhead.name.length)
	                                val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
	                            else
	                                val = 0;
	                            put_byte(s, val)
	                        } while (val !== 0);
	                        if (s.gzhead.hcrc && s.pending > beg)
	                            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	                        if (val === 0) {
	                            s.gzindex = 0;
	                            s.status = COMMENT_STATE
	                        }
	                    } else
	                        s.status = COMMENT_STATE;
	                if (s.status === COMMENT_STATE)
	                    if (s.gzhead.comment) {
	                        beg = s.pending;
	                        do {
	                            if (s.pending === s.pending_buf_size) {
	                                if (s.gzhead.hcrc && s.pending > beg)
	                                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	                                flush_pending(strm);
	                                beg = s.pending;
	                                if (s.pending === s.pending_buf_size) {
	                                    val = 1;
	                                    break
	                                }
	                            }
	                            if (s.gzindex < s.gzhead.comment.length)
	                                val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
	                            else
	                                val = 0;
	                            put_byte(s, val)
	                        } while (val !== 0);
	                        if (s.gzhead.hcrc && s.pending > beg)
	                            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	                        if (val === 0)
	                            s.status = HCRC_STATE
	                    } else
	                        s.status = HCRC_STATE;
	                if (s.status === HCRC_STATE)
	                    if (s.gzhead.hcrc) {
	                        if (s.pending + 2 > s.pending_buf_size)
	                            flush_pending(strm);
	                        if (s.pending + 2 <= s.pending_buf_size) {
	                            put_byte(s, strm.adler & 255);
	                            put_byte(s, strm.adler >> 8 & 255);
	                            strm.adler = 0;
	                            s.status = BUSY_STATE
	                        }
	                    } else
	                        s.status = BUSY_STATE;
	                if (s.pending !== 0) {
	                    flush_pending(strm);
	                    if (strm.avail_out === 0) {
	                        s.last_flush = -1;
	                        return Z_OK
	                    }
	                } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH)
	                    return err(strm, Z_BUF_ERROR);
	                if (s.status === FINISH_STATE && strm.avail_in !== 0)
	                    return err(strm, Z_BUF_ERROR);
	                if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
	                    var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
	                    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE)
	                        s.status = FINISH_STATE;
	                    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
	                        if (strm.avail_out === 0)
	                            s.last_flush = -1;
	                        return Z_OK
	                    }
	                    if (bstate === BS_BLOCK_DONE) {
	                        if (flush === Z_PARTIAL_FLUSH)
	                            trees._tr_align(s);
	                        else if (flush !== Z_BLOCK) {
	                            trees._tr_stored_block(s, 0, 0, false);
	                            if (flush === Z_FULL_FLUSH) {
	                                zero(s.head);
	                                if (s.lookahead === 0) {
	                                    s.strstart = 0;
	                                    s.block_start = 0;
	                                    s.insert = 0
	                                }
	                            }
	                        }
	                        flush_pending(strm);
	                        if (strm.avail_out === 0) {
	                            s.last_flush = -1;
	                            return Z_OK
	                        }
	                    }
	                }
	                if (flush !== Z_FINISH)
	                    return Z_OK;
	                if (s.wrap <= 0)
	                    return Z_STREAM_END;
	                if (s.wrap === 2) {
	                    put_byte(s, strm.adler & 255);
	                    put_byte(s, strm.adler >> 8 & 255);
	                    put_byte(s, strm.adler >> 16 & 255);
	                    put_byte(s, strm.adler >> 24 & 255);
	                    put_byte(s, strm.total_in & 255);
	                    put_byte(s, strm.total_in >> 8 & 255);
	                    put_byte(s, strm.total_in >> 16 & 255);
	                    put_byte(s, strm.total_in >> 24 & 255)
	                } else {
	                    putShortMSB(s, strm.adler >>> 16);
	                    putShortMSB(s, strm.adler & 65535)
	                }
	                flush_pending(strm);
	                if (s.wrap > 0)
	                    s.wrap = -s.wrap;
	                return s.pending !== 0 ? Z_OK : Z_STREAM_END
	            }
	            function deflateEnd(strm) {
	                var status;
	                if (!strm || !strm.state)
	                    return Z_STREAM_ERROR;
	                status = strm.state.status;
	                if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE)
	                    return err(strm, Z_STREAM_ERROR);
	                strm.state = null;
	                return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK
	            }
	            exports.deflateInit = deflateInit;
	            exports.deflateInit2 = deflateInit2;
	            exports.deflateReset = deflateReset;
	            exports.deflateResetKeep = deflateResetKeep;
	            exports.deflateSetHeader = deflateSetHeader;
	            exports.deflate = deflate;
	            exports.deflateEnd = deflateEnd;
	            exports.deflateInfo = "pako deflate (from Nodeca project)"
	        }
	        , {
	            "../utils/common": 27,
	            "./adler32": 29,
	            "./crc32": 31,
	            "./messages": 37,
	            "./trees": 38
	        }],
	        33: [function(_dereq_, module, exports) {
	            function GZheader() {
	                this.text = 0;
	                this.time = 0;
	                this.xflags = 0;
	                this.os = 0;
	                this.extra = null;
	                this.extra_len = 0;
	                this.name = "";
	                this.comment = "";
	                this.hcrc = 0;
	                this.done = false
	            }
	            module.exports = GZheader
	        }
	        , {}],
	        34: [function(_dereq_, module, exports) {
	            var BAD = 30;
	            var TYPE = 12;
	            module.exports = function inflate_fast(strm, start) {
	                var state;
	                var _in;
	                var last;
	                var _out;
	                var beg;
	                var end;
	                var dmax;
	                var wsize;
	                var whave;
	                var wnext;
	                var window;
	                var hold;
	                var bits;
	                var lcode;
	                var dcode;
	                var lmask;
	                var dmask;
	                var here;
	                var op;
	                var len;
	                var dist;
	                var from;
	                var from_source;
	                var input, output;
	                state = strm.state;
	                _in = strm.next_in;
	                input = strm.input;
	                last = _in + (strm.avail_in - 5);
	                _out = strm.next_out;
	                output = strm.output;
	                beg = _out - (start - strm.avail_out);
	                end = _out + (strm.avail_out - 257);
	                dmax = state.dmax;
	                wsize = state.wsize;
	                whave = state.whave;
	                wnext = state.wnext;
	                window = state.window;
	                hold = state.hold;
	                bits = state.bits;
	                lcode = state.lencode;
	                dcode = state.distcode;
	                lmask = (1 << state.lenbits) - 1;
	                dmask = (1 << state.distbits) - 1;
	                top: do {
	                    if (bits < 15) {
	                        hold += input[_in++] << bits;
	                        bits += 8;
	                        hold += input[_in++] << bits;
	                        bits += 8
	                    }
	                    here = lcode[hold & lmask];
	                    dolen: for (; ; ) {
	                        op = here >>> 24;
	                        hold >>>= op;
	                        bits -= op;
	                        op = here >>> 16 & 255;
	                        if (op === 0)
	                            output[_out++] = here & 65535;
	                        else if (op & 16) {
	                            len = here & 65535;
	                            op &= 15;
	                            if (op) {
	                                if (bits < op) {
	                                    hold += input[_in++] << bits;
	                                    bits += 8
	                                }
	                                len += hold & (1 << op) - 1;
	                                hold >>>= op;
	                                bits -= op
	                            }
	                            if (bits < 15) {
	                                hold += input[_in++] << bits;
	                                bits += 8;
	                                hold += input[_in++] << bits;
	                                bits += 8
	                            }
	                            here = dcode[hold & dmask];
	                            dodist: for (; ; ) {
	                                op = here >>> 24;
	                                hold >>>= op;
	                                bits -= op;
	                                op = here >>> 16 & 255;
	                                if (op & 16) {
	                                    dist = here & 65535;
	                                    op &= 15;
	                                    if (bits < op) {
	                                        hold += input[_in++] << bits;
	                                        bits += 8;
	                                        if (bits < op) {
	                                            hold += input[_in++] << bits;
	                                            bits += 8
	                                        }
	                                    }
	                                    dist += hold & (1 << op) - 1;
	                                    if (dist > dmax) {
	                                        strm.msg = "invalid distance too far back";
	                                        state.mode = BAD;
	                                        break top
	                                    }
	                                    hold >>>= op;
	                                    bits -= op;
	                                    op = _out - beg;
	                                    if (dist > op) {
	                                        op = dist - op;
	                                        if (op > whave)
	                                            if (state.sane) {
	                                                strm.msg = "invalid distance too far back";
	                                                state.mode = BAD;
	                                                break top
	                                            }
	                                        from = 0;
	                                        from_source = window;
	                                        if (wnext === 0) {
	                                            from += wsize - op;
	                                            if (op < len) {
	                                                len -= op;
	                                                do
	                                                    output[_out++] = window[from++];
	                                                while (--op);
	                                                from = _out - dist;
	                                                from_source = output
	                                            }
	                                        } else if (wnext < op) {
	                                            from += wsize + wnext - op;
	                                            op -= wnext;
	                                            if (op < len) {
	                                                len -= op;
	                                                do
	                                                    output[_out++] = window[from++];
	                                                while (--op);
	                                                from = 0;
	                                                if (wnext < len) {
	                                                    op = wnext;
	                                                    len -= op;
	                                                    do
	                                                        output[_out++] = window[from++];
	                                                    while (--op);
	                                                    from = _out - dist;
	                                                    from_source = output
	                                                }
	                                            }
	                                        } else {
	                                            from += wnext - op;
	                                            if (op < len) {
	                                                len -= op;
	                                                do
	                                                    output[_out++] = window[from++];
	                                                while (--op);
	                                                from = _out - dist;
	                                                from_source = output
	                                            }
	                                        }
	                                        while (len > 2) {
	                                            output[_out++] = from_source[from++];
	                                            output[_out++] = from_source[from++];
	                                            output[_out++] = from_source[from++];
	                                            len -= 3
	                                        }
	                                        if (len) {
	                                            output[_out++] = from_source[from++];
	                                            if (len > 1)
	                                                output[_out++] = from_source[from++]
	                                        }
	                                    } else {
	                                        from = _out - dist;
	                                        do {
	                                            output[_out++] = output[from++];
	                                            output[_out++] = output[from++];
	                                            output[_out++] = output[from++];
	                                            len -= 3
	                                        } while (len > 2);
	                                        if (len) {
	                                            output[_out++] = output[from++];
	                                            if (len > 1)
	                                                output[_out++] = output[from++]
	                                        }
	                                    }
	                                } else if ((op & 64) === 0) {
	                                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
	                                    continue dodist
	                                } else {
	                                    strm.msg = "invalid distance code";
	                                    state.mode = BAD;
	                                    break top
	                                }
	                                break
	                            }
	                        } else if ((op & 64) === 0) {
	                            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
	                            continue dolen
	                        } else if (op & 32) {
	                            state.mode = TYPE;
	                            break top
	                        } else {
	                            strm.msg = "invalid literal/length code";
	                            state.mode = BAD;
	                            break top
	                        }
	                        break
	                    }
	                } while (_in < last && _out < end);
	                len = bits >> 3;
	                _in -= len;
	                bits -= len << 3;
	                hold &= (1 << bits) - 1;
	                strm.next_in = _in;
	                strm.next_out = _out;
	                strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
	                strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
	                state.hold = hold;
	                state.bits = bits;
	                return
	            }
	        }
	        , {}],
	        35: [function(_dereq_, module, exports) {
	            var utils = _dereq_("../utils/common");
	            var adler32 = _dereq_("./adler32");
	            var crc32 = _dereq_("./crc32");
	            var inflate_fast = _dereq_("./inffast");
	            var inflate_table = _dereq_("./inftrees");
	            var CODES = 0;
	            var LENS = 1;
	            var DISTS = 2;
	            var Z_FINISH = 4;
	            var Z_BLOCK = 5;
	            var Z_TREES = 6;
	            var Z_OK = 0;
	            var Z_STREAM_END = 1;
	            var Z_NEED_DICT = 2;
	            var Z_STREAM_ERROR = -2;
	            var Z_DATA_ERROR = -3;
	            var Z_MEM_ERROR = -4;
	            var Z_BUF_ERROR = -5;
	            var Z_DEFLATED = 8;
	            var HEAD = 1;
	            var FLAGS = 2;
	            var TIME = 3;
	            var OS = 4;
	            var EXLEN = 5;
	            var EXTRA = 6;
	            var NAME = 7;
	            var COMMENT = 8;
	            var HCRC = 9;
	            var DICTID = 10;
	            var DICT = 11;
	            var TYPE = 12;
	            var TYPEDO = 13;
	            var STORED = 14;
	            var COPY_ = 15;
	            var COPY = 16;
	            var TABLE = 17;
	            var LENLENS = 18;
	            var CODELENS = 19;
	            var LEN_ = 20;
	            var LEN = 21;
	            var LENEXT = 22;
	            var DIST = 23;
	            var DISTEXT = 24;
	            var MATCH = 25;
	            var LIT = 26;
	            var CHECK = 27;
	            var LENGTH = 28;
	            var DONE = 29;
	            var BAD = 30;
	            var MEM = 31;
	            var SYNC = 32;
	            var ENOUGH_LENS = 852;
	            var ENOUGH_DISTS = 592;
	            var MAX_WBITS = 15;
	            var DEF_WBITS = MAX_WBITS;
	            function ZSWAP32(q) {
	                return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24)
	            }
	            function InflateState() {
	                this.mode = 0;
	                this.last = false;
	                this.wrap = 0;
	                this.havedict = false;
	                this.flags = 0;
	                this.dmax = 0;
	                this.check = 0;
	                this.total = 0;
	                this.head = null;
	                this.wbits = 0;
	                this.wsize = 0;
	                this.whave = 0;
	                this.wnext = 0;
	                this.window = null;
	                this.hold = 0;
	                this.bits = 0;
	                this.length = 0;
	                this.offset = 0;
	                this.extra = 0;
	                this.lencode = null;
	                this.distcode = null;
	                this.lenbits = 0;
	                this.distbits = 0;
	                this.ncode = 0;
	                this.nlen = 0;
	                this.ndist = 0;
	                this.have = 0;
	                this.next = null;
	                this.lens = new utils.Buf16(320);
	                this.work = new utils.Buf16(288);
	                this.lendyn = null;
	                this.distdyn = null;
	                this.sane = 0;
	                this.back = 0;
	                this.was = 0
	            }
	            function inflateResetKeep(strm) {
	                var state;
	                if (!strm || !strm.state)
	                    return Z_STREAM_ERROR;
	                state = strm.state;
	                strm.total_in = strm.total_out = state.total = 0;
	                strm.msg = "";
	                if (state.wrap)
	                    strm.adler = state.wrap & 1;
	                state.mode = HEAD;
	                state.last = 0;
	                state.havedict = 0;
	                state.dmax = 32768;
	                state.head = null;
	                state.hold = 0;
	                state.bits = 0;
	                state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
	                state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
	                state.sane = 1;
	                state.back = -1;
	                return Z_OK
	            }
	            function inflateReset(strm) {
	                var state;
	                if (!strm || !strm.state)
	                    return Z_STREAM_ERROR;
	                state = strm.state;
	                state.wsize = 0;
	                state.whave = 0;
	                state.wnext = 0;
	                return inflateResetKeep(strm)
	            }
	            function inflateReset2(strm, windowBits) {
	                var wrap;
	                var state;
	                if (!strm || !strm.state)
	                    return Z_STREAM_ERROR;
	                state = strm.state;
	                if (windowBits < 0) {
	                    wrap = 0;
	                    windowBits = -windowBits
	                } else {
	                    wrap = (windowBits >> 4) + 1;
	                    if (windowBits < 48)
	                        windowBits &= 15
	                }
	                if (windowBits && (windowBits < 8 || windowBits > 15))
	                    return Z_STREAM_ERROR;
	                if (state.window !== null && state.wbits !== windowBits)
	                    state.window = null;
	                state.wrap = wrap;
	                state.wbits = windowBits;
	                return inflateReset(strm)
	            }
	            function inflateInit2(strm, windowBits) {
	                var ret;
	                var state;
	                if (!strm)
	                    return Z_STREAM_ERROR;
	                state = new InflateState;
	                strm.state = state;
	                state.window = null;
	                ret = inflateReset2(strm, windowBits);
	                if (ret !== Z_OK)
	                    strm.state = null;
	                return ret
	            }
	            function inflateInit(strm) {
	                return inflateInit2(strm, DEF_WBITS)
	            }
	            var virgin = true;
	            var lenfix, distfix;
	            function fixedtables(state) {
	                if (virgin) {
	                    var sym;
	                    lenfix = new utils.Buf32(512);
	                    distfix = new utils.Buf32(32);
	                    sym = 0;
	                    while (sym < 144)
	                        state.lens[sym++] = 8;
	                    while (sym < 256)
	                        state.lens[sym++] = 9;
	                    while (sym < 280)
	                        state.lens[sym++] = 7;
	                    while (sym < 288)
	                        state.lens[sym++] = 8;
	                    inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {
	                        bits: 9
	                    });
	                    sym = 0;
	                    while (sym < 32)
	                        state.lens[sym++] = 5;
	                    inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {
	                        bits: 5
	                    });
	                    virgin = false
	                }
	                state.lencode = lenfix;
	                state.lenbits = 9;
	                state.distcode = distfix;
	                state.distbits = 5
	            }
	            function updatewindow(strm, src, end, copy) {
	                var dist;
	                var state = strm.state;
	                if (state.window === null) {
	                    state.wsize = 1 << state.wbits;
	                    state.wnext = 0;
	                    state.whave = 0;
	                    state.window = new utils.Buf8(state.wsize)
	                }
	                if (copy >= state.wsize) {
	                    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
	                    state.wnext = 0;
	                    state.whave = state.wsize
	                } else {
	                    dist = state.wsize - state.wnext;
	                    if (dist > copy)
	                        dist = copy;
	                    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
	                    copy -= dist;
	                    if (copy) {
	                        utils.arraySet(state.window, src, end - copy, copy, 0);
	                        state.wnext = copy;
	                        state.whave = state.wsize
	                    } else {
	                        state.wnext += dist;
	                        if (state.wnext === state.wsize)
	                            state.wnext = 0;
	                        if (state.whave < state.wsize)
	                            state.whave += dist
	                    }
	                }
	                return 0
	            }
	            function inflate(strm, flush) {
	                var state;
	                var input, output;
	                var next;
	                var put;
	                var have, left;
	                var hold;
	                var bits;
	                var _in, _out;
	                var copy;
	                var from;
	                var from_source;
	                var here = 0;
	                var here_bits, here_op, here_val;
	                var last_bits, last_op, last_val;
	                var len;
	                var ret;
	                var hbuf = new utils.Buf8(4);
	                var opts;
	                var n;
	                var order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
	                if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0)
	                    return Z_STREAM_ERROR;
	                state = strm.state;
	                if (state.mode === TYPE)
	                    state.mode = TYPEDO;
	                put = strm.next_out;
	                output = strm.output;
	                left = strm.avail_out;
	                next = strm.next_in;
	                input = strm.input;
	                have = strm.avail_in;
	                hold = state.hold;
	                bits = state.bits;
	                _in = have;
	                _out = left;
	                ret = Z_OK;
	                inf_leave: for (; ; )
	                    switch (state.mode) {
	                    case HEAD:
	                        if (state.wrap === 0) {
	                            state.mode = TYPEDO;
	                            break
	                        }
	                        while (bits < 16) {
	                            if (have === 0)
	                                break inf_leave;
	                            have--;
	                            hold += input[next++] << bits;
	                            bits += 8
	                        }
	                        if (state.wrap & 2 && hold === 35615) {
	                            state.check = 0;
	                            hbuf[0] = hold & 255;
	                            hbuf[1] = hold >>> 8 & 255;
	                            state.check = crc32(state.check, hbuf, 2, 0);
	                            hold = 0;
	                            bits = 0;
	                            state.mode = FLAGS;
	                            break
	                        }
	                        state.flags = 0;
	                        if (state.head)
	                            state.head.done = false;
	                        if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
	                            strm.msg = "incorrect header check";
	                            state.mode = BAD;
	                            break
	                        }
	                        if ((hold & 15) !== Z_DEFLATED) {
	                            strm.msg = "unknown compression method";
	                            state.mode = BAD;
	                            break
	                        }
	                        hold >>>= 4;
	                        bits -= 4;
	                        len = (hold & 15) + 8;
	                        if (state.wbits === 0)
	                            state.wbits = len;
	                        else if (len > state.wbits) {
	                            strm.msg = "invalid window size";
	                            state.mode = BAD;
	                            break
	                        }
	                        state.dmax = 1 << len;
	                        strm.adler = state.check = 1;
	                        state.mode = hold & 512 ? DICTID : TYPE;
	                        hold = 0;
	                        bits = 0;
	                        break;
	                    case FLAGS:
	                        while (bits < 16) {
	                            if (have === 0)
	                                break inf_leave;
	                            have--;
	                            hold += input[next++] << bits;
	                            bits += 8
	                        }
	                        state.flags = hold;
	                        if ((state.flags & 255) !== Z_DEFLATED) {
	                            strm.msg = "unknown compression method";
	                            state.mode = BAD;
	                            break
	                        }
	                        if (state.flags & 57344) {
	                            strm.msg = "unknown header flags set";
	                            state.mode = BAD;
	                            break
	                        }
	                        if (state.head)
	                            state.head.text = hold >> 8 & 1;
	                        if (state.flags & 512) {
	                            hbuf[0] = hold & 255;
	                            hbuf[1] = hold >>> 8 & 255;
	                            state.check = crc32(state.check, hbuf, 2, 0)
	                        }
	                        hold = 0;
	                        bits = 0;
	                        state.mode = TIME;
	                    case TIME:
	                        while (bits < 32) {
	                            if (have === 0)
	                                break inf_leave;
	                            have--;
	                            hold += input[next++] << bits;
	                            bits += 8
	                        }
	                        if (state.head)
	                            state.head.time = hold;
	                        if (state.flags & 512) {
	                            hbuf[0] = hold & 255;
	                            hbuf[1] = hold >>> 8 & 255;
	                            hbuf[2] = hold >>> 16 & 255;
	                            hbuf[3] = hold >>> 24 & 255;
	                            state.check = crc32(state.check, hbuf, 4, 0)
	                        }
	                        hold = 0;
	                        bits = 0;
	                        state.mode = OS;
	                    case OS:
	                        while (bits < 16) {
	                            if (have === 0)
	                                break inf_leave;
	                            have--;
	                            hold += input[next++] << bits;
	                            bits += 8
	                        }
	                        if (state.head) {
	                            state.head.xflags = hold & 255;
	                            state.head.os = hold >> 8
	                        }
	                        if (state.flags & 512) {
	                            hbuf[0] = hold & 255;
	                            hbuf[1] = hold >>> 8 & 255;
	                            state.check = crc32(state.check, hbuf, 2, 0)
	                        }
	                        hold = 0;
	                        bits = 0;
	                        state.mode = EXLEN;
	                    case EXLEN:
	                        if (state.flags & 1024) {
	                            while (bits < 16) {
	                                if (have === 0)
	                                    break inf_leave;
	                                have--;
	                                hold += input[next++] << bits;
	                                bits += 8
	                            }
	                            state.length = hold;
	                            if (state.head)
	                                state.head.extra_len = hold;
	                            if (state.flags & 512) {
	                                hbuf[0] = hold & 255;
	                                hbuf[1] = hold >>> 8 & 255;
	                                state.check = crc32(state.check, hbuf, 2, 0)
	                            }
	                            hold = 0;
	                            bits = 0
	                        } else if (state.head)
	                            state.head.extra = null;
	                        state.mode = EXTRA;
	                    case EXTRA:
	                        if (state.flags & 1024) {
	                            copy = state.length;
	                            if (copy > have)
	                                copy = have;
	                            if (copy) {
	                                if (state.head) {
	                                    len = state.head.extra_len - state.length;
	                                    if (!state.head.extra)
	                                        state.head.extra = new Array(state.head.extra_len);
	                                    utils.arraySet(state.head.extra, input, next, copy, len)
	                                }
	                                if (state.flags & 512)
	                                    state.check = crc32(state.check, input, copy, next);
	                                have -= copy;
	                                next += copy;
	                                state.length -= copy
	                            }
	                            if (state.length)
	                                break inf_leave
	                        }
	                        state.length = 0;
	                        state.mode = NAME;
	                    case NAME:
	                        if (state.flags & 2048) {
	                            if (have === 0)
	                                break inf_leave;
	                            copy = 0;
	                            do {
	                                len = input[next + copy++];
	                                if (state.head && len && state.length < 65536)
	                                    state.head.name += String.fromCharCode(len)
	                            } while (len && copy < have);
	                            if (state.flags & 512)
	                                state.check = crc32(state.check, input, copy, next);
	                            have -= copy;
	                            next += copy;
	                            if (len)
	                                break inf_leave
	                        } else if (state.head)
	                            state.head.name = null;
	                        state.length = 0;
	                        state.mode = COMMENT;
	                    case COMMENT:
	                        if (state.flags & 4096) {
	                            if (have === 0)
	                                break inf_leave;
	                            copy = 0;
	                            do {
	                                len = input[next + copy++];
	                                if (state.head && len && state.length < 65536)
	                                    state.head.comment += String.fromCharCode(len)
	                            } while (len && copy < have);
	                            if (state.flags & 512)
	                                state.check = crc32(state.check, input, copy, next);
	                            have -= copy;
	                            next += copy;
	                            if (len)
	                                break inf_leave
	                        } else if (state.head)
	                            state.head.comment = null;
	                        state.mode = HCRC;
	                    case HCRC:
	                        if (state.flags & 512) {
	                            while (bits < 16) {
	                                if (have === 0)
	                                    break inf_leave;
	                                have--;
	                                hold += input[next++] << bits;
	                                bits += 8
	                            }
	                            if (hold !== (state.check & 65535)) {
	                                strm.msg = "header crc mismatch";
	                                state.mode = BAD;
	                                break
	                            }
	                            hold = 0;
	                            bits = 0
	                        }
	                        if (state.head) {
	                            state.head.hcrc = state.flags >> 9 & 1;
	                            state.head.done = true
	                        }
	                        strm.adler = state.check = 0;
	                        state.mode = TYPE;
	                        break;
	                    case DICTID:
	                        while (bits < 32) {
	                            if (have === 0)
	                                break inf_leave;
	                            have--;
	                            hold += input[next++] << bits;
	                            bits += 8
	                        }
	                        strm.adler = state.check = ZSWAP32(hold);
	                        hold = 0;
	                        bits = 0;
	                        state.mode = DICT;
	                    case DICT:
	                        if (state.havedict === 0) {
	                            strm.next_out = put;
	                            strm.avail_out = left;
	                            strm.next_in = next;
	                            strm.avail_in = have;
	                            state.hold = hold;
	                            state.bits = bits;
	                            return Z_NEED_DICT
	                        }
	                        strm.adler = state.check = 1;
	                        state.mode = TYPE;
	                    case TYPE:
	                        if (flush === Z_BLOCK || flush === Z_TREES)
	                            break inf_leave;
	                    case TYPEDO:
	                        if (state.last) {
	                            hold >>>= bits & 7;
	                            bits -= bits & 7;
	                            state.mode = CHECK;
	                            break
	                        }
	                        while (bits < 3) {
	                            if (have === 0)
	                                break inf_leave;
	                            have--;
	                            hold += input[next++] << bits;
	                            bits += 8
	                        }
	                        state.last = hold & 1;
	                        hold >>>= 1;
	                        bits -= 1;
	                        switch (hold & 3) {
	                        case 0:
	                            state.mode = STORED;
	                            break;
	                        case 1:
	                            fixedtables(state);
	                            state.mode = LEN_;
	                            if (flush === Z_TREES) {
	                                hold >>>= 2;
	                                bits -= 2;
	                                break inf_leave
	                            }
	                            break;
	                        case 2:
	                            state.mode = TABLE;
	                            break;
	                        case 3:
	                            strm.msg = "invalid block type";
	                            state.mode = BAD
	                        }
	                        hold >>>= 2;
	                        bits -= 2;
	                        break;
	                    case STORED:
	                        hold >>>= bits & 7;
	                        bits -= bits & 7;
	                        while (bits < 32) {
	                            if (have === 0)
	                                break inf_leave;
	                            have--;
	                            hold += input[next++] << bits;
	                            bits += 8
	                        }
	                        if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
	                            strm.msg = "invalid stored block lengths";
	                            state.mode = BAD;
	                            break
	                        }
	                        state.length = hold & 65535;
	                        hold = 0;
	                        bits = 0;
	                        state.mode = COPY_;
	                        if (flush === Z_TREES)
	                            break inf_leave;
	                    case COPY_:
	                        state.mode = COPY;
	                    case COPY:
	                        copy = state.length;
	                        if (copy) {
	                            if (copy > have)
	                                copy = have;
	                            if (copy > left)
	                                copy = left;
	                            if (copy === 0)
	                                break inf_leave;
	                            utils.arraySet(output, input, next, copy, put);
	                            have -= copy;
	                            next += copy;
	                            left -= copy;
	                            put += copy;
	                            state.length -= copy;
	                            break
	                        }
	                        state.mode = TYPE;
	                        break;
	                    case TABLE:
	                        while (bits < 14) {
	                            if (have === 0)
	                                break inf_leave;
	                            have--;
	                            hold += input[next++] << bits;
	                            bits += 8
	                        }
	                        state.nlen = (hold & 31) + 257;
	                        hold >>>= 5;
	                        bits -= 5;
	                        state.ndist = (hold & 31) + 1;
	                        hold >>>= 5;
	                        bits -= 5;
	                        state.ncode = (hold & 15) + 4;
	                        hold >>>= 4;
	                        bits -= 4;
	                        if (state.nlen > 286 || state.ndist > 30) {
	                            strm.msg = "too many length or distance symbols";
	                            state.mode = BAD;
	                            break
	                        }
	                        state.have = 0;
	                        state.mode = LENLENS;
	                    case LENLENS:
	                        while (state.have < state.ncode) {
	                            while (bits < 3) {
	                                if (have === 0)
	                                    break inf_leave;
	                                have--;
	                                hold += input[next++] << bits;
	                                bits += 8
	                            }
	                            state.lens[order[state.have++]] = hold & 7;
	                            hold >>>= 3;
	                            bits -= 3
	                        }
	                        while (state.have < 19)
	                            state.lens[order[state.have++]] = 0;
	                        state.lencode = state.lendyn;
	                        state.lenbits = 7;
	                        opts = {
	                            bits: state.lenbits
	                        };
	                        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
	                        state.lenbits = opts.bits;
	                        if (ret) {
	                            strm.msg = "invalid code lengths set";
	                            state.mode = BAD;
	                            break
	                        }
	                        state.have = 0;
	                        state.mode = CODELENS;
	                    case CODELENS:
	                        while (state.have < state.nlen + state.ndist) {
	                            for (; ; ) {
	                                here = state.lencode[hold & (1 << state.lenbits) - 1];
	                                here_bits = here >>> 24;
	                                here_op = here >>> 16 & 255;
	                                here_val = here & 65535;
	                                if (here_bits <= bits)
	                                    break;
	                                if (have === 0)
	                                    break inf_leave;
	                                have--;
	                                hold += input[next++] << bits;
	                                bits += 8
	                            }
	                            if (here_val < 16) {
	                                hold >>>= here_bits;
	                                bits -= here_bits;
	                                state.lens[state.have++] = here_val
	                            } else {
	                                if (here_val === 16) {
	                                    n = here_bits + 2;
	                                    while (bits < n) {
	                                        if (have === 0)
	                                            break inf_leave;
	                                        have--;
	                                        hold += input[next++] << bits;
	                                        bits += 8
	                                    }
	                                    hold >>>= here_bits;
	                                    bits -= here_bits;
	                                    if (state.have === 0) {
	                                        strm.msg = "invalid bit length repeat";
	                                        state.mode = BAD;
	                                        break
	                                    }
	                                    len = state.lens[state.have - 1];
	                                    copy = 3 + (hold & 3);
	                                    hold >>>= 2;
	                                    bits -= 2
	                                } else if (here_val === 17) {
	                                    n = here_bits + 3;
	                                    while (bits < n) {
	                                        if (have === 0)
	                                            break inf_leave;
	                                        have--;
	                                        hold += input[next++] << bits;
	                                        bits += 8
	                                    }
	                                    hold >>>= here_bits;
	                                    bits -= here_bits;
	                                    len = 0;
	                                    copy = 3 + (hold & 7);
	                                    hold >>>= 3;
	                                    bits -= 3
	                                } else {
	                                    n = here_bits + 7;
	                                    while (bits < n) {
	                                        if (have === 0)
	                                            break inf_leave;
	                                        have--;
	                                        hold += input[next++] << bits;
	                                        bits += 8
	                                    }
	                                    hold >>>= here_bits;
	                                    bits -= here_bits;
	                                    len = 0;
	                                    copy = 11 + (hold & 127);
	                                    hold >>>= 7;
	                                    bits -= 7
	                                }
	                                if (state.have + copy > state.nlen + state.ndist) {
	                                    strm.msg = "invalid bit length repeat";
	                                    state.mode = BAD;
	                                    break
	                                }
	                                while (copy--)
	                                    state.lens[state.have++] = len
	                            }
	                        }
	                        if (state.mode === BAD)
	                            break;
	                        if (state.lens[256] === 0) {
	                            strm.msg = "invalid code -- missing end-of-block";
	                            state.mode = BAD;
	                            break
	                        }
	                        state.lenbits = 9;
	                        opts = {
	                            bits: state.lenbits
	                        };
	                        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
	                        state.lenbits = opts.bits;
	                        if (ret) {
	                            strm.msg = "invalid literal/lengths set";
	                            state.mode = BAD;
	                            break
	                        }
	                        state.distbits = 6;
	                        state.distcode = state.distdyn;
	                        opts = {
	                            bits: state.distbits
	                        };
	                        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
	                        state.distbits = opts.bits;
	                        if (ret) {
	                            strm.msg = "invalid distances set";
	                            state.mode = BAD;
	                            break
	                        }
	                        state.mode = LEN_;
	                        if (flush === Z_TREES)
	                            break inf_leave;
	                    case LEN_:
	                        state.mode = LEN;
	                    case LEN:
	                        if (have >= 6 && left >= 258) {
	                            strm.next_out = put;
	                            strm.avail_out = left;
	                            strm.next_in = next;
	                            strm.avail_in = have;
	                            state.hold = hold;
	                            state.bits = bits;
	                            inflate_fast(strm, _out);
	                            put = strm.next_out;
	                            output = strm.output;
	                            left = strm.avail_out;
	                            next = strm.next_in;
	                            input = strm.input;
	                            have = strm.avail_in;
	                            hold = state.hold;
	                            bits = state.bits;
	                            if (state.mode === TYPE)
	                                state.back = -1;
	                            break
	                        }
	                        state.back = 0;
	                        for (; ; ) {
	                            here = state.lencode[hold & (1 << state.lenbits) - 1];
	                            here_bits = here >>> 24;
	                            here_op = here >>> 16 & 255;
	                            here_val = here & 65535;
	                            if (here_bits <= bits)
	                                break;
	                            if (have === 0)
	                                break inf_leave;
	                            have--;
	                            hold += input[next++] << bits;
	                            bits += 8
	                        }
	                        if (here_op && (here_op & 240) === 0) {
	                            last_bits = here_bits;
	                            last_op = here_op;
	                            last_val = here_val;
	                            for (; ; ) {
	                                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
	                                here_bits = here >>> 24;
	                                here_op = here >>> 16 & 255;
	                                here_val = here & 65535;
	                                if (last_bits + here_bits <= bits)
	                                    break;
	                                if (have === 0)
	                                    break inf_leave;
	                                have--;
	                                hold += input[next++] << bits;
	                                bits += 8
	                            }
	                            hold >>>= last_bits;
	                            bits -= last_bits;
	                            state.back += last_bits
	                        }
	                        hold >>>= here_bits;
	                        bits -= here_bits;
	                        state.back += here_bits;
	                        state.length = here_val;
	                        if (here_op === 0) {
	                            state.mode = LIT;
	                            break
	                        }
	                        if (here_op & 32) {
	                            state.back = -1;
	                            state.mode = TYPE;
	                            break
	                        }
	                        if (here_op & 64) {
	                            strm.msg = "invalid literal/length code";
	                            state.mode = BAD;
	                            break
	                        }
	                        state.extra = here_op & 15;
	                        state.mode = LENEXT;
	                    case LENEXT:
	                        if (state.extra) {
	                            n = state.extra;
	                            while (bits < n) {
	                                if (have === 0)
	                                    break inf_leave;
	                                have--;
	                                hold += input[next++] << bits;
	                                bits += 8
	                            }
	                            state.length += hold & (1 << state.extra) - 1;
	                            hold >>>= state.extra;
	                            bits -= state.extra;
	                            state.back += state.extra
	                        }
	                        state.was = state.length;
	                        state.mode = DIST;
	                    case DIST:
	                        for (; ; ) {
	                            here = state.distcode[hold & (1 << state.distbits) - 1];
	                            here_bits = here >>> 24;
	                            here_op = here >>> 16 & 255;
	                            here_val = here & 65535;
	                            if (here_bits <= bits)
	                                break;
	                            if (have === 0)
	                                break inf_leave;
	                            have--;
	                            hold += input[next++] << bits;
	                            bits += 8
	                        }
	                        if ((here_op & 240) === 0) {
	                            last_bits = here_bits;
	                            last_op = here_op;
	                            last_val = here_val;
	                            for (; ; ) {
	                                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
	                                here_bits = here >>> 24;
	                                here_op = here >>> 16 & 255;
	                                here_val = here & 65535;
	                                if (last_bits + here_bits <= bits)
	                                    break;
	                                if (have === 0)
	                                    break inf_leave;
	                                have--;
	                                hold += input[next++] << bits;
	                                bits += 8
	                            }
	                            hold >>>= last_bits;
	                            bits -= last_bits;
	                            state.back += last_bits
	                        }
	                        hold >>>= here_bits;
	                        bits -= here_bits;
	                        state.back += here_bits;
	                        if (here_op & 64) {
	                            strm.msg = "invalid distance code";
	                            state.mode = BAD;
	                            break
	                        }
	                        state.offset = here_val;
	                        state.extra = here_op & 15;
	                        state.mode = DISTEXT;
	                    case DISTEXT:
	                        if (state.extra) {
	                            n = state.extra;
	                            while (bits < n) {
	                                if (have === 0)
	                                    break inf_leave;
	                                have--;
	                                hold += input[next++] << bits;
	                                bits += 8
	                            }
	                            state.offset += hold & (1 << state.extra) - 1;
	                            hold >>>= state.extra;
	                            bits -= state.extra;
	                            state.back += state.extra
	                        }
	                        if (state.offset > state.dmax) {
	                            strm.msg = "invalid distance too far back";
	                            state.mode = BAD;
	                            break
	                        }
	                        state.mode = MATCH;
	                    case MATCH:
	                        if (left === 0)
	                            break inf_leave;
	                        copy = _out - left;
	                        if (state.offset > copy) {
	                            copy = state.offset - copy;
	                            if (copy > state.whave)
	                                if (state.sane) {
	                                    strm.msg = "invalid distance too far back";
	                                    state.mode = BAD;
	                                    break
	                                }
	                            if (copy > state.wnext) {
	                                copy -= state.wnext;
	                                from = state.wsize - copy
	                            } else
	                                from = state.wnext - copy;
	                            if (copy > state.length)
	                                copy = state.length;
	                            from_source = state.window
	                        } else {
	                            from_source = output;
	                            from = put - state.offset;
	                            copy = state.length
	                        }
	                        if (copy > left)
	                            copy = left;
	                        left -= copy;
	                        state.length -= copy;
	                        do
	                            output[put++] = from_source[from++];
	                        while (--copy);
	                        if (state.length === 0)
	                            state.mode = LEN;
	                        break;
	                    case LIT:
	                        if (left === 0)
	                            break inf_leave;
	                        output[put++] = state.length;
	                        left--;
	                        state.mode = LEN;
	                        break;
	                    case CHECK:
	                        if (state.wrap) {
	                            while (bits < 32) {
	                                if (have === 0)
	                                    break inf_leave;
	                                have--;
	                                hold |= input[next++] << bits;
	                                bits += 8
	                            }
	                            _out -= left;
	                            strm.total_out += _out;
	                            state.total += _out;
	                            if (_out)
	                                strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
	                            _out = left;
	                            if ((state.flags ? hold : ZSWAP32(hold)) !== state.check) {
	                                strm.msg = "incorrect data check";
	                                state.mode = BAD;
	                                break
	                            }
	                            hold = 0;
	                            bits = 0
	                        }
	                        state.mode = LENGTH;
	                    case LENGTH:
	                        if (state.wrap && state.flags) {
	                            while (bits < 32) {
	                                if (have === 0)
	                                    break inf_leave;
	                                have--;
	                                hold += input[next++] << bits;
	                                bits += 8
	                            }
	                            if (hold !== (state.total & 4294967295)) {
	                                strm.msg = "incorrect length check";
	                                state.mode = BAD;
	                                break
	                            }
	                            hold = 0;
	                            bits = 0
	                        }
	                        state.mode = DONE;
	                    case DONE:
	                        ret = Z_STREAM_END;
	                        break inf_leave;
	                    case BAD:
	                        ret = Z_DATA_ERROR;
	                        break inf_leave;
	                    case MEM:
	                        return Z_MEM_ERROR;
	                    case SYNC:
	                    default:
	                        return Z_STREAM_ERROR
	                    }
	                strm.next_out = put;
	                strm.avail_out = left;
	                strm.next_in = next;
	                strm.avail_in = have;
	                state.hold = hold;
	                state.bits = bits;
	                if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH))
	                    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
	                        state.mode = MEM;
	                        return Z_MEM_ERROR
	                    }
	                _in -= strm.avail_in;
	                _out -= strm.avail_out;
	                strm.total_in += _in;
	                strm.total_out += _out;
	                state.total += _out;
	                if (state.wrap && _out)
	                    strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
	                strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
	                if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK)
	                    ret = Z_BUF_ERROR;
	                return ret
	            }
	            function inflateEnd(strm) {
	                if (!strm || !strm.state)
	                    return Z_STREAM_ERROR;
	                var state = strm.state;
	                if (state.window)
	                    state.window = null;
	                strm.state = null;
	                return Z_OK
	            }
	            function inflateGetHeader(strm, head) {
	                var state;
	                if (!strm || !strm.state)
	                    return Z_STREAM_ERROR;
	                state = strm.state;
	                if ((state.wrap & 2) === 0)
	                    return Z_STREAM_ERROR;
	                state.head = head;
	                head.done = false;
	                return Z_OK
	            }
	            exports.inflateReset = inflateReset;
	            exports.inflateReset2 = inflateReset2;
	            exports.inflateResetKeep = inflateResetKeep;
	            exports.inflateInit = inflateInit;
	            exports.inflateInit2 = inflateInit2;
	            exports.inflate = inflate;
	            exports.inflateEnd = inflateEnd;
	            exports.inflateGetHeader = inflateGetHeader;
	            exports.inflateInfo = "pako inflate (from Nodeca project)"
	        }
	        , {
	            "../utils/common": 27,
	            "./adler32": 29,
	            "./crc32": 31,
	            "./inffast": 34,
	            "./inftrees": 36
	        }],
	        36: [function(_dereq_, module, exports) {
	            var utils = _dereq_("../utils/common");
	            var MAXBITS = 15;
	            var ENOUGH_LENS = 852;
	            var ENOUGH_DISTS = 592;
	            var CODES = 0;
	            var LENS = 1;
	            var DISTS = 2;
	            var lbase = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];
	            var lext = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78];
	            var dbase = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0];
	            var dext = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
	            module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
	                var bits = opts.bits;
	                var len = 0;
	                var sym = 0;
	                var min = 0
	                  , max = 0;
	                var root = 0;
	                var curr = 0;
	                var drop = 0;
	                var left = 0;
	                var used = 0;
	                var huff = 0;
	                var incr;
	                var fill;
	                var low;
	                var mask;
	                var next;
	                var base = null;
	                var base_index = 0;
	                var end;
	                var count = new utils.Buf16(MAXBITS + 1);
	                var offs = new utils.Buf16(MAXBITS + 1);
	                var extra = null;
	                var extra_index = 0;
	                var here_bits, here_op, here_val;
	                for (len = 0; len <= MAXBITS; len++)
	                    count[len] = 0;
	                for (sym = 0; sym < codes; sym++)
	                    count[lens[lens_index + sym]]++;
	                root = bits;
	                for (max = MAXBITS; max >= 1; max--)
	                    if (count[max] !== 0)
	                        break;
	                if (root > max)
	                    root = max;
	                if (max === 0) {
	                    table[table_index++] = 1 << 24 | 64 << 16 | 0;
	                    table[table_index++] = 1 << 24 | 64 << 16 | 0;
	                    opts.bits = 1;
	                    return 0
	                }
	                for (min = 1; min < max; min++)
	                    if (count[min] !== 0)
	                        break;
	                if (root < min)
	                    root = min;
	                left = 1;
	                for (len = 1; len <= MAXBITS; len++) {
	                    left <<= 1;
	                    left -= count[len];
	                    if (left < 0)
	                        return -1
	                }
	                if (left > 0 && (type === CODES || max !== 1))
	                    return -1;
	                offs[1] = 0;
	                for (len = 1; len < MAXBITS; len++)
	                    offs[len + 1] = offs[len] + count[len];
	                for (sym = 0; sym < codes; sym++)
	                    if (lens[lens_index + sym] !== 0)
	                        work[offs[lens[lens_index + sym]]++] = sym;
	                if (type === CODES) {
	                    base = extra = work;
	                    end = 19
	                } else if (type === LENS) {
	                    base = lbase;
	                    base_index -= 257;
	                    extra = lext;
	                    extra_index -= 257;
	                    end = 256
	                } else {
	                    base = dbase;
	                    extra = dext;
	                    end = -1
	                }
	                huff = 0;
	                sym = 0;
	                len = min;
	                next = table_index;
	                curr = root;
	                drop = 0;
	                low = -1;
	                used = 1 << root;
	                mask = used - 1;
	                if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS)
	                    return 1;
	                var i = 0;
	                for (; ; ) {
	                    i++;
	                    here_bits = len - drop;
	                    if (work[sym] < end) {
	                        here_op = 0;
	                        here_val = work[sym]
	                    } else if (work[sym] > end) {
	                        here_op = extra[extra_index + work[sym]];
	                        here_val = base[base_index + work[sym]]
	                    } else {
	                        here_op = 32 + 64;
	                        here_val = 0
	                    }
	                    incr = 1 << len - drop;
	                    fill = 1 << curr;
	                    min = fill;
	                    do {
	                        fill -= incr;
	                        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0
	                    } while (fill !== 0);
	                    incr = 1 << len - 1;
	                    while (huff & incr)
	                        incr >>= 1;
	                    if (incr !== 0) {
	                        huff &= incr - 1;
	                        huff += incr
	                    } else
	                        huff = 0;
	                    sym++;
	                    if (--count[len] === 0) {
	                        if (len === max)
	                            break;
	                        len = lens[lens_index + work[sym]]
	                    }
	                    if (len > root && (huff & mask) !== low) {
	                        if (drop === 0)
	                            drop = root;
	                        next += min;
	                        curr = len - drop;
	                        left = 1 << curr;
	                        while (curr + drop < max) {
	                            left -= count[curr + drop];
	                            if (left <= 0)
	                                break;
	                            curr++;
	                            left <<= 1
	                        }
	                        used += 1 << curr;
	                        if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS)
	                            return 1;
	                        low = huff & mask;
	                        table[low] = root << 24 | curr << 16 | next - table_index | 0
	                    }
	                }
	                if (huff !== 0)
	                    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
	                opts.bits = root;
	                return 0
	            }
	        }
	        , {
	            "../utils/common": 27
	        }],
	        37: [function(_dereq_, module, exports) {
	            module.exports = {
	                2: "need dictionary",
	                1: "stream end",
	                0: "",
	                "-1": "file error",
	                "-2": "stream error",
	                "-3": "data error",
	                "-4": "insufficient memory",
	                "-5": "buffer error",
	                "-6": "incompatible version"
	            }
	        }
	        , {}],
	        38: [function(_dereq_, module, exports) {
	            var utils = _dereq_("../utils/common");
	            var Z_FIXED = 4;
	            var Z_BINARY = 0;
	            var Z_TEXT = 1;
	            var Z_UNKNOWN = 2;
	            function zero(buf) {
	                var len = buf.length;
	                while (--len >= 0)
	                    buf[len] = 0
	            }
	            var STORED_BLOCK = 0;
	            var STATIC_TREES = 1;
	            var DYN_TREES = 2;
	            var MIN_MATCH = 3;
	            var MAX_MATCH = 258;
	            var LENGTH_CODES = 29;
	            var LITERALS = 256;
	            var L_CODES = LITERALS + 1 + LENGTH_CODES;
	            var D_CODES = 30;
	            var BL_CODES = 19;
	            var HEAP_SIZE = 2 * L_CODES + 1;
	            var MAX_BITS = 15;
	            var Buf_size = 16;
	            var MAX_BL_BITS = 7;
	            var END_BLOCK = 256;
	            var REP_3_6 = 16;
	            var REPZ_3_10 = 17;
	            var REPZ_11_138 = 18;
	            var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
	            var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
	            var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
	            var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
	            var DIST_CODE_LEN = 512;
	            var static_ltree = new Array((L_CODES + 2) * 2);
	            zero(static_ltree);
	            var static_dtree = new Array(D_CODES * 2);
	            zero(static_dtree);
	            var _dist_code = new Array(DIST_CODE_LEN);
	            zero(_dist_code);
	            var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
	            zero(_length_code);
	            var base_length = new Array(LENGTH_CODES);
	            zero(base_length);
	            var base_dist = new Array(D_CODES);
	            zero(base_dist);
	            var StaticTreeDesc = function(static_tree, extra_bits, extra_base, elems, max_length) {
	                this.static_tree = static_tree;
	                this.extra_bits = extra_bits;
	                this.extra_base = extra_base;
	                this.elems = elems;
	                this.max_length = max_length;
	                this.has_stree = static_tree && static_tree.length
	            };
	            var static_l_desc;
	            var static_d_desc;
	            var static_bl_desc;
	            var TreeDesc = function(dyn_tree, stat_desc) {
	                this.dyn_tree = dyn_tree;
	                this.max_code = 0;
	                this.stat_desc = stat_desc
	            };
	            function d_code(dist) {
	                return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)]
	            }
	            function put_short(s, w) {
	                s.pending_buf[s.pending++] = w & 255;
	                s.pending_buf[s.pending++] = w >>> 8 & 255
	            }
	            function send_bits(s, value, length) {
	                if (s.bi_valid > Buf_size - length) {
	                    s.bi_buf |= value << s.bi_valid & 65535;
	                    put_short(s, s.bi_buf);
	                    s.bi_buf = value >> Buf_size - s.bi_valid;
	                    s.bi_valid += length - Buf_size
	                } else {
	                    s.bi_buf |= value << s.bi_valid & 65535;
	                    s.bi_valid += length
	                }
	            }
	            function send_code(s, c, tree) {
	                send_bits(s, tree[c * 2], tree[c * 2 + 1])
	            }
	            function bi_reverse(code, len) {
	                var res = 0;
	                do {
	                    res |= code & 1;
	                    code >>>= 1;
	                    res <<= 1
	                } while (--len > 0);
	                return res >>> 1
	            }
	            function bi_flush(s) {
	                if (s.bi_valid === 16) {
	                    put_short(s, s.bi_buf);
	                    s.bi_buf = 0;
	                    s.bi_valid = 0
	                } else if (s.bi_valid >= 8) {
	                    s.pending_buf[s.pending++] = s.bi_buf & 255;
	                    s.bi_buf >>= 8;
	                    s.bi_valid -= 8
	                }
	            }
	            function gen_bitlen(s, desc) {
	                var tree = desc.dyn_tree;
	                var max_code = desc.max_code;
	                var stree = desc.stat_desc.static_tree;
	                var has_stree = desc.stat_desc.has_stree;
	                var extra = desc.stat_desc.extra_bits;
	                var base = desc.stat_desc.extra_base;
	                var max_length = desc.stat_desc.max_length;
	                var h;
	                var n, m;
	                var bits;
	                var xbits;
	                var f;
	                var overflow = 0;
	                for (bits = 0; bits <= MAX_BITS; bits++)
	                    s.bl_count[bits] = 0;
	                tree[s.heap[s.heap_max] * 2 + 1] = 0;
	                for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
	                    n = s.heap[h];
	                    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
	                    if (bits > max_length) {
	                        bits = max_length;
	                        overflow++
	                    }
	                    tree[n * 2 + 1] = bits;
	                    if (n > max_code)
	                        continue;
	                    s.bl_count[bits]++;
	                    xbits = 0;
	                    if (n >= base)
	                        xbits = extra[n - base];
	                    f = tree[n * 2];
	                    s.opt_len += f * (bits + xbits);
	                    if (has_stree)
	                        s.static_len += f * (stree[n * 2 + 1] + xbits)
	                }
	                if (overflow === 0)
	                    return;
	                do {
	                    bits = max_length - 1;
	                    while (s.bl_count[bits] === 0)
	                        bits--;
	                    s.bl_count[bits]--;
	                    s.bl_count[bits + 1] += 2;
	                    s.bl_count[max_length]--;
	                    overflow -= 2
	                } while (overflow > 0);
	                for (bits = max_length; bits !== 0; bits--) {
	                    n = s.bl_count[bits];
	                    while (n !== 0) {
	                        m = s.heap[--h];
	                        if (m > max_code)
	                            continue;
	                        if (tree[m * 2 + 1] !== bits) {
	                            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
	                            tree[m * 2 + 1] = bits
	                        }
	                        n--
	                    }
	                }
	            }
	            function gen_codes(tree, max_code, bl_count) {
	                var next_code = new Array(MAX_BITS + 1);
	                var code = 0;
	                var bits;
	                var n;
	                for (bits = 1; bits <= MAX_BITS; bits++)
	                    next_code[bits] = code = code + bl_count[bits - 1] << 1;
	                for (n = 0; n <= max_code; n++) {
	                    var len = tree[n * 2 + 1];
	                    if (len === 0)
	                        continue;
	                    tree[n * 2] = bi_reverse(next_code[len]++, len)
	                }
	            }
	            function tr_static_init() {
	                var n;
	                var bits;
	                var length;
	                var code;
	                var dist;
	                var bl_count = new Array(MAX_BITS + 1);
	                length = 0;
	                for (code = 0; code < LENGTH_CODES - 1; code++) {
	                    base_length[code] = length;
	                    for (n = 0; n < 1 << extra_lbits[code]; n++)
	                        _length_code[length++] = code
	                }
	                _length_code[length - 1] = code;
	                dist = 0;
	                for (code = 0; code < 16; code++) {
	                    base_dist[code] = dist;
	                    for (n = 0; n < 1 << extra_dbits[code]; n++)
	                        _dist_code[dist++] = code
	                }
	                dist >>= 7;
	                for (; code < D_CODES; code++) {
	                    base_dist[code] = dist << 7;
	                    for (n = 0; n < 1 << extra_dbits[code] - 7; n++)
	                        _dist_code[256 + dist++] = code
	                }
	                for (bits = 0; bits <= MAX_BITS; bits++)
	                    bl_count[bits] = 0;
	                n = 0;
	                while (n <= 143) {
	                    static_ltree[n * 2 + 1] = 8;
	                    n++;
	                    bl_count[8]++
	                }
	                while (n <= 255) {
	                    static_ltree[n * 2 + 1] = 9;
	                    n++;
	                    bl_count[9]++
	                }
	                while (n <= 279) {
	                    static_ltree[n * 2 + 1] = 7;
	                    n++;
	                    bl_count[7]++
	                }
	                while (n <= 287) {
	                    static_ltree[n * 2 + 1] = 8;
	                    n++;
	                    bl_count[8]++
	                }
	                gen_codes(static_ltree, L_CODES + 1, bl_count);
	                for (n = 0; n < D_CODES; n++) {
	                    static_dtree[n * 2 + 1] = 5;
	                    static_dtree[n * 2] = bi_reverse(n, 5)
	                }
	                static_l_desc = new StaticTreeDesc(static_ltree,extra_lbits,LITERALS + 1,L_CODES,MAX_BITS);
	                static_d_desc = new StaticTreeDesc(static_dtree,extra_dbits,0,D_CODES,MAX_BITS);
	                static_bl_desc = new StaticTreeDesc(new Array(0),extra_blbits,0,BL_CODES,MAX_BL_BITS)
	            }
	            function init_block(s) {
	                var n;
	                for (n = 0; n < L_CODES; n++)
	                    s.dyn_ltree[n * 2] = 0;
	                for (n = 0; n < D_CODES; n++)
	                    s.dyn_dtree[n * 2] = 0;
	                for (n = 0; n < BL_CODES; n++)
	                    s.bl_tree[n * 2] = 0;
	                s.dyn_ltree[END_BLOCK * 2] = 1;
	                s.opt_len = s.static_len = 0;
	                s.last_lit = s.matches = 0
	            }
	            function bi_windup(s) {
	                if (s.bi_valid > 8)
	                    put_short(s, s.bi_buf);
	                else if (s.bi_valid > 0)
	                    s.pending_buf[s.pending++] = s.bi_buf;
	                s.bi_buf = 0;
	                s.bi_valid = 0
	            }
	            function copy_block(s, buf, len, header) {
	                bi_windup(s);
	                if (header) {
	                    put_short(s, len);
	                    put_short(s, ~len)
	                }
	                utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
	                s.pending += len
	            }
	            function smaller(tree, n, m, depth) {
	                var _n2 = n * 2;
	                var _m2 = m * 2;
	                return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m]
	            }
	            function pqdownheap(s, tree, k) {
	                var v = s.heap[k];
	                var j = k << 1;
	                while (j <= s.heap_len) {
	                    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth))
	                        j++;
	                    if (smaller(tree, v, s.heap[j], s.depth))
	                        break;
	                    s.heap[k] = s.heap[j];
	                    k = j;
	                    j <<= 1
	                }
	                s.heap[k] = v
	            }
	            function compress_block(s, ltree, dtree) {
	                var dist;
	                var lc;
	                var lx = 0;
	                var code;
	                var extra;
	                if (s.last_lit !== 0) {
	                    do {
	                        dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
	                        lc = s.pending_buf[s.l_buf + lx];
	                        lx++;
	                        if (dist === 0)
	                            send_code(s, lc, ltree);
	                        else {
	                            code = _length_code[lc];
	                            send_code(s, code + LITERALS + 1, ltree);
	                            extra = extra_lbits[code];
	                            if (extra !== 0) {
	                                lc -= base_length[code];
	                                send_bits(s, lc, extra)
	                            }
	                            dist--;
	                            code = d_code(dist);
	                            send_code(s, code, dtree);
	                            extra = extra_dbits[code];
	                            if (extra !== 0) {
	                                dist -= base_dist[code];
	                                send_bits(s, dist, extra)
	                            }
	                        }
	                    } while (lx < s.last_lit)
	                }
	                send_code(s, END_BLOCK, ltree)
	            }
	            function build_tree(s, desc) {
	                var tree = desc.dyn_tree;
	                var stree = desc.stat_desc.static_tree;
	                var has_stree = desc.stat_desc.has_stree;
	                var elems = desc.stat_desc.elems;
	                var n, m;
	                var max_code = -1;
	                var node;
	                s.heap_len = 0;
	                s.heap_max = HEAP_SIZE;
	                for (n = 0; n < elems; n++)
	                    if (tree[n * 2] !== 0) {
	                        s.heap[++s.heap_len] = max_code = n;
	                        s.depth[n] = 0
	                    } else
	                        tree[n * 2 + 1] = 0;
	                while (s.heap_len < 2) {
	                    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
	                    tree[node * 2] = 1;
	                    s.depth[node] = 0;
	                    s.opt_len--;
	                    if (has_stree)
	                        s.static_len -= stree[node * 2 + 1]
	                }
	                desc.max_code = max_code;
	                for (n = s.heap_len >> 1; n >= 1; n--)
	                    pqdownheap(s, tree, n);
	                node = elems;
	                do {
	                    n = s.heap[1];
	                    s.heap[1] = s.heap[s.heap_len--];
	                    pqdownheap(s, tree, 1);
	                    m = s.heap[1];
	                    s.heap[--s.heap_max] = n;
	                    s.heap[--s.heap_max] = m;
	                    tree[node * 2] = tree[n * 2] + tree[m * 2];
	                    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
	                    tree[n * 2 + 1] = tree[m * 2 + 1] = node;
	                    s.heap[1] = node++;
	                    pqdownheap(s, tree, 1)
	                } while (s.heap_len >= 2);
	                s.heap[--s.heap_max] = s.heap[1];
	                gen_bitlen(s, desc);
	                gen_codes(tree, max_code, s.bl_count)
	            }
	            function scan_tree(s, tree, max_code) {
	                var n;
	                var prevlen = -1;
	                var curlen;
	                var nextlen = tree[0 * 2 + 1];
	                var count = 0;
	                var max_count = 7;
	                var min_count = 4;
	                if (nextlen === 0) {
	                    max_count = 138;
	                    min_count = 3
	                }
	                tree[(max_code + 1) * 2 + 1] = 65535;
	                for (n = 0; n <= max_code; n++) {
	                    curlen = nextlen;
	                    nextlen = tree[(n + 1) * 2 + 1];
	                    if (++count < max_count && curlen === nextlen)
	                        continue;
	                    else if (count < min_count)
	                        s.bl_tree[curlen * 2] += count;
	                    else if (curlen !== 0) {
	                        if (curlen !== prevlen)
	                            s.bl_tree[curlen * 2]++;
	                        s.bl_tree[REP_3_6 * 2]++
	                    } else if (count <= 10)
	                        s.bl_tree[REPZ_3_10 * 2]++;
	                    else
	                        s.bl_tree[REPZ_11_138 * 2]++;
	                    count = 0;
	                    prevlen = curlen;
	                    if (nextlen === 0) {
	                        max_count = 138;
	                        min_count = 3
	                    } else if (curlen === nextlen) {
	                        max_count = 6;
	                        min_count = 3
	                    } else {
	                        max_count = 7;
	                        min_count = 4
	                    }
	                }
	            }
	            function send_tree(s, tree, max_code) {
	                var n;
	                var prevlen = -1;
	                var curlen;
	                var nextlen = tree[0 * 2 + 1];
	                var count = 0;
	                var max_count = 7;
	                var min_count = 4;
	                if (nextlen === 0) {
	                    max_count = 138;
	                    min_count = 3
	                }
	                for (n = 0; n <= max_code; n++) {
	                    curlen = nextlen;
	                    nextlen = tree[(n + 1) * 2 + 1];
	                    if (++count < max_count && curlen === nextlen)
	                        continue;
	                    else if (count < min_count) {
	                        do
	                            send_code(s, curlen, s.bl_tree);
	                        while (--count !== 0)
	                    } else if (curlen !== 0) {
	                        if (curlen !== prevlen) {
	                            send_code(s, curlen, s.bl_tree);
	                            count--
	                        }
	                        send_code(s, REP_3_6, s.bl_tree);
	                        send_bits(s, count - 3, 2)
	                    } else if (count <= 10) {
	                        send_code(s, REPZ_3_10, s.bl_tree);
	                        send_bits(s, count - 3, 3)
	                    } else {
	                        send_code(s, REPZ_11_138, s.bl_tree);
	                        send_bits(s, count - 11, 7)
	                    }
	                    count = 0;
	                    prevlen = curlen;
	                    if (nextlen === 0) {
	                        max_count = 138;
	                        min_count = 3
	                    } else if (curlen === nextlen) {
	                        max_count = 6;
	                        min_count = 3
	                    } else {
	                        max_count = 7;
	                        min_count = 4
	                    }
	                }
	            }
	            function build_bl_tree(s) {
	                var max_blindex;
	                scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
	                scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
	                build_tree(s, s.bl_desc);
	                for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--)
	                    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0)
	                        break;
	                s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
	                return max_blindex
	            }
	            function send_all_trees(s, lcodes, dcodes, blcodes) {
	                var rank;
	                send_bits(s, lcodes - 257, 5);
	                send_bits(s, dcodes - 1, 5);
	                send_bits(s, blcodes - 4, 4);
	                for (rank = 0; rank < blcodes; rank++)
	                    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
	                send_tree(s, s.dyn_ltree, lcodes - 1);
	                send_tree(s, s.dyn_dtree, dcodes - 1)
	            }
	            function detect_data_type(s) {
	                var black_mask = 4093624447;
	                var n;
	                for (n = 0; n <= 31; n++,
	                black_mask >>>= 1)
	                    if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0)
	                        return Z_BINARY;
	                if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0)
	                    return Z_TEXT;
	                for (n = 32; n < LITERALS; n++)
	                    if (s.dyn_ltree[n * 2] !== 0)
	                        return Z_TEXT;
	                return Z_BINARY
	            }
	            var static_init_done = false;
	            function _tr_init(s) {
	                if (!static_init_done) {
	                    tr_static_init();
	                    static_init_done = true
	                }
	                s.l_desc = new TreeDesc(s.dyn_ltree,static_l_desc);
	                s.d_desc = new TreeDesc(s.dyn_dtree,static_d_desc);
	                s.bl_desc = new TreeDesc(s.bl_tree,static_bl_desc);
	                s.bi_buf = 0;
	                s.bi_valid = 0;
	                init_block(s)
	            }
	            function _tr_stored_block(s, buf, stored_len, last) {
	                send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
	                copy_block(s, buf, stored_len, true)
	            }
	            function _tr_align(s) {
	                send_bits(s, STATIC_TREES << 1, 3);
	                send_code(s, END_BLOCK, static_ltree);
	                bi_flush(s)
	            }
	            function _tr_flush_block(s, buf, stored_len, last) {
	                var opt_lenb, static_lenb;
	                var max_blindex = 0;
	                if (s.level > 0) {
	                    if (s.strm.data_type === Z_UNKNOWN)
	                        s.strm.data_type = detect_data_type(s);
	                    build_tree(s, s.l_desc);
	                    build_tree(s, s.d_desc);
	                    max_blindex = build_bl_tree(s);
	                    opt_lenb = s.opt_len + 3 + 7 >>> 3;
	                    static_lenb = s.static_len + 3 + 7 >>> 3;
	                    if (static_lenb <= opt_lenb)
	                        opt_lenb = static_lenb
	                } else
	                    opt_lenb = static_lenb = stored_len + 5;
	                if (stored_len + 4 <= opt_lenb && buf !== -1)
	                    _tr_stored_block(s, buf, stored_len, last);
	                else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
	                    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
	                    compress_block(s, static_ltree, static_dtree)
	                } else {
	                    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
	                    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
	                    compress_block(s, s.dyn_ltree, s.dyn_dtree)
	                }
	                init_block(s);
	                if (last)
	                    bi_windup(s)
	            }
	            function _tr_tally(s, dist, lc) {
	                s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
	                s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
	                s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
	                s.last_lit++;
	                if (dist === 0)
	                    s.dyn_ltree[lc * 2]++;
	                else {
	                    s.matches++;
	                    dist--;
	                    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
	                    s.dyn_dtree[d_code(dist) * 2]++
	                }
	                return s.last_lit === s.lit_bufsize - 1
	            }
	            exports._tr_init = _tr_init;
	            exports._tr_stored_block = _tr_stored_block;
	            exports._tr_flush_block = _tr_flush_block;
	            exports._tr_tally = _tr_tally;
	            exports._tr_align = _tr_align
	        }
	        , {
	            "../utils/common": 27
	        }],
	        39: [function(_dereq_, module, exports) {
	            function ZStream() {
	                this.input = null;
	                this.next_in = 0;
	                this.avail_in = 0;
	                this.total_in = 0;
	                this.output = null;
	                this.next_out = 0;
	                this.avail_out = 0;
	                this.total_out = 0;
	                this.msg = "";
	                this.state = null;
	                this.data_type = 2;
	                this.adler = 0
	            }
	            module.exports = ZStream
	        }
	        , {}]
	    }, {}, [9])(9)
	});

	return {
		runtime,
		odf
	}
});
define('skylark-webodf/main',[
	"skylark-langx-ns",
	"./webodf"
],function(skylark,webodf) {
	return skylark.attach("intg.webodf",webodf)
});
define('skylark-webodf', ['skylark-webodf/main'], function (main) { return main; });

define('skylark-viewerjs/ODFViewerPlugin',[
    "skylark-webodf",
    "./viewerjs"
],function(webodf,viewerjs) {
    function ODFViewerPlugin() {
        "use strict";

        function init(callback) {
            /*
            var lib = document.createElement('script'),
                pluginCSS;

            lib.async = false;
            lib.src = './webodf.js';
            lib.type = 'text/javascript';
            lib.onload = function () {
                runtime.loadClass('gui.HyperlinkClickHandler');
                runtime.loadClass('odf.OdfCanvas');
                runtime.loadClass('ops.Session');
                runtime.loadClass('gui.CaretManager');
                runtime.loadClass("gui.HyperlinkTooltipView");
                runtime.loadClass('gui.SessionController');
                runtime.loadClass('gui.SvgSelectionView');
                runtime.loadClass('gui.SelectionViewManager');
                runtime.loadClass('gui.ShadowCursor');
                runtime.loadClass('gui.SessionView');

                callback();
            };

            document.head.appendChild(lib);
            */
            callback();
        }

        // that should probably be provided by webodf
        function nsResolver(prefix) {
            var ns = {
                'draw' : "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0",
                'presentation' : "urn:oasis:names:tc:opendocument:xmlns:presentation:1.0",
                'text' : "urn:oasis:names:tc:opendocument:xmlns:text:1.0",
                'office' : "urn:oasis:names:tc:opendocument:xmlns:office:1.0"
            };
            return ns[prefix] || console.log('prefix [' + prefix + '] unknown.');
        }

        var self = this,
            pluginName = "WebODF",
            pluginURL = "http://webodf.org",
            odfCanvas = null,
            odfElement = null,
            initialized = false,
            root = null,
            documentType = null,
            pages = [],
            currentPage = null;

        this.initialize = function (viewerElement, documentUrl) {
            // If the URL has a fragment (#...), try to load the file it represents
            init(function () {
                var session,
                    sessionController,
                    sessionView,
                    odtDocument,
                    shadowCursor,
                    selectionViewManager,
                    caretManager,
                    localMemberId = 'localuser',
                    hyperlinkTooltipView,
                    eventManager;

                odfElement = document.getElementById('canvas');
                odfCanvas = new webodf.odf.OdfCanvas(odfElement);
                odfCanvas.load(documentUrl);

                odfCanvas.addListener('statereadychange', function () {
                    root = odfCanvas.odfContainer().rootElement;
                    initialized = true;
                    documentType = odfCanvas.odfContainer().getDocumentType(root);
                    if (documentType === 'text') {
                        odfCanvas.enableAnnotations(true, false);

                        session = new ops.Session(odfCanvas);
                        odtDocument = session.getOdtDocument();
                        shadowCursor = new gui.ShadowCursor(odtDocument);
                        sessionController = new gui.SessionController(session, localMemberId, shadowCursor, {});
                        eventManager = sessionController.getEventManager();
                        caretManager = new gui.CaretManager(sessionController, odfCanvas.getViewport());
                        selectionViewManager = new gui.SelectionViewManager(gui.SvgSelectionView);
                        sessionView = new gui.SessionView({
                            caretAvatarsInitiallyVisible: false
                        }, localMemberId, session, sessionController.getSessionConstraints(), caretManager, selectionViewManager);
                        selectionViewManager.registerCursor(shadowCursor);
                        hyperlinkTooltipView = new gui.HyperlinkTooltipView(odfCanvas,
                            sessionController.getHyperlinkClickHandler().getModifier);
                        eventManager.subscribe("mousemove", hyperlinkTooltipView.showTooltip);
                        eventManager.subscribe("mouseout", hyperlinkTooltipView.hideTooltip);

                        var op = new ops.OpAddMember();
                        op.init({
                            memberid: localMemberId,
                            setProperties: {
                                fillName: webodf.runtime.tr("Unknown Author"),
                                color: "blue"
                            }
                        });
                        session.enqueue([op]);
                        sessionController.insertLocalCursor();
                    }

                    self.onLoad();
                });
            });
        };

        this.isSlideshow = function () {
            return documentType === 'presentation';
        };

        this.onLoad = function () {};

        this.fitToWidth = function (width) {
            odfCanvas.fitToWidth(width);
        };

        this.fitToHeight = function (height) {
            odfCanvas.fitToHeight(height);
        };

        this.fitToPage = function (width, height) {
            odfCanvas.fitToContainingElement(width, height);
        };

        this.fitSmart = function (width) {
            odfCanvas.fitSmart(width);
        };

        this.getZoomLevel = function () {
            return odfCanvas.getZoomLevel();
        };

        this.setZoomLevel = function (value) {
            odfCanvas.setZoomLevel(value);
        };

        // return a list of tuples (pagename, pagenode)
        this.getPages = function () {
            var pageNodes = Array.prototype.slice.call(root.getElementsByTagNameNS(nsResolver('draw'), 'page')),
                pages  = [],
                i,
                tuple;

            for (i = 0; i < pageNodes.length; i += 1) {
                tuple = [
                    pageNodes[i].getAttribute('draw:name'),
                    pageNodes[i]
                ];
                pages.push(tuple);
            }
            return pages;
        };

        this.showPage = function (n) {
            odfCanvas.showPage(n);
        };

        this.getPluginName = function () {
            return pluginName;
        };

        this.getPluginVersion = function () {
            var version;

            if (String(typeof webodf) !== "undefined") {
                version = webodf.Version;
            } else {
                version = "Unknown";
            }

            return version;
        };

        this.getPluginURL = function () {
            return pluginURL;
        };
    }

    return viewerjs.ODFViewerPlugin = ODFViewerPlugin;
});



define('skylark-langx/skylark',[
    "skylark-langx-ns"
], function(ns) {
	return ns;
});

define('skylark-pdfjs-display/pdfjs',[
	"skylark-langx/skylark"
],function(skylark) {
	return skylark.attach("intg.pdfjs");
});
define('skylark-pdfjs-display/display',[
  "./pdfjs"
],function(pdfjs){
return pdfjs.display = /******/ (() => { // webpackBootstrap
/******/  "use strict";
/******/  var __webpack_modules__ = ([
/* 0 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {
  Object.defineProperty(exports, "__esModule", ({
    value: true
  }));
  Object.defineProperty(exports, "addLinkAttributes", ({
    enumerable: true,
    get: function () {
      return _display_utils.addLinkAttributes;
    }
  }));
  Object.defineProperty(exports, "getFilenameFromUrl", ({
    enumerable: true,
    get: function () {
      return _display_utils.getFilenameFromUrl;
    }
  }));
  Object.defineProperty(exports, "LinkTarget", ({
    enumerable: true,
    get: function () {
      return _display_utils.LinkTarget;
    }
  }));
  Object.defineProperty(exports, "loadScript", ({
    enumerable: true,
    get: function () {
      return _display_utils.loadScript;
    }
  }));
  Object.defineProperty(exports, "PDFDateString", ({
    enumerable: true,
    get: function () {
      return _display_utils.PDFDateString;
    }
  }));
  Object.defineProperty(exports, "RenderingCancelledException", ({
    enumerable: true,
    get: function () {
      return _display_utils.RenderingCancelledException;
    }
  }));
  Object.defineProperty(exports, "build", ({
    enumerable: true,
    get: function () {
      return _api.build;
    }
  }));
  Object.defineProperty(exports, "getDocument", ({
    enumerable: true,
    get: function () {
      return _api.getDocument;
    }
  }));
  Object.defineProperty(exports, "LoopbackPort", ({
    enumerable: true,
    get: function () {
      return _api.LoopbackPort;
    }
  }));
  Object.defineProperty(exports, "PDFDataRangeTransport", ({
    enumerable: true,
    get: function () {
      return _api.PDFDataRangeTransport;
    }
  }));
  Object.defineProperty(exports, "PDFWorker", ({
    enumerable: true,
    get: function () {
      return _api.PDFWorker;
    }
  }));
  Object.defineProperty(exports, "version", ({
    enumerable: true,
    get: function () {
      return _api.version;
    }
  }));
  Object.defineProperty(exports, "CMapCompressionType", ({
    enumerable: true,
    get: function () {
      return _util.CMapCompressionType;
    }
  }));
  Object.defineProperty(exports, "createObjectURL", ({
    enumerable: true,
    get: function () {
      return _util.createObjectURL;
    }
  }));
  Object.defineProperty(exports, "createPromiseCapability", ({
    enumerable: true,
    get: function () {
      return _util.createPromiseCapability;
    }
  }));
  Object.defineProperty(exports, "createValidAbsoluteUrl", ({
    enumerable: true,
    get: function () {
      return _util.createValidAbsoluteUrl;
    }
  }));
  Object.defineProperty(exports, "InvalidPDFException", ({
    enumerable: true,
    get: function () {
      return _util.InvalidPDFException;
    }
  }));
  Object.defineProperty(exports, "MissingPDFException", ({
    enumerable: true,
    get: function () {
      return _util.MissingPDFException;
    }
  }));
  Object.defineProperty(exports, "OPS", ({
    enumerable: true,
    get: function () {
      return _util.OPS;
    }
  }));
  Object.defineProperty(exports, "PasswordResponses", ({
    enumerable: true,
    get: function () {
      return _util.PasswordResponses;
    }
  }));
  Object.defineProperty(exports, "PermissionFlag", ({
    enumerable: true,
    get: function () {
      return _util.PermissionFlag;
    }
  }));
  Object.defineProperty(exports, "removeNullCharacters", ({
    enumerable: true,
    get: function () {
      return _util.removeNullCharacters;
    }
  }));
  Object.defineProperty(exports, "shadow", ({
    enumerable: true,
    get: function () {
      return _util.shadow;
    }
  }));
  Object.defineProperty(exports, "UnexpectedResponseException", ({
    enumerable: true,
    get: function () {
      return _util.UnexpectedResponseException;
    }
  }));
  Object.defineProperty(exports, "UNSUPPORTED_FEATURES", ({
    enumerable: true,
    get: function () {
      return _util.UNSUPPORTED_FEATURES;
    }
  }));
  Object.defineProperty(exports, "Util", ({
    enumerable: true,
    get: function () {
      return _util.Util;
    }
  }));
  Object.defineProperty(exports, "VerbosityLevel", ({
    enumerable: true,
    get: function () {
      return _util.VerbosityLevel;
    }
  }));
  Object.defineProperty(exports, "AnnotationLayer", ({
    enumerable: true,
    get: function () {
      return _annotation_layer.AnnotationLayer;
    }
  }));
  Object.defineProperty(exports, "apiCompatibilityParams", ({
    enumerable: true,
    get: function () {
      return _api_compatibility.apiCompatibilityParams;
    }
  }));
  Object.defineProperty(exports, "GlobalWorkerOptions", ({
    enumerable: true,
    get: function () {
      return _worker_options.GlobalWorkerOptions;
    }
  }));
  Object.defineProperty(exports, "renderTextLayer", ({
    enumerable: true,
    get: function () {
      return _text_layer.renderTextLayer;
    }
  }));
  Object.defineProperty(exports, "SVGGraphics", ({
    enumerable: true,
    get: function () {
      return _svg.SVGGraphics;
    }
  }));

  var _display_utils = __w_pdfjs_require__(1);

  var _api = __w_pdfjs_require__(5);

  var _util = __w_pdfjs_require__(2);

  var _annotation_layer = __w_pdfjs_require__(19);

  var _api_compatibility = __w_pdfjs_require__(9);

  var _worker_options = __w_pdfjs_require__(12);

  var _text_layer = __w_pdfjs_require__(21);

  var _svg = __w_pdfjs_require__(22);

  const pdfjsVersion = '2.7.570';
  const pdfjsBuild = 'f2c7338b0';
  {
    const {
      isNodeJS
    } = __w_pdfjs_require__(4);

    if (isNodeJS) {
      const PDFNodeStream = __w_pdfjs_require__(23).PDFNodeStream;

      (0, _api.setPDFNetworkStreamFactory)(params => {
        return new PDFNodeStream(params);
      });
    } else {
      const PDFNetworkStream = __w_pdfjs_require__(26).PDFNetworkStream;

      let PDFFetchStream;

      if ((0, _display_utils.isFetchSupported)()) {
        PDFFetchStream = __w_pdfjs_require__(27).PDFFetchStream;
      }

      (0, _api.setPDFNetworkStreamFactory)(params => {
        if (PDFFetchStream && (0, _display_utils.isValidFetchUrl)(params.url)) {
          return new PDFFetchStream(params);
        }

        return new PDFNetworkStream(params);
      });
    }
  }

  /***/ }),
  /* 1 */
  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



  Object.defineProperty(exports, "__esModule", ({
    value: true
  }));
  exports.addLinkAttributes = addLinkAttributes;
  exports.deprecated = deprecated;
  exports.getFilenameFromUrl = getFilenameFromUrl;
  exports.isFetchSupported = isFetchSupported;
  exports.isValidFetchUrl = isValidFetchUrl;
  exports.loadScript = loadScript;
  exports.StatTimer = exports.RenderingCancelledException = exports.PDFDateString = exports.PageViewport = exports.LinkTarget = exports.DOMSVGFactory = exports.DOMCMapReaderFactory = exports.DOMCanvasFactory = exports.DEFAULT_LINK_REL = exports.BaseCMapReaderFactory = exports.BaseCanvasFactory = void 0;

  var _util = __w_pdfjs_require__(2);

  const DEFAULT_LINK_REL = "noopener noreferrer nofollow";
  exports.DEFAULT_LINK_REL = DEFAULT_LINK_REL;
  const SVG_NS = "http://www.w3.org/2000/svg";

  class BaseCanvasFactory {
    constructor() {
      if (this.constructor === BaseCanvasFactory) {
        (0, _util.unreachable)("Cannot initialize BaseCanvasFactory.");
      }
    }

    create(width, height) {
      (0, _util.unreachable)("Abstract method `create` called.");
    }

    reset(canvasAndContext, width, height) {
      if (!canvasAndContext.canvas) {
        throw new Error("Canvas is not specified");
      }

      if (width <= 0 || height <= 0) {
        throw new Error("Invalid canvas size");
      }

      canvasAndContext.canvas.width = width;
      canvasAndContext.canvas.height = height;
    }

    destroy(canvasAndContext) {
      if (!canvasAndContext.canvas) {
        throw new Error("Canvas is not specified");
      }

      canvasAndContext.canvas.width = 0;
      canvasAndContext.canvas.height = 0;
      canvasAndContext.canvas = null;
      canvasAndContext.context = null;
    }

  }

  exports.BaseCanvasFactory = BaseCanvasFactory;

  class DOMCanvasFactory extends BaseCanvasFactory {
    constructor({
      ownerDocument = globalThis.document
    } = {}) {
      super();
      this._document = ownerDocument;
    }

    create(width, height) {
      if (width <= 0 || height <= 0) {
        throw new Error("Invalid canvas size");
      }

      const canvas = this._document.createElement("canvas");

      const context = canvas.getContext("2d");
      canvas.width = width;
      canvas.height = height;
      return {
        canvas,
        context
      };
    }

  }

  exports.DOMCanvasFactory = DOMCanvasFactory;

  class BaseCMapReaderFactory {
    constructor({
      baseUrl = null,
      isCompressed = false
    }) {
      if (this.constructor === BaseCMapReaderFactory) {
        (0, _util.unreachable)("Cannot initialize BaseCMapReaderFactory.");
      }

      this.baseUrl = baseUrl;
      this.isCompressed = isCompressed;
    }

    async fetch({
      name
    }) {
      if (!this.baseUrl) {
        throw new Error('The CMap "baseUrl" parameter must be specified, ensure that ' + 'the "cMapUrl" and "cMapPacked" API parameters are provided.');
      }

      if (!name) {
        throw new Error("CMap name must be specified.");
      }

      const url = this.baseUrl + name + (this.isCompressed ? ".bcmap" : "");
      const compressionType = this.isCompressed ? _util.CMapCompressionType.BINARY : _util.CMapCompressionType.NONE;
      return this._fetchData(url, compressionType).catch(reason => {
        throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${url}`);
      });
    }

    _fetchData(url, compressionType) {
      (0, _util.unreachable)("Abstract method `_fetchData` called.");
    }

  }

  exports.BaseCMapReaderFactory = BaseCMapReaderFactory;

  class DOMCMapReaderFactory extends BaseCMapReaderFactory {
    _fetchData(url, compressionType) {
      if (isFetchSupported() && isValidFetchUrl(url, document.baseURI)) {
        return fetch(url).then(async response => {
          if (!response.ok) {
            throw new Error(response.statusText);
          }

          let cMapData;

          if (this.isCompressed) {
            cMapData = new Uint8Array(await response.arrayBuffer());
          } else {
            cMapData = (0, _util.stringToBytes)(await response.text());
          }

          return {
            cMapData,
            compressionType
          };
        });
      }

      return new Promise((resolve, reject) => {
        const request = new XMLHttpRequest();
        request.open("GET", url, true);

        if (this.isCompressed) {
          request.responseType = "arraybuffer";
        }

        request.onreadystatechange = () => {
          if (request.readyState !== XMLHttpRequest.DONE) {
            return;
          }

          if (request.status === 200 || request.status === 0) {
            let cMapData;

            if (this.isCompressed && request.response) {
              cMapData = new Uint8Array(request.response);
            } else if (!this.isCompressed && request.responseText) {
              cMapData = (0, _util.stringToBytes)(request.responseText);
            }

            if (cMapData) {
              resolve({
                cMapData,
                compressionType
              });
              return;
            }
          }

          reject(new Error(request.statusText));
        };

        request.send(null);
      });
    }

  }

  exports.DOMCMapReaderFactory = DOMCMapReaderFactory;

  class DOMSVGFactory {
    create(width, height) {
      (0, _util.assert)(width > 0 && height > 0, "Invalid SVG dimensions");
      const svg = document.createElementNS(SVG_NS, "svg:svg");
      svg.setAttribute("version", "1.1");
      svg.setAttribute("width", width + "px");
      svg.setAttribute("height", height + "px");
      svg.setAttribute("preserveAspectRatio", "none");
      svg.setAttribute("viewBox", "0 0 " + width + " " + height);
      return svg;
    }

    createElement(type) {
      (0, _util.assert)(typeof type === "string", "Invalid SVG element type");
      return document.createElementNS(SVG_NS, type);
    }

  }

  exports.DOMSVGFactory = DOMSVGFactory;

  class PageViewport {
    constructor({
      viewBox,
      scale,
      rotation,
      offsetX = 0,
      offsetY = 0,
      dontFlip = false
    }) {
      this.viewBox = viewBox;
      this.scale = scale;
      this.rotation = rotation;
      this.offsetX = offsetX;
      this.offsetY = offsetY;
      const centerX = (viewBox[2] + viewBox[0]) / 2;
      const centerY = (viewBox[3] + viewBox[1]) / 2;
      let rotateA, rotateB, rotateC, rotateD;
      rotation = rotation % 360;
      rotation = rotation < 0 ? rotation + 360 : rotation;

      switch (rotation) {
        case 180:
          rotateA = -1;
          rotateB = 0;
          rotateC = 0;
          rotateD = 1;
          break;

        case 90:
          rotateA = 0;
          rotateB = 1;
          rotateC = 1;
          rotateD = 0;
          break;

        case 270:
          rotateA = 0;
          rotateB = -1;
          rotateC = -1;
          rotateD = 0;
          break;

        case 0:
          rotateA = 1;
          rotateB = 0;
          rotateC = 0;
          rotateD = -1;
          break;

        default:
          throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
      }

      if (dontFlip) {
        rotateC = -rotateC;
        rotateD = -rotateD;
      }

      let offsetCanvasX, offsetCanvasY;
      let width, height;

      if (rotateA === 0) {
        offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
        offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
        width = Math.abs(viewBox[3] - viewBox[1]) * scale;
        height = Math.abs(viewBox[2] - viewBox[0]) * scale;
      } else {
        offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
        offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
        width = Math.abs(viewBox[2] - viewBox[0]) * scale;
        height = Math.abs(viewBox[3] - viewBox[1]) * scale;
      }

      this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
      this.width = width;
      this.height = height;
    }

    clone({
      scale = this.scale,
      rotation = this.rotation,
      offsetX = this.offsetX,
      offsetY = this.offsetY,
      dontFlip = false
    } = {}) {
      return new PageViewport({
        viewBox: this.viewBox.slice(),
        scale,
        rotation,
        offsetX,
        offsetY,
        dontFlip
      });
    }

    convertToViewportPoint(x, y) {
      return _util.Util.applyTransform([x, y], this.transform);
    }

    convertToViewportRectangle(rect) {
      const topLeft = _util.Util.applyTransform([rect[0], rect[1]], this.transform);

      const bottomRight = _util.Util.applyTransform([rect[2], rect[3]], this.transform);

      return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];
    }

    convertToPdfPoint(x, y) {
      return _util.Util.applyInverseTransform([x, y], this.transform);
    }

  }

  exports.PageViewport = PageViewport;

  class RenderingCancelledException extends _util.BaseException {
    constructor(msg, type) {
      super(msg);
      this.type = type;
    }

  }

  exports.RenderingCancelledException = RenderingCancelledException;
  const LinkTarget = {
    NONE: 0,
    SELF: 1,
    BLANK: 2,
    PARENT: 3,
    TOP: 4
  };
  exports.LinkTarget = LinkTarget;

  function addLinkAttributes(link, {
    url,
    target,
    rel,
    enabled = true
  } = {}) {
    (0, _util.assert)(url && typeof url === "string", 'addLinkAttributes: A valid "url" parameter must provided.');
    const urlNullRemoved = (0, _util.removeNullCharacters)(url);

    if (enabled) {
      link.href = link.title = urlNullRemoved;
    } else {
      link.href = "";
      link.title = `Disabled: ${urlNullRemoved}`;

      link.onclick = () => {
        return false;
      };
    }

    let targetStr = "";

    switch (target) {
      case LinkTarget.NONE:
        break;

      case LinkTarget.SELF:
        targetStr = "_self";
        break;

      case LinkTarget.BLANK:
        targetStr = "_blank";
        break;

      case LinkTarget.PARENT:
        targetStr = "_parent";
        break;

      case LinkTarget.TOP:
        targetStr = "_top";
        break;
    }

    link.target = targetStr;
    link.rel = typeof rel === "string" ? rel : DEFAULT_LINK_REL;
  }

  function getFilenameFromUrl(url) {
    const anchor = url.indexOf("#");
    const query = url.indexOf("?");
    const end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);
    return url.substring(url.lastIndexOf("/", end) + 1, end);
  }

  class StatTimer {
    constructor() {
      this.started = Object.create(null);
      this.times = [];
    }

    time(name) {
      if (name in this.started) {
        (0, _util.warn)(`Timer is already running for ${name}`);
      }

      this.started[name] = Date.now();
    }

    timeEnd(name) {
      if (!(name in this.started)) {
        (0, _util.warn)(`Timer has not been started for ${name}`);
      }

      this.times.push({
        name,
        start: this.started[name],
        end: Date.now()
      });
      delete this.started[name];
    }

    toString() {
      const outBuf = [];
      let longest = 0;

      for (const time of this.times) {
        const name = time.name;

        if (name.length > longest) {
          longest = name.length;
        }
      }

      for (const time of this.times) {
        const duration = time.end - time.start;
        outBuf.push(`${time.name.padEnd(longest)} ${duration}ms\n`);
      }

      return outBuf.join("");
    }

  }

  exports.StatTimer = StatTimer;

  function isFetchSupported() {
    return typeof fetch !== "undefined" && typeof Response !== "undefined" && "body" in Response.prototype && typeof ReadableStream !== "undefined";
  }

  function isValidFetchUrl(url, baseUrl) {
    try {
      const {
        protocol
      } = baseUrl ? new URL(url, baseUrl) : new URL(url);
      return protocol === "http:" || protocol === "https:";
    } catch (ex) {
      return false;
    }
  }

  function loadScript(src, removeScriptElement = false) {
    return new Promise((resolve, reject) => {
      const script = document.createElement("script");
      script.src = src;

      script.onload = function (evt) {
        if (removeScriptElement) {
          script.remove();
        }

        resolve(evt);
      };

      script.onerror = function () {
        reject(new Error(`Cannot load script at: ${script.src}`));
      };

      (document.head || document.documentElement).appendChild(script);
    });
  }

  function deprecated(details) {
    console.log("Deprecated API usage: " + details);
  }

  let pdfDateStringRegex;

  class PDFDateString {
    static toDateObject(input) {
      if (!input || !(0, _util.isString)(input)) {
        return null;
      }

      if (!pdfDateStringRegex) {
        pdfDateStringRegex = new RegExp("^D:" + "(\\d{4})" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "([Z|+|-])?" + "(\\d{2})?" + "'?" + "(\\d{2})?" + "'?");
      }

      const matches = pdfDateStringRegex.exec(input);

      if (!matches) {
        return null;
      }

      const year = parseInt(matches[1], 10);
      let month = parseInt(matches[2], 10);
      month = month >= 1 && month <= 12 ? month - 1 : 0;
      let day = parseInt(matches[3], 10);
      day = day >= 1 && day <= 31 ? day : 1;
      let hour = parseInt(matches[4], 10);
      hour = hour >= 0 && hour <= 23 ? hour : 0;
      let minute = parseInt(matches[5], 10);
      minute = minute >= 0 && minute <= 59 ? minute : 0;
      let second = parseInt(matches[6], 10);
      second = second >= 0 && second <= 59 ? second : 0;
      const universalTimeRelation = matches[7] || "Z";
      let offsetHour = parseInt(matches[8], 10);
      offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;
      let offsetMinute = parseInt(matches[9], 10) || 0;
      offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;

      if (universalTimeRelation === "-") {
        hour += offsetHour;
        minute += offsetMinute;
      } else if (universalTimeRelation === "+") {
        hour -= offsetHour;
        minute -= offsetMinute;
      }

      return new Date(Date.UTC(year, month, day, hour, minute, second));
    }

  }

  exports.PDFDateString = PDFDateString;

  /***/ }),
  /* 2 */
  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



  Object.defineProperty(exports, "__esModule", ({
    value: true
  }));
  exports.arrayByteLength = arrayByteLength;
  exports.arraysToBytes = arraysToBytes;
  exports.assert = assert;
  exports.bytesToString = bytesToString;
  exports.createPromiseCapability = createPromiseCapability;
  exports.createValidAbsoluteUrl = createValidAbsoluteUrl;
  exports.encodeToXmlString = encodeToXmlString;
  exports.escapeString = escapeString;
  exports.getModificationDate = getModificationDate;
  exports.getVerbosityLevel = getVerbosityLevel;
  exports.info = info;
  exports.isArrayBuffer = isArrayBuffer;
  exports.isArrayEqual = isArrayEqual;
  exports.isAscii = isAscii;
  exports.isBool = isBool;
  exports.isNum = isNum;
  exports.isSameOrigin = isSameOrigin;
  exports.isString = isString;
  exports.objectFromEntries = objectFromEntries;
  exports.objectSize = objectSize;
  exports.removeNullCharacters = removeNullCharacters;
  exports.setVerbosityLevel = setVerbosityLevel;
  exports.shadow = shadow;
  exports.string32 = string32;
  exports.stringToBytes = stringToBytes;
  exports.stringToPDFString = stringToPDFString;
  exports.stringToUTF16BEString = stringToUTF16BEString;
  exports.stringToUTF8String = stringToUTF8String;
  exports.unreachable = unreachable;
  exports.utf8StringToString = utf8StringToString;
  exports.warn = warn;
  exports.VerbosityLevel = exports.Util = exports.UNSUPPORTED_FEATURES = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.TextRenderingMode = exports.StreamType = exports.PermissionFlag = exports.PasswordResponses = exports.PasswordException = exports.PageActionEventType = exports.OPS = exports.MissingPDFException = exports.IsLittleEndianCached = exports.IsEvalSupportedCached = exports.InvalidPDFException = exports.ImageKind = exports.IDENTITY_MATRIX = exports.FormatError = exports.FontType = exports.FONT_IDENTITY_MATRIX = exports.DocumentActionEventType = exports.createObjectURL = exports.CMapCompressionType = exports.BaseException = exports.AnnotationType = exports.AnnotationStateModelType = exports.AnnotationReviewState = exports.AnnotationReplyType = exports.AnnotationMarkedState = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationBorderStyleType = exports.AnnotationActionEventType = exports.AbortException = void 0;

  __w_pdfjs_require__(3);

  const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
  exports.IDENTITY_MATRIX = IDENTITY_MATRIX;
  const FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];
  exports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
  const PermissionFlag = {
    PRINT: 0x04,
    MODIFY_CONTENTS: 0x08,
    COPY: 0x10,
    MODIFY_ANNOTATIONS: 0x20,
    FILL_INTERACTIVE_FORMS: 0x100,
    COPY_FOR_ACCESSIBILITY: 0x200,
    ASSEMBLE: 0x400,
    PRINT_HIGH_QUALITY: 0x800
  };
  exports.PermissionFlag = PermissionFlag;
  const TextRenderingMode = {
    FILL: 0,
    STROKE: 1,
    FILL_STROKE: 2,
    INVISIBLE: 3,
    FILL_ADD_TO_PATH: 4,
    STROKE_ADD_TO_PATH: 5,
    FILL_STROKE_ADD_TO_PATH: 6,
    ADD_TO_PATH: 7,
    FILL_STROKE_MASK: 3,
    ADD_TO_PATH_FLAG: 4
  };
  exports.TextRenderingMode = TextRenderingMode;
  const ImageKind = {
    GRAYSCALE_1BPP: 1,
    RGB_24BPP: 2,
    RGBA_32BPP: 3
  };
  exports.ImageKind = ImageKind;
  const AnnotationType = {
    TEXT: 1,
    LINK: 2,
    FREETEXT: 3,
    LINE: 4,
    SQUARE: 5,
    CIRCLE: 6,
    POLYGON: 7,
    POLYLINE: 8,
    HIGHLIGHT: 9,
    UNDERLINE: 10,
    SQUIGGLY: 11,
    STRIKEOUT: 12,
    STAMP: 13,
    CARET: 14,
    INK: 15,
    POPUP: 16,
    FILEATTACHMENT: 17,
    SOUND: 18,
    MOVIE: 19,
    WIDGET: 20,
    SCREEN: 21,
    PRINTERMARK: 22,
    TRAPNET: 23,
    WATERMARK: 24,
    THREED: 25,
    REDACT: 26
  };
  exports.AnnotationType = AnnotationType;
  const AnnotationStateModelType = {
    MARKED: "Marked",
    REVIEW: "Review"
  };
  exports.AnnotationStateModelType = AnnotationStateModelType;
  const AnnotationMarkedState = {
    MARKED: "Marked",
    UNMARKED: "Unmarked"
  };
  exports.AnnotationMarkedState = AnnotationMarkedState;
  const AnnotationReviewState = {
    ACCEPTED: "Accepted",
    REJECTED: "Rejected",
    CANCELLED: "Cancelled",
    COMPLETED: "Completed",
    NONE: "None"
  };
  exports.AnnotationReviewState = AnnotationReviewState;
  const AnnotationReplyType = {
    GROUP: "Group",
    REPLY: "R"
  };
  exports.AnnotationReplyType = AnnotationReplyType;
  const AnnotationFlag = {
    INVISIBLE: 0x01,
    HIDDEN: 0x02,
    PRINT: 0x04,
    NOZOOM: 0x08,
    NOROTATE: 0x10,
    NOVIEW: 0x20,
    READONLY: 0x40,
    LOCKED: 0x80,
    TOGGLENOVIEW: 0x100,
    LOCKEDCONTENTS: 0x200
  };
  exports.AnnotationFlag = AnnotationFlag;
  const AnnotationFieldFlag = {
    READONLY: 0x0000001,
    REQUIRED: 0x0000002,
    NOEXPORT: 0x0000004,
    MULTILINE: 0x0001000,
    PASSWORD: 0x0002000,
    NOTOGGLETOOFF: 0x0004000,
    RADIO: 0x0008000,
    PUSHBUTTON: 0x0010000,
    COMBO: 0x0020000,
    EDIT: 0x0040000,
    SORT: 0x0080000,
    FILESELECT: 0x0100000,
    MULTISELECT: 0x0200000,
    DONOTSPELLCHECK: 0x0400000,
    DONOTSCROLL: 0x0800000,
    COMB: 0x1000000,
    RICHTEXT: 0x2000000,
    RADIOSINUNISON: 0x2000000,
    COMMITONSELCHANGE: 0x4000000
  };
  exports.AnnotationFieldFlag = AnnotationFieldFlag;
  const AnnotationBorderStyleType = {
    SOLID: 1,
    DASHED: 2,
    BEVELED: 3,
    INSET: 4,
    UNDERLINE: 5
  };
  exports.AnnotationBorderStyleType = AnnotationBorderStyleType;
  const AnnotationActionEventType = {
    E: "Mouse Enter",
    X: "Mouse Exit",
    D: "Mouse Down",
    U: "Mouse Up",
    Fo: "Focus",
    Bl: "Blur",
    PO: "PageOpen",
    PC: "PageClose",
    PV: "PageVisible",
    PI: "PageInvisible",
    K: "Keystroke",
    F: "Format",
    V: "Validate",
    C: "Calculate"
  };
  exports.AnnotationActionEventType = AnnotationActionEventType;
  const DocumentActionEventType = {
    WC: "WillClose",
    WS: "WillSave",
    DS: "DidSave",
    WP: "WillPrint",
    DP: "DidPrint"
  };
  exports.DocumentActionEventType = DocumentActionEventType;
  const PageActionEventType = {
    O: "PageOpen",
    C: "PageClose"
  };
  exports.PageActionEventType = PageActionEventType;
  const StreamType = {
    UNKNOWN: "UNKNOWN",
    FLATE: "FLATE",
    LZW: "LZW",
    DCT: "DCT",
    JPX: "JPX",
    JBIG: "JBIG",
    A85: "A85",
    AHX: "AHX",
    CCF: "CCF",
    RLX: "RLX"
  };
  exports.StreamType = StreamType;
  const FontType = {
    UNKNOWN: "UNKNOWN",
    TYPE1: "TYPE1",
    TYPE1C: "TYPE1C",
    CIDFONTTYPE0: "CIDFONTTYPE0",
    CIDFONTTYPE0C: "CIDFONTTYPE0C",
    TRUETYPE: "TRUETYPE",
    CIDFONTTYPE2: "CIDFONTTYPE2",
    TYPE3: "TYPE3",
    OPENTYPE: "OPENTYPE",
    TYPE0: "TYPE0",
    MMTYPE1: "MMTYPE1"
  };
  exports.FontType = FontType;
  const VerbosityLevel = {
    ERRORS: 0,
    WARNINGS: 1,
    INFOS: 5
  };
  exports.VerbosityLevel = VerbosityLevel;
  const CMapCompressionType = {
    NONE: 0,
    BINARY: 1,
    STREAM: 2
  };
  exports.CMapCompressionType = CMapCompressionType;
  const OPS = {
    dependency: 1,
    setLineWidth: 2,
    setLineCap: 3,
    setLineJoin: 4,
    setMiterLimit: 5,
    setDash: 6,
    setRenderingIntent: 7,
    setFlatness: 8,
    setGState: 9,
    save: 10,
    restore: 11,
    transform: 12,
    moveTo: 13,
    lineTo: 14,
    curveTo: 15,
    curveTo2: 16,
    curveTo3: 17,
    closePath: 18,
    rectangle: 19,
    stroke: 20,
    closeStroke: 21,
    fill: 22,
    eoFill: 23,
    fillStroke: 24,
    eoFillStroke: 25,
    closeFillStroke: 26,
    closeEOFillStroke: 27,
    endPath: 28,
    clip: 29,
    eoClip: 30,
    beginText: 31,
    endText: 32,
    setCharSpacing: 33,
    setWordSpacing: 34,
    setHScale: 35,
    setLeading: 36,
    setFont: 37,
    setTextRenderingMode: 38,
    setTextRise: 39,
    moveText: 40,
    setLeadingMoveText: 41,
    setTextMatrix: 42,
    nextLine: 43,
    showText: 44,
    showSpacedText: 45,
    nextLineShowText: 46,
    nextLineSetSpacingShowText: 47,
    setCharWidth: 48,
    setCharWidthAndBounds: 49,
    setStrokeColorSpace: 50,
    setFillColorSpace: 51,
    setStrokeColor: 52,
    setStrokeColorN: 53,
    setFillColor: 54,
    setFillColorN: 55,
    setStrokeGray: 56,
    setFillGray: 57,
    setStrokeRGBColor: 58,
    setFillRGBColor: 59,
    setStrokeCMYKColor: 60,
    setFillCMYKColor: 61,
    shadingFill: 62,
    beginInlineImage: 63,
    beginImageData: 64,
    endInlineImage: 65,
    paintXObject: 66,
    markPoint: 67,
    markPointProps: 68,
    beginMarkedContent: 69,
    beginMarkedContentProps: 70,
    endMarkedContent: 71,
    beginCompat: 72,
    endCompat: 73,
    paintFormXObjectBegin: 74,
    paintFormXObjectEnd: 75,
    beginGroup: 76,
    endGroup: 77,
    beginAnnotations: 78,
    endAnnotations: 79,
    beginAnnotation: 80,
    endAnnotation: 81,
    paintJpegXObject: 82,
    paintImageMaskXObject: 83,
    paintImageMaskXObjectGroup: 84,
    paintImageXObject: 85,
    paintInlineImageXObject: 86,
    paintInlineImageXObjectGroup: 87,
    paintImageXObjectRepeat: 88,
    paintImageMaskXObjectRepeat: 89,
    paintSolidColorImageMask: 90,
    constructPath: 91
  };
  exports.OPS = OPS;
  const UNSUPPORTED_FEATURES = {
    unknown: "unknown",
    forms: "forms",
    javaScript: "javaScript",
    smask: "smask",
    shadingPattern: "shadingPattern",
    font: "font",
    errorTilingPattern: "errorTilingPattern",
    errorExtGState: "errorExtGState",
    errorXObject: "errorXObject",
    errorFontLoadType3: "errorFontLoadType3",
    errorFontState: "errorFontState",
    errorFontMissing: "errorFontMissing",
    errorFontTranslate: "errorFontTranslate",
    errorColorSpace: "errorColorSpace",
    errorOperatorList: "errorOperatorList",
    errorFontToUnicode: "errorFontToUnicode",
    errorFontLoadNative: "errorFontLoadNative",
    errorFontGetPath: "errorFontGetPath",
    errorMarkedContent: "errorMarkedContent"
  };
  exports.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;
  const PasswordResponses = {
    NEED_PASSWORD: 1,
    INCORRECT_PASSWORD: 2
  };
  exports.PasswordResponses = PasswordResponses;
  let verbosity = VerbosityLevel.WARNINGS;

  function setVerbosityLevel(level) {
    if (Number.isInteger(level)) {
      verbosity = level;
    }
  }

  function getVerbosityLevel() {
    return verbosity;
  }

  function info(msg) {
    if (verbosity >= VerbosityLevel.INFOS) {
      console.log(`Info: ${msg}`);
    }
  }

  function warn(msg) {
    if (verbosity >= VerbosityLevel.WARNINGS) {
      console.log(`Warning: ${msg}`);
    }
  }

  function unreachable(msg) {
    throw new Error(msg);
  }

  function assert(cond, msg) {
    if (!cond) {
      unreachable(msg);
    }
  }

  function isSameOrigin(baseUrl, otherUrl) {
    let base;

    try {
      base = new URL(baseUrl);

      if (!base.origin || base.origin === "null") {
        return false;
      }
    } catch (e) {
      return false;
    }

    const other = new URL(otherUrl, base);
    return base.origin === other.origin;
  }

  function _isValidProtocol(url) {
    if (!url) {
      return false;
    }

    switch (url.protocol) {
      case "http:":
      case "https:":
      case "ftp:":
      case "mailto:":
      case "tel:":
        return true;

      default:
        return false;
    }
  }

  function createValidAbsoluteUrl(url, baseUrl) {
    if (!url) {
      return null;
    }

    try {
      const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);

      if (_isValidProtocol(absoluteUrl)) {
        return absoluteUrl;
      }
    } catch (ex) {}

    return null;
  }

  function shadow(obj, prop, value) {
    Object.defineProperty(obj, prop, {
      value,
      enumerable: true,
      configurable: true,
      writable: false
    });
    return value;
  }

  const BaseException = function BaseExceptionClosure() {
    function BaseException(message) {
      if (this.constructor === BaseException) {
        unreachable("Cannot initialize BaseException.");
      }

      this.message = message;
      this.name = this.constructor.name;
    }

    BaseException.prototype = new Error();
    BaseException.constructor = BaseException;
    return BaseException;
  }();

  exports.BaseException = BaseException;

  class PasswordException extends BaseException {
    constructor(msg, code) {
      super(msg);
      this.code = code;
    }

  }

  exports.PasswordException = PasswordException;

  class UnknownErrorException extends BaseException {
    constructor(msg, details) {
      super(msg);
      this.details = details;
    }

  }

  exports.UnknownErrorException = UnknownErrorException;

  class InvalidPDFException extends BaseException {}

  exports.InvalidPDFException = InvalidPDFException;

  class MissingPDFException extends BaseException {}

  exports.MissingPDFException = MissingPDFException;

  class UnexpectedResponseException extends BaseException {
    constructor(msg, status) {
      super(msg);
      this.status = status;
    }

  }

  exports.UnexpectedResponseException = UnexpectedResponseException;

  class FormatError extends BaseException {}

  exports.FormatError = FormatError;

  class AbortException extends BaseException {}

  exports.AbortException = AbortException;
  const NullCharactersRegExp = /\x00/g;

  function removeNullCharacters(str) {
    if (typeof str !== "string") {
      warn("The argument for removeNullCharacters must be a string.");
      return str;
    }

    return str.replace(NullCharactersRegExp, "");
  }

  function bytesToString(bytes) {
    assert(bytes !== null && typeof bytes === "object" && bytes.length !== undefined, "Invalid argument for bytesToString");
    const length = bytes.length;
    const MAX_ARGUMENT_COUNT = 8192;

    if (length < MAX_ARGUMENT_COUNT) {
      return String.fromCharCode.apply(null, bytes);
    }

    const strBuf = [];

    for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
      const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
      const chunk = bytes.subarray(i, chunkEnd);
      strBuf.push(String.fromCharCode.apply(null, chunk));
    }

    return strBuf.join("");
  }

  function stringToBytes(str) {
    assert(typeof str === "string", "Invalid argument for stringToBytes");
    const length = str.length;
    const bytes = new Uint8Array(length);

    for (let i = 0; i < length; ++i) {
      bytes[i] = str.charCodeAt(i) & 0xff;
    }

    return bytes;
  }

  function arrayByteLength(arr) {
    if (arr.length !== undefined) {
      return arr.length;
    }

    assert(arr.byteLength !== undefined, "arrayByteLength - invalid argument.");
    return arr.byteLength;
  }

  function arraysToBytes(arr) {
    const length = arr.length;

    if (length === 1 && arr[0] instanceof Uint8Array) {
      return arr[0];
    }

    let resultLength = 0;

    for (let i = 0; i < length; i++) {
      resultLength += arrayByteLength(arr[i]);
    }

    let pos = 0;
    const data = new Uint8Array(resultLength);

    for (let i = 0; i < length; i++) {
      let item = arr[i];

      if (!(item instanceof Uint8Array)) {
        if (typeof item === "string") {
          item = stringToBytes(item);
        } else {
          item = new Uint8Array(item);
        }
      }

      const itemLength = item.byteLength;
      data.set(item, pos);
      pos += itemLength;
    }

    return data;
  }

  function string32(value) {
    return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);
  }

  function objectSize(obj) {
    return Object.keys(obj).length;
  }

  function objectFromEntries(iterable) {
    return Object.assign(Object.create(null), Object.fromEntries(iterable));
  }

  function isLittleEndian() {
    const buffer8 = new Uint8Array(4);
    buffer8[0] = 1;
    const view32 = new Uint32Array(buffer8.buffer, 0, 1);
    return view32[0] === 1;
  }

  const IsLittleEndianCached = {
    get value() {
      return shadow(this, "value", isLittleEndian());
    }

  };
  exports.IsLittleEndianCached = IsLittleEndianCached;

  function isEvalSupported() {
    try {
      new Function("");
      return true;
    } catch (e) {
      return false;
    }
  }

  const IsEvalSupportedCached = {
    get value() {
      return shadow(this, "value", isEvalSupported());
    }

  };
  exports.IsEvalSupportedCached = IsEvalSupportedCached;
  const hexNumbers = [...Array(256).keys()].map(n => n.toString(16).padStart(2, "0"));

  class Util {
    static makeHexColor(r, g, b) {
      return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;
    }

    static transform(m1, m2) {
      return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
    }

    static applyTransform(p, m) {
      const xt = p[0] * m[0] + p[1] * m[2] + m[4];
      const yt = p[0] * m[1] + p[1] * m[3] + m[5];
      return [xt, yt];
    }

    static applyInverseTransform(p, m) {
      const d = m[0] * m[3] - m[1] * m[2];
      const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
      const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
      return [xt, yt];
    }

    static getAxialAlignedBoundingBox(r, m) {
      const p1 = Util.applyTransform(r, m);
      const p2 = Util.applyTransform(r.slice(2, 4), m);
      const p3 = Util.applyTransform([r[0], r[3]], m);
      const p4 = Util.applyTransform([r[2], r[1]], m);
      return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
    }

    static inverseTransform(m) {
      const d = m[0] * m[3] - m[1] * m[2];
      return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
    }

    static apply3dTransform(m, v) {
      return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];
    }

    static singularValueDecompose2dScale(m) {
      const transpose = [m[0], m[2], m[1], m[3]];
      const a = m[0] * transpose[0] + m[1] * transpose[2];
      const b = m[0] * transpose[1] + m[1] * transpose[3];
      const c = m[2] * transpose[0] + m[3] * transpose[2];
      const d = m[2] * transpose[1] + m[3] * transpose[3];
      const first = (a + d) / 2;
      const second = Math.sqrt((a + d) * (a + d) - 4 * (a * d - c * b)) / 2;
      const sx = first + second || 1;
      const sy = first - second || 1;
      return [Math.sqrt(sx), Math.sqrt(sy)];
    }

    static normalizeRect(rect) {
      const r = rect.slice(0);

      if (rect[0] > rect[2]) {
        r[0] = rect[2];
        r[2] = rect[0];
      }

      if (rect[1] > rect[3]) {
        r[1] = rect[3];
        r[3] = rect[1];
      }

      return r;
    }

    static intersect(rect1, rect2) {
      function compare(a, b) {
        return a - b;
      }

      const orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare);
      const orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare);
      const result = [];
      rect1 = Util.normalizeRect(rect1);
      rect2 = Util.normalizeRect(rect2);

      if (orderedX[0] === rect1[0] && orderedX[1] === rect2[0] || orderedX[0] === rect2[0] && orderedX[1] === rect1[0]) {
        result[0] = orderedX[1];
        result[2] = orderedX[2];
      } else {
        return null;
      }

      if (orderedY[0] === rect1[1] && orderedY[1] === rect2[1] || orderedY[0] === rect2[1] && orderedY[1] === rect1[1]) {
        result[1] = orderedY[1];
        result[3] = orderedY[2];
      } else {
        return null;
      }

      return result;
    }

  }

  exports.Util = Util;
  const PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2D8, 0x2C7, 0x2C6, 0x2D9, 0x2DD, 0x2DB, 0x2DA, 0x2DC, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203A, 0x2212, 0x2030, 0x201E, 0x201C, 0x201D, 0x2018, 0x2019, 0x201A, 0x2122, 0xFB01, 0xFB02, 0x141, 0x152, 0x160, 0x178, 0x17D, 0x131, 0x142, 0x153, 0x161, 0x17E, 0, 0x20AC];

  function stringToPDFString(str) {
    const length = str.length,
          strBuf = [];

    if (str[0] === "\xFE" && str[1] === "\xFF") {
      for (let i = 2; i < length; i += 2) {
        strBuf.push(String.fromCharCode(str.charCodeAt(i) << 8 | str.charCodeAt(i + 1)));
      }
    } else if (str[0] === "\xFF" && str[1] === "\xFE") {
      for (let i = 2; i < length; i += 2) {
        strBuf.push(String.fromCharCode(str.charCodeAt(i + 1) << 8 | str.charCodeAt(i)));
      }
    } else {
      for (let i = 0; i < length; ++i) {
        const code = PDFStringTranslateTable[str.charCodeAt(i)];
        strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
      }
    }

    return strBuf.join("");
  }

  function escapeString(str) {
    return str.replace(/([()\\\n\r])/g, match => {
      if (match === "\n") {
        return "\\n";
      } else if (match === "\r") {
        return "\\r";
      }

      return `\\${match}`;
    });
  }

  function isAscii(str) {
    return /^[\x00-\x7F]*$/.test(str);
  }

  function stringToUTF16BEString(str) {
    const buf = ["\xFE\xFF"];

    for (let i = 0, ii = str.length; i < ii; i++) {
      const char = str.charCodeAt(i);
      buf.push(String.fromCharCode(char >> 8 & 0xff));
      buf.push(String.fromCharCode(char & 0xff));
    }

    return buf.join("");
  }

  function stringToUTF8String(str) {
    return decodeURIComponent(escape(str));
  }

  function utf8StringToString(str) {
    return unescape(encodeURIComponent(str));
  }

  function isBool(v) {
    return typeof v === "boolean";
  }

  function isNum(v) {
    return typeof v === "number";
  }

  function isString(v) {
    return typeof v === "string";
  }

  function isArrayBuffer(v) {
    return typeof v === "object" && v !== null && v.byteLength !== undefined;
  }

  function isArrayEqual(arr1, arr2) {
    if (arr1.length !== arr2.length) {
      return false;
    }

    return arr1.every(function (element, index) {
      return element === arr2[index];
    });
  }

  function getModificationDate(date = new Date()) {
    const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, "0"), date.getUTCDate().toString().padStart(2, "0"), date.getUTCHours().toString().padStart(2, "0"), date.getUTCMinutes().toString().padStart(2, "0"), date.getUTCSeconds().toString().padStart(2, "0")];
    return buffer.join("");
  }

  function createPromiseCapability() {
    const capability = Object.create(null);
    let isSettled = false;
    Object.defineProperty(capability, "settled", {
      get() {
        return isSettled;
      }

    });
    capability.promise = new Promise(function (resolve, reject) {
      capability.resolve = function (data) {
        isSettled = true;
        resolve(data);
      };

      capability.reject = function (reason) {
        isSettled = true;
        reject(reason);
      };
    });
    return capability;
  }

  const createObjectURL = function createObjectURLClosure() {
    const digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    return function createObjectURL(data, contentType, forceDataSchema = false) {
      if (!forceDataSchema && URL.createObjectURL) {
        const blob = new Blob([data], {
          type: contentType
        });
        return URL.createObjectURL(blob);
      }

      let buffer = `data:${contentType};base64,`;

      for (let i = 0, ii = data.length; i < ii; i += 3) {
        const b1 = data[i] & 0xff;
        const b2 = data[i + 1] & 0xff;
        const b3 = data[i + 2] & 0xff;
        const d1 = b1 >> 2,
              d2 = (b1 & 3) << 4 | b2 >> 4;
        const d3 = i + 1 < ii ? (b2 & 0xf) << 2 | b3 >> 6 : 64;
        const d4 = i + 2 < ii ? b3 & 0x3f : 64;
        buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
      }

      return buffer;
    };
  }();

  exports.createObjectURL = createObjectURL;
  const XMLEntities = {
    0x3c: "&lt;",
    0x3e: "&gt;",
    0x26: "&amp;",
    0x22: "&quot;",
    0x27: "&apos;"
  };

  function encodeToXmlString(str) {
    const buffer = [];
    let start = 0;

    for (let i = 0, ii = str.length; i < ii; i++) {
      const char = str.codePointAt(i);

      if (0x20 <= char && char <= 0x7e) {
        const entity = XMLEntities[char];

        if (entity) {
          if (start < i) {
            buffer.push(str.substring(start, i));
          }

          buffer.push(entity);
          start = i + 1;
        }
      } else {
        if (start < i) {
          buffer.push(str.substring(start, i));
        }

        buffer.push(`&#x${char.toString(16).toUpperCase()};`);

        if (char > 0xd7ff && (char < 0xe000 || char > 0xfffd)) {
          i++;
        }

        start = i + 1;
      }
    }

    if (buffer.length === 0) {
      return str;
    }

    if (start < str.length) {
      buffer.push(str.substring(start, str.length));
    }

    return buffer.join("");
  }

  /***/ }),
  /* 3 */
  /***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {



  var _is_node = __w_pdfjs_require__(4);

  ;

  /***/ }),
  /* 4 */
  /***/ ((__unused_webpack_module, exports) => {



  Object.defineProperty(exports, "__esModule", ({
    value: true
  }));
  exports.isNodeJS = void 0;
  const isNodeJS = typeof process === "object" && process + "" === "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
  exports.isNodeJS = isNodeJS;

  /***/ }),
  /* 5 */
  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



  Object.defineProperty(exports, "__esModule", ({
    value: true
  }));
  exports.getDocument = getDocument;
  exports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory;
  exports.version = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultCMapReaderFactory = exports.DefaultCanvasFactory = exports.build = void 0;

  var _util = __w_pdfjs_require__(2);

  var _display_utils = __w_pdfjs_require__(1);

  var _font_loader = __w_pdfjs_require__(6);

  var _node_utils = __w_pdfjs_require__(7);

  var _annotation_storage = __w_pdfjs_require__(8);

  var _api_compatibility = __w_pdfjs_require__(9);

  var _canvas = __w_pdfjs_require__(10);

  var _worker_options = __w_pdfjs_require__(12);

  var _is_node = __w_pdfjs_require__(4);

  var _message_handler = __w_pdfjs_require__(13);

  var _metadata = __w_pdfjs_require__(14);

  var _optional_content_config = __w_pdfjs_require__(16);

  var _transport_stream = __w_pdfjs_require__(17);

  var _webgl = __w_pdfjs_require__(18);

  const DEFAULT_RANGE_CHUNK_SIZE = 65536;
  const RENDERING_CANCELLED_TIMEOUT = 100;
  const DefaultCanvasFactory = _is_node.isNodeJS ? _node_utils.NodeCanvasFactory : _display_utils.DOMCanvasFactory;
  exports.DefaultCanvasFactory = DefaultCanvasFactory;
  const DefaultCMapReaderFactory = _is_node.isNodeJS ? _node_utils.NodeCMapReaderFactory : _display_utils.DOMCMapReaderFactory;
  exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;
  let createPDFNetworkStream;

  function setPDFNetworkStreamFactory(pdfNetworkStreamFactory) {
    createPDFNetworkStream = pdfNetworkStreamFactory;
  }

  function getDocument(src) {
    const task = new PDFDocumentLoadingTask();
    let source;

    if (typeof src === "string") {
      source = {
        url: src
      };
    } else if ((0, _util.isArrayBuffer)(src)) {
      source = {
        data: src
      };
    } else if (src instanceof PDFDataRangeTransport) {
      source = {
        range: src
      };
    } else {
      if (typeof src !== "object") {
        throw new Error("Invalid parameter in getDocument, " + "need either Uint8Array, string or a parameter object");
      }

      if (!src.url && !src.data && !src.range) {
        throw new Error("Invalid parameter object: need either .data, .range or .url");
      }

      source = src;
    }

    const params = Object.create(null);
    let rangeTransport = null,
        worker = null;

    for (const key in source) {
      if (key === "url" && typeof window !== "undefined") {
        params[key] = new URL(source[key], window.location).href;
        continue;
      } else if (key === "range") {
        rangeTransport = source[key];
        continue;
      } else if (key === "worker") {
        worker = source[key];
        continue;
      } else if (key === "data" && !(source[key] instanceof Uint8Array)) {
        const pdfBytes = source[key];

        if (typeof pdfBytes === "string") {
          params[key] = (0, _util.stringToBytes)(pdfBytes);
        } else if (typeof pdfBytes === "object" && pdfBytes !== null && !isNaN(pdfBytes.length)) {
          params[key] = new Uint8Array(pdfBytes);
        } else if ((0, _util.isArrayBuffer)(pdfBytes)) {
          params[key] = new Uint8Array(pdfBytes);
        } else {
          throw new Error("Invalid PDF binary data: either typed array, " + "string or array-like object is expected in the " + "data property.");
        }

        continue;
      }

      params[key] = source[key];
    }

    params.rangeChunkSize = params.rangeChunkSize || DEFAULT_RANGE_CHUNK_SIZE;
    params.CMapReaderFactory = params.CMapReaderFactory || DefaultCMapReaderFactory;
    params.ignoreErrors = params.stopAtErrors !== true;
    params.fontExtraProperties = params.fontExtraProperties === true;
    params.pdfBug = params.pdfBug === true;

    if (!Number.isInteger(params.maxImageSize)) {
      params.maxImageSize = -1;
    }

    if (typeof params.isEvalSupported !== "boolean") {
      params.isEvalSupported = true;
    }

    if (typeof params.disableFontFace !== "boolean") {
      params.disableFontFace = _api_compatibility.apiCompatibilityParams.disableFontFace || false;
    }

    if (typeof params.ownerDocument === "undefined") {
      params.ownerDocument = globalThis.document;
    }

    if (typeof params.disableRange !== "boolean") {
      params.disableRange = false;
    }

    if (typeof params.disableStream !== "boolean") {
      params.disableStream = false;
    }

    if (typeof params.disableAutoFetch !== "boolean") {
      params.disableAutoFetch = false;
    }

    (0, _util.setVerbosityLevel)(params.verbosity);

    if (!worker) {
      const workerParams = {
        verbosity: params.verbosity,
        port: _worker_options.GlobalWorkerOptions.workerPort
      };
      worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);
      task._worker = worker;
    }

    const docId = task.docId;
    worker.promise.then(function () {
      if (task.destroyed) {
        throw new Error("Loading aborted");
      }

      const workerIdPromise = _fetchDocument(worker, params, rangeTransport, docId);

      const networkStreamPromise = new Promise(function (resolve) {
        let networkStream;

        if (rangeTransport) {
          networkStream = new _transport_stream.PDFDataTransportStream({
            length: params.length,
            initialData: params.initialData,
            progressiveDone: params.progressiveDone,
            disableRange: params.disableRange,
            disableStream: params.disableStream
          }, rangeTransport);
        } else if (!params.data) {
          networkStream = createPDFNetworkStream({
            url: params.url,
            length: params.length,
            httpHeaders: params.httpHeaders,
            withCredentials: params.withCredentials,
            rangeChunkSize: params.rangeChunkSize,
            disableRange: params.disableRange,
            disableStream: params.disableStream
          });
        }

        resolve(networkStream);
      });
      return Promise.all([workerIdPromise, networkStreamPromise]).then(function ([workerId, networkStream]) {
        if (task.destroyed) {
          throw new Error("Loading aborted");
        }

        const messageHandler = new _message_handler.MessageHandler(docId, workerId, worker.port);
        messageHandler.postMessageTransfers = worker.postMessageTransfers;
        const transport = new WorkerTransport(messageHandler, task, networkStream, params);
        task._transport = transport;
        messageHandler.send("Ready", null);
      });
    }).catch(task._capability.reject);
    return task;
  }

  function _fetchDocument(worker, source, pdfDataRangeTransport, docId) {
    if (worker.destroyed) {
      return Promise.reject(new Error("Worker was destroyed"));
    }

    if (pdfDataRangeTransport) {
      source.length = pdfDataRangeTransport.length;
      source.initialData = pdfDataRangeTransport.initialData;
      source.progressiveDone = pdfDataRangeTransport.progressiveDone;
    }

    return worker.messageHandler.sendWithPromise("GetDocRequest", {
      docId,
      apiVersion: '2.7.570',
      source: {
        data: source.data,
        url: source.url,
        password: source.password,
        disableAutoFetch: source.disableAutoFetch,
        rangeChunkSize: source.rangeChunkSize,
        length: source.length
      },
      maxImageSize: source.maxImageSize,
      disableFontFace: source.disableFontFace,
      postMessageTransfers: worker.postMessageTransfers,
      docBaseUrl: source.docBaseUrl,
      ignoreErrors: source.ignoreErrors,
      isEvalSupported: source.isEvalSupported,
      fontExtraProperties: source.fontExtraProperties
    }).then(function (workerId) {
      if (worker.destroyed) {
        throw new Error("Worker was destroyed");
      }

      return workerId;
    });
  }

  const PDFDocumentLoadingTask = function PDFDocumentLoadingTaskClosure() {
    let nextDocumentId = 0;

    class PDFDocumentLoadingTask {
      constructor() {
        this._capability = (0, _util.createPromiseCapability)();
        this._transport = null;
        this._worker = null;
        this.docId = "d" + nextDocumentId++;
        this.destroyed = false;
        this.onPassword = null;
        this.onProgress = null;
        this.onUnsupportedFeature = null;
      }

      get promise() {
        return this._capability.promise;
      }

      destroy() {
        this.destroyed = true;
        const transportDestroyed = !this._transport ? Promise.resolve() : this._transport.destroy();
        return transportDestroyed.then(() => {
          this._transport = null;

          if (this._worker) {
            this._worker.destroy();

            this._worker = null;
          }
        });
      }

    }

    return PDFDocumentLoadingTask;
  }();

  class PDFDataRangeTransport {
    constructor(length, initialData, progressiveDone = false) {
      this.length = length;
      this.initialData = initialData;
      this.progressiveDone = progressiveDone;
      this._rangeListeners = [];
      this._progressListeners = [];
      this._progressiveReadListeners = [];
      this._progressiveDoneListeners = [];
      this._readyCapability = (0, _util.createPromiseCapability)();
    }

    addRangeListener(listener) {
      this._rangeListeners.push(listener);
    }

    addProgressListener(listener) {
      this._progressListeners.push(listener);
    }

    addProgressiveReadListener(listener) {
      this._progressiveReadListeners.push(listener);
    }

    addProgressiveDoneListener(listener) {
      this._progressiveDoneListeners.push(listener);
    }

    onDataRange(begin, chunk) {
      for (const listener of this._rangeListeners) {
        listener(begin, chunk);
      }
    }

    onDataProgress(loaded, total) {
      this._readyCapability.promise.then(() => {
        for (const listener of this._progressListeners) {
          listener(loaded, total);
        }
      });
    }

    onDataProgressiveRead(chunk) {
      this._readyCapability.promise.then(() => {
        for (const listener of this._progressiveReadListeners) {
          listener(chunk);
        }
      });
    }

    onDataProgressiveDone() {
      this._readyCapability.promise.then(() => {
        for (const listener of this._progressiveDoneListeners) {
          listener();
        }
      });
    }

    transportReady() {
      this._readyCapability.resolve();
    }

    requestDataRange(begin, end) {
      (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
    }

    abort() {}

  }

  exports.PDFDataRangeTransport = PDFDataRangeTransport;

  class PDFDocumentProxy {
    constructor(pdfInfo, transport) {
      this._pdfInfo = pdfInfo;
      this._transport = transport;
    }

    get annotationStorage() {
      return (0, _util.shadow)(this, "annotationStorage", new _annotation_storage.AnnotationStorage());
    }

    get numPages() {
      return this._pdfInfo.numPages;
    }

    get fingerprint() {
      return this._pdfInfo.fingerprint;
    }

    getPage(pageNumber) {
      return this._transport.getPage(pageNumber);
    }

    getPageIndex(ref) {
      return this._transport.getPageIndex(ref);
    }

    getDestinations() {
      return this._transport.getDestinations();
    }

    getDestination(id) {
      return this._transport.getDestination(id);
    }

    getPageLabels() {
      return this._transport.getPageLabels();
    }

    getPageLayout() {
      return this._transport.getPageLayout();
    }

    getPageMode() {
      return this._transport.getPageMode();
    }

    getViewerPreferences() {
      return this._transport.getViewerPreferences();
    }

    getOpenAction() {
      return this._transport.getOpenAction();
    }

    getAttachments() {
      return this._transport.getAttachments();
    }

    getJavaScript() {
      return this._transport.getJavaScript();
    }

    getJSActions() {
      return this._transport.getDocJSActions();
    }

    getOutline() {
      return this._transport.getOutline();
    }

    getOptionalContentConfig() {
      return this._transport.getOptionalContentConfig();
    }

    getPermissions() {
      return this._transport.getPermissions();
    }

    getMetadata() {
      return this._transport.getMetadata();
    }

    getMarkInfo() {
      return this._transport.getMarkInfo();
    }

    getData() {
      return this._transport.getData();
    }

    getDownloadInfo() {
      return this._transport.downloadInfoCapability.promise;
    }

    getStats() {
      return this._transport.getStats();
    }

    cleanup() {
      return this._transport.startCleanup();
    }

    destroy() {
      return this.loadingTask.destroy();
    }

    get loadingParams() {
      return this._transport.loadingParams;
    }

    get loadingTask() {
      return this._transport.loadingTask;
    }

    saveDocument(annotationStorage) {
      return this._transport.saveDocument(annotationStorage);
    }

    getFieldObjects() {
      return this._transport.getFieldObjects();
    }

    hasJSActions() {
      return this._transport.hasJSActions();
    }

    getCalculationOrderIds() {
      return this._transport.getCalculationOrderIds();
    }

  }

  exports.PDFDocumentProxy = PDFDocumentProxy;

  class PDFPageProxy {
    constructor(pageIndex, pageInfo, transport, ownerDocument, pdfBug = false) {
      this._pageIndex = pageIndex;
      this._pageInfo = pageInfo;
      this._ownerDocument = ownerDocument;
      this._transport = transport;
      this._stats = pdfBug ? new _display_utils.StatTimer() : null;
      this._pdfBug = pdfBug;
      this.commonObjs = transport.commonObjs;
      this.objs = new PDFObjects();
      this.cleanupAfterRender = false;
      this.pendingCleanup = false;
      this._intentStates = new Map();
      this.destroyed = false;
    }

    get pageNumber() {
      return this._pageIndex + 1;
    }

    get rotate() {
      return this._pageInfo.rotate;
    }

    get ref() {
      return this._pageInfo.ref;
    }

    get userUnit() {
      return this._pageInfo.userUnit;
    }

    get view() {
      return this._pageInfo.view;
    }

    getViewport({
      scale,
      rotation = this.rotate,
      offsetX = 0,
      offsetY = 0,
      dontFlip = false
    } = {}) {
      return new _display_utils.PageViewport({
        viewBox: this.view,
        scale,
        rotation,
        offsetX,
        offsetY,
        dontFlip
      });
    }

    getAnnotations({
      intent = null
    } = {}) {
      if (!this.annotationsPromise || this.annotationsIntent !== intent) {
        this.annotationsPromise = this._transport.getAnnotations(this._pageIndex, intent);
        this.annotationsIntent = intent;
      }

      return this.annotationsPromise;
    }

    getJSActions() {
      return this._jsActionsPromise || (this._jsActionsPromise = this._transport.getPageJSActions(this._pageIndex));
    }

    render({
      canvasContext,
      viewport,
      intent = "display",
      enableWebGL = false,
      renderInteractiveForms = false,
      transform = null,
      imageLayer = null,
      canvasFactory = null,
      background = null,
      annotationStorage = null,
      optionalContentConfigPromise = null
    }) {
      if (this._stats) {
        this._stats.time("Overall");
      }

      const renderingIntent = intent === "print" ? "print" : "display";
      this.pendingCleanup = false;

      if (!optionalContentConfigPromise) {
        optionalContentConfigPromise = this._transport.getOptionalContentConfig();
      }

      let intentState = this._intentStates.get(renderingIntent);

      if (!intentState) {
        intentState = Object.create(null);

        this._intentStates.set(renderingIntent, intentState);
      }

      if (intentState.streamReaderCancelTimeout) {
        clearTimeout(intentState.streamReaderCancelTimeout);
        intentState.streamReaderCancelTimeout = null;
      }

      const canvasFactoryInstance = canvasFactory || new DefaultCanvasFactory({
        ownerDocument: this._ownerDocument
      });
      const webGLContext = new _webgl.WebGLContext({
        enable: enableWebGL
      });

      if (!intentState.displayReadyCapability) {
        intentState.displayReadyCapability = (0, _util.createPromiseCapability)();
        intentState.operatorList = {
          fnArray: [],
          argsArray: [],
          lastChunk: false
        };

        if (this._stats) {
          this._stats.time("Page Request");
        }

        this._pumpOperatorList({
          pageIndex: this._pageIndex,
          intent: renderingIntent,
          renderInteractiveForms: renderInteractiveForms === true,
          annotationStorage: annotationStorage && annotationStorage.getAll() || null  // lwf
        });
      }

      const complete = error => {
        const i = intentState.renderTasks.indexOf(internalRenderTask);

        if (i >= 0) {
          intentState.renderTasks.splice(i, 1);
        }

        if (this.cleanupAfterRender || renderingIntent === "print") {
          this.pendingCleanup = true;
        }

        this._tryCleanup();

        if (error) {
          internalRenderTask.capability.reject(error);

          this._abortOperatorList({
            intentState,
            reason: error
          });
        } else {
          internalRenderTask.capability.resolve();
        }

        if (this._stats) {
          this._stats.timeEnd("Rendering");

          this._stats.timeEnd("Overall");
        }
      };

      const internalRenderTask = new InternalRenderTask({
        callback: complete,
        params: {
          canvasContext,
          viewport,
          transform,
          imageLayer,
          background
        },
        objs: this.objs,
        commonObjs: this.commonObjs,
        operatorList: intentState.operatorList,
        pageIndex: this._pageIndex,
        canvasFactory: canvasFactoryInstance,
        webGLContext,
        useRequestAnimationFrame: renderingIntent !== "print",
        pdfBug: this._pdfBug
      });

      if (!intentState.renderTasks) {
        intentState.renderTasks = [];
      }

      intentState.renderTasks.push(internalRenderTask);
      const renderTask = internalRenderTask.task;
      Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(([transparency, optionalContentConfig]) => {
        if (this.pendingCleanup) {
          complete();
          return;
        }

        if (this._stats) {
          this._stats.time("Rendering");
        }

        internalRenderTask.initializeGraphics({
          transparency,
          optionalContentConfig
        });
        internalRenderTask.operatorListChanged();
      }).catch(complete);
      return renderTask;
    }

    getOperatorList() {
      function operatorListChanged() {
        if (intentState.operatorList.lastChunk) {
          intentState.opListReadCapability.resolve(intentState.operatorList);
          const i = intentState.renderTasks.indexOf(opListTask);

          if (i >= 0) {
            intentState.renderTasks.splice(i, 1);
          }
        }
      }

      const renderingIntent = "oplist";

      let intentState = this._intentStates.get(renderingIntent);

      if (!intentState) {
        intentState = Object.create(null);

        this._intentStates.set(renderingIntent, intentState);
      }

      let opListTask;

      if (!intentState.opListReadCapability) {
        opListTask = Object.create(null);
        opListTask.operatorListChanged = operatorListChanged;
        intentState.opListReadCapability = (0, _util.createPromiseCapability)();
        intentState.renderTasks = [];
        intentState.renderTasks.push(opListTask);
        intentState.operatorList = {
          fnArray: [],
          argsArray: [],
          lastChunk: false
        };

        if (this._stats) {
          this._stats.time("Page Request");
        }

        this._pumpOperatorList({
          pageIndex: this._pageIndex,
          intent: renderingIntent
        });
      }

      return intentState.opListReadCapability.promise;
    }

    streamTextContent({
      normalizeWhitespace = false,
      disableCombineTextItems = false
    } = {}) {
      const TEXT_CONTENT_CHUNK_SIZE = 100;
      return this._transport.messageHandler.sendWithStream("GetTextContent", {
        pageIndex: this._pageIndex,
        normalizeWhitespace: normalizeWhitespace === true,
        combineTextItems: disableCombineTextItems !== true
      }, {
        highWaterMark: TEXT_CONTENT_CHUNK_SIZE,

        size(textContent) {
          return textContent.items.length;
        }

      });
    }

    getTextContent(params = {}) {
      const readableStream = this.streamTextContent(params);
      return new Promise(function (resolve, reject) {
        function pump() {
          reader.read().then(function ({
            value,
            done
          }) {
            if (done) {
              resolve(textContent);
              return;
            }

            Object.assign(textContent.styles, value.styles);
            textContent.items.push(...value.items);
            pump();
          }, reject);
        }

        const reader = readableStream.getReader();
        const textContent = {
          items: [],
          styles: Object.create(null)
        };
        pump();
      });
    }

    _destroy() {
      this.destroyed = true;
      this._transport.pageCache[this._pageIndex] = null;
      const waitOn = [];

      for (const [intent, intentState] of this._intentStates) {
        this._abortOperatorList({
          intentState,
          reason: new Error("Page was destroyed."),
          force: true
        });

        if (intent === "oplist") {
          continue;
        }

        for (const internalRenderTask of intentState.renderTasks) {
          waitOn.push(internalRenderTask.completed);
          internalRenderTask.cancel();
        }
      }

      this.objs.clear();
      this.annotationsPromise = null;
      this._jsActionsPromise = null;
      this.pendingCleanup = false;
      return Promise.all(waitOn);
    }

    cleanup(resetStats = false) {
      this.pendingCleanup = true;
      return this._tryCleanup(resetStats);
    }

    _tryCleanup(resetStats = false) {
      if (!this.pendingCleanup) {
        return false;
      }

      for (const {
        renderTasks,
        operatorList
      } of this._intentStates.values()) {
        if (renderTasks.length !== 0 || !operatorList.lastChunk) {
          return false;
        }
      }

      this._intentStates.clear();

      this.objs.clear();
      this.annotationsPromise = null;
      this._jsActionsPromise = null;

      if (resetStats && this._stats) {
        this._stats = new _display_utils.StatTimer();
      }

      this.pendingCleanup = false;
      return true;
    }

    _startRenderPage(transparency, intent) {
      const intentState = this._intentStates.get(intent);

      if (!intentState) {
        return;
      }

      if (this._stats) {
        this._stats.timeEnd("Page Request");
      }

      if (intentState.displayReadyCapability) {
        intentState.displayReadyCapability.resolve(transparency);
      }
    }

    _renderPageChunk(operatorListChunk, intentState) {
      for (let i = 0, ii = operatorListChunk.length; i < ii; i++) {
        intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);
        intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);
      }

      intentState.operatorList.lastChunk = operatorListChunk.lastChunk;

      for (let i = 0; i < intentState.renderTasks.length; i++) {
        intentState.renderTasks[i].operatorListChanged();
      }

      if (operatorListChunk.lastChunk) {
        this._tryCleanup();
      }
    }

    _pumpOperatorList(args) {
      (0, _util.assert)(args.intent, 'PDFPageProxy._pumpOperatorList: Expected "intent" argument.');

      const readableStream = this._transport.messageHandler.sendWithStream("GetOperatorList", args);

      const reader = readableStream.getReader();

      const intentState = this._intentStates.get(args.intent);

      intentState.streamReader = reader;

      const pump = () => {
        reader.read().then(({
          value,
          done
        }) => {
          if (done) {
            intentState.streamReader = null;
            return;
          }

          if (this._transport.destroyed) {
            return;
          }

          this._renderPageChunk(value, intentState);

          pump();
        }, reason => {
          intentState.streamReader = null;

          if (this._transport.destroyed) {
            return;
          }

          if (intentState.operatorList) {
            intentState.operatorList.lastChunk = true;

            for (let i = 0; i < intentState.renderTasks.length; i++) {
              intentState.renderTasks[i].operatorListChanged();
            }

            this._tryCleanup();
          }

          if (intentState.displayReadyCapability) {
            intentState.displayReadyCapability.reject(reason);
          } else if (intentState.opListReadCapability) {
            intentState.opListReadCapability.reject(reason);
          } else {
            throw reason;
          }
        });
      };

      pump();
    }

    _abortOperatorList({
      intentState,
      reason,
      force = false
    }) {
      (0, _util.assert)(reason instanceof Error || typeof reason === "object" && reason !== null, 'PDFPageProxy._abortOperatorList: Expected "reason" argument.');

      if (!intentState.streamReader) {
        return;
      }

      if (!force) {
        if (intentState.renderTasks.length !== 0) {
          return;
        }

        if (reason instanceof _display_utils.RenderingCancelledException) {
          intentState.streamReaderCancelTimeout = setTimeout(() => {
            this._abortOperatorList({
              intentState,
              reason,
              force: true
            });

            intentState.streamReaderCancelTimeout = null;
          }, RENDERING_CANCELLED_TIMEOUT);
          return;
        }
      }

      intentState.streamReader.cancel(new _util.AbortException(reason && reason.message)); // lwf
      intentState.streamReader = null;

      if (this._transport.destroyed) {
        return;
      }

      for (const [intent, curIntentState] of this._intentStates) {
        if (curIntentState === intentState) {
          this._intentStates.delete(intent);

          break;
        }
      }

      this.cleanup();
    }

    get stats() {
      return this._stats;
    }

  }

  exports.PDFPageProxy = PDFPageProxy;

  class LoopbackPort {
    constructor(defer = true) {
      this._listeners = [];
      this._defer = defer;
      this._deferred = Promise.resolve(undefined);
    }

    postMessage(obj, transfers) {
      function cloneValue(value) {
        if (typeof value !== "object" || value === null) {
          return value;
        }

        if (cloned.has(value)) {
          return cloned.get(value);
        }

        let buffer, result;

        if ((buffer = value.buffer) && (0, _util.isArrayBuffer)(buffer)) {
          if (transfers && transfers.includes(buffer)) { // lwf
            result = new value.constructor(buffer, value.byteOffset, value.byteLength);
          } else {
            result = new value.constructor(value);
          }

          cloned.set(value, result);
          return result;
        }

        result = Array.isArray(value) ? [] : {};
        cloned.set(value, result);

        for (const i in value) {
          let desc,
              p = value;

          while (!(desc = Object.getOwnPropertyDescriptor(p, i))) {
            p = Object.getPrototypeOf(p);
          }

          if (typeof desc.value === "undefined") {
            continue;
          }

          if (typeof desc.value === "function") {
            if (value.hasOwnProperty && value.hasOwnProperty(i)) {
              throw new Error(`LoopbackPort.postMessage - cannot clone: ${value[i]}`);
            }

            continue;
          }

          result[i] = cloneValue(desc.value);
        }

        return result;
      }

      if (!this._defer) {
        this._listeners.forEach(listener => {
          listener.call(this, {
            data: obj
          });
        });

        return;
      }

      const cloned = new WeakMap();
      const e = {
        data: cloneValue(obj)
      };

      this._deferred.then(() => {
        this._listeners.forEach(listener => {
          listener.call(this, e);
        });
      });
    }

    addEventListener(name, listener) {
      this._listeners.push(listener);
    }

    removeEventListener(name, listener) {
      const i = this._listeners.indexOf(listener);

      this._listeners.splice(i, 1);
    }

    terminate() {
      this._listeners.length = 0;
    }

  }

  exports.LoopbackPort = LoopbackPort;

  const PDFWorker = function PDFWorkerClosure() {
    const pdfWorkerPorts = new WeakMap();
    let isWorkerDisabled = false;
    let fallbackWorkerSrc;
    let nextFakeWorkerId = 0;
    let fakeWorkerCapability;

    if (_is_node.isNodeJS && typeof require === "function") {
      isWorkerDisabled = true;
      fallbackWorkerSrc = "./skylark-pdfjs-worker-all.js"; //"./pdf.worker.js";
    } else if (typeof document === "object" && "currentScript" in document) {
      const pdfjsFilePath = document.currentScript && document.currentScript.src; // lwf

      if (pdfjsFilePath) {
        fallbackWorkerSrc = pdfjsFilePath.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2");
      }
    }

    function getWorkerSrc() {
      if (_worker_options.GlobalWorkerOptions.workerSrc) {
        return _worker_options.GlobalWorkerOptions.workerSrc;
      }

      if (typeof fallbackWorkerSrc !== "undefined") {
        if (!_is_node.isNodeJS) {
          (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.');
        }

        return fallbackWorkerSrc;
      }

      throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
    }

    function getMainThreadWorkerMessageHandler() {
      let mainWorkerMessageHandler;

      try {
        ///mainWorkerMessageHandler = globalThis.pdfjsWorker && globalThis.pdfjsWorker.WorkerMessageHandler;  // lwf
        mainWorkerMessageHandler = pdfjs.worker.WorkerMessageHandler; 
      } catch (ex) {}

      return mainWorkerMessageHandler || null;
    }

    function setupFakeWorkerGlobal() {
      if (fakeWorkerCapability) {
        return fakeWorkerCapability.promise;
      }

      fakeWorkerCapability = (0, _util.createPromiseCapability)();

      const loader = async function () {
        const mainWorkerMessageHandler = getMainThreadWorkerMessageHandler();

        if (mainWorkerMessageHandler) {
          return mainWorkerMessageHandler;
        }

        if (_is_node.isNodeJS && typeof require === "function") {
          const worker = eval("require")(getWorkerSrc());
          return worker.WorkerMessageHandler;
        }

        await (0, _display_utils.loadScript)(getWorkerSrc());
        return window.pdfjsWorker.WorkerMessageHandler;
      };

      loader().then(fakeWorkerCapability.resolve, fakeWorkerCapability.reject);
      return fakeWorkerCapability.promise;
    }

    function createCDNWrapper(url) {
      const wrapper = "importScripts('" + url + "');";
      return URL.createObjectURL(new Blob([wrapper]));
    }

    class PDFWorker {
      constructor({
        name = null,
        port = null,
        verbosity = (0, _util.getVerbosityLevel)()
      } = {}) {
        if (port && pdfWorkerPorts.has(port)) {
          throw new Error("Cannot use more than one PDFWorker per port");
        }

        this.name = name;
        this.destroyed = false;
        this.postMessageTransfers = true;
        this.verbosity = verbosity;
        this._readyCapability = (0, _util.createPromiseCapability)();
        this._port = null;
        this._webWorker = null;
        this._messageHandler = null;

        if (port) {
          pdfWorkerPorts.set(port, this);

          this._initializeFromPort(port);

          return;
        }

        this._initialize();
      }

      get promise() {
        return this._readyCapability.promise;
      }

      get port() {
        return this._port;
      }

      get messageHandler() {
        return this._messageHandler;
      }

      _initializeFromPort(port) {
        this._port = port;
        this._messageHandler = new _message_handler.MessageHandler("main", "worker", port);

        this._messageHandler.on("ready", function () {});

        this._readyCapability.resolve();
      }

      _initialize() {
        if (typeof Worker !== "undefined" && !isWorkerDisabled && !getMainThreadWorkerMessageHandler()) {
          let workerSrc = getWorkerSrc();

          try {
            if (!(0, _util.isSameOrigin)(window.location.href, workerSrc)) {
              workerSrc = createCDNWrapper(new URL(workerSrc, window.location).href);
            }

            const worker = new Worker(workerSrc);
            const messageHandler = new _message_handler.MessageHandler("main", "worker", worker);

            const terminateEarly = () => {
              worker.removeEventListener("error", onWorkerError);
              messageHandler.destroy();
              worker.terminate();

              if (this.destroyed) {
                this._readyCapability.reject(new Error("Worker was destroyed"));
              } else {
                this._setupFakeWorker();
              }
            };

            const onWorkerError = () => {
              if (!this._webWorker) {
                terminateEarly();
              }
            };

            worker.addEventListener("error", onWorkerError);
            messageHandler.on("test", data => {
              worker.removeEventListener("error", onWorkerError);

              if (this.destroyed) {
                terminateEarly();
                return;
              }

              if (data) {
                this._messageHandler = messageHandler;
                this._port = worker;
                this._webWorker = worker;

                if (!data.supportTransfers) {
                  this.postMessageTransfers = false;
                }

                this._readyCapability.resolve();

                messageHandler.send("configure", {
                  verbosity: this.verbosity
                });
              } else {
                this._setupFakeWorker();

                messageHandler.destroy();
                worker.terminate();
              }
            });
            messageHandler.on("ready", data => {
              worker.removeEventListener("error", onWorkerError);

              if (this.destroyed) {
                terminateEarly();
                return;
              }

              try {
                sendTest();
              } catch (e) {
                this._setupFakeWorker();
              }
            });

            const sendTest = () => {
              const testObj = new Uint8Array([this.postMessageTransfers ? 255 : 0]);

              try {
                messageHandler.send("test", testObj, [testObj.buffer]);
              } catch (ex) {
                (0, _util.warn)("Cannot use postMessage transfers.");
                testObj[0] = 0;
                messageHandler.send("test", testObj);
              }
            };

            sendTest();
            return;
          } catch (e) {
            (0, _util.info)("The worker has been disabled.");
          }
        }

        this._setupFakeWorker();
      }

      _setupFakeWorker() {
        if (!isWorkerDisabled) {
          (0, _util.warn)("Setting up fake worker.");
          isWorkerDisabled = true;
        }

        setupFakeWorkerGlobal().then(WorkerMessageHandler => {
          if (this.destroyed) {
            this._readyCapability.reject(new Error("Worker was destroyed"));

            return;
          }

          const port = new LoopbackPort();
          this._port = port;
          const id = "fake" + nextFakeWorkerId++;
          const workerHandler = new _message_handler.MessageHandler(id + "_worker", id, port);
          WorkerMessageHandler.setup(workerHandler, port);
          const messageHandler = new _message_handler.MessageHandler(id, id + "_worker", port);
          this._messageHandler = messageHandler;

          this._readyCapability.resolve();

          messageHandler.send("configure", {
            verbosity: this.verbosity
          });
        }).catch(reason => {
          this._readyCapability.reject(new Error(`Setting up fake worker failed: "${reason.message}".`));
        });
      }

      destroy() {
        this.destroyed = true;

        if (this._webWorker) {
          this._webWorker.terminate();

          this._webWorker = null;
        }

        pdfWorkerPorts.delete(this._port);
        this._port = null;

        if (this._messageHandler) {
          this._messageHandler.destroy();

          this._messageHandler = null;
        }
      }

      static fromPort(params) {
        if (!params || !params.port) {
          throw new Error("PDFWorker.fromPort - invalid method signature.");
        }

        if (pdfWorkerPorts.has(params.port)) {
          return pdfWorkerPorts.get(params.port);
        }

        return new PDFWorker(params);
      }

      static getWorkerSrc() {
        return getWorkerSrc();
      }

    }

    return PDFWorker;
  }();

  exports.PDFWorker = PDFWorker;

  class WorkerTransport {
    constructor(messageHandler, loadingTask, networkStream, params) {
      this.messageHandler = messageHandler;
      this.loadingTask = loadingTask;
      this.commonObjs = new PDFObjects();
      this.fontLoader = new _font_loader.FontLoader({
        docId: loadingTask.docId,
        onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
        ownerDocument: params.ownerDocument
      });
      this._params = params;
      this.CMapReaderFactory = new params.CMapReaderFactory({
        baseUrl: params.cMapUrl,
        isCompressed: params.cMapPacked
      });
      this.destroyed = false;
      this.destroyCapability = null;
      this._passwordCapability = null;
      this._networkStream = networkStream;
      this._fullReader = null;
      this._lastProgress = null;
      this.pageCache = [];
      this.pagePromises = [];
      this.downloadInfoCapability = (0, _util.createPromiseCapability)();
      this.setupMessageHandler();
    }

    get loadingTaskSettled() {
      return this.loadingTask._capability.settled;
    }

    destroy() {
      if (this.destroyCapability) {
        return this.destroyCapability.promise;
      }

      this.destroyed = true;
      this.destroyCapability = (0, _util.createPromiseCapability)();

      if (this._passwordCapability) {
        this._passwordCapability.reject(new Error("Worker was destroyed during onPassword callback"));
      }

      const waitOn = [];
      this.pageCache.forEach(function (page) {
        if (page) {
          waitOn.push(page._destroy());
        }
      });
      this.pageCache.length = 0;
      this.pagePromises.length = 0;
      const terminated = this.messageHandler.sendWithPromise("Terminate", null);
      waitOn.push(terminated);

      if (this.loadingTaskSettled) {
        const annotationStorageResetModified = this.loadingTask.promise.then(pdfDocument => {
          if (pdfDocument.hasOwnProperty("annotationStorage")) {
            pdfDocument.annotationStorage.resetModified();
          }
        }).catch(() => {});
        waitOn.push(annotationStorageResetModified);
      }

      Promise.all(waitOn).then(() => {
        this.commonObjs.clear();
        this.fontLoader.clear();
        this._hasJSActionsPromise = null;

        if (this._networkStream) {
          this._networkStream.cancelAllRequests(new _util.AbortException("Worker was terminated."));
        }

        if (this.messageHandler) {
          this.messageHandler.destroy();
          this.messageHandler = null;
        }

        this.destroyCapability.resolve();
      }, this.destroyCapability.reject);
      return this.destroyCapability.promise;
    }

    setupMessageHandler() {
      const {
        messageHandler,
        loadingTask
      } = this;
      messageHandler.on("GetReader", (data, sink) => {
        (0, _util.assert)(this._networkStream, "GetReader - no `IPDFStream` instance available.");
        this._fullReader = this._networkStream.getFullReader();

        this._fullReader.onProgress = evt => {
          this._lastProgress = {
            loaded: evt.loaded,
            total: evt.total
          };
        };

        sink.onPull = () => {
          this._fullReader.read().then(function ({
            value,
            done
          }) {
            if (done) {
              sink.close();
              return;
            }

            (0, _util.assert)((0, _util.isArrayBuffer)(value), "GetReader - expected an ArrayBuffer.");
            sink.enqueue(new Uint8Array(value), 1, [value]);
          }).catch(reason => {
            sink.error(reason);
          });
        };

        sink.onCancel = reason => {
          this._fullReader.cancel(reason);

          sink.ready.catch(readyReason => {
            if (this.destroyed) {
              return;
            }

            throw readyReason;
          });
        };
      });
      messageHandler.on("ReaderHeadersReady", data => {
        const headersCapability = (0, _util.createPromiseCapability)();
        const fullReader = this._fullReader;
        fullReader.headersReady.then(() => {
          if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {
            if (this._lastProgress && loadingTask.onProgress) {
              loadingTask.onProgress(this._lastProgress);
            }

            fullReader.onProgress = evt => {
              if (loadingTask.onProgress) {
                loadingTask.onProgress({
                  loaded: evt.loaded,
                  total: evt.total
                });
              }
            };
          }

          headersCapability.resolve({
            isStreamingSupported: fullReader.isStreamingSupported,
            isRangeSupported: fullReader.isRangeSupported,
            contentLength: fullReader.contentLength
          });
        }, headersCapability.reject);
        return headersCapability.promise;
      });
      messageHandler.on("GetRangeReader", (data, sink) => {
        (0, _util.assert)(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");

        const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);

        if (!rangeReader) {
          sink.close();
          return;
        }

        sink.onPull = () => {
          rangeReader.read().then(function ({
            value,
            done
          }) {
            if (done) {
              sink.close();
              return;
            }

            (0, _util.assert)((0, _util.isArrayBuffer)(value), "GetRangeReader - expected an ArrayBuffer.");
            sink.enqueue(new Uint8Array(value), 1, [value]);
          }).catch(reason => {
            sink.error(reason);
          });
        };

        sink.onCancel = reason => {
          rangeReader.cancel(reason);
          sink.ready.catch(readyReason => {
            if (this.destroyed) {
              return;
            }

            throw readyReason;
          });
        };
      });
      messageHandler.on("GetDoc", ({
        pdfInfo
      }) => {
        this._numPages = pdfInfo.numPages;

        loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));
      });
      messageHandler.on("DocException", function (ex) {
        let reason;

        switch (ex.name) {
          case "PasswordException":
            reason = new _util.PasswordException(ex.message, ex.code);
            break;

          case "InvalidPDFException":
            reason = new _util.InvalidPDFException(ex.message);
            break;

          case "MissingPDFException":
            reason = new _util.MissingPDFException(ex.message);
            break;

          case "UnexpectedResponseException":
            reason = new _util.UnexpectedResponseException(ex.message, ex.status);
            break;

          case "UnknownErrorException":
            reason = new _util.UnknownErrorException(ex.message, ex.details);
            break;
        }

        if (!(reason instanceof Error)) {
          const msg = "DocException - expected a valid Error.";
          (0, _util.warn)(msg);
        }

        loadingTask._capability.reject(reason);
      });
      messageHandler.on("PasswordRequest", exception => {
        this._passwordCapability = (0, _util.createPromiseCapability)();

        if (loadingTask.onPassword) {
          const updatePassword = password => {
            this._passwordCapability.resolve({
              password
            });
          };

          try {
            loadingTask.onPassword(updatePassword, exception.code);
          } catch (ex) {
            this._passwordCapability.reject(ex);
          }
        } else {
          this._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));
        }

        return this._passwordCapability.promise;
      });
      messageHandler.on("DataLoaded", data => {
        if (loadingTask.onProgress) {
          loadingTask.onProgress({
            loaded: data.length,
            total: data.length
          });
        }

        this.downloadInfoCapability.resolve(data);
      });
      messageHandler.on("StartRenderPage", data => {
        if (this.destroyed) {
          return;
        }

        const page = this.pageCache[data.pageIndex];

        page._startRenderPage(data.transparency, data.intent);
      });
      messageHandler.on("commonobj", data => {
        if (this.destroyed) {
          return;
        }

        const [id, type, exportedData] = data;

        if (this.commonObjs.has(id)) {
          return;
        }

        switch (type) {
          case "Font":
            const params = this._params;

            if ("error" in exportedData) {
              const exportedError = exportedData.error;
              (0, _util.warn)(`Error during font loading: ${exportedError}`);
              this.commonObjs.resolve(id, exportedError);
              break;
            }

            let fontRegistry = null;

            if (params.pdfBug && globalThis.FontInspector && globalThis.FontInspector.enabled) { //lwf
              fontRegistry = {
                registerFont(font, url) {
                  globalThis.FontInspector.fontAdded(font, url);
                }

              };
            }

            const font = new _font_loader.FontFaceObject(exportedData, {
              isEvalSupported: params.isEvalSupported,
              disableFontFace: params.disableFontFace,
              ignoreErrors: params.ignoreErrors,
              onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
              fontRegistry
            });
            this.fontLoader.bind(font).catch(reason => {
              return messageHandler.sendWithPromise("FontFallback", {
                id
              });
            }).finally(() => {
              if (!params.fontExtraProperties && font.data) {
                font.data = null;
              }

              this.commonObjs.resolve(id, font);
            });
            break;

          case "FontPath":
          case "Image":
            this.commonObjs.resolve(id, exportedData);
            break;

          default:
            throw new Error(`Got unknown common object type ${type}`);
        }
      });
      messageHandler.on("obj", data => {
        if (this.destroyed) {
          return undefined;
        }

        const [id, pageIndex, type, imageData] = data;
        const pageProxy = this.pageCache[pageIndex];

        if (pageProxy.objs.has(id)) {
          return undefined;
        }

        switch (type) {
          case "Image":
            pageProxy.objs.resolve(id, imageData);
            const MAX_IMAGE_SIZE_TO_STORE = 8000000;

            if (imageData && imageData.data && imageData.data.length > MAX_IMAGE_SIZE_TO_STORE) { //lwf
              pageProxy.cleanupAfterRender = true;
            }

            break;

          default:
            throw new Error(`Got unknown object type ${type}`);
        }

        return undefined;
      });
      messageHandler.on("DocProgress", data => {
        if (this.destroyed) {
          return;
        }

        if (loadingTask.onProgress) {
          loadingTask.onProgress({
            loaded: data.loaded,
            total: data.total
          });
        }
      });
      messageHandler.on("UnsupportedFeature", this._onUnsupportedFeature.bind(this));
      messageHandler.on("FetchBuiltInCMap", (data, sink) => {
        if (this.destroyed) {
          sink.error(new Error("Worker was destroyed"));
          return;
        }

        let fetched = false;

        sink.onPull = () => {
          if (fetched) {
            sink.close();
            return;
          }

          fetched = true;
          this.CMapReaderFactory.fetch(data).then(function (builtInCMap) {
            sink.enqueue(builtInCMap, 1, [builtInCMap.cMapData.buffer]);
          }).catch(function (reason) {
            sink.error(reason);
          });
        };
      });
    }

    _onUnsupportedFeature({
      featureId
    }) {
      if (this.destroyed) {
        return;
      }

      if (this.loadingTask.onUnsupportedFeature) {
        this.loadingTask.onUnsupportedFeature(featureId);
      }
    }

    getData() {
      return this.messageHandler.sendWithPromise("GetData", null);
    }

    getPage(pageNumber) {
      if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {
        return Promise.reject(new Error("Invalid page request"));
      }

      const pageIndex = pageNumber - 1;

      if (pageIndex in this.pagePromises) {
        return this.pagePromises[pageIndex];
      }

      const promise = this.messageHandler.sendWithPromise("GetPage", {
        pageIndex
      }).then(pageInfo => {
        if (this.destroyed) {
          throw new Error("Transport destroyed");
        }

        const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.ownerDocument, this._params.pdfBug);
        this.pageCache[pageIndex] = page;
        return page;
      });
      this.pagePromises[pageIndex] = promise;
      return promise;
    }

    getPageIndex(ref) {
      return this.messageHandler.sendWithPromise("GetPageIndex", {
        ref
      }).catch(function (reason) {
        return Promise.reject(new Error(reason));
      });
    }

    getAnnotations(pageIndex, intent) {
      return this.messageHandler.sendWithPromise("GetAnnotations", {
        pageIndex,
        intent
      });
    }

    saveDocument(annotationStorage) {
      return this.messageHandler.sendWithPromise("SaveDocument", {
        numPages: this._numPages,
        annotationStorage: annotationStorage && annotationStorage.getAll() || null,  // lwf
        filename: this._fullReader && this._fullReader.filename || null // lwf
      }).finally(() => {
        if (annotationStorage) {
          annotationStorage.resetModified();
        }
      });
    }

    getFieldObjects() {
      return this.messageHandler.sendWithPromise("GetFieldObjects", null);
    }

    hasJSActions() {
      return this._hasJSActionsPromise || (this._hasJSActionsPromise = this.messageHandler.sendWithPromise("HasJSActions", null));
    }

    getCalculationOrderIds() {
      return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
    }

    getDestinations() {
      return this.messageHandler.sendWithPromise("GetDestinations", null);
    }

    getDestination(id) {
      if (typeof id !== "string") {
        return Promise.reject(new Error("Invalid destination request."));
      }

      return this.messageHandler.sendWithPromise("GetDestination", {
        id
      });
    }

    getPageLabels() {
      return this.messageHandler.sendWithPromise("GetPageLabels", null);
    }

    getPageLayout() {
      return this.messageHandler.sendWithPromise("GetPageLayout", null);
    }

    getPageMode() {
      return this.messageHandler.sendWithPromise("GetPageMode", null);
    }

    getViewerPreferences() {
      return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
    }

    getOpenAction() {
      return this.messageHandler.sendWithPromise("GetOpenAction", null);
    }

    getAttachments() {
      return this.messageHandler.sendWithPromise("GetAttachments", null);
    }

    getJavaScript() {
      return this.messageHandler.sendWithPromise("GetJavaScript", null);
    }

    getDocJSActions() {
      return this.messageHandler.sendWithPromise("GetDocJSActions", null);
    }

    getPageJSActions(pageIndex) {
      return this.messageHandler.sendWithPromise("GetPageJSActions", {
        pageIndex
      });
    }

    getOutline() {
      return this.messageHandler.sendWithPromise("GetOutline", null);
    }

    getOptionalContentConfig() {
      return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then(results => {
        return new _optional_content_config.OptionalContentConfig(results);
      });
    }

    getPermissions() {
      return this.messageHandler.sendWithPromise("GetPermissions", null);
    }

    getMetadata() {
      return this.messageHandler.sendWithPromise("GetMetadata", null).then(results => {
        return {
          info: results[0],
          metadata: results[1] ? new _metadata.Metadata(results[1]) : null,
          contentDispositionFilename: this._fullReader && this._fullReader.filename || null, // lwf
          contentLength: this._fullReader && this._fullReader.contentLength || null  // lwf
        };
      });
    }

    getMarkInfo() {
      return this.messageHandler.sendWithPromise("GetMarkInfo", null);
    }

    getStats() {
      return this.messageHandler.sendWithPromise("GetStats", null);
    }

    startCleanup() {
      return this.messageHandler.sendWithPromise("Cleanup", null).then(() => {
        for (let i = 0, ii = this.pageCache.length; i < ii; i++) {
          const page = this.pageCache[i];

          if (page) {
            const cleanupSuccessful = page.cleanup();

            if (!cleanupSuccessful) {
              throw new Error(`startCleanup: Page ${i + 1} is currently rendering.`);
            }
          }
        }

        this.commonObjs.clear();
        this.fontLoader.clear();
        this._hasJSActionsPromise = null;
      });
    }

    get loadingParams() {
      const params = this._params;
      return (0, _util.shadow)(this, "loadingParams", {
        disableAutoFetch: params.disableAutoFetch,
        disableFontFace: params.disableFontFace
      });
    }

  }

  class PDFObjects {
    constructor() {
      this._objs = Object.create(null);
    }

    _ensureObj(objId) {
      if (this._objs[objId]) {
        return this._objs[objId];
      }

      return this._objs[objId] = {
        capability: (0, _util.createPromiseCapability)(),
        data: null,
        resolved: false
      };
    }

    get(objId, callback = null) {
      if (callback) {
        this._ensureObj(objId).capability.promise.then(callback);

        return null;
      }

      const obj = this._objs[objId];

      if (!obj || !obj.resolved) {
        throw new Error(`Requesting object that isn't resolved yet ${objId}.`);
      }

      return obj.data;
    }

    has(objId) {
      const obj = this._objs[objId];
      return obj && obj.resolved || false; // lwf
    }

    resolve(objId, data) {
      const obj = this._ensureObj(objId);

      obj.resolved = true;
      obj.data = data;
      obj.capability.resolve(data);
    }

    clear() {
      this._objs = Object.create(null);
    }

  }

  class RenderTask {
    constructor(internalRenderTask) {
      this._internalRenderTask = internalRenderTask;
      this.onContinue = null;
    }

    get promise() {
      return this._internalRenderTask.capability.promise;
    }

    cancel() {
      this._internalRenderTask.cancel();
    }

  }

  const InternalRenderTask = function InternalRenderTaskClosure() {
    const canvasInRendering = new WeakSet();

    class InternalRenderTask {
      constructor({
        callback,
        params,
        objs,
        commonObjs,
        operatorList,
        pageIndex,
        canvasFactory,
        webGLContext,
        useRequestAnimationFrame = false,
        pdfBug = false
      }) {
        this.callback = callback;
        this.params = params;
        this.objs = objs;
        this.commonObjs = commonObjs;
        this.operatorListIdx = null;
        this.operatorList = operatorList;
        this._pageIndex = pageIndex;
        this.canvasFactory = canvasFactory;
        this.webGLContext = webGLContext;
        this._pdfBug = pdfBug;
        this.running = false;
        this.graphicsReadyCallback = null;
        this.graphicsReady = false;
        this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== "undefined";
        this.cancelled = false;
        this.capability = (0, _util.createPromiseCapability)();
        this.task = new RenderTask(this);
        this._continueBound = this._continue.bind(this);
        this._scheduleNextBound = this._scheduleNext.bind(this);
        this._nextBound = this._next.bind(this);
        this._canvas = params.canvasContext.canvas;
      }

      get completed() {
        return this.capability.promise.catch(function () {});
      }

      initializeGraphics({
        transparency = false,
        optionalContentConfig
      }) {
        if (this.cancelled) {
          return;
        }

        if (this._canvas) {
          if (canvasInRendering.has(this._canvas)) {
            throw new Error("Cannot use the same canvas during multiple render() operations. " + "Use different canvas or ensure previous operations were " + "cancelled or completed.");
          }

          canvasInRendering.add(this._canvas);
        }

        if (this._pdfBug && globalThis.StepperManager && globalThis.StepperManager.enabled) { // lwf
          this.stepper = globalThis.StepperManager.create(this._pageIndex);
          this.stepper.init(this.operatorList);
          this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
        }

        const {
          canvasContext,
          viewport,
          transform,
          imageLayer,
          background
        } = this.params;
        this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.webGLContext, imageLayer, optionalContentConfig);
        this.gfx.beginDrawing({
          transform,
          viewport,
          transparency,
          background
        });
        this.operatorListIdx = 0;
        this.graphicsReady = true;

        if (this.graphicsReadyCallback) {
          this.graphicsReadyCallback();
        }
      }

      cancel(error = null) {
        this.running = false;
        this.cancelled = true;

        if (this.gfx) {
          this.gfx.endDrawing();
        }

        if (this._canvas) {
          canvasInRendering.delete(this._canvas);
        }

        this.callback(error || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, "canvas"));
      }

      operatorListChanged() {
        if (!this.graphicsReady) {
          if (!this.graphicsReadyCallback) {
            this.graphicsReadyCallback = this._continueBound;
          }

          return;
        }

        if (this.stepper) {
          this.stepper.updateOperatorList(this.operatorList);
        }

        if (this.running) {
          return;
        }

        this._continue();
      }

      _continue() {
        this.running = true;

        if (this.cancelled) {
          return;
        }

        if (this.task.onContinue) {
          this.task.onContinue(this._scheduleNextBound);
        } else {
          this._scheduleNext();
        }
      }

      _scheduleNext() {
        if (this._useRequestAnimationFrame) {
          window.requestAnimationFrame(() => {
            this._nextBound().catch(this.cancel.bind(this));
          });
        } else {
          Promise.resolve().then(this._nextBound).catch(this.cancel.bind(this));
        }
      }

      async _next() {
        if (this.cancelled) {
          return;
        }

        this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);

        if (this.operatorListIdx === this.operatorList.argsArray.length) {
          this.running = false;

          if (this.operatorList.lastChunk) {
            this.gfx.endDrawing();

            if (this._canvas) {
              canvasInRendering.delete(this._canvas);
            }

            this.callback();
          }
        }
      }

    }

    return InternalRenderTask;
  }();

  const version = '2.7.570';
  exports.version = version;
  const build = 'f2c7338b0';
  exports.build = build;

  /***/ }),
  /* 6 */
  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



  Object.defineProperty(exports, "__esModule", ({
    value: true
  }));
  exports.FontLoader = exports.FontFaceObject = void 0;

  var _util = __w_pdfjs_require__(2);

  class BaseFontLoader {
    constructor({
      docId,
      onUnsupportedFeature,
      ownerDocument = globalThis.document
    }) {
      if (this.constructor === BaseFontLoader) {
        (0, _util.unreachable)("Cannot initialize BaseFontLoader.");
      }

      this.docId = docId;
      this._onUnsupportedFeature = onUnsupportedFeature;
      this._document = ownerDocument;
      this.nativeFontFaces = [];
      this.styleElement = null;
    }

    addNativeFontFace(nativeFontFace) {
      this.nativeFontFaces.push(nativeFontFace);

      this._document.fonts.add(nativeFontFace);
    }

    insertRule(rule) {
      let styleElement = this.styleElement;

      if (!styleElement) {
        styleElement = this.styleElement = this._document.createElement("style");
        styleElement.id = `PDFJS_FONT_STYLE_TAG_${this.docId}`;

        this._document.documentElement.getElementsByTagName("head")[0].appendChild(styleElement);
      }

      const styleSheet = styleElement.sheet;
      styleSheet.insertRule(rule, styleSheet.cssRules.length);
    }

    clear() {
      this.nativeFontFaces.forEach(nativeFontFace => {
        this._document.fonts.delete(nativeFontFace);
      });
      this.nativeFontFaces.length = 0;

      if (this.styleElement) {
        this.styleElement.remove();
        this.styleElement = null;
      }
    }

    async bind(font) {
      if (font.attached || font.missingFile) {
        return;
      }

      font.attached = true;

      if (this.isFontLoadingAPISupported) {
        const nativeFontFace = font.createNativeFontFace();

        if (nativeFontFace) {
          this.addNativeFontFace(nativeFontFace);

          try {
            await nativeFontFace.loaded;
          } catch (ex) {
            this._onUnsupportedFeature({
              featureId: _util.UNSUPPORTED_FEATURES.errorFontLoadNative
            });

            (0, _util.warn)(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);
            font.disableFontFace = true;
            throw ex;
          }
        }

        return;
      }

      const rule = font.createFontFaceRule();

      if (rule) {
        this.insertRule(rule);

        if (this.isSyncFontLoadingSupported) {
          return;
        }

        await new Promise(resolve => {
          const request = this._queueLoadingCallback(resolve);

          this._prepareFontLoadEvent([rule], [font], request);
        });
      }
    }

    _queueLoadingCallback(callback) {
      (0, _util.unreachable)("Abstract method `_queueLoadingCallback`.");
    }

    get isFontLoadingAPISupported() {
      return (0, _util.shadow)(this, "isFontLoadingAPISupported", !!(this._document && this._document.fonts)); // lwf
    }

    get isSyncFontLoadingSupported() {
      (0, _util.unreachable)("Abstract method `isSyncFontLoadingSupported`.");
    }

    get _loadTestFont() {
      (0, _util.unreachable)("Abstract method `_loadTestFont`.");
    }

    _prepareFontLoadEvent(rules, fontsToLoad, request) {
      (0, _util.unreachable)("Abstract method `_prepareFontLoadEvent`.");
    }

  }

  let FontLoader;
  exports.FontLoader = FontLoader;
  {
    exports.FontLoader = FontLoader = class GenericFontLoader extends BaseFontLoader {
      constructor(params) {
        super(params);
        this.loadingContext = {
          requests: [],
          nextRequestId: 0
        };
        this.loadTestFontId = 0;
      }

      get isSyncFontLoadingSupported() {
        let supported = false;

        if (typeof navigator === "undefined") {
          supported = true;
        } else {
          const m = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(navigator.userAgent);

          if (m && m[1] >= 14) { // lwf
            supported = true;
          }
        }

        return (0, _util.shadow)(this, "isSyncFontLoadingSupported", supported);
      }

      _queueLoadingCallback(callback) {
        function completeRequest() {
          (0, _util.assert)(!request.done, "completeRequest() cannot be called twice.");
          request.done = true;

          while (context.requests.length > 0 && context.requests[0].done) {
            const otherRequest = context.requests.shift();
            setTimeout(otherRequest.callback, 0);
          }
        }

        const context = this.loadingContext;
        const request = {
          id: `pdfjs-font-loading-${context.nextRequestId++}`,
          done: false,
          complete: completeRequest,
          callback
        };
        context.requests.push(request);
        return request;
      }

      get _loadTestFont() {
        const getLoadTestFont = function () {
          return atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA" + "FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA" + "ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA" + "AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1" + "AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD" + "6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM" + "AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D" + "IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA" + "AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA" + "AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB" + "AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY" + "AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA" + "AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA" + "AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC" + "AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3" + "Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj" + "FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
        };

        return (0, _util.shadow)(this, "_loadTestFont", getLoadTestFont());
      }

      _prepareFontLoadEvent(rules, fonts, request) {
        function int32(data, offset) {
          return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;
        }

        function spliceString(s, offset, remove, insert) {
          const chunk1 = s.substring(0, offset);
          const chunk2 = s.substring(offset + remove);
          return chunk1 + insert + chunk2;
        }

        let i, ii;

        const canvas = this._document.createElement("canvas");

        canvas.width = 1;
        canvas.height = 1;
        const ctx = canvas.getContext("2d");
        let called = 0;

        function isFontReady(name, callback) {
          called++;

          if (called > 30) {
            (0, _util.warn)("Load test font never loaded.");
            callback();
            return;
          }

          ctx.font = "30px " + name;
          ctx.fillText(".", 0, 20);
          const imageData = ctx.getImageData(0, 0, 1, 1);

          if (imageData.data[3] > 0) {
            callback();
            return;
          }

          setTimeout(isFontReady.bind(null, name, callback));
        }

        const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;
        let data = this._loadTestFont;
        const COMMENT_OFFSET = 976;
        data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
        const CFF_CHECKSUM_OFFSET = 16;
        const XXXX_VALUE = 0x58585858;
        let checksum = int32(data, CFF_CHECKSUM_OFFSET);

        for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {
          checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;
        }

        if (i < loadTestFontId.length) {
          checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i) | 0;
        }

        data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util.string32)(checksum));
        const url = `url(data:font/opentype;base64,${btoa(data)});`;
        const rule = `@font-face {font-family:"${loadTestFontId}";src:${url}}`;
        this.insertRule(rule);
        const names = [];

        for (i = 0, ii = fonts.length; i < ii; i++) {
          names.push(fonts[i].loadedName);
        }

        names.push(loadTestFontId);

        const div = this._document.createElement("div");

        div.style.visibility = "hidden";
        div.style.width = div.style.height = "10px";
        div.style.position = "absolute";
        div.style.top = div.style.left = "0px";

        for (i = 0, ii = names.length; i < ii; ++i) {
          const span = this._document.createElement("span");

          span.textContent = "Hi";
          span.style.fontFamily = names[i];
          div.appendChild(span);
        }

        this._document.body.appendChild(div);

        isFontReady(loadTestFontId, () => {
          this._document.body.removeChild(div);

          request.complete();
        });
      }

    };
  }

  class FontFaceObject {
    constructor(translatedData, {
      isEvalSupported = true,
      disableFontFace = false,
      ignoreErrors = false,
      onUnsupportedFeature = null,
      fontRegistry = null
    }) {
      this.compiledGlyphs = Object.create(null);

      for (const i in translatedData) {
        this[i] = translatedData[i];
      }

      this.isEvalSupported = isEvalSupported !== false;
      this.disableFontFace = disableFontFace === true;
      this.ignoreErrors = ignoreErrors === true;
      this._onUnsupportedFeature = onUnsupportedFeature;
      this.fontRegistry = fontRegistry;
    }

    createNativeFontFace() {
      if (!this.data || this.disableFontFace) {
        return null;
      }

      const nativeFontFace = new FontFace(this.loadedName, this.data, {});

      if (this.fontRegistry) {
        this.fontRegistry.registerFont(this);
      }

      return nativeFontFace;
    }

    createFontFaceRule() {
      if (!this.data || this.disableFontFace) {
        return null;
      }

      const data = (0, _util.bytesToString)(new Uint8Array(this.data));
      const url = `url(data:${this.mimetype};base64,${btoa(data)});`;
      const rule = `@font-face {font-family:"${this.loadedName}";src:${url}}`;

      if (this.fontRegistry) {
        this.fontRegistry.registerFont(this, url);
      }

      return rule;
    }

    getPathGenerator(objs, character) {
      if (this.compiledGlyphs[character] !== undefined) {
        return this.compiledGlyphs[character];
      }

      let cmds, current;

      try {
        cmds = objs.get(this.loadedName + "_path_" + character);
      } catch (ex) {
        if (!this.ignoreErrors) {
          throw ex;
        }

        if (this._onUnsupportedFeature) {
          this._onUnsupportedFeature({
            featureId: _util.UNSUPPORTED_FEATURES.errorFontGetPath
          });
        }

        (0, _util.warn)(`getPathGenerator - ignoring character: "${ex}".`);
        return this.compiledGlyphs[character] = function (c, size) {};
      }

      if (this.isEvalSupported && _util.IsEvalSupportedCached.value) {
        let args,
            js = "";

        for (let i = 0, ii = cmds.length; i < ii; i++) {
          current = cmds[i];

          if (current.args !== undefined) {
            args = current.args.join(",");
          } else {
            args = "";
          }

          js += "c." + current.cmd + "(" + args + ");\n";
        }

        return this.compiledGlyphs[character] = new Function("c", "size", js);
      }

      return this.compiledGlyphs[character] = function (c, size) {
        for (let i = 0, ii = cmds.length; i < ii; i++) {
          current = cmds[i];

          if (current.cmd === "scale") {
            current.args = [size, -size];
          }

          c[current.cmd].apply(c, current.args);
        }
      };
    }

  }

  exports.FontFaceObject = FontFaceObject;

  /***/ }),
  /* 7 */
  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



  Object.defineProperty(exports, "__esModule", ({
    value: true
  }));
  exports.NodeCMapReaderFactory = exports.NodeCanvasFactory = void 0;

  var _display_utils = __w_pdfjs_require__(1);

  var _is_node = __w_pdfjs_require__(4);

  var _util = __w_pdfjs_require__(2);

  let NodeCanvasFactory = class {
    constructor() {
      (0, _util.unreachable)("Not implemented: NodeCanvasFactory");
    }

  };
  exports.NodeCanvasFactory = NodeCanvasFactory;
  let NodeCMapReaderFactory = class {
    constructor() {
      (0, _util.unreachable)("Not implemented: NodeCMapReaderFactory");
    }

  };
  exports.NodeCMapReaderFactory = NodeCMapReaderFactory;

  if (_is_node.isNodeJS) {
    exports.NodeCanvasFactory = NodeCanvasFactory = class extends _display_utils.BaseCanvasFactory {
      create(width, height) {
        if (width <= 0 || height <= 0) {
          throw new Error("Invalid canvas size");
        }

        const Canvas = require("canvas");

        const canvas = Canvas.createCanvas(width, height);
        return {
          canvas,
          context: canvas.getContext("2d")
        };
      }

    };
    exports.NodeCMapReaderFactory = NodeCMapReaderFactory = class extends _display_utils.BaseCMapReaderFactory {
      _fetchData(url, compressionType) {
        return new Promise((resolve, reject) => {
          const fs = require("fs");

          fs.readFile(url, (error, data) => {
            if (error || !data) {
              reject(new Error(error));
              return;
            }

            resolve({
              cMapData: new Uint8Array(data),
              compressionType
            });
          });
        });
      }

    };
  }

  /***/ }),
  /* 8 */
  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



  Object.defineProperty(exports, "__esModule", ({
    value: true
  }));
  exports.AnnotationStorage = void 0;

  var _util = __w_pdfjs_require__(2);

  class AnnotationStorage {
    constructor() {
      this._storage = new Map();
      this._modified = false;
      this.onSetModified = null;
      this.onResetModified = null;
    }

    getOrCreateValue(key, defaultValue) {
      if (this._storage.has(key)) {
        return this._storage.get(key);
      }

      this._storage.set(key, defaultValue);

      return defaultValue;
    }

    setValue(key, value) {
      const obj = this._storage.get(key);

      let modified = false;

      if (obj !== undefined) {
        for (const [entry, val] of Object.entries(value)) {
          if (obj[entry] !== val) {
            modified = true;
            obj[entry] = val;
          }
        }
      } else {
        this._storage.set(key, value);

        modified = true;
      }

      if (modified) {
        this._setModified();
      }
    }

    getAll() {
      if (this._storage.size === 0) {
        return null;
      }

      return (0, _util.objectFromEntries)(this._storage);
    }

    get size() {
      return this._storage.size;
    }

    _setModified() {
      if (!this._modified) {
        this._modified = true;

        if (typeof this.onSetModified === "function") {
          this.onSetModified();
        }
      }
    }

    resetModified() {
      if (this._modified) {
        this._modified = false;

        if (typeof this.onResetModified === "function") {
          this.onResetModified();
        }
      }
    }

  }

  exports.AnnotationStorage = AnnotationStorage;

  /***/ }),
  /* 9 */
  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



  Object.defineProperty(exports, "__esModule", ({
    value: true
  }));
  exports.apiCompatibilityParams = void 0;

  var _is_node = __w_pdfjs_require__(4);

  const compatibilityParams = Object.create(null);
  {
    (function checkFontFace() {
      if (_is_node.isNodeJS) {
        compatibilityParams.disableFontFace = true;
      }
    })();
  }
  const apiCompatibilityParams = Object.freeze(compatibilityParams);
  exports.apiCompatibilityParams = apiCompatibilityParams;

  /***/ }),
  /* 10 */
  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



  Object.defineProperty(exports, "__esModule", ({
    value: true
  }));
  exports.CanvasGraphics = void 0;

  var _util = __w_pdfjs_require__(2);

  var _pattern_helper = __w_pdfjs_require__(11);

  const MIN_FONT_SIZE = 16;
  const MAX_FONT_SIZE = 100;
  const MAX_GROUP_SIZE = 4096;
  const COMPILE_TYPE3_GLYPHS = true;
  const MAX_SIZE_TO_COMPILE = 1000;
  const FULL_CHUNK_HEIGHT = 16;

  function addContextCurrentTransform(ctx) {
    if (!ctx.mozCurrentTransform) {
      ctx._originalSave = ctx.save;
      ctx._originalRestore = ctx.restore;
      ctx._originalRotate = ctx.rotate;
      ctx._originalScale = ctx.scale;
      ctx._originalTranslate = ctx.translate;
      ctx._originalTransform = ctx.transform;
      ctx._originalSetTransform = ctx.setTransform;
      ctx._transformMatrix = ctx._transformMatrix || [1, 0, 0, 1, 0, 0];
      ctx._transformStack = [];
      Object.defineProperty(ctx, "mozCurrentTransform", {
        get: function getCurrentTransform() {
          return this._transformMatrix;
        }
      });
      Object.defineProperty(ctx, "mozCurrentTransformInverse", {
        get: function getCurrentTransformInverse() {
          const m = this._transformMatrix;
          const a = m[0],
                b = m[1],
                c = m[2],
                d = m[3],
                e = m[4],
                f = m[5];
          const ad_bc = a * d - b * c;
          const bc_ad = b * c - a * d;
          return [d / ad_bc, b / bc_ad, c / bc_ad, a / ad_bc, (d * e - c * f) / bc_ad, (b * e - a * f) / ad_bc];
        }
      });

      ctx.save = function ctxSave() {
        const old = this._transformMatrix;

        this._transformStack.push(old);

        this._transformMatrix = old.slice(0, 6);

        this._originalSave();
      };

      ctx.restore = function ctxRestore() {
        const prev = this._transformStack.pop();

        if (prev) {
          this._transformMatrix = prev;

          this._originalRestore();
        }
      };

      ctx.translate = function ctxTranslate(x, y) {
        const m = this._transformMatrix;
        m[4] = m[0] * x + m[2] * y + m[4];
        m[5] = m[1] * x + m[3] * y + m[5];

        this._originalTranslate(x, y);
      };

      ctx.scale = function ctxScale(x, y) {
        const m = this._transformMatrix;
        m[0] = m[0] * x;
        m[1] = m[1] * x;
        m[2] = m[2] * y;
        m[3] = m[3] * y;

        this._originalScale(x, y);
      };

      ctx.transform = function ctxTransform(a, b, c, d, e, f) {
        const m = this._transformMatrix;
        this._transformMatrix = [m[0] * a + m[2] * b, m[1] * a + m[3] * b, m[0] * c + m[2] * d, m[1] * c + m[3] * d, m[0] * e + m[2] * f + m[4], m[1] * e + m[3] * f + m[5]];

        ctx._originalTransform(a, b, c, d, e, f);
      };

      ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
        this._transformMatrix = [a, b, c, d, e, f];

        ctx._originalSetTransform(a, b, c, d, e, f);
      };

      ctx.rotate = function ctxRotate(angle) {
        const cosValue = Math.cos(angle);
        const sinValue = Math.sin(angle);
        const m = this._transformMatrix;
        this._transformMatrix = [m[0] * cosValue + m[2] * sinValue, m[1] * cosValue + m[3] * sinValue, m[0] * -sinValue + m[2] * cosValue, m[1] * -sinValue + m[3] * cosValue, m[4], m[5]];

        this._originalRotate(angle);
      };
    }
  }

  const CachedCanvases = function CachedCanvasesClosure() {
    function CachedCanvases(canvasFactory) {
      this.canvasFactory = canvasFactory;
      this.cache = Object.create(null);
    }

    CachedCanvases.prototype = {
      getCanvas: function CachedCanvases_getCanvas(id, width, height, trackTransform) {
        let canvasEntry;

        if (this.cache[id] !== undefined) {
          canvasEntry = this.cache[id];
          this.canvasFactory.reset(canvasEntry, width, height);
          canvasEntry.context.setTransform(1, 0, 0, 1, 0, 0);
        } else {
          canvasEntry = this.canvasFactory.create(width, height);
          this.cache[id] = canvasEntry;
        }

        if (trackTransform) {
          addContextCurrentTransform(canvasEntry.context);
        }

        return canvasEntry;
      },

      clear() {
        for (const id in this.cache) {
          const canvasEntry = this.cache[id];
          this.canvasFactory.destroy(canvasEntry);
          delete this.cache[id];
        }
      }

    };
    return CachedCanvases;
  }();

  function compileType3Glyph(imgData) {
    const POINT_TO_PROCESS_LIMIT = 1000;
    const width = imgData.width,
          height = imgData.height,
          width1 = width + 1;
    let i, ii, j, j0;
    const points = new Uint8Array(width1 * (height + 1));
    const POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);
    const lineSize = width + 7 & ~7,
          data0 = imgData.data;
    const data = new Uint8Array(lineSize * height);
    let pos = 0;

    for (i = 0, ii = data0.length; i < ii; i++) {
      const elem = data0[i];
      let mask = 128;

      while (mask > 0) {
        data[pos++] = elem & mask ? 0 : 255;
        mask >>= 1;
      }
    }

    let count = 0;
    pos = 0;

    if (data[pos] !== 0) {
      points[0] = 1;
      ++count;
    }

    for (j = 1; j < width; j++) {
      if (data[pos] !== data[pos + 1]) {
        points[j] = data[pos] ? 2 : 1;
        ++count;
      }

      pos++;
    }

    if (data[pos] !== 0) {
      points[j] = 2;
      ++count;
    }

    for (i = 1; i < height; i++) {
      pos = i * lineSize;
      j0 = i * width1;

      if (data[pos - lineSize] !== data[pos]) {
        points[j0] = data[pos] ? 1 : 8;
        ++count;
      }

      let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);

      for (j = 1; j < width; j++) {
        sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);

        if (POINT_TYPES[sum]) {
          points[j0 + j] = POINT_TYPES[sum];
          ++count;
        }

        pos++;
      }

      if (data[pos - lineSize] !== data[pos]) {
        points[j0 + j] = data[pos] ? 2 : 4;
        ++count;
      }

      if (count > POINT_TO_PROCESS_LIMIT) {
        return null;
      }
    }

    pos = lineSize * (height - 1);
    j0 = i * width1;

    if (data[pos] !== 0) {
      points[j0] = 8;
      ++count;
    }

    for (j = 1; j < width; j++) {
      if (data[pos] !== data[pos + 1]) {
        points[j0 + j] = data[pos] ? 4 : 8;
        ++count;
      }

      pos++;
    }

    if (data[pos] !== 0) {
      points[j0 + j] = 4;
      ++count;
    }

    if (count > POINT_TO_PROCESS_LIMIT) {
      return null;
    }

    const steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
    const outlines = [];

    for (i = 0; count && i <= height; i++) {
      let p = i * width1;
      const end = p + width;

      while (p < end && !points[p]) {
        p++;
      }

      if (p === end) {
        continue;
      }

      const coords = [p % width1, i];
      const p0 = p;
      let type = points[p];

      do {
        const step = steps[type];

        do {
          p += step;
        } while (!points[p]);

        const pp = points[p];

        if (pp !== 5 && pp !== 10) {
          type = pp;
          points[p] = 0;
        } else {
          type = pp & 0x33 * type >> 4;
          points[p] &= type >> 2 | type << 2;
        }

        coords.push(p % width1);
        coords.push(p / width1 | 0);

        if (!points[p]) {
          --count;
        }
      } while (p0 !== p);

      outlines.push(coords);
      --i;
    }

    const drawOutline = function (c) {
      c.save();
      c.scale(1 / width, -1 / height);
      c.translate(0, -height);
      c.beginPath();

      for (let k = 0, kk = outlines.length; k < kk; k++) {
        const o = outlines[k];
        c.moveTo(o[0], o[1]);

        for (let l = 2, ll = o.length; l < ll; l += 2) {
          c.lineTo(o[l], o[l + 1]);
        }
      }

      c.fill();
      c.beginPath();
      c.restore();
    };

    return drawOutline;
  }

  const CanvasExtraState = function CanvasExtraStateClosure() {
    function CanvasExtraState() {
      this.alphaIsShape = false;
      this.fontSize = 0;
      this.fontSizeScale = 1;
      this.textMatrix = _util.IDENTITY_MATRIX;
      this.textMatrixScale = 1;
      this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
      this.leading = 0;
      this.x = 0;
      this.y = 0;
      this.lineX = 0;
      this.lineY = 0;
      this.charSpacing = 0;
      this.wordSpacing = 0;
      this.textHScale = 1;
      this.textRenderingMode = _util.TextRenderingMode.FILL;
      this.textRise = 0;
      this.fillColor = "#000000";
      this.strokeColor = "#000000";
      this.patternFill = false;
      this.fillAlpha = 1;
      this.strokeAlpha = 1;
      this.lineWidth = 1;
      this.activeSMask = null;
      this.resumeSMaskCtx = null;
      this.transferMaps = null;
    }

    CanvasExtraState.prototype = {
      clone: function CanvasExtraState_clone() {
        return Object.create(this);
      },
      setCurrentPoint: function CanvasExtraState_setCurrentPoint(x, y) {
        this.x = x;
        this.y = y;
      }
    };
    return CanvasExtraState;
  }();

  const CanvasGraphics = function CanvasGraphicsClosure() {
    const EXECUTION_TIME = 15;
    const EXECUTION_STEPS = 10;

    function CanvasGraphics(canvasCtx, commonObjs, objs, canvasFactory, webGLContext, imageLayer, optionalContentConfig) {
      this.ctx = canvasCtx;
      this.current = new CanvasExtraState();
      this.stateStack = [];
      this.pendingClip = null;
      this.pendingEOFill = false;
      this.res = null;
      this.xobjs = null;
      this.commonObjs = commonObjs;
      this.objs = objs;
      this.canvasFactory = canvasFactory;
      this.webGLContext = webGLContext;
      this.imageLayer = imageLayer;
      this.groupStack = [];
      this.processingType3 = null;
      this.baseTransform = null;
      this.baseTransformStack = [];
      this.groupLevel = 0;
      this.smaskStack = [];
      this.smaskCounter = 0;
      this.tempSMask = null;
      this.contentVisible = true;
      this.markedContentStack = [];
      this.optionalContentConfig = optionalContentConfig;
      this.cachedCanvases = new CachedCanvases(this.canvasFactory);

      if (canvasCtx) {
        addContextCurrentTransform(canvasCtx);
      }

      this._cachedGetSinglePixelWidth = null;
    }

    function putBinaryImageData(ctx, imgData, transferMaps = null) {
      if (typeof ImageData !== "undefined" && imgData instanceof ImageData) {
        ctx.putImageData(imgData, 0, 0);
        return;
      }

      const height = imgData.height,
            width = imgData.width;
      const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
      const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
      const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
      const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
      let srcPos = 0,
          destPos;
      const src = imgData.data;
      const dest = chunkImgData.data;
      let i, j, thisChunkHeight, elemsInThisChunk;
      let transferMapRed, transferMapGreen, transferMapBlue, transferMapGray;

      if (transferMaps) {
        switch (transferMaps.length) {
          case 1:
            transferMapRed = transferMaps[0];
            transferMapGreen = transferMaps[0];
            transferMapBlue = transferMaps[0];
            transferMapGray = transferMaps[0];
            break;

          case 4:
            transferMapRed = transferMaps[0];
            transferMapGreen = transferMaps[1];
            transferMapBlue = transferMaps[2];
            transferMapGray = transferMaps[3];
            break;
        }
      }

      if (imgData.kind === _util.ImageKind.GRAYSCALE_1BPP) {
        const srcLength = src.byteLength;
        const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
        const dest32DataLength = dest32.length;
        const fullSrcDiff = width + 7 >> 3;
        let white = 0xffffffff;
        let black = _util.IsLittleEndianCached.value ? 0xff000000 : 0x000000ff;

        if (transferMapGray) {
          if (transferMapGray[0] === 0xff && transferMapGray[0xff] === 0) {
            [white, black] = [black, white];
          }
        }

        for (i = 0; i < totalChunks; i++) {
          thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
          destPos = 0;

          for (j = 0; j < thisChunkHeight; j++) {
            const srcDiff = srcLength - srcPos;
            let k = 0;
            const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
            const kEndUnrolled = kEnd & ~7;
            let mask = 0;
            let srcByte = 0;

            for (; k < kEndUnrolled; k += 8) {
              srcByte = src[srcPos++];
              dest32[destPos++] = srcByte & 128 ? white : black;
              dest32[destPos++] = srcByte & 64 ? white : black;
              dest32[destPos++] = srcByte & 32 ? white : black;
              dest32[destPos++] = srcByte & 16 ? white : black;
              dest32[destPos++] = srcByte & 8 ? white : black;
              dest32[destPos++] = srcByte & 4 ? white : black;
              dest32[destPos++] = srcByte & 2 ? white : black;
              dest32[destPos++] = srcByte & 1 ? white : black;
            }

            for (; k < kEnd; k++) {
              if (mask === 0) {
                srcByte = src[srcPos++];
                mask = 128;
              }

              dest32[destPos++] = srcByte & mask ? white : black;
              mask >>= 1;
            }
          }

          while (destPos < dest32DataLength) {
            dest32[destPos++] = 0;
          }

          ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
        }
      } else if (imgData.kind === _util.ImageKind.RGBA_32BPP) {
        const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);
        j = 0;
        elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;

        for (i = 0; i < fullChunks; i++) {
          dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
          srcPos += elemsInThisChunk;

          if (hasTransferMaps) {
            for (let k = 0; k < elemsInThisChunk; k += 4) {
              if (transferMapRed) {
                dest[k + 0] = transferMapRed[dest[k + 0]];
              }

              if (transferMapGreen) {
                dest[k + 1] = transferMapGreen[dest[k + 1]];
              }

              if (transferMapBlue) {
                dest[k + 2] = transferMapBlue[dest[k + 2]];
              }
            }
          }

          ctx.putImageData(chunkImgData, 0, j);
          j += FULL_CHUNK_HEIGHT;
        }

        if (i < totalChunks) {
          elemsInThisChunk = width * partialChunkHeight * 4;
          dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));

          if (hasTransferMaps) {
            for (let k = 0; k < elemsInThisChunk; k += 4) {
              if (transferMapRed) {
                dest[k + 0] = transferMapRed[dest[k + 0]];
              }

              if (transferMapGreen) {
                dest[k + 1] = transferMapGreen[dest[k + 1]];
              }

              if (transferMapBlue) {
                dest[k + 2] = transferMapBlue[dest[k + 2]];
              }
            }
          }

          ctx.putImageData(chunkImgData, 0, j);
        }
      } else if (imgData.kind === _util.ImageKind.RGB_24BPP) {
        const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);
        thisChunkHeight = FULL_CHUNK_HEIGHT;
        elemsInThisChunk = width * thisChunkHeight;

        for (i = 0; i < totalChunks; i++) {
          if (i >= fullChunks) {
            thisChunkHeight = partialChunkHeight;
            elemsInThisChunk = width * thisChunkHeight;
          }

          destPos = 0;

          for (j = elemsInThisChunk; j--;) {
            dest[destPos++] = src[srcPos++];
            dest[destPos++] = src[srcPos++];
            dest[destPos++] = src[srcPos++];
            dest[destPos++] = 255;
          }

          if (hasTransferMaps) {
            for (let k = 0; k < destPos; k += 4) {
              if (transferMapRed) {
                dest[k + 0] = transferMapRed[dest[k + 0]];
              }

              if (transferMapGreen) {
                dest[k + 1] = transferMapGreen[dest[k + 1]];
              }

              if (transferMapBlue) {
                dest[k + 2] = transferMapBlue[dest[k + 2]];
              }
            }
          }

          ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
        }
      } else {
        throw new Error(`bad image kind: ${imgData.kind}`);
      }
    }

    function putBinaryImageMask(ctx, imgData) {
      const height = imgData.height,
            width = imgData.width;
      const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
      const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
      const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
      const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
      let srcPos = 0;
      const src = imgData.data;
      const dest = chunkImgData.data;

      for (let i = 0; i < totalChunks; i++) {
        const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
        let destPos = 3;

        for (let j = 0; j < thisChunkHeight; j++) {
          let elem,
              mask = 0;

          for (let k = 0; k < width; k++) {
            if (!mask) {
              elem = src[srcPos++];
              mask = 128;
            }

            dest[destPos] = elem & mask ? 0 : 255;
            destPos += 4;
            mask >>= 1;
          }
        }

        ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
      }
    }

    function copyCtxState(sourceCtx, destCtx) {
      const properties = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font"];

      for (let i = 0, ii = properties.length; i < ii; i++) {
        const property = properties[i];

        if (sourceCtx[property] !== undefined) {
          destCtx[property] = sourceCtx[property];
        }
      }

      if (sourceCtx.setLineDash !== undefined) {
        destCtx.setLineDash(sourceCtx.getLineDash());
        destCtx.lineDashOffset = sourceCtx.lineDashOffset;
      }
    }

    function resetCtxToDefault(ctx) {
      ctx.strokeStyle = "#000000";
      ctx.fillStyle = "#000000";
      ctx.fillRule = "nonzero";
      ctx.globalAlpha = 1;
      ctx.lineWidth = 1;
      ctx.lineCap = "butt";
      ctx.lineJoin = "miter";
      ctx.miterLimit = 10;
      ctx.globalCompositeOperation = "source-over";
      ctx.font = "10px sans-serif";

      if (ctx.setLineDash !== undefined) {
        ctx.setLineDash([]);
        ctx.lineDashOffset = 0;
      }
    }

    function composeSMaskBackdrop(bytes, r0, g0, b0) {
      const length = bytes.length;

      for (let i = 3; i < length; i += 4) {
        const alpha = bytes[i];

        if (alpha === 0) {
          bytes[i - 3] = r0;
          bytes[i - 2] = g0;
          bytes[i - 1] = b0;
        } else if (alpha < 255) {
          const alpha_ = 255 - alpha;
          bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;
          bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;
          bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;
        }
      }
    }

    function composeSMaskAlpha(maskData, layerData, transferMap) {
      const length = maskData.length;
      const scale = 1 / 255;

      for (let i = 3; i < length; i += 4) {
        const alpha = transferMap ? transferMap[maskData[i]] : maskData[i];
        layerData[i] = layerData[i] * alpha * scale | 0;
      }
    }

    function composeSMaskLuminosity(maskData, layerData, transferMap) {
      const length = maskData.length;

      for (let i = 3; i < length; i += 4) {
        const y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;
        layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;
      }
    }

    function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap) {
      const hasBackdrop = !!backdrop;
      const r0 = hasBackdrop ? backdrop[0] : 0;
      const g0 = hasBackdrop ? backdrop[1] : 0;
      const b0 = hasBackdrop ? backdrop[2] : 0;
      let composeFn;

      if (subtype === "Luminosity") {
        composeFn = composeSMaskLuminosity;
      } else {
        composeFn = composeSMaskAlpha;
      }

      const PIXELS_TO_PROCESS = 1048576;
      const chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));

      for (let row = 0; row < height; row += chunkSize) {
        const chunkHeight = Math.min(chunkSize, height - row);
        const maskData = maskCtx.getImageData(0, row, width, chunkHeight);
        const layerData = layerCtx.getImageData(0, row, width, chunkHeight);

        if (hasBackdrop) {
          composeSMaskBackdrop(maskData.data, r0, g0, b0);
        }

        composeFn(maskData.data, layerData.data, transferMap);
        maskCtx.putImageData(layerData, 0, row);
      }
    }

    function composeSMask(ctx, smask, layerCtx, webGLContext) {
      const mask = smask.canvas;
      const maskCtx = smask.context;
      ctx.setTransform(smask.scaleX, 0, 0, smask.scaleY, smask.offsetX, smask.offsetY);
      const backdrop = smask.backdrop || null;

      if (!smask.transferMap && webGLContext.isEnabled) {
        const composed = webGLContext.composeSMask({
          layer: layerCtx.canvas,
          mask,
          properties: {
            subtype: smask.subtype,
            backdrop
          }
        });
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.drawImage(composed, smask.offsetX, smask.offsetY);
        return;
      }

      genericComposeSMask(maskCtx, layerCtx, mask.width, mask.height, smask.subtype, backdrop, smask.transferMap);
      ctx.drawImage(mask, 0, 0);
    }

    const LINE_CAP_STYLES = ["butt", "round", "square"];
    const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
    const NORMAL_CLIP = {};
    const EO_CLIP = {};
    CanvasGraphics.prototype = {
      beginDrawing({
        transform,
        viewport,
        transparency = false,
        background = null
      }) {
        const width = this.ctx.canvas.width;
        const height = this.ctx.canvas.height;
        this.ctx.save();
        this.ctx.fillStyle = background || "rgb(255, 255, 255)";
        this.ctx.fillRect(0, 0, width, height);
        this.ctx.restore();

        if (transparency) {
          const transparentCanvas = this.cachedCanvases.getCanvas("transparent", width, height, true);
          this.compositeCtx = this.ctx;
          this.transparentCanvas = transparentCanvas.canvas;
          this.ctx = transparentCanvas.context;
          this.ctx.save();
          this.ctx.transform.apply(this.ctx, this.compositeCtx.mozCurrentTransform);
        }

        this.ctx.save();
        resetCtxToDefault(this.ctx);

        if (transform) {
          this.ctx.transform.apply(this.ctx, transform);
        }

        this.ctx.transform.apply(this.ctx, viewport.transform);
        this.baseTransform = this.ctx.mozCurrentTransform.slice();
        this._combinedScaleFactor = Math.hypot(this.baseTransform[0], this.baseTransform[2]);

        if (this.imageLayer) {
          this.imageLayer.beginLayout();
        }
      },

      executeOperatorList: function CanvasGraphics_executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {
        const argsArray = operatorList.argsArray;
        const fnArray = operatorList.fnArray;
        let i = executionStartIdx || 0;
        const argsArrayLen = argsArray.length;

        if (argsArrayLen === i) {
          return i;
        }

        const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === "function";
        const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
        let steps = 0;
        const commonObjs = this.commonObjs;
        const objs = this.objs;
        let fnId;

        while (true) {
          if (stepper !== undefined && i === stepper.nextBreakPoint) {
            stepper.breakIt(i, continueCallback);
            return i;
          }

          fnId = fnArray[i];

          if (fnId !== _util.OPS.dependency) {
            this[fnId].apply(this, argsArray[i]);
          } else {
            for (const depObjId of argsArray[i]) {
              const objsPool = depObjId.startsWith("g_") ? commonObjs : objs;

              if (!objsPool.has(depObjId)) {
                objsPool.get(depObjId, continueCallback);
                return i;
              }
            }
          }

          i++;

          if (i === argsArrayLen) {
            return i;
          }

          if (chunkOperations && ++steps > EXECUTION_STEPS) {
            if (Date.now() > endTime) {
              continueCallback();
              return i;
            }

            steps = 0;
          }
        }
      },
      endDrawing: function CanvasGraphics_endDrawing() {
        while (this.stateStack.length || this.current.activeSMask !== null) {
          this.restore();
        }

        this.ctx.restore();

        if (this.transparentCanvas) {
          this.ctx = this.compositeCtx;
          this.ctx.save();
          this.ctx.setTransform(1, 0, 0, 1, 0, 0);
          this.ctx.drawImage(this.transparentCanvas, 0, 0);
          this.ctx.restore();
          this.transparentCanvas = null;
        }

        this.cachedCanvases.clear();
        this.webGLContext.clear();

        if (this.imageLayer) {
          this.imageLayer.endLayout();
        }
      },
      setLineWidth: function CanvasGraphics_setLineWidth(width) {
        this.current.lineWidth = width;
        this.ctx.lineWidth = width;
      },
      setLineCap: function CanvasGraphics_setLineCap(style) {
        this.ctx.lineCap = LINE_CAP_STYLES[style];
      },
      setLineJoin: function CanvasGraphics_setLineJoin(style) {
        this.ctx.lineJoin = LINE_JOIN_STYLES[style];
      },
      setMiterLimit: function CanvasGraphics_setMiterLimit(limit) {
        this.ctx.miterLimit = limit;
      },
      setDash: function CanvasGraphics_setDash(dashArray, dashPhase) {
        const ctx = this.ctx;

        if (ctx.setLineDash !== undefined) {
          ctx.setLineDash(dashArray);
          ctx.lineDashOffset = dashPhase;
        }
      },

      setRenderingIntent(intent) {},

      setFlatness(flatness) {},

      setGState: function CanvasGraphics_setGState(states) {
        for (let i = 0, ii = states.length; i < ii; i++) {
          const state = states[i];
          const key = state[0];
          const value = state[1];

          switch (key) {
            case "LW":
              this.setLineWidth(value);
              break;

            case "LC":
              this.setLineCap(value);
              break;

            case "LJ":
              this.setLineJoin(value);
              break;

            case "ML":
              this.setMiterLimit(value);
              break;

            case "D":
              this.setDash(value[0], value[1]);
              break;

            case "RI":
              this.setRenderingIntent(value);
              break;

            case "FL":
              this.setFlatness(value);
              break;

            case "Font":
              this.setFont(value[0], value[1]);
              break;

            case "CA":
              this.current.strokeAlpha = state[1];
              break;

            case "ca":
              this.current.fillAlpha = state[1];
              this.ctx.globalAlpha = state[1];
              break;

            case "BM":
              this.ctx.globalCompositeOperation = value;
              break;

            case "SMask":
              if (this.current.activeSMask) {
                if (this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1].activeSMask === this.current.activeSMask) {
                  this.suspendSMaskGroup();
                } else {
                  this.endSMaskGroup();
                }
              }

              this.current.activeSMask = value ? this.tempSMask : null;

              if (this.current.activeSMask) {
                this.beginSMaskGroup();
              }

              this.tempSMask = null;
              break;

            case "TR":
              this.current.transferMaps = value;
          }
        }
      },
      beginSMaskGroup: function CanvasGraphics_beginSMaskGroup() {
        const activeSMask = this.current.activeSMask;
        const drawnWidth = activeSMask.canvas.width;
        const drawnHeight = activeSMask.canvas.height;
        const cacheId = "smaskGroupAt" + this.groupLevel;
        const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
        const currentCtx = this.ctx;
        const currentTransform = currentCtx.mozCurrentTransform;
        this.ctx.save();
        const groupCtx = scratchCanvas.context;
        groupCtx.scale(1 / activeSMask.scaleX, 1 / activeSMask.scaleY);
        groupCtx.translate(-activeSMask.offsetX, -activeSMask.offsetY);
        groupCtx.transform.apply(groupCtx, currentTransform);
        activeSMask.startTransformInverse = groupCtx.mozCurrentTransformInverse;
        copyCtxState(currentCtx, groupCtx);
        this.ctx = groupCtx;
        this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
        this.groupStack.push(currentCtx);
        this.groupLevel++;
      },
      suspendSMaskGroup: function CanvasGraphics_endSMaskGroup() {
        const groupCtx = this.ctx;
        this.groupLevel--;
        this.ctx = this.groupStack.pop();
        composeSMask(this.ctx, this.current.activeSMask, groupCtx, this.webGLContext);
        this.ctx.restore();
        this.ctx.save();
        copyCtxState(groupCtx, this.ctx);
        this.current.resumeSMaskCtx = groupCtx;

        const deltaTransform = _util.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);

        this.ctx.transform.apply(this.ctx, deltaTransform);
        groupCtx.save();
        groupCtx.setTransform(1, 0, 0, 1, 0, 0);
        groupCtx.clearRect(0, 0, groupCtx.canvas.width, groupCtx.canvas.height);
        groupCtx.restore();
      },
      resumeSMaskGroup: function CanvasGraphics_resumeSMaskGroup() {
        const groupCtx = this.current.resumeSMaskCtx;
        const currentCtx = this.ctx;
        this.ctx = groupCtx;
        this.groupStack.push(currentCtx);
        this.groupLevel++;
      },
      endSMaskGroup: function CanvasGraphics_endSMaskGroup() {
        const groupCtx = this.ctx;
        this.groupLevel--;
        this.ctx = this.groupStack.pop();
        composeSMask(this.ctx, this.current.activeSMask, groupCtx, this.webGLContext);
        this.ctx.restore();
        copyCtxState(groupCtx, this.ctx);

        const deltaTransform = _util.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);

        this.ctx.transform.apply(this.ctx, deltaTransform);
      },
      save: function CanvasGraphics_save() {
        this.ctx.save();
        const old = this.current;
        this.stateStack.push(old);
        this.current = old.clone();
        this.current.resumeSMaskCtx = null;
      },
      restore: function CanvasGraphics_restore() {
        if (this.current.resumeSMaskCtx) {
          this.resumeSMaskGroup();
        }

        if (this.current.activeSMask !== null && (this.stateStack.length === 0 || this.stateStack[this.stateStack.length - 1].activeSMask !== this.current.activeSMask)) {
          this.endSMaskGroup();
        }

        if (this.stateStack.length !== 0) {
          this.current = this.stateStack.pop();
          this.ctx.restore();
          this.pendingClip = null;
          this._cachedGetSinglePixelWidth = null;
        } else {
          this.current.activeSMask = null;
        }
      },
      transform: function CanvasGraphics_transform(a, b, c, d, e, f) {
        this.ctx.transform(a, b, c, d, e, f);
        this._cachedGetSinglePixelWidth = null;
      },
      constructPath: function CanvasGraphics_constructPath(ops, args) {
        const ctx = this.ctx;
        const current = this.current;
        let x = current.x,
            y = current.y;

        for (let i = 0, j = 0, ii = ops.length; i < ii; i++) {
          switch (ops[i] | 0) {
            case _util.OPS.rectangle:
              x = args[j++];
              y = args[j++];
              const width = args[j++];
              const height = args[j++];
              const xw = x + width;
              const yh = y + height;
              ctx.moveTo(x, y);

              if (width === 0 || height === 0) {
                ctx.lineTo(xw, yh);
              } else {
                ctx.lineTo(xw, y);
                ctx.lineTo(xw, yh);
                ctx.lineTo(x, yh);
              }

              ctx.closePath();
              break;

            case _util.OPS.moveTo:
              x = args[j++];
              y = args[j++];
              ctx.moveTo(x, y);
              break;

            case _util.OPS.lineTo:
              x = args[j++];
              y = args[j++];
              ctx.lineTo(x, y);
              break;

            case _util.OPS.curveTo:
              x = args[j + 4];
              y = args[j + 5];
              ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);
              j += 6;
              break;

            case _util.OPS.curveTo2:
              ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);
              x = args[j + 2];
              y = args[j + 3];
              j += 4;
              break;

            case _util.OPS.curveTo3:
              x = args[j + 2];
              y = args[j + 3];
              ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);
              j += 4;
              break;

            case _util.OPS.closePath:
              ctx.closePath();
              break;
          }
        }

        current.setCurrentPoint(x, y);
      },
      closePath: function CanvasGraphics_closePath() {
        this.ctx.closePath();
      },
      stroke: function CanvasGraphics_stroke(consumePath) {
        consumePath = typeof consumePath !== "undefined" ? consumePath : true;
        const ctx = this.ctx;
        const strokeColor = this.current.strokeColor;
        ctx.globalAlpha = this.current.strokeAlpha;

        if (this.contentVisible) {
          if (typeof strokeColor === "object" && strokeColor && strokeColor.getPattern) { // lwf
            ctx.save();
            const transform = ctx.mozCurrentTransform;

            const scale = _util.Util.singularValueDecompose2dScale(transform)[0];

            ctx.strokeStyle = strokeColor.getPattern(ctx, this);
            const lineWidth = this.getSinglePixelWidth();
            const scaledLineWidth = this.current.lineWidth * scale;

            if (lineWidth < 0 && -lineWidth >= scaledLineWidth) {
              ctx.resetTransform();
              ctx.lineWidth = Math.round(this._combinedScaleFactor);
            } else {
              ctx.lineWidth = Math.max(lineWidth, scaledLineWidth);
            }

            ctx.stroke();
            ctx.restore();
          } else {
            const lineWidth = this.getSinglePixelWidth();

            if (lineWidth < 0 && -lineWidth >= this.current.lineWidth) {
              ctx.save();
              ctx.resetTransform();
              ctx.lineWidth = Math.round(this._combinedScaleFactor);
              ctx.stroke();
              ctx.restore();
            } else {
              ctx.lineWidth = Math.max(lineWidth, this.current.lineWidth);
              ctx.stroke();
            }
          }
        }

        if (consumePath) {
          this.consumePath();
        }

        ctx.globalAlpha = this.current.fillAlpha;
      },
      closeStroke: function CanvasGraphics_closeStroke() {
        this.closePath();
        this.stroke();
      },
      fill: function CanvasGraphics_fill(consumePath) {
        consumePath = typeof consumePath !== "undefined" ? consumePath : true;
        const ctx = this.ctx;
        const fillColor = this.current.fillColor;
        const isPatternFill = this.current.patternFill;
        let needRestore = false;

        if (isPatternFill) {
          ctx.save();

          if (this.baseTransform) {
            ctx.setTransform.apply(ctx, this.baseTransform);
          }

          ctx.fillStyle = fillColor.getPattern(ctx, this);
          needRestore = true;
        }

        if (this.contentVisible) {
          if (this.pendingEOFill) {
            ctx.fill("evenodd");
            this.pendingEOFill = false;
          } else {
            ctx.fill();
          }
        }

        if (needRestore) {
          ctx.restore();
        }

        if (consumePath) {
          this.consumePath();
        }
      },
      eoFill: function CanvasGraphics_eoFill() {
        this.pendingEOFill = true;
        this.fill();
      },
      fillStroke: function CanvasGraphics_fillStroke() {
        this.fill(false);
        this.stroke(false);
        this.consumePath();
      },
      eoFillStroke: function CanvasGraphics_eoFillStroke() {
        this.pendingEOFill = true;
        this.fillStroke();
      },
      closeFillStroke: function CanvasGraphics_closeFillStroke() {
        this.closePath();
        this.fillStroke();
      },
      closeEOFillStroke: function CanvasGraphics_closeEOFillStroke() {
        this.pendingEOFill = true;
        this.closePath();
        this.fillStroke();
      },
      endPath: function CanvasGraphics_endPath() {
        this.consumePath();
      },
      clip: function CanvasGraphics_clip() {
        this.pendingClip = NORMAL_CLIP;
      },
      eoClip: function CanvasGraphics_eoClip() {
        this.pendingClip = EO_CLIP;
      },
      beginText: function CanvasGraphics_beginText() {
        this.current.textMatrix = _util.IDENTITY_MATRIX;
        this.current.textMatrixScale = 1;
        this.current.x = this.current.lineX = 0;
        this.current.y = this.current.lineY = 0;
      },
      endText: function CanvasGraphics_endText() {
        const paths = this.pendingTextPaths;
        const ctx = this.ctx;

        if (paths === undefined) {
          ctx.beginPath();
          return;
        }

        ctx.save();
        ctx.beginPath();

        for (let i = 0; i < paths.length; i++) {
          const path = paths[i];
          ctx.setTransform.apply(ctx, path.transform);
          ctx.translate(path.x, path.y);
          path.addToPath(ctx, path.fontSize);
        }

        ctx.restore();
        ctx.clip();
        ctx.beginPath();
        delete this.pendingTextPaths;
      },
      setCharSpacing: function CanvasGraphics_setCharSpacing(spacing) {
        this.current.charSpacing = spacing;
      },
      setWordSpacing: function CanvasGraphics_setWordSpacing(spacing) {
        this.current.wordSpacing = spacing;
      },
      setHScale: function CanvasGraphics_setHScale(scale) {
        this.current.textHScale = scale / 100;
      },
      setLeading: function CanvasGraphics_setLeading(leading) {
        this.current.leading = -leading;
      },
      setFont: function CanvasGraphics_setFont(fontRefName, size) {
        const fontObj = this.commonObjs.get(fontRefName);
        const current = this.current;

        if (!fontObj) {
          throw new Error(`Can't find font for ${fontRefName}`);
        }

        current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;

        if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
          (0, _util.warn)("Invalid font matrix for font " + fontRefName);
        }

        if (size < 0) {
          size = -size;
          current.fontDirection = -1;
        } else {
          current.fontDirection = 1;
        }

        this.current.font = fontObj;
        this.current.fontSize = size;

        if (fontObj.isType3Font) {
          return;
        }

        const name = fontObj.loadedName || "sans-serif";
        let bold = "normal";

        if (fontObj.black) {
          bold = "900";
        } else if (fontObj.bold) {
          bold = "bold";
        }

        const italic = fontObj.italic ? "italic" : "normal";
        const typeface = `"${name}", ${fontObj.fallbackName}`;
        let browserFontSize = size;

        if (size < MIN_FONT_SIZE) {
          browserFontSize = MIN_FONT_SIZE;
        } else if (size > MAX_FONT_SIZE) {
          browserFontSize = MAX_FONT_SIZE;
        }

        this.current.fontSizeScale = size / browserFontSize;
        this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;
      },
      setTextRenderingMode: function CanvasGraphics_setTextRenderingMode(mode) {
        this.current.textRenderingMode = mode;
      },
      setTextRise: function CanvasGraphics_setTextRise(rise) {
        this.current.textRise = rise;
      },
      moveText: function CanvasGraphics_moveText(x, y) {
        this.current.x = this.current.lineX += x;
        this.current.y = this.current.lineY += y;
      },
      setLeadingMoveText: function CanvasGraphics_setLeadingMoveText(x, y) {
        this.setLeading(-y);
        this.moveText(x, y);
      },
      setTextMatrix: function CanvasGraphics_setTextMatrix(a, b, c, d, e, f) {
        this.current.textMatrix = [a, b, c, d, e, f];
        this.current.textMatrixScale = Math.sqrt(a * a + b * b);
        this.current.x = this.current.lineX = 0;
        this.current.y = this.current.lineY = 0;
      },
      nextLine: function CanvasGraphics_nextLine() {
        this.moveText(0, this.current.leading);
      },

      paintChar(character, x, y, patternTransform, resetLineWidthToOne) {
        const ctx = this.ctx;
        const current = this.current;
        const font = current.font;
        const textRenderingMode = current.textRenderingMode;
        const fontSize = current.fontSize / current.fontSizeScale;
        const fillStrokeMode = textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;
        const isAddToPathSet = !!(textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);
        const patternFill = current.patternFill && !font.missingFile;
        let addToPath;

        if (font.disableFontFace || isAddToPathSet || patternFill) {
          addToPath = font.getPathGenerator(this.commonObjs, character);
        }

        if (font.disableFontFace || patternFill) {
          ctx.save();
          ctx.translate(x, y);
          ctx.beginPath();
          addToPath(ctx, fontSize);

          if (patternTransform) {
            ctx.setTransform.apply(ctx, patternTransform);
          }

          if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
            ctx.fill();
          }

          if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
            if (resetLineWidthToOne) {
              ctx.resetTransform();
              ctx.lineWidth = Math.round(this._combinedScaleFactor);
            }

            ctx.stroke();
          }

          ctx.restore();
        } else {
          if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
            ctx.fillText(character, x, y);
          }

          if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
            if (resetLineWidthToOne) {
              ctx.save();
              ctx.moveTo(x, y);
              ctx.resetTransform();
              ctx.lineWidth = Math.round(this._combinedScaleFactor);
              ctx.strokeText(character, 0, 0);
              ctx.restore();
            } else {
              ctx.strokeText(character, x, y);
            }
          }
        }

        if (isAddToPathSet) {
          const paths = this.pendingTextPaths || (this.pendingTextPaths = []);
          paths.push({
            transform: ctx.mozCurrentTransform,
            x,
            y,
            fontSize,
            addToPath
          });
        }
      },

      get isFontSubpixelAAEnabled() {
        const {
          context: ctx
        } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
        ctx.scale(1.5, 1);
        ctx.fillText("I", 0, 10);
        const data = ctx.getImageData(0, 0, 10, 10).data;
        let enabled = false;

        for (let i = 3; i < data.length; i += 4) {
          if (data[i] > 0 && data[i] < 255) {
            enabled = true;
            break;
          }
        }

        return (0, _util.shadow)(this, "isFontSubpixelAAEnabled", enabled);
      },

      showText: function CanvasGraphics_showText(glyphs) {
        const current = this.current;
        const font = current.font;

        if (font.isType3Font) {
          return this.showType3Text(glyphs);
        }

        const fontSize = current.fontSize;

        if (fontSize === 0) {
          return undefined;
        }

        const ctx = this.ctx;
        const fontSizeScale = current.fontSizeScale;
        const charSpacing = current.charSpacing;
        const wordSpacing = current.wordSpacing;
        const fontDirection = current.fontDirection;
        const textHScale = current.textHScale * fontDirection;
        const glyphsLength = glyphs.length;
        const vertical = font.vertical;
        const spacingDir = vertical ? 1 : -1;
        const defaultVMetrics = font.defaultVMetrics;
        const widthAdvanceScale = fontSize * current.fontMatrix[0];
        const simpleFillText = current.textRenderingMode === _util.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;
        ctx.save();
        let patternTransform;

        if (current.patternFill) {
          ctx.save();
          const pattern = current.fillColor.getPattern(ctx, this);
          patternTransform = ctx.mozCurrentTransform;
          ctx.restore();
          ctx.fillStyle = pattern;
        }

        ctx.transform.apply(ctx, current.textMatrix);
        ctx.translate(current.x, current.y + current.textRise);

        if (fontDirection > 0) {
          ctx.scale(textHScale, -1);
        } else {
          ctx.scale(textHScale, 1);
        }

        let lineWidth = current.lineWidth;
        let resetLineWidthToOne = false;
        const scale = current.textMatrixScale;

        if (scale === 0 || lineWidth === 0) {
          const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;

          if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
            this._cachedGetSinglePixelWidth = null;
            lineWidth = this.getSinglePixelWidth();
            resetLineWidthToOne = lineWidth < 0;
          }
        } else {
          lineWidth /= scale;
        }

        if (fontSizeScale !== 1.0) {
          ctx.scale(fontSizeScale, fontSizeScale);
          lineWidth /= fontSizeScale;
        }

        ctx.lineWidth = lineWidth;
        let x = 0,
            i;

        for (i = 0; i < glyphsLength; ++i) {
          const glyph = glyphs[i];

          if ((0, _util.isNum)(glyph)) {
            x += spacingDir * glyph * fontSize / 1000;
            continue;
          }

          let restoreNeeded = false;
          const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
          const character = glyph.fontChar;
          const accent = glyph.accent;
          let scaledX, scaledY;
          let width = glyph.width;

          if (vertical) {
            const vmetric = glyph.vmetric || defaultVMetrics;
            const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;
            const vy = vmetric[2] * widthAdvanceScale;
            width = vmetric ? -vmetric[0] : width;
            scaledX = vx / fontSizeScale;
            scaledY = (x + vy) / fontSizeScale;
          } else {
            scaledX = x / fontSizeScale;
            scaledY = 0;
          }

          if (font.remeasure && width > 0) {
            const measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;

            if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
              const characterScaleX = width / measuredWidth;
              restoreNeeded = true;
              ctx.save();
              ctx.scale(characterScaleX, 1);
              scaledX /= characterScaleX;
            } else if (width !== measuredWidth) {
              scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;
            }
          }

          if (this.contentVisible && (glyph.isInFont || font.missingFile)) {
            if (simpleFillText && !accent) {
              ctx.fillText(character, scaledX, scaledY);
            } else {
              this.paintChar(character, scaledX, scaledY, patternTransform, resetLineWidthToOne);

              if (accent) {
                const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;
                const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;
                this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform, resetLineWidthToOne);
              }
            }
          }

          let charWidth;

          if (vertical) {
            charWidth = width * widthAdvanceScale - spacing * fontDirection;
          } else {
            charWidth = width * widthAdvanceScale + spacing * fontDirection;
          }

          x += charWidth;

          if (restoreNeeded) {
            ctx.restore();
          }
        }

        if (vertical) {
          current.y -= x;
        } else {
          current.x += x * textHScale;
        }

        ctx.restore();
      },
      showType3Text: function CanvasGraphics_showType3Text(glyphs) {
        const ctx = this.ctx;
        const current = this.current;
        const font = current.font;
        const fontSize = current.fontSize;
        const fontDirection = current.fontDirection;
        const spacingDir = font.vertical ? 1 : -1;
        const charSpacing = current.charSpacing;
        const wordSpacing = current.wordSpacing;
        const textHScale = current.textHScale * fontDirection;
        const fontMatrix = current.fontMatrix || _util.FONT_IDENTITY_MATRIX;
        const glyphsLength = glyphs.length;
        const isTextInvisible = current.textRenderingMode === _util.TextRenderingMode.INVISIBLE;
        let i, glyph, width, spacingLength;

        if (isTextInvisible || fontSize === 0) {
          return;
        }

        this._cachedGetSinglePixelWidth = null;
        ctx.save();
        ctx.transform.apply(ctx, current.textMatrix);
        ctx.translate(current.x, current.y);
        ctx.scale(textHScale, fontDirection);

        for (i = 0; i < glyphsLength; ++i) {
          glyph = glyphs[i];

          if ((0, _util.isNum)(glyph)) {
            spacingLength = spacingDir * glyph * fontSize / 1000;
            this.ctx.translate(spacingLength, 0);
            current.x += spacingLength * textHScale;
            continue;
          }

          const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
          const operatorList = font.charProcOperatorList[glyph.operatorListId];

          if (!operatorList) {
            (0, _util.warn)(`Type3 character "${glyph.operatorListId}" is not available.`);
            continue;
          }

          if (this.contentVisible) {
            this.processingType3 = glyph;
            this.save();
            ctx.scale(fontSize, fontSize);
            ctx.transform.apply(ctx, fontMatrix);
            this.executeOperatorList(operatorList);
            this.restore();
          }

          const transformed = _util.Util.applyTransform([glyph.width, 0], fontMatrix);

          width = transformed[0] * fontSize + spacing;
          ctx.translate(width, 0);
          current.x += width * textHScale;
        }

        ctx.restore();
        this.processingType3 = null;
      },
      setCharWidth: function CanvasGraphics_setCharWidth(xWidth, yWidth) {},
      setCharWidthAndBounds: function CanvasGraphics_setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
        this.ctx.rect(llx, lly, urx - llx, ury - lly);
        this.clip();
        this.endPath();
      },
      getColorN_Pattern: function CanvasGraphics_getColorN_Pattern(IR) {
        let pattern;

        if (IR[0] === "TilingPattern") {
          const color = IR[1];
          const baseTransform = this.baseTransform || this.ctx.mozCurrentTransform.slice();
          const canvasGraphicsFactory = {
            createCanvasGraphics: ctx => {
              return new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory, this.webGLContext);
            }
          };
          pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);
        } else {
          pattern = (0, _pattern_helper.getShadingPatternFromIR)(IR);
        }

        return pattern;
      },
      setStrokeColorN: function CanvasGraphics_setStrokeColorN() {
        this.current.strokeColor = this.getColorN_Pattern(arguments);
      },
      setFillColorN: function CanvasGraphics_setFillColorN() {
        this.current.fillColor = this.getColorN_Pattern(arguments);
        this.current.patternFill = true;
      },
      setStrokeRGBColor: function CanvasGraphics_setStrokeRGBColor(r, g, b) {
        const color = _util.Util.makeHexColor(r, g, b);

        this.ctx.strokeStyle = color;
        this.current.strokeColor = color;
      },
      setFillRGBColor: function CanvasGraphics_setFillRGBColor(r, g, b) {
        const color = _util.Util.makeHexColor(r, g, b);

        this.ctx.fillStyle = color;
        this.current.fillColor = color;
        this.current.patternFill = false;
      },
      shadingFill: function CanvasGraphics_shadingFill(patternIR) {
        if (!this.contentVisible) {
          return;
        }

        const ctx = this.ctx;
        this.save();
        const pattern = (0, _pattern_helper.getShadingPatternFromIR)(patternIR);
        ctx.fillStyle = pattern.getPattern(ctx, this, true);
        const inv = ctx.mozCurrentTransformInverse;

        if (inv) {
          const canvas = ctx.canvas;
          const width = canvas.width;
          const height = canvas.height;

          const bl = _util.Util.applyTransform([0, 0], inv);

          const br = _util.Util.applyTransform([0, height], inv);

          const ul = _util.Util.applyTransform([width, 0], inv);

          const ur = _util.Util.applyTransform([width, height], inv);

          const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
          const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
          const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
          const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
          this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
        } else {
          this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
        }

        this.restore();
      },
      beginInlineImage: function CanvasGraphics_beginInlineImage() {
        (0, _util.unreachable)("Should not call beginInlineImage");
      },
      beginImageData: function CanvasGraphics_beginImageData() {
        (0, _util.unreachable)("Should not call beginImageData");
      },
      paintFormXObjectBegin: function CanvasGraphics_paintFormXObjectBegin(matrix, bbox) {
        if (!this.contentVisible) {
          return;
        }

        this.save();
        this.baseTransformStack.push(this.baseTransform);

        if (Array.isArray(matrix) && matrix.length === 6) {
          this.transform.apply(this, matrix);
        }

        this.baseTransform = this.ctx.mozCurrentTransform;

        if (bbox) {
          const width = bbox[2] - bbox[0];
          const height = bbox[3] - bbox[1];
          this.ctx.rect(bbox[0], bbox[1], width, height);
          this.clip();
          this.endPath();
        }
      },
      paintFormXObjectEnd: function CanvasGraphics_paintFormXObjectEnd() {
        if (!this.contentVisible) {
          return;
        }

        this.restore();
        this.baseTransform = this.baseTransformStack.pop();
      },
      beginGroup: function CanvasGraphics_beginGroup(group) {
        if (!this.contentVisible) {
          return;
        }

        this.save();
        const currentCtx = this.ctx;

        if (!group.isolated) {
          (0, _util.info)("TODO: Support non-isolated groups.");
        }

        if (group.knockout) {
          (0, _util.warn)("Knockout groups not supported.");
        }

        const currentTransform = currentCtx.mozCurrentTransform;

        if (group.matrix) {
          currentCtx.transform.apply(currentCtx, group.matrix);
        }

        if (!group.bbox) {
          throw new Error("Bounding box is required.");
        }

        let bounds = _util.Util.getAxialAlignedBoundingBox(group.bbox, currentCtx.mozCurrentTransform);

        const canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
        bounds = _util.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
        const offsetX = Math.floor(bounds[0]);
        const offsetY = Math.floor(bounds[1]);
        let drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
        let drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
        let scaleX = 1,
            scaleY = 1;

        if (drawnWidth > MAX_GROUP_SIZE) {
          scaleX = drawnWidth / MAX_GROUP_SIZE;
          drawnWidth = MAX_GROUP_SIZE;
        }

        if (drawnHeight > MAX_GROUP_SIZE) {
          scaleY = drawnHeight / MAX_GROUP_SIZE;
          drawnHeight = MAX_GROUP_SIZE;
        }

        let cacheId = "groupAt" + this.groupLevel;

        if (group.smask) {
          cacheId += "_smask_" + this.smaskCounter++ % 2;
        }

        const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
        const groupCtx = scratchCanvas.context;
        groupCtx.scale(1 / scaleX, 1 / scaleY);
        groupCtx.translate(-offsetX, -offsetY);
        groupCtx.transform.apply(groupCtx, currentTransform);

        if (group.smask) {
          this.smaskStack.push({
            canvas: scratchCanvas.canvas,
            context: groupCtx,
            offsetX,
            offsetY,
            scaleX,
            scaleY,
            subtype: group.smask.subtype,
            backdrop: group.smask.backdrop,
            transferMap: group.smask.transferMap || null,
            startTransformInverse: null
          });
        } else {
          currentCtx.setTransform(1, 0, 0, 1, 0, 0);
          currentCtx.translate(offsetX, offsetY);
          currentCtx.scale(scaleX, scaleY);
        }

        copyCtxState(currentCtx, groupCtx);
        this.ctx = groupCtx;
        this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
        this.groupStack.push(currentCtx);
        this.groupLevel++;
        this.current.activeSMask = null;
      },
      endGroup: function CanvasGraphics_endGroup(group) {
        if (!this.contentVisible) {
          return;
        }

        this.groupLevel--;
        const groupCtx = this.ctx;
        this.ctx = this.groupStack.pop();

        if (this.ctx.imageSmoothingEnabled !== undefined) {
          this.ctx.imageSmoothingEnabled = false;
        } else {
          this.ctx.mozImageSmoothingEnabled = false;
        }

        if (group.smask) {
          this.tempSMask = this.smaskStack.pop();
        } else {
          this.ctx.drawImage(groupCtx.canvas, 0, 0);
        }

        this.restore();
      },
      beginAnnotations: function CanvasGraphics_beginAnnotations() {
        this.save();

        if (this.baseTransform) {
          this.ctx.setTransform.apply(this.ctx, this.baseTransform);
        }
      },
      endAnnotations: function CanvasGraphics_endAnnotations() {
        this.restore();
      },
      beginAnnotation: function CanvasGraphics_beginAnnotation(rect, transform, matrix) {
        this.save();
        resetCtxToDefault(this.ctx);
        this.current = new CanvasExtraState();

        if (Array.isArray(rect) && rect.length === 4) {
          const width = rect[2] - rect[0];
          const height = rect[3] - rect[1];
          this.ctx.rect(rect[0], rect[1], width, height);
          this.clip();
          this.endPath();
        }

        this.transform.apply(this, transform);
        this.transform.apply(this, matrix);
      },
      endAnnotation: function CanvasGraphics_endAnnotation() {
        this.restore();
      },
      paintImageMaskXObject: function CanvasGraphics_paintImageMaskXObject(img) {
        if (!this.contentVisible) {
          return;
        }

        const ctx = this.ctx;
        const width = img.width,
              height = img.height;
        const fillColor = this.current.fillColor;
        const isPatternFill = this.current.patternFill;
        const glyph = this.processingType3;

        if (COMPILE_TYPE3_GLYPHS && glyph && glyph.compiled === undefined) {
          if (width <= MAX_SIZE_TO_COMPILE && height <= MAX_SIZE_TO_COMPILE) {
            glyph.compiled = compileType3Glyph({
              data: img.data,
              width,
              height
            });
          } else {
            glyph.compiled = null;
          }
        }

        if (glyph && glyph.compiled) { // lwf
          glyph.compiled(ctx);
          return;
        }

        const maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
        const maskCtx = maskCanvas.context;
        maskCtx.save();
        putBinaryImageMask(maskCtx, img);
        maskCtx.globalCompositeOperation = "source-in";
        maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
        maskCtx.fillRect(0, 0, width, height);
        maskCtx.restore();
        this.paintInlineImageXObject(maskCanvas.canvas);
      },

      paintImageMaskXObjectRepeat(imgData, scaleX, skewX = 0, skewY = 0, scaleY, positions) {
        if (!this.contentVisible) {
          return;
        }

        const width = imgData.width;
        const height = imgData.height;
        const fillColor = this.current.fillColor;
        const isPatternFill = this.current.patternFill;
        const maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
        const maskCtx = maskCanvas.context;
        maskCtx.save();
        putBinaryImageMask(maskCtx, imgData);
        maskCtx.globalCompositeOperation = "source-in";
        maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
        maskCtx.fillRect(0, 0, width, height);
        maskCtx.restore();
        const ctx = this.ctx;

        for (let i = 0, ii = positions.length; i < ii; i += 2) {
          ctx.save();
          ctx.transform(scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]);
          ctx.scale(1, -1);
          ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
          ctx.restore();
        }
      },

      paintImageMaskXObjectGroup: function CanvasGraphics_paintImageMaskXObjectGroup(images) {
        if (!this.contentVisible) {
          return;
        }

        const ctx = this.ctx;
        const fillColor = this.current.fillColor;
        const isPatternFill = this.current.patternFill;

        for (let i = 0, ii = images.length; i < ii; i++) {
          const image = images[i];
          const width = image.width,
                height = image.height;
          const maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
          const maskCtx = maskCanvas.context;
          maskCtx.save();
          putBinaryImageMask(maskCtx, image);
          maskCtx.globalCompositeOperation = "source-in";
          maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
          maskCtx.fillRect(0, 0, width, height);
          maskCtx.restore();
          ctx.save();
          ctx.transform.apply(ctx, image.transform);
          ctx.scale(1, -1);
          ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
          ctx.restore();
        }
      },
      paintImageXObject: function CanvasGraphics_paintImageXObject(objId) {
        if (!this.contentVisible) {
          return;
        }

        const imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId);

        if (!imgData) {
          (0, _util.warn)("Dependent image isn't ready yet");
          return;
        }

        this.paintInlineImageXObject(imgData);
      },
      paintImageXObjectRepeat: function CanvasGraphics_paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
        if (!this.contentVisible) {
          return;
        }

        const imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId);

        if (!imgData) {
          (0, _util.warn)("Dependent image isn't ready yet");
          return;
        }

        const width = imgData.width;
        const height = imgData.height;
        const map = [];

        for (let i = 0, ii = positions.length; i < ii; i += 2) {
          map.push({
            transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
            x: 0,
            y: 0,
            w: width,
            h: height
          });
        }

        this.paintInlineImageXObjectGroup(imgData, map);
      },
      paintInlineImageXObject: function CanvasGraphics_paintInlineImageXObject(imgData) {
        if (!this.contentVisible) {
          return;
        }

        const width = imgData.width;
        const height = imgData.height;
        const ctx = this.ctx;
        this.save();
        ctx.scale(1 / width, -1 / height);
        const currentTransform = ctx.mozCurrentTransformInverse;
        const a = currentTransform[0],
              b = currentTransform[1];
        let widthScale = Math.max(Math.sqrt(a * a + b * b), 1);
        const c = currentTransform[2],
              d = currentTransform[3];
        let heightScale = Math.max(Math.sqrt(c * c + d * d), 1);
        let imgToPaint, tmpCanvas, tmpCtx;

        if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) {
          imgToPaint = imgData;
        } else {
          tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
          tmpCtx = tmpCanvas.context;
          putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);
          imgToPaint = tmpCanvas.canvas;
        }

        let paintWidth = width,
            paintHeight = height;
        let tmpCanvasId = "prescale1";

        while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {
          let newWidth = paintWidth,
              newHeight = paintHeight;

          if (widthScale > 2 && paintWidth > 1) {
            newWidth = Math.ceil(paintWidth / 2);
            widthScale /= paintWidth / newWidth;
          }

          if (heightScale > 2 && paintHeight > 1) {
            newHeight = Math.ceil(paintHeight / 2);
            heightScale /= paintHeight / newHeight;
          }

          tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);
          tmpCtx = tmpCanvas.context;
          tmpCtx.clearRect(0, 0, newWidth, newHeight);
          tmpCtx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
          imgToPaint = tmpCanvas.canvas;
          paintWidth = newWidth;
          paintHeight = newHeight;
          tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
        }

        ctx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, -height, width, height);

        if (this.imageLayer) {
          const position = this.getCanvasPosition(0, -height);
          this.imageLayer.appendImage({
            imgData,
            left: position[0],
            top: position[1],
            width: width / currentTransform[0],
            height: height / currentTransform[3]
          });
        }

        this.restore();
      },
      paintInlineImageXObjectGroup: function CanvasGraphics_paintInlineImageXObjectGroup(imgData, map) {
        if (!this.contentVisible) {
          return;
        }

        const ctx = this.ctx;
        const w = imgData.width;
        const h = imgData.height;
        const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h);
        const tmpCtx = tmpCanvas.context;
        putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);

        for (let i = 0, ii = map.length; i < ii; i++) {
          const entry = map[i];
          ctx.save();
          ctx.transform.apply(ctx, entry.transform);
          ctx.scale(1, -1);
          ctx.drawImage(tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);

          if (this.imageLayer) {
            const position = this.getCanvasPosition(entry.x, entry.y);
            this.imageLayer.appendImage({
              imgData,
              left: position[0],
              top: position[1],
              width: w,
              height: h
            });
          }

          ctx.restore();
        }
      },
      paintSolidColorImageMask: function CanvasGraphics_paintSolidColorImageMask() {
        if (!this.contentVisible) {
          return;
        }

        this.ctx.fillRect(0, 0, 1, 1);
      },
      markPoint: function CanvasGraphics_markPoint(tag) {},
      markPointProps: function CanvasGraphics_markPointProps(tag, properties) {},
      beginMarkedContent: function CanvasGraphics_beginMarkedContent(tag) {
        this.markedContentStack.push({
          visible: true
        });
      },
      beginMarkedContentProps: function CanvasGraphics_beginMarkedContentProps(tag, properties) {
        if (tag === "OC") {
          this.markedContentStack.push({
            visible: this.optionalContentConfig.isVisible(properties)
          });
        } else {
          this.markedContentStack.push({
            visible: true
          });
        }

        this.contentVisible = this.isContentVisible();
      },
      endMarkedContent: function CanvasGraphics_endMarkedContent() {
        this.markedContentStack.pop();
        this.contentVisible = this.isContentVisible();
      },
      beginCompat: function CanvasGraphics_beginCompat() {},
      endCompat: function CanvasGraphics_endCompat() {},
      consumePath: function CanvasGraphics_consumePath() {
        const ctx = this.ctx;

        if (this.pendingClip) {
          if (this.pendingClip === EO_CLIP) {
            ctx.clip("evenodd");
          } else {
            ctx.clip();
          }

          this.pendingClip = null;
        }

        ctx.beginPath();
      },

      getSinglePixelWidth() {
        if (this._cachedGetSinglePixelWidth === null) {
          const m = this.ctx.mozCurrentTransform;
          const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
          const sqNorm1 = m[0] ** 2 + m[2] ** 2;
          const sqNorm2 = m[1] ** 2 + m[3] ** 2;
          const pixelHeight = Math.sqrt(Math.max(sqNorm1, sqNorm2)) / absDet;

          if (sqNorm1 !== sqNorm2 && this._combinedScaleFactor * pixelHeight > 1) {
            this._cachedGetSinglePixelWidth = -(this._combinedScaleFactor * pixelHeight);
          } else if (absDet > Number.EPSILON) {
            this._cachedGetSinglePixelWidth = pixelHeight * 1.0000001;
          } else {
            this._cachedGetSinglePixelWidth = 1;
          }
        }

        return this._cachedGetSinglePixelWidth;
      },

      getCanvasPosition: function CanvasGraphics_getCanvasPosition(x, y) {
        const transform = this.ctx.mozCurrentTransform;
        return [transform[0] * x + transform[2] * y + transform[4], transform[1] * x + transform[3] * y + transform[5]];
      },
      isContentVisible: function CanvasGraphics_isContentVisible() {
        for (let i = this.markedContentStack.length - 1; i >= 0; i--) {
          if (!this.markedContentStack[i].visible) {
            return false;
          }
        }

        return true;
      }
    };

    for (const op in _util.OPS) {
      CanvasGraphics.prototype[_util.OPS[op]] = CanvasGraphics.prototype[op];
    }

    return CanvasGraphics;
  }();

  exports.CanvasGraphics = CanvasGraphics;

  /***/ }),
  /* 11 */
  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



  Object.defineProperty(exports, "__esModule", ({
    value: true
  }));
  exports.getShadingPatternFromIR = getShadingPatternFromIR;
  exports.TilingPattern = void 0;

  var _util = __w_pdfjs_require__(2);

  const ShadingIRs = {};

  function applyBoundingBox(ctx, bbox) {
    if (!bbox || typeof Path2D === "undefined") {
      return;
    }

    const width = bbox[2] - bbox[0];
    const height = bbox[3] - bbox[1];
    const region = new Path2D();
    region.rect(bbox[0], bbox[1], width, height);
    ctx.clip(region);
  }

  ShadingIRs.RadialAxial = {
    fromIR: function RadialAxial_fromIR(raw) {
      const type = raw[1];
      const bbox = raw[2];
      const colorStops = raw[3];
      const p0 = raw[4];
      const p1 = raw[5];
      const r0 = raw[6];
      const r1 = raw[7];
      return {
        getPattern: function RadialAxial_getPattern(ctx) {
          applyBoundingBox(ctx, bbox);
          let grad;

          if (type === "axial") {
            grad = ctx.createLinearGradient(p0[0], p0[1], p1[0], p1[1]);
          } else if (type === "radial") {
            grad = ctx.createRadialGradient(p0[0], p0[1], r0, p1[0], p1[1], r1);
          }

          for (let i = 0, ii = colorStops.length; i < ii; ++i) {
            const c = colorStops[i];
            grad.addColorStop(c[0], c[1]);
          }

          return grad;
        }
      };
    }
  };

  const createMeshCanvas = function createMeshCanvasClosure() {
    function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {
      const coords = context.coords,
            colors = context.colors;
      const bytes = data.data,
            rowSize = data.width * 4;
      let tmp;

      if (coords[p1 + 1] > coords[p2 + 1]) {
        tmp = p1;
        p1 = p2;
        p2 = tmp;
        tmp = c1;
        c1 = c2;
        c2 = tmp;
      }

      if (coords[p2 + 1] > coords[p3 + 1]) {
        tmp = p2;
        p2 = p3;
        p3 = tmp;
        tmp = c2;
        c2 = c3;
        c3 = tmp;
      }

      if (coords[p1 + 1] > coords[p2 + 1]) {
        tmp = p1;
        p1 = p2;
        p2 = tmp;
        tmp = c1;
        c1 = c2;
        c2 = tmp;
      }

      const x1 = (coords[p1] + context.offsetX) * context.scaleX;
      const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
      const x2 = (coords[p2] + context.offsetX) * context.scaleX;
      const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
      const x3 = (coords[p3] + context.offsetX) * context.scaleX;
      const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;

      if (y1 >= y3) {
        return;
      }

      const c1r = colors[c1],
            c1g = colors[c1 + 1],
            c1b = colors[c1 + 2];
      const c2r = colors[c2],
            c2g = colors[c2 + 1],
            c2b = colors[c2 + 2];
      const c3r = colors[c3],
            c3g = colors[c3 + 1],
            c3b = colors[c3 + 2];
      const minY = Math.round(y1),
            maxY = Math.round(y3);
      let xa, car, cag, cab;
      let xb, cbr, cbg, cbb;

      for (let y = minY; y <= maxY; y++) {
        if (y < y2) {
          let k;

          if (y < y1) {
            k = 0;
          } else if (y1 === y2) {
            k = 1;
          } else {
            k = (y1 - y) / (y1 - y2);
          }

          xa = x1 - (x1 - x2) * k;
          car = c1r - (c1r - c2r) * k;
          cag = c1g - (c1g - c2g) * k;
          cab = c1b - (c1b - c2b) * k;
        } else {
          let k;

          if (y > y3) {
            k = 1;
          } else if (y2 === y3) {
            k = 0;
          } else {
            k = (y2 - y) / (y2 - y3);
          }

          xa = x2 - (x2 - x3) * k;
          car = c2r - (c2r - c3r) * k;
          cag = c2g - (c2g - c3g) * k;
          cab = c2b - (c2b - c3b) * k;
        }

        let k;

        if (y < y1) {
          k = 0;
        } else if (y > y3) {
          k = 1;
        } else {
          k = (y1 - y) / (y1 - y3);
        }

        xb = x1 - (x1 - x3) * k;
        cbr = c1r - (c1r - c3r) * k;
        cbg = c1g - (c1g - c3g) * k;
        cbb = c1b - (c1b - c3b) * k;
        const x1_ = Math.round(Math.min(xa, xb));
        const x2_ = Math.round(Math.max(xa, xb));
        let j = rowSize * y + x1_ * 4;

        for (let x = x1_; x <= x2_; x++) {
          k = (xa - x) / (xa - xb);

          if (k < 0) {
            k = 0;
          } else if (k > 1) {
            k = 1;
          }

          bytes[j++] = car - (car - cbr) * k | 0;
          bytes[j++] = cag - (cag - cbg) * k | 0;
          bytes[j++] = cab - (cab - cbb) * k | 0;
          bytes[j++] = 255;
        }
      }
    }

    function drawFigure(data, figure, context) {
      const ps = figure.coords;
      const cs = figure.colors;
      let i, ii;

      switch (figure.type) {
        case "lattice":
          const verticesPerRow = figure.verticesPerRow;
          const rows = Math.floor(ps.length / verticesPerRow) - 1;
          const cols = verticesPerRow - 1;

          for (i = 0; i < rows; i++) {
            let q = i * verticesPerRow;

            for (let j = 0; j < cols; j++, q++) {
              drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);
              drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);
            }
          }

          break;

        case "triangles":
          for (i = 0, ii = ps.length; i < ii; i += 3) {
            drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);
          }

          break;

        default:
          throw new Error("illegal figure");
      }
    }

    function createMeshCanvas(bounds, combinesScale, coords, colors, figures, backgroundColor, cachedCanvases, webGLContext) {
      const EXPECTED_SCALE = 1.1;
      const MAX_PATTERN_SIZE = 3000;
      const BORDER_SIZE = 2;
      const offsetX = Math.floor(bounds[0]);
      const offsetY = Math.floor(bounds[1]);
      const boundsWidth = Math.ceil(bounds[2]) - offsetX;
      const boundsHeight = Math.ceil(bounds[3]) - offsetY;
      const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinesScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
      const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinesScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
      const scaleX = boundsWidth / width;
      const scaleY = boundsHeight / height;
      const context = {
        coords,
        colors,
        offsetX: -offsetX,
        offsetY: -offsetY,
        scaleX: 1 / scaleX,
        scaleY: 1 / scaleY
      };
      const paddedWidth = width + BORDER_SIZE * 2;
      const paddedHeight = height + BORDER_SIZE * 2;
      let canvas, tmpCanvas, i, ii;

      if (webGLContext.isEnabled) {
        canvas = webGLContext.drawFigures({
          width,
          height,
          backgroundColor,
          figures,
          context
        });
        tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);
        tmpCanvas.context.drawImage(canvas, BORDER_SIZE, BORDER_SIZE);
        canvas = tmpCanvas.canvas;
      } else {
        tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);
        const tmpCtx = tmpCanvas.context;
        const data = tmpCtx.createImageData(width, height);

        if (backgroundColor) {
          const bytes = data.data;

          for (i = 0, ii = bytes.length; i < ii; i += 4) {
            bytes[i] = backgroundColor[0];
            bytes[i + 1] = backgroundColor[1];
            bytes[i + 2] = backgroundColor[2];
            bytes[i + 3] = 255;
          }
        }

        for (i = 0; i < figures.length; i++) {
          drawFigure(data, figures[i], context);
        }

        tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
        canvas = tmpCanvas.canvas;
      }

      return {
        canvas,
        offsetX: offsetX - BORDER_SIZE * scaleX,
        offsetY: offsetY - BORDER_SIZE * scaleY,
        scaleX,
        scaleY
      };
    }

    return createMeshCanvas;
  }();

  ShadingIRs.Mesh = {
    fromIR: function Mesh_fromIR(raw) {
      const coords = raw[2];
      const colors = raw[3];
      const figures = raw[4];
      const bounds = raw[5];
      const matrix = raw[6];
      const bbox = raw[7];
      const background = raw[8];
      return {
        getPattern: function Mesh_getPattern(ctx, owner, shadingFill) {
          applyBoundingBox(ctx, bbox);
          let scale;

          if (shadingFill) {
            scale = _util.Util.singularValueDecompose2dScale(ctx.mozCurrentTransform);
          } else {
            scale = _util.Util.singularValueDecompose2dScale(owner.baseTransform);

            if (matrix) {
              const matrixScale = _util.Util.singularValueDecompose2dScale(matrix);

              scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];
            }
          }

          const temporaryPatternCanvas = createMeshCanvas(bounds, scale, coords, colors, figures, shadingFill ? null : background, owner.cachedCanvases, owner.webGLContext);

          if (!shadingFill) {
            ctx.setTransform.apply(ctx, owner.baseTransform);

            if (matrix) {
              ctx.transform.apply(ctx, matrix);
            }
          }

          ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
          ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
          return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat");
        }
      };
    }
  };
  ShadingIRs.Dummy = {
    fromIR: function Dummy_fromIR() {
      return {
        getPattern: function Dummy_fromIR_getPattern() {
          return "hotpink";
        }
      };
    }
  };

  function getShadingPatternFromIR(raw) {
    const shadingIR = ShadingIRs[raw[0]];

    if (!shadingIR) {
      throw new Error(`Unknown IR type: ${raw[0]}`);
    }

    return shadingIR.fromIR(raw);
  }

  const TilingPattern = function TilingPatternClosure() {
    const PaintType = {
      COLORED: 1,
      UNCOLORED: 2
    };
    const MAX_PATTERN_SIZE = 3000;

    function TilingPattern(IR, color, ctx, canvasGraphicsFactory, baseTransform) {
      this.operatorList = IR[2];
      this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];
      this.bbox = IR[4];
      this.xstep = IR[5];
      this.ystep = IR[6];
      this.paintType = IR[7];
      this.tilingType = IR[8];
      this.color = color;
      this.canvasGraphicsFactory = canvasGraphicsFactory;
      this.baseTransform = baseTransform;
      this.ctx = ctx;
    }

    TilingPattern.prototype = {
      createPatternCanvas: function TilinPattern_createPatternCanvas(owner) {
        const operatorList = this.operatorList;
        const bbox = this.bbox;
        const xstep = this.xstep;
        const ystep = this.ystep;
        const paintType = this.paintType;
        const tilingType = this.tilingType;
        const color = this.color;
        const canvasGraphicsFactory = this.canvasGraphicsFactory;
        (0, _util.info)("TilingType: " + tilingType);
        const x0 = bbox[0],
              y0 = bbox[1],
              x1 = bbox[2],
              y1 = bbox[3];

        const matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);

        const curMatrixScale = _util.Util.singularValueDecompose2dScale(this.baseTransform);

        const combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];
        const dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);
        const dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);
        const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", dimx.size, dimy.size, true);
        const tmpCtx = tmpCanvas.context;
        const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);
        graphics.groupLevel = owner.groupLevel;
        this.setFillAndStrokeStyleToContext(graphics, paintType, color);
        graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);
        graphics.transform(1, 0, 0, 1, -x0, -y0);
        this.clipBbox(graphics, bbox, x0, y0, x1, y1);
        graphics.executeOperatorList(operatorList);
        this.ctx.transform(1, 0, 0, 1, x0, y0);
        this.ctx.scale(1 / dimx.scale, 1 / dimy.scale);
        return tmpCanvas.canvas;
      },
      getSizeAndScale: function TilingPattern_getSizeAndScale(step, realOutputSize, scale) {
        step = Math.abs(step);
        const maxSize = Math.max(MAX_PATTERN_SIZE, realOutputSize);
        let size = Math.ceil(step * scale);

        if (size >= maxSize) {
          size = maxSize;
        } else {
          scale = size / step;
        }

        return {
          scale,
          size
        };
      },
      clipBbox: function clipBbox(graphics, bbox, x0, y0, x1, y1) {
        if (Array.isArray(bbox) && bbox.length === 4) {
          const bboxWidth = x1 - x0;
          const bboxHeight = y1 - y0;
          graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
          graphics.clip();
          graphics.endPath();
        }
      },
      setFillAndStrokeStyleToContext: function setFillAndStrokeStyleToContext(graphics, paintType, color) {
        const context = graphics.ctx,
              current = graphics.current;

        switch (paintType) {
          case PaintType.COLORED:
            const ctx = this.ctx;
            context.fillStyle = ctx.fillStyle;
            context.strokeStyle = ctx.strokeStyle;
            current.fillColor = ctx.fillStyle;
            current.strokeColor = ctx.strokeStyle;
            break;

          case PaintType.UNCOLORED:
            const cssColor = _util.Util.makeHexColor(color[0], color[1], color[2]);

            context.fillStyle = cssColor;
            context.strokeStyle = cssColor;
            current.fillColor = cssColor;
            current.strokeColor = cssColor;
            break;

          default:
            throw new _util.FormatError(`Unsupported paint type: ${paintType}`);
        }
      },
      getPattern: function TilingPattern_getPattern(ctx, owner) {
        ctx = this.ctx;
        ctx.setTransform.apply(ctx, this.baseTransform);
        ctx.transform.apply(ctx, this.matrix);
        const temporaryPatternCanvas = this.createPatternCanvas(owner);
        return ctx.createPattern(temporaryPatternCanvas, "repeat");
      }
    };
    return TilingPattern;
  }();

  exports.TilingPattern = TilingPattern;

  /***/ }),
  /* 12 */
  /***/ ((__unused_webpack_module, exports) => {



  Object.defineProperty(exports, "__esModule", ({
    value: true
  }));
  exports.GlobalWorkerOptions = void 0;
  const GlobalWorkerOptions = Object.create(null);
  exports.GlobalWorkerOptions = GlobalWorkerOptions;
  GlobalWorkerOptions.workerPort = GlobalWorkerOptions.workerPort === undefined ? null : GlobalWorkerOptions.workerPort;
  GlobalWorkerOptions.workerSrc = GlobalWorkerOptions.workerSrc === undefined ? "" : GlobalWorkerOptions.workerSrc;

  /***/ }),
  /* 13 */
  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



  Object.defineProperty(exports, "__esModule", ({
    value: true
  }));
  exports.MessageHandler = void 0;

  var _util = __w_pdfjs_require__(2);

  const CallbackKind = {
    UNKNOWN: 0,
    DATA: 1,
    ERROR: 2
  };
  const StreamKind = {
    UNKNOWN: 0,
    CANCEL: 1,
    CANCEL_COMPLETE: 2,
    CLOSE: 3,
    ENQUEUE: 4,
    ERROR: 5,
    PULL: 6,
    PULL_COMPLETE: 7,
    START_COMPLETE: 8
  };

  function wrapReason(reason) {
    if (typeof reason !== "object" || reason === null) {
      return reason;
    }

    switch (reason.name) {
      case "AbortException":
        return new _util.AbortException(reason.message);

      case "MissingPDFException":
        return new _util.MissingPDFException(reason.message);

      case "UnexpectedResponseException":
        return new _util.UnexpectedResponseException(reason.message, reason.status);

      case "UnknownErrorException":
        return new _util.UnknownErrorException(reason.message, reason.details);

      default:
        return new _util.UnknownErrorException(reason.message, reason.toString());
    }
  }

  class MessageHandler {
    constructor(sourceName, targetName, comObj) {
      this.sourceName = sourceName;
      this.targetName = targetName;
      this.comObj = comObj;
      this.callbackId = 1;
      this.streamId = 1;
      this.postMessageTransfers = true;
      this.streamSinks = Object.create(null);
      this.streamControllers = Object.create(null);
      this.callbackCapabilities = Object.create(null);
      this.actionHandler = Object.create(null);

      this._onComObjOnMessage = event => {
        const data = event.data;

        if (data.targetName !== this.sourceName) {
          return;
        }

        if (data.stream) {
          this._processStreamMessage(data);

          return;
        }

        if (data.callback) {
          const callbackId = data.callbackId;
          const capability = this.callbackCapabilities[callbackId];

          if (!capability) {
            throw new Error(`Cannot resolve callback ${callbackId}`);
          }

          delete this.callbackCapabilities[callbackId];

          if (data.callback === CallbackKind.DATA) {
            capability.resolve(data.data);
          } else if (data.callback === CallbackKind.ERROR) {
            capability.reject(wrapReason(data.reason));
          } else {
            throw new Error("Unexpected callback case");
          }

          return;
        }

        const action = this.actionHandler[data.action];

        if (!action) {
          throw new Error(`Unknown action from worker: ${data.action}`);
        }

        if (data.callbackId) {
          const cbSourceName = this.sourceName;
          const cbTargetName = data.sourceName;
          new Promise(function (resolve) {
            resolve(action(data.data));
          }).then(function (result) {
            comObj.postMessage({
              sourceName: cbSourceName,
              targetName: cbTargetName,
              callback: CallbackKind.DATA,
              callbackId: data.callbackId,
              data: result
            });
          }, function (reason) {
            comObj.postMessage({
              sourceName: cbSourceName,
              targetName: cbTargetName,
              callback: CallbackKind.ERROR,
              callbackId: data.callbackId,
              reason: wrapReason(reason)
            });
          });
          return;
        }

        if (data.streamId) {
          this._createStreamSink(data);

          return;
        }

        action(data.data);
      };

      comObj.addEventListener("message", this._onComObjOnMessage);
    }

    on(actionName, handler) {
      const ah = this.actionHandler;

      if (ah[actionName]) {
        throw new Error(`There is already an actionName called "${actionName}"`);
      }

      ah[actionName] = handler;
    }

    send(actionName, data, transfers) {
      this._postMessage({
        sourceName: this.sourceName,
        targetName: this.targetName,
        action: actionName,
        data
      }, transfers);
    }

    sendWithPromise(actionName, data, transfers) {
      const callbackId = this.callbackId++;
      const capability = (0, _util.createPromiseCapability)();
      this.callbackCapabilities[callbackId] = capability;

      try {
        this._postMessage({
          sourceName: this.sourceName,
          targetName: this.targetName,
          action: actionName,
          callbackId,
          data
        }, transfers);
      } catch (ex) {
        capability.reject(ex);
      }

      return capability.promise;
    }

    sendWithStream(actionName, data, queueingStrategy, transfers) {
      const streamId = this.streamId++;
      const sourceName = this.sourceName;
      const targetName = this.targetName;
      const comObj = this.comObj;
      return new ReadableStream({
        start: controller => {
          const startCapability = (0, _util.createPromiseCapability)();
          this.streamControllers[streamId] = {
            controller,
            startCall: startCapability,
            pullCall: null,
            cancelCall: null,
            isClosed: false
          };

          this._postMessage({
            sourceName,
            targetName,
            action: actionName,
            streamId,
            data,
            desiredSize: controller.desiredSize
          }, transfers);

          return startCapability.promise;
        },
        pull: controller => {
          const pullCapability = (0, _util.createPromiseCapability)();
          this.streamControllers[streamId].pullCall = pullCapability;
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.PULL,
            streamId,
            desiredSize: controller.desiredSize
          });
          return pullCapability.promise;
        },
        cancel: reason => {
          (0, _util.assert)(reason instanceof Error, "cancel must have a valid reason");
          const cancelCapability = (0, _util.createPromiseCapability)();
          this.streamControllers[streamId].cancelCall = cancelCapability;
          this.streamControllers[streamId].isClosed = true;
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.CANCEL,
            streamId,
            reason: wrapReason(reason)
          });
          return cancelCapability.promise;
        }
      }, queueingStrategy);
    }

    _createStreamSink(data) {
      const self = this;
      const action = this.actionHandler[data.action];
      const streamId = data.streamId;
      const sourceName = this.sourceName;
      const targetName = data.sourceName;
      const comObj = this.comObj;
      const streamSink = {
        enqueue(chunk, size = 1, transfers) {
          if (this.isCancelled) {
            return;
          }

          const lastDesiredSize = this.desiredSize;
          this.desiredSize -= size;

          if (lastDesiredSize > 0 && this.desiredSize <= 0) {
            this.sinkCapability = (0, _util.createPromiseCapability)();
            this.ready = this.sinkCapability.promise;
          }

          self._postMessage({
            sourceName,
            targetName,
            stream: StreamKind.ENQUEUE,
            streamId,
            chunk
          }, transfers);
        },

        close() {
          if (this.isCancelled) {
            return;
          }

          this.isCancelled = true;
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.CLOSE,
            streamId
          });
          delete self.streamSinks[streamId];
        },

        error(reason) {
          (0, _util.assert)(reason instanceof Error, "error must have a valid reason");

          if (this.isCancelled) {
            return;
          }

          this.isCancelled = true;
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.ERROR,
            streamId,
            reason: wrapReason(reason)
          });
        },

        sinkCapability: (0, _util.createPromiseCapability)(),
        onPull: null,
        onCancel: null,
        isCancelled: false,
        desiredSize: data.desiredSize,
        ready: null
      };
      streamSink.sinkCapability.resolve();
      streamSink.ready = streamSink.sinkCapability.promise;
      this.streamSinks[streamId] = streamSink;
      new Promise(function (resolve) {
        resolve(action(data.data, streamSink));
      }).then(function () {
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.START_COMPLETE,
          streamId,
          success: true
        });
      }, function (reason) {
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.START_COMPLETE,
          streamId,
          reason: wrapReason(reason)
        });
      });
    }

    _processStreamMessage(data) {
      const streamId = data.streamId;
      const sourceName = this.sourceName;
      const targetName = data.sourceName;
      const comObj = this.comObj;

      switch (data.stream) {
        case StreamKind.START_COMPLETE:
          if (data.success) {
            this.streamControllers[streamId].startCall.resolve();
          } else {
            this.streamControllers[streamId].startCall.reject(wrapReason(data.reason));
          }

          break;

        case StreamKind.PULL_COMPLETE:
          if (data.success) {
            this.streamControllers[streamId].pullCall.resolve();
          } else {
            this.streamControllers[streamId].pullCall.reject(wrapReason(data.reason));
          }

          break;

        case StreamKind.PULL:
          if (!this.streamSinks[streamId]) {
            comObj.postMessage({
              sourceName,
              targetName,
              stream: StreamKind.PULL_COMPLETE,
              streamId,
              success: true
            });
            break;
          }

          if (this.streamSinks[streamId].desiredSize <= 0 && data.desiredSize > 0) {
            this.streamSinks[streamId].sinkCapability.resolve();
          }

          this.streamSinks[streamId].desiredSize = data.desiredSize;
          const {
            onPull
          } = this.streamSinks[data.streamId];
          new Promise(function (resolve) {
            resolve(onPull && onPull());
          }).then(function () {
            comObj.postMessage({
              sourceName,
              targetName,
              stream: StreamKind.PULL_COMPLETE,
              streamId,
              success: true
            });
          }, function (reason) {
            comObj.postMessage({
              sourceName,
              targetName,
              stream: StreamKind.PULL_COMPLETE,
              streamId,
              reason: wrapReason(reason)
            });
          });
          break;

        case StreamKind.ENQUEUE:
          (0, _util.assert)(this.streamControllers[streamId], "enqueue should have stream controller");

          if (this.streamControllers[streamId].isClosed) {
            break;
          }

          this.streamControllers[streamId].controller.enqueue(data.chunk);
          break;

        case StreamKind.CLOSE:
          (0, _util.assert)(this.streamControllers[streamId], "close should have stream controller");

          if (this.streamControllers[streamId].isClosed) {
            break;
          }

          this.streamControllers[streamId].isClosed = true;
          this.streamControllers[streamId].controller.close();

          this._deleteStreamController(streamId);

          break;

        case StreamKind.ERROR:
          (0, _util.assert)(this.streamControllers[streamId], "error should have stream controller");
          this.streamControllers[streamId].controller.error(wrapReason(data.reason));

          this._deleteStreamController(streamId);

          break;

        case StreamKind.CANCEL_COMPLETE:
          if (data.success) {
            this.streamControllers[streamId].cancelCall.resolve();
          } else {
            this.streamControllers[streamId].cancelCall.reject(wrapReason(data.reason));
          }

          this._deleteStreamController(streamId);

          break;

        case StreamKind.CANCEL:
          if (!this.streamSinks[streamId]) {
            break;
          }

          const {
            onCancel
          } = this.streamSinks[data.streamId];
          new Promise(function (resolve) {
            resolve(onCancel && onCancel(wrapReason(data.reason)));
          }).then(function () {
            comObj.postMessage({
              sourceName,
              targetName,
              stream: StreamKind.CANCEL_COMPLETE,
              streamId,
              success: true
            });
          }, function (reason) {
            comObj.postMessage({
              sourceName,
              targetName,
              stream: StreamKind.CANCEL_COMPLETE,
              streamId,
              reason: wrapReason(reason)
            });
          });
          this.streamSinks[streamId].sinkCapability.reject(wrapReason(data.reason));
          this.streamSinks[streamId].isCancelled = true;
          delete this.streamSinks[streamId];
          break;

        default:
          throw new Error("Unexpected stream case");
      }
    }

    async _deleteStreamController(streamId) {
      await Promise.allSettled([this.streamControllers[streamId].startCall, this.streamControllers[streamId].pullCall, this.streamControllers[streamId].cancelCall].map(function (capability) {
        return capability && capability.promise;
      }));
      delete this.streamControllers[streamId];
    }

    _postMessage(message, transfers) {
      if (transfers && this.postMessageTransfers) {
        this.comObj.postMessage(message, transfers);
      } else {
        this.comObj.postMessage(message);
      }
    }

    destroy() {
      this.comObj.removeEventListener("message", this._onComObjOnMessage);
    }

  }

  exports.MessageHandler = MessageHandler;

  /***/ }),
  /* 14 */
  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



  Object.defineProperty(exports, "__esModule", ({
    value: true
  }));
  exports.Metadata = void 0;

  var _util = __w_pdfjs_require__(2);

  var _xml_parser = __w_pdfjs_require__(15);

  class Metadata {
    constructor(data) {
      (0, _util.assert)(typeof data === "string", "Metadata: input is not a string");
      data = this._repair(data);
      const parser = new _xml_parser.SimpleXMLParser({
        lowerCaseName: true
      });
      const xmlDocument = parser.parseFromString(data);
      this._metadataMap = new Map();

      if (xmlDocument) {
        this._parse(xmlDocument);
      }

      this._data = data;
    }

    _repair(data) {
      return data.replace(/^[^<]+/, "").replace(/>\\376\\377([^<]+)/g, function (all, codes) {
        const bytes = codes.replace(/\\([0-3])([0-7])([0-7])/g, function (code, d1, d2, d3) {
          return String.fromCharCode(d1 * 64 + d2 * 8 + d3 * 1);
        }).replace(/&(amp|apos|gt|lt|quot);/g, function (str, name) {
          switch (name) {
            case "amp":
              return "&";

            case "apos":
              return "'";

            case "gt":
              return ">";

            case "lt":
              return "<";

            case "quot":
              return '"';
          }

          throw new Error(`_repair: ${name} isn't defined.`);
        });
        let chars = "";

        for (let i = 0, ii = bytes.length; i < ii; i += 2) {
          const code = bytes.charCodeAt(i) * 256 + bytes.charCodeAt(i + 1);

          if (code >= 32 && code < 127 && code !== 60 && code !== 62 && code !== 38) {
            chars += String.fromCharCode(code);
          } else {
            chars += "&#x" + (0x10000 + code).toString(16).substring(1) + ";";
          }
        }

        return ">" + chars;
      });
    }

    _getSequence(entry) {
      const name = entry.nodeName;

      if (name !== "rdf:bag" && name !== "rdf:seq" && name !== "rdf:alt") {
        return null;
      }

      return entry.childNodes.filter(node => node.nodeName === "rdf:li");
    }

    _getCreators(entry) {
      if (entry.nodeName !== "dc:creator") {
        return false;
      }

      if (!entry.hasChildNodes()) {
        return true;
      }

      const seqNode = entry.childNodes[0];
      const authors = this._getSequence(seqNode) || [];

      this._metadataMap.set(entry.nodeName, authors.map(node => node.textContent.trim()));

      return true;
    }

    _parse(xmlDocument) {
      let rdf = xmlDocument.documentElement;

      if (rdf.nodeName !== "rdf:rdf") {
        rdf = rdf.firstChild;

        while (rdf && rdf.nodeName !== "rdf:rdf") {
          rdf = rdf.nextSibling;
        }
      }

      if (!rdf || rdf.nodeName !== "rdf:rdf" || !rdf.hasChildNodes()) {
        return;
      }

      for (const desc of rdf.childNodes) {
        if (desc.nodeName !== "rdf:description") {
          continue;
        }

        for (const entry of desc.childNodes) {
          const name = entry.nodeName;

          if (name === "#text") {
            continue;
          }

          if (this._getCreators(entry)) {
            continue;
          }

          this._metadataMap.set(name, entry.textContent.trim());
        }
      }
    }

    getRaw() {
      return this._data;
    }

    get(name) {
      return this._metadataMap.get(name) || null; //lwf
    }

    getAll() {
      return (0, _util.objectFromEntries)(this._metadataMap);
    }

    has(name) {
      return this._metadataMap.has(name);
    }

  }

  exports.Metadata = Metadata;

  /***/ }),
  /* 15 */
  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



  Object.defineProperty(exports, "__esModule", ({
    value: true
  }));
  exports.SimpleXMLParser = exports.SimpleDOMNode = void 0;

  var _util = __w_pdfjs_require__(2);

  const XMLParserErrorCode = {
    NoError: 0,
    EndOfDocument: -1,
    UnterminatedCdat: -2,
    UnterminatedXmlDeclaration: -3,
    UnterminatedDoctypeDeclaration: -4,
    UnterminatedComment: -5,
    MalformedElement: -6,
    OutOfMemory: -7,
    UnterminatedAttributeValue: -8,
    UnterminatedElement: -9,
    ElementNeverBegun: -10
  };

  function isWhitespace(s, index) {
    const ch = s[index];
    return ch === " " || ch === "\n" || ch === "\r" || ch === "\t";
  }

  function isWhitespaceString(s) {
    for (let i = 0, ii = s.length; i < ii; i++) {
      if (!isWhitespace(s, i)) {
        return false;
      }
    }

    return true;
  }

  class XMLParserBase {
    _resolveEntities(s) {
      return s.replace(/&([^;]+);/g, (all, entity) => {
        if (entity.substring(0, 2) === "#x") {
          return String.fromCodePoint(parseInt(entity.substring(2), 16));
        } else if (entity.substring(0, 1) === "#") {
          return String.fromCodePoint(parseInt(entity.substring(1), 10));
        }

        switch (entity) {
          case "lt":
            return "<";

          case "gt":
            return ">";

          case "amp":
            return "&";

          case "quot":
            return '"';
        }

        return this.onResolveEntity(entity);
      });
    }

    _parseContent(s, start) {
      const attributes = [];
      let pos = start;

      function skipWs() {
        while (pos < s.length && isWhitespace(s, pos)) {
          ++pos;
        }
      }

      while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== ">" && s[pos] !== "/") {
        ++pos;
      }

      const name = s.substring(start, pos);
      skipWs();

      while (pos < s.length && s[pos] !== ">" && s[pos] !== "/" && s[pos] !== "?") {
        skipWs();
        let attrName = "",
            attrValue = "";

        while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== "=") {
          attrName += s[pos];
          ++pos;
        }

        skipWs();

        if (s[pos] !== "=") {
          return null;
        }

        ++pos;
        skipWs();
        const attrEndChar = s[pos];

        if (attrEndChar !== '"' && attrEndChar !== "'") {
          return null;
        }

        const attrEndIndex = s.indexOf(attrEndChar, ++pos);

        if (attrEndIndex < 0) {
          return null;
        }

        attrValue = s.substring(pos, attrEndIndex);
        attributes.push({
          name: attrName,
          value: this._resolveEntities(attrValue)
        });
        pos = attrEndIndex + 1;
        skipWs();
      }

      return {
        name,
        attributes,
        parsed: pos - start
      };
    }

    _parseProcessingInstruction(s, start) {
      let pos = start;

      function skipWs() {
        while (pos < s.length && isWhitespace(s, pos)) {
          ++pos;
        }
      }

      while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== ">" && s[pos] !== "/") {
        ++pos;
      }

      const name = s.substring(start, pos);
      skipWs();
      const attrStart = pos;

      while (pos < s.length && (s[pos] !== "?" || s[pos + 1] !== ">")) {
        ++pos;
      }

      const value = s.substring(attrStart, pos);
      return {
        name,
        value,
        parsed: pos - start
      };
    }

    parseXml(s) {
      let i = 0;

      while (i < s.length) {
        const ch = s[i];
        let j = i;

        if (ch === "<") {
          ++j;
          const ch2 = s[j];
          let q;

          switch (ch2) {
            case "/":
              ++j;
              q = s.indexOf(">", j);

              if (q < 0) {
                this.onError(XMLParserErrorCode.UnterminatedElement);
                return;
              }

              this.onEndElement(s.substring(j, q));
              j = q + 1;
              break;

            case "?":
              ++j;

              const pi = this._parseProcessingInstruction(s, j);

              if (s.substring(j + pi.parsed, j + pi.parsed + 2) !== "?>") {
                this.onError(XMLParserErrorCode.UnterminatedXmlDeclaration);
                return;
              }

              this.onPi(pi.name, pi.value);
              j += pi.parsed + 2;
              break;

            case "!":
              if (s.substring(j + 1, j + 3) === "--") {
                q = s.indexOf("-->", j + 3);

                if (q < 0) {
                  this.onError(XMLParserErrorCode.UnterminatedComment);
                  return;
                }

                this.onComment(s.substring(j + 3, q));
                j = q + 3;
              } else if (s.substring(j + 1, j + 8) === "[CDATA[") {
                q = s.indexOf("]]>", j + 8);

                if (q < 0) {
                  this.onError(XMLParserErrorCode.UnterminatedCdat);
                  return;
                }

                this.onCdata(s.substring(j + 8, q));
                j = q + 3;
              } else if (s.substring(j + 1, j + 8) === "DOCTYPE") {
                const q2 = s.indexOf("[", j + 8);
                let complexDoctype = false;
                q = s.indexOf(">", j + 8);

                if (q < 0) {
                  this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);
                  return;
                }

                if (q2 > 0 && q > q2) {
                  q = s.indexOf("]>", j + 8);

                  if (q < 0) {
                    this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);
                    return;
                  }

                  complexDoctype = true;
                }

                const doctypeContent = s.substring(j + 8, q + (complexDoctype ? 1 : 0));
                this.onDoctype(doctypeContent);
                j = q + (complexDoctype ? 2 : 1);
              } else {
                this.onError(XMLParserErrorCode.MalformedElement);
                return;
              }

              break;

            default:
              const content = this._parseContent(s, j);

              if (content === null) {
                this.onError(XMLParserErrorCode.MalformedElement);
                return;
              }

              let isClosed = false;

              if (s.substring(j + content.parsed, j + content.parsed + 2) === "/>") {
                isClosed = true;
              } else if (s.substring(j + content.parsed, j + content.parsed + 1) !== ">") {
                this.onError(XMLParserErrorCode.UnterminatedElement);
                return;
              }

              this.onBeginElement(content.name, content.attributes, isClosed);
              j += content.parsed + (isClosed ? 2 : 1);
              break;
          }
        } else {
          while (j < s.length && s[j] !== "<") {
            j++;
          }

          const text = s.substring(i, j);
          this.onText(this._resolveEntities(text));
        }

        i = j;
      }
    }

    onResolveEntity(name) {
      return `&${name};`;
    }

    onPi(name, value) {}

    onComment(text) {}

    onCdata(text) {}

    onDoctype(doctypeContent) {}

    onText(text) {}

    onBeginElement(name, attributes, isEmpty) {}

    onEndElement(name) {}

    onError(code) {}

  }

  class SimpleDOMNode {
    constructor(nodeName, nodeValue) {
      this.nodeName = nodeName;
      this.nodeValue = nodeValue;
      Object.defineProperty(this, "parentNode", {
        value: null,
        writable: true
      });
    }

    get firstChild() {
      return this.childNodes && this.childNodes[0];
    }

    get nextSibling() {
      const childNodes = this.parentNode.childNodes;

      if (!childNodes) {
        return undefined;
      }

      const index = childNodes.indexOf(this);

      if (index === -1) {
        return undefined;
      }

      return childNodes[index + 1];
    }

    get textContent() {
      if (!this.childNodes) {
        return this.nodeValue || "";
      }

      return this.childNodes.map(function (child) {
        return child.textContent;
      }).join("");
    }

    hasChildNodes() {
      return this.childNodes && this.childNodes.length > 0;
    }

    searchNode(paths, pos) {
      if (pos >= paths.length) {
        return this;
      }

      const component = paths[pos];
      const stack = [];
      let node = this;

      while (true) {
        if (component.name === node.nodeName) {
          if (component.pos === 0) {
            const res = node.searchNode(paths, pos + 1);

            if (res !== null) {
              return res;
            }
          } else if (stack.length === 0) {
            return null;
          } else {
            const [parent] = stack.pop();
            let siblingPos = 0;

            for (const child of parent.childNodes) {
              if (component.name === child.nodeName) {
                if (siblingPos === component.pos) {
                  return child.searchNode(paths, pos + 1);
                }

                siblingPos++;
              }
            }

            return node.searchNode(paths, pos + 1);
          }
        }

        if (node.childNodes && node.childNodes.length !== 0) {
          stack.push([node, 0]);
          node = node.childNodes[0];
        } else if (stack.length === 0) {
          return null;
        } else {
          while (stack.length !== 0) {
            const [parent, currentPos] = stack.pop();
            const newPos = currentPos + 1;

            if (newPos < parent.childNodes.length) {
              stack.push([parent, newPos]);
              node = parent.childNodes[newPos];
              break;
            }
          }

          if (stack.length === 0) {
            return null;
          }
        }
      }
    }

    dump(buffer) {
      if (this.nodeName === "#text") {
        buffer.push((0, _util.encodeToXmlString)(this.nodeValue));
        return;
      }

      buffer.push(`<${this.nodeName}`);

      if (this.attributes) {
        for (const attribute of this.attributes) {
          buffer.push(` ${attribute.name}="${(0, _util.encodeToXmlString)(attribute.value)}"`);
        }
      }

      if (this.hasChildNodes()) {
        buffer.push(">");

        for (const child of this.childNodes) {
          child.dump(buffer);
        }

        buffer.push(`</${this.nodeName}>`);
      } else if (this.nodeValue) {
        buffer.push(`>${(0, _util.encodeToXmlString)(this.nodeValue)}</${this.nodeName}>`);
      } else {
        buffer.push("/>");
      }
    }

  }

  exports.SimpleDOMNode = SimpleDOMNode;

  class SimpleXMLParser extends XMLParserBase {
    constructor({
      hasAttributes = false,
      lowerCaseName = false
    }) {
      super();
      this._currentFragment = null;
      this._stack = null;
      this._errorCode = XMLParserErrorCode.NoError;
      this._hasAttributes = hasAttributes;
      this._lowerCaseName = lowerCaseName;
    }

    parseFromString(data) {
      this._currentFragment = [];
      this._stack = [];
      this._errorCode = XMLParserErrorCode.NoError;
      this.parseXml(data);

      if (this._errorCode !== XMLParserErrorCode.NoError) {
        return undefined;
      }

      const [documentElement] = this._currentFragment;

      if (!documentElement) {
        return undefined;
      }

      return {
        documentElement
      };
    }

    onResolveEntity(name) {
      switch (name) {
        case "apos":
          return "'";
      }

      return super.onResolveEntity(name);
    }

    onText(text) {
      if (isWhitespaceString(text)) {
        return;
      }

      const node = new SimpleDOMNode("#text", text);

      this._currentFragment.push(node);
    }

    onCdata(text) {
      const node = new SimpleDOMNode("#text", text);

      this._currentFragment.push(node);
    }

    onBeginElement(name, attributes, isEmpty) {
      if (this._lowerCaseName) {
        name = name.toLowerCase();
      }

      const node = new SimpleDOMNode(name);
      node.childNodes = [];

      if (this._hasAttributes) {
        node.attributes = attributes;
      }

      this._currentFragment.push(node);

      if (isEmpty) {
        return;
      }

      this._stack.push(this._currentFragment);

      this._currentFragment = node.childNodes;
    }

    onEndElement(name) {
      this._currentFragment = this._stack.pop() || [];
      const lastElement = this._currentFragment[this._currentFragment.length - 1];

      if (!lastElement) {
        return;
      }

      for (let i = 0, ii = lastElement.childNodes.length; i < ii; i++) {
        lastElement.childNodes[i].parentNode = lastElement;
      }
    }

    onError(code) {
      this._errorCode = code;
    }

  }

  exports.SimpleXMLParser = SimpleXMLParser;

  /***/ }),
  /* 16 */
  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



  Object.defineProperty(exports, "__esModule", ({
    value: true
  }));
  exports.OptionalContentConfig = void 0;

  var _util = __w_pdfjs_require__(2);

  class OptionalContentGroup {
    constructor(name, intent) {
      this.visible = true;
      this.name = name;
      this.intent = intent;
    }

  }

  class OptionalContentConfig {
    constructor(data) {
      this.name = null;
      this.creator = null;
      this._order = null;
      this._groups = new Map();

      if (data === null) {
        return;
      }

      this.name = data.name;
      this.creator = data.creator;
      this._order = data.order;

      for (const group of data.groups) {
        this._groups.set(group.id, new OptionalContentGroup(group.name, group.intent));
      }

      if (data.baseState === "OFF") {
        for (const group of this._groups) {
          group.visible = false;
        }
      }

      for (const on of data.on) {
        this._groups.get(on).visible = true;
      }

      for (const off of data.off) {
        this._groups.get(off).visible = false;
      }
    }

    isVisible(group) {
      if (group.type === "OCG") {
        if (!this._groups.has(group.id)) {
          (0, _util.warn)(`Optional content group not found: ${group.id}`);
          return true;
        }

        return this._groups.get(group.id).visible;
      } else if (group.type === "OCMD") {
        if (group.expression) {
          (0, _util.warn)("Visibility expression not supported yet.");
        }

        if (!group.policy || group.policy === "AnyOn") {
          for (const id of group.ids) {
            if (!this._groups.has(id)) {
              (0, _util.warn)(`Optional content group not found: ${id}`);
              return true;
            }

            if (this._groups.get(id).visible) {
              return true;
            }
          }

          return false;
        } else if (group.policy === "AllOn") {
          for (const id of group.ids) {
            if (!this._groups.has(id)) {
              (0, _util.warn)(`Optional content group not found: ${id}`);
              return true;
            }

            if (!this._groups.get(id).visible) {
              return false;
            }
          }

          return true;
        } else if (group.policy === "AnyOff") {
          for (const id of group.ids) {
            if (!this._groups.has(id)) {
              (0, _util.warn)(`Optional content group not found: ${id}`);
              return true;
            }

            if (!this._groups.get(id).visible) {
              return true;
            }
          }

          return false;
        } else if (group.policy === "AllOff") {
          for (const id of group.ids) {
            if (!this._groups.has(id)) {
              (0, _util.warn)(`Optional content group not found: ${id}`);
              return true;
            }

            if (this._groups.get(id).visible) {
              return false;
            }
          }

          return true;
        }

        (0, _util.warn)(`Unknown optional content policy ${group.policy}.`);
        return true;
      }

      (0, _util.warn)(`Unknown group type ${group.type}.`);
      return true;
    }

    setVisibility(id, visible = true) {
      if (!this._groups.has(id)) {
        (0, _util.warn)(`Optional content group not found: ${id}`);
        return;
      }

      this._groups.get(id).visible = !!visible;
    }

    getOrder() {
      if (!this._groups.size) {
        return null;
      }

      if (this._order) {
        return this._order.slice();
      }

      return Array.from(this._groups.keys());
    }

    getGroups() {
      if (!this._groups.size) {
        return null;
      }

      return (0, _util.objectFromEntries)(this._groups);
    }

    getGroup(id) {
      return this._groups.get(id) || null;
    }

  }

  exports.OptionalContentConfig = OptionalContentConfig;

  /***/ }),
  /* 17 */
  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



  Object.defineProperty(exports, "__esModule", ({
    value: true
  }));
  exports.PDFDataTransportStream = void 0;

  var _util = __w_pdfjs_require__(2);

  class PDFDataTransportStream {
    constructor(params, pdfDataRangeTransport) {
      (0, _util.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
      this._queuedChunks = [];
      this._progressiveDone = params.progressiveDone || false;
      const initialData = params.initialData;

      if (initialData && initialData.length > 0) { // lwf
        const buffer = new Uint8Array(initialData).buffer;

        this._queuedChunks.push(buffer);
      }

      this._pdfDataRangeTransport = pdfDataRangeTransport;
      this._isStreamingSupported = !params.disableStream;
      this._isRangeSupported = !params.disableRange;
      this._contentLength = params.length;
      this._fullRequestReader = null;
      this._rangeReaders = [];

      this._pdfDataRangeTransport.addRangeListener((begin, chunk) => {
        this._onReceiveData({
          begin,
          chunk
        });
      });

      this._pdfDataRangeTransport.addProgressListener((loaded, total) => {
        this._onProgress({
          loaded,
          total
        });
      });

      this._pdfDataRangeTransport.addProgressiveReadListener(chunk => {
        this._onReceiveData({
          chunk
        });
      });

      this._pdfDataRangeTransport.addProgressiveDoneListener(() => {
        this._onProgressiveDone();
      });

      this._pdfDataRangeTransport.transportReady();
    }

    _onReceiveData(args) {
      const buffer = new Uint8Array(args.chunk).buffer;

      if (args.begin === undefined) {
        if (this._fullRequestReader) {
          this._fullRequestReader._enqueue(buffer);
        } else {
          this._queuedChunks.push(buffer);
        }
      } else {
        const found = this._rangeReaders.some(function (rangeReader) {
          if (rangeReader._begin !== args.begin) {
            return false;
          }

          rangeReader._enqueue(buffer);

          return true;
        });

        (0, _util.assert)(found, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
      }
    }

    get _progressiveDataLength() {
      return this._fullRequestReader && this._fullRequestReader._loaded || 0; // lwf
    }

    _onProgress(evt) {
      if (evt.total === undefined) {
        const firstReader = this._rangeReaders[0];

        if (firstReader && firstReader.onProgress) { // lwf
          firstReader.onProgress({
            loaded: evt.loaded
          });
        }
      } else {
        const fullReader = this._fullRequestReader;

        if (fullReader && fullReader.onProgress) { // lwf
          fullReader.onProgress({
            loaded: evt.loaded,
            total: evt.total
          });
        }
      }
    }

    _onProgressiveDone() {
      if (this._fullRequestReader) {
        this._fullRequestReader.progressiveDone();
      }

      this._progressiveDone = true;
    }

    _removeRangeReader(reader) {
      const i = this._rangeReaders.indexOf(reader);

      if (i >= 0) {
        this._rangeReaders.splice(i, 1);
      }
    }

    getFullReader() {
      (0, _util.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
      const queuedChunks = this._queuedChunks;
      this._queuedChunks = null;
      return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone);
    }

    getRangeReader(begin, end) {
      if (end <= this._progressiveDataLength) {
        return null;
      }

      const reader = new PDFDataTransportStreamRangeReader(this, begin, end);

      this._pdfDataRangeTransport.requestDataRange(begin, end);

      this._rangeReaders.push(reader);

      return reader;
    }

    cancelAllRequests(reason) {
      if (this._fullRequestReader) {
        this._fullRequestReader.cancel(reason);
      }

      const readers = this._rangeReaders.slice(0);

      readers.forEach(function (rangeReader) {
        rangeReader.cancel(reason);
      });

      this._pdfDataRangeTransport.abort();
    }

  }

  exports.PDFDataTransportStream = PDFDataTransportStream;

  class PDFDataTransportStreamReader {
    constructor(stream, queuedChunks, progressiveDone = false) {
      this._stream = stream;
      this._done = progressiveDone || false;
      this._filename = null;
      this._queuedChunks = queuedChunks || [];
      this._loaded = 0;

      for (const chunk of this._queuedChunks) {
        this._loaded += chunk.byteLength;
      }

      this._requests = [];
      this._headersReady = Promise.resolve();
      stream._fullRequestReader = this;
      this.onProgress = null;
    }

    _enqueue(chunk) {
      if (this._done) {
        return;
      }

      if (this._requests.length > 0) {
        const requestCapability = this._requests.shift();

        requestCapability.resolve({
          value: chunk,
          done: false
        });
      } else {
        this._queuedChunks.push(chunk);
      }

      this._loaded += chunk.byteLength;
    }

    get headersReady() {
      return this._headersReady;
    }

    get filename() {
      return this._filename;
    }

    get isRangeSupported() {
      return this._stream._isRangeSupported;
    }

    get isStreamingSupported() {
      return this._stream._isStreamingSupported;
    }

    get contentLength() {
      return this._stream._contentLength;
    }

    async read() {
      if (this._queuedChunks.length > 0) {
        const chunk = this._queuedChunks.shift();

        return {
          value: chunk,
          done: false
        };
      }

      if (this._done) {
        return {
          value: undefined,
          done: true
        };
      }

      const requestCapability = (0, _util.createPromiseCapability)();

      this._requests.push(requestCapability);

      return requestCapability.promise;
    }

    cancel(reason) {
      this._done = true;

      this._requests.forEach(function (requestCapability) {
        requestCapability.resolve({
          value: undefined,
          done: true
        });
      });

      this._requests = [];
    }

    progressiveDone() {
      if (this._done) {
        return;
      }

      this._done = true;
    }

  }

  class PDFDataTransportStreamRangeReader {
    constructor(stream, begin, end) {
      this._stream = stream;
      this._begin = begin;
      this._end = end;
      this._queuedChunk = null;
      this._requests = [];
      this._done = false;
      this.onProgress = null;
    }

    _enqueue(chunk) {
      if (this._done) {
        return;
      }

      if (this._requests.length === 0) {
        this._queuedChunk = chunk;
      } else {
        const requestsCapability = this._requests.shift();

        requestsCapability.resolve({
          value: chunk,
          done: false
        });

        this._requests.forEach(function (requestCapability) {
          requestCapability.resolve({
            value: undefined,
            done: true
          });
        });

        this._requests = [];
      }

      this._done = true;

      this._stream._removeRangeReader(this);
    }

    get isStreamingSupported() {
      return false;
    }

    async read() {
      if (this._queuedChunk) {
        const chunk = this._queuedChunk;
        this._queuedChunk = null;
        return {
          value: chunk,
          done: false
        };
      }

      if (this._done) {
        return {
          value: undefined,
          done: true
        };
      }

      const requestCapability = (0, _util.createPromiseCapability)();

      this._requests.push(requestCapability);

      return requestCapability.promise;
    }

    cancel(reason) {
      this._done = true;

      this._requests.forEach(function (requestCapability) {
        requestCapability.resolve({
          value: undefined,
          done: true
        });
      });

      this._requests = [];

      this._stream._removeRangeReader(this);
    }

  }

  /***/ }),
  /* 18 */
  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



  Object.defineProperty(exports, "__esModule", ({
    value: true
  }));
  exports.WebGLContext = void 0;

  var _util = __w_pdfjs_require__(2);

  class WebGLContext {
    constructor({
      enable = false
    }) {
      this._enabled = enable === true;
    }

    get isEnabled() {
      let enabled = this._enabled;

      if (enabled) {
        enabled = WebGLUtils.tryInitGL();
      }

      return (0, _util.shadow)(this, "isEnabled", enabled);
    }

    composeSMask({
      layer,
      mask,
      properties
    }) {
      return WebGLUtils.composeSMask(layer, mask, properties);
    }

    drawFigures({
      width,
      height,
      backgroundColor,
      figures,
      context
    }) {
      return WebGLUtils.drawFigures(width, height, backgroundColor, figures, context);
    }

    clear() {
      WebGLUtils.cleanup();
    }

  }

  exports.WebGLContext = WebGLContext;

  const WebGLUtils = function WebGLUtilsClosure() {
    function loadShader(gl, code, shaderType) {
      const shader = gl.createShader(shaderType);
      gl.shaderSource(shader, code);
      gl.compileShader(shader);
      const compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

      if (!compiled) {
        const errorMsg = gl.getShaderInfoLog(shader);
        throw new Error("Error during shader compilation: " + errorMsg);
      }

      return shader;
    }

    function createVertexShader(gl, code) {
      return loadShader(gl, code, gl.VERTEX_SHADER);
    }

    function createFragmentShader(gl, code) {
      return loadShader(gl, code, gl.FRAGMENT_SHADER);
    }

    function createProgram(gl, shaders) {
      const program = gl.createProgram();

      for (let i = 0, ii = shaders.length; i < ii; ++i) {
        gl.attachShader(program, shaders[i]);
      }

      gl.linkProgram(program);
      const linked = gl.getProgramParameter(program, gl.LINK_STATUS);

      if (!linked) {
        const errorMsg = gl.getProgramInfoLog(program);
        throw new Error("Error during program linking: " + errorMsg);
      }

      return program;
    }

    function createTexture(gl, image, textureId) {
      gl.activeTexture(textureId);
      const texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
      return texture;
    }

    let currentGL, currentCanvas;

    function generateGL() {
      if (currentGL) {
        return;
      }

      currentCanvas = document.createElement("canvas");
      currentGL = currentCanvas.getContext("webgl", {
        premultipliedalpha: false
      });
    }

    const smaskVertexShaderCode = "\
    attribute vec2 a_position;                                    \
    attribute vec2 a_texCoord;                                    \
                                                                  \
    uniform vec2 u_resolution;                                    \
                                                                  \
    varying vec2 v_texCoord;                                      \
                                                                  \
    void main() {                                                 \
      vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;   \
      gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);          \
                                                                  \
      v_texCoord = a_texCoord;                                    \
    }                                                             ";
    const smaskFragmentShaderCode = "\
    precision mediump float;                                      \
                                                                  \
    uniform vec4 u_backdrop;                                      \
    uniform int u_subtype;                                        \
    uniform sampler2D u_image;                                    \
    uniform sampler2D u_mask;                                     \
                                                                  \
    varying vec2 v_texCoord;                                      \
                                                                  \
    void main() {                                                 \
      vec4 imageColor = texture2D(u_image, v_texCoord);           \
      vec4 maskColor = texture2D(u_mask, v_texCoord);             \
      if (u_backdrop.a > 0.0) {                                   \
        maskColor.rgb = maskColor.rgb * maskColor.a +             \
                        u_backdrop.rgb * (1.0 - maskColor.a);     \
      }                                                           \
      float lum;                                                  \
      if (u_subtype == 0) {                                       \
        lum = maskColor.a;                                        \
      } else {                                                    \
        lum = maskColor.r * 0.3 + maskColor.g * 0.59 +            \
              maskColor.b * 0.11;                                 \
      }                                                           \
      imageColor.a *= lum;                                        \
      imageColor.rgb *= imageColor.a;                             \
      gl_FragColor = imageColor;                                  \
    }                                                             ";
    let smaskCache = null;

    function initSmaskGL() {
      generateGL();
      const canvas = currentCanvas;
      currentCanvas = null;
      const gl = currentGL;
      currentGL = null;
      const vertexShader = createVertexShader(gl, smaskVertexShaderCode);
      const fragmentShader = createFragmentShader(gl, smaskFragmentShaderCode);
      const program = createProgram(gl, [vertexShader, fragmentShader]);
      gl.useProgram(program);
      const cache = {};
      cache.gl = gl;
      cache.canvas = canvas;
      cache.resolutionLocation = gl.getUniformLocation(program, "u_resolution");
      cache.positionLocation = gl.getAttribLocation(program, "a_position");
      cache.backdropLocation = gl.getUniformLocation(program, "u_backdrop");
      cache.subtypeLocation = gl.getUniformLocation(program, "u_subtype");
      const texCoordLocation = gl.getAttribLocation(program, "a_texCoord");
      const texLayerLocation = gl.getUniformLocation(program, "u_image");
      const texMaskLocation = gl.getUniformLocation(program, "u_mask");
      const texCoordBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), gl.STATIC_DRAW);
      gl.enableVertexAttribArray(texCoordLocation);
      gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);
      gl.uniform1i(texLayerLocation, 0);
      gl.uniform1i(texMaskLocation, 1);
      smaskCache = cache;
    }

    function composeSMask(layer, mask, properties) {
      const width = layer.width,
            height = layer.height;

      if (!smaskCache) {
        initSmaskGL();
      }

      const cache = smaskCache,
            canvas = cache.canvas,
            gl = cache.gl;
      canvas.width = width;
      canvas.height = height;
      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
      gl.uniform2f(cache.resolutionLocation, width, height);

      if (properties.backdrop) {
        gl.uniform4f(cache.resolutionLocation, properties.backdrop[0], properties.backdrop[1], properties.backdrop[2], 1);
      } else {
        gl.uniform4f(cache.resolutionLocation, 0, 0, 0, 0);
      }

      gl.uniform1i(cache.subtypeLocation, properties.subtype === "Luminosity" ? 1 : 0);
      const texture = createTexture(gl, layer, gl.TEXTURE0);
      const maskTexture = createTexture(gl, mask, gl.TEXTURE1);
      const buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, width, 0, 0, height, 0, height, width, 0, width, height]), gl.STATIC_DRAW);
      gl.enableVertexAttribArray(cache.positionLocation);
      gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);
      gl.clearColor(0, 0, 0, 0);
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      gl.flush();
      gl.deleteTexture(texture);
      gl.deleteTexture(maskTexture);
      gl.deleteBuffer(buffer);
      return canvas;
    }

    const figuresVertexShaderCode = "\
    attribute vec2 a_position;                                    \
    attribute vec3 a_color;                                       \
                                                                  \
    uniform vec2 u_resolution;                                    \
    uniform vec2 u_scale;                                         \
    uniform vec2 u_offset;                                        \
                                                                  \
    varying vec4 v_color;                                         \
                                                                  \
    void main() {                                                 \
      vec2 position = (a_position + u_offset) * u_scale;          \
      vec2 clipSpace = (position / u_resolution) * 2.0 - 1.0;     \
      gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);          \
                                                                  \
      v_color = vec4(a_color / 255.0, 1.0);                       \
    }                                                             ";
    const figuresFragmentShaderCode = "\
    precision mediump float;                                      \
                                                                  \
    varying vec4 v_color;                                         \
                                                                  \
    void main() {                                                 \
      gl_FragColor = v_color;                                     \
    }                                                             ";
    let figuresCache = null;

    function initFiguresGL() {
      generateGL();
      const canvas = currentCanvas;
      currentCanvas = null;
      const gl = currentGL;
      currentGL = null;
      const vertexShader = createVertexShader(gl, figuresVertexShaderCode);
      const fragmentShader = createFragmentShader(gl, figuresFragmentShaderCode);
      const program = createProgram(gl, [vertexShader, fragmentShader]);
      gl.useProgram(program);
      const cache = {};
      cache.gl = gl;
      cache.canvas = canvas;
      cache.resolutionLocation = gl.getUniformLocation(program, "u_resolution");
      cache.scaleLocation = gl.getUniformLocation(program, "u_scale");
      cache.offsetLocation = gl.getUniformLocation(program, "u_offset");
      cache.positionLocation = gl.getAttribLocation(program, "a_position");
      cache.colorLocation = gl.getAttribLocation(program, "a_color");
      figuresCache = cache;
    }

    function drawFigures(width, height, backgroundColor, figures, context) {
      if (!figuresCache) {
        initFiguresGL();
      }

      const cache = figuresCache,
            canvas = cache.canvas,
            gl = cache.gl;
      canvas.width = width;
      canvas.height = height;
      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
      gl.uniform2f(cache.resolutionLocation, width, height);
      let count = 0;

      for (let i = 0, ii = figures.length; i < ii; i++) {
        switch (figures[i].type) {
          case "lattice":
            const rows = figures[i].coords.length / figures[i].verticesPerRow | 0;
            count += (rows - 1) * (figures[i].verticesPerRow - 1) * 6;
            break;

          case "triangles":
            count += figures[i].coords.length;
            break;
        }
      }

      const coords = new Float32Array(count * 2);
      const colors = new Uint8Array(count * 3);
      const coordsMap = context.coords,
            colorsMap = context.colors;
      let pIndex = 0,
          cIndex = 0;

      for (let i = 0, ii = figures.length; i < ii; i++) {
        const figure = figures[i],
              ps = figure.coords,
              cs = figure.colors;

        switch (figure.type) {
          case "lattice":
            const cols = figure.verticesPerRow;
            const rows = ps.length / cols | 0;

            for (let row = 1; row < rows; row++) {
              let offset = row * cols + 1;

              for (let col = 1; col < cols; col++, offset++) {
                coords[pIndex] = coordsMap[ps[offset - cols - 1]];
                coords[pIndex + 1] = coordsMap[ps[offset - cols - 1] + 1];
                coords[pIndex + 2] = coordsMap[ps[offset - cols]];
                coords[pIndex + 3] = coordsMap[ps[offset - cols] + 1];
                coords[pIndex + 4] = coordsMap[ps[offset - 1]];
                coords[pIndex + 5] = coordsMap[ps[offset - 1] + 1];
                colors[cIndex] = colorsMap[cs[offset - cols - 1]];
                colors[cIndex + 1] = colorsMap[cs[offset - cols - 1] + 1];
                colors[cIndex + 2] = colorsMap[cs[offset - cols - 1] + 2];
                colors[cIndex + 3] = colorsMap[cs[offset - cols]];
                colors[cIndex + 4] = colorsMap[cs[offset - cols] + 1];
                colors[cIndex + 5] = colorsMap[cs[offset - cols] + 2];
                colors[cIndex + 6] = colorsMap[cs[offset - 1]];
                colors[cIndex + 7] = colorsMap[cs[offset - 1] + 1];
                colors[cIndex + 8] = colorsMap[cs[offset - 1] + 2];
                coords[pIndex + 6] = coords[pIndex + 2];
                coords[pIndex + 7] = coords[pIndex + 3];
                coords[pIndex + 8] = coords[pIndex + 4];
                coords[pIndex + 9] = coords[pIndex + 5];
                coords[pIndex + 10] = coordsMap[ps[offset]];
                coords[pIndex + 11] = coordsMap[ps[offset] + 1];
                colors[cIndex + 9] = colors[cIndex + 3];
                colors[cIndex + 10] = colors[cIndex + 4];
                colors[cIndex + 11] = colors[cIndex + 5];
                colors[cIndex + 12] = colors[cIndex + 6];
                colors[cIndex + 13] = colors[cIndex + 7];
                colors[cIndex + 14] = colors[cIndex + 8];
                colors[cIndex + 15] = colorsMap[cs[offset]];
                colors[cIndex + 16] = colorsMap[cs[offset] + 1];
                colors[cIndex + 17] = colorsMap[cs[offset] + 2];
                pIndex += 12;
                cIndex += 18;
              }
            }

            break;

          case "triangles":
            for (let j = 0, jj = ps.length; j < jj; j++) {
              coords[pIndex] = coordsMap[ps[j]];
              coords[pIndex + 1] = coordsMap[ps[j] + 1];
              colors[cIndex] = colorsMap[cs[j]];
              colors[cIndex + 1] = colorsMap[cs[j] + 1];
              colors[cIndex + 2] = colorsMap[cs[j] + 2];
              pIndex += 2;
              cIndex += 3;
            }

            break;
        }
      }

      if (backgroundColor) {
        gl.clearColor(backgroundColor[0] / 255, backgroundColor[1] / 255, backgroundColor[2] / 255, 1.0);
      } else {
        gl.clearColor(0, 0, 0, 0);
      }

      gl.clear(gl.COLOR_BUFFER_BIT);
      const coordsBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, coordsBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, coords, gl.STATIC_DRAW);
      gl.enableVertexAttribArray(cache.positionLocation);
      gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);
      const colorsBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, colorsBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
      gl.enableVertexAttribArray(cache.colorLocation);
      gl.vertexAttribPointer(cache.colorLocation, 3, gl.UNSIGNED_BYTE, false, 0, 0);
      gl.uniform2f(cache.scaleLocation, context.scaleX, context.scaleY);
      gl.uniform2f(cache.offsetLocation, context.offsetX, context.offsetY);
      gl.drawArrays(gl.TRIANGLES, 0, count);
      gl.flush();
      gl.deleteBuffer(coordsBuffer);
      gl.deleteBuffer(colorsBuffer);
      return canvas;
    }

    return {
      tryInitGL() {
        try {
          generateGL();
          return !!currentGL;
        } catch (ex) {}

        return false;
      },

      composeSMask,
      drawFigures,

      cleanup() {
        if (smaskCache && smaskCache.canvas) { // lwf
          smaskCache.canvas.width = 0;
          smaskCache.canvas.height = 0;
        }

        if (figuresCache && figuresCache.canvas) { // lwf
          figuresCache.canvas.width = 0;
          figuresCache.canvas.height = 0;
        }

        smaskCache = null;
        figuresCache = null;
      }

    };
  }();

  /***/ }),
  /* 19 */
  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



  Object.defineProperty(exports, "__esModule", ({
    value: true
  }));
  exports.AnnotationLayer = void 0;

  var _display_utils = __w_pdfjs_require__(1);

  var _util = __w_pdfjs_require__(2);

  var _annotation_storage = __w_pdfjs_require__(8);

  var _scripting_utils = __w_pdfjs_require__(20);

  class AnnotationElementFactory {
    static create(parameters) {
      const subtype = parameters.data.annotationType;

      switch (subtype) {
        case _util.AnnotationType.LINK:
          return new LinkAnnotationElement(parameters);

        case _util.AnnotationType.TEXT:
          return new TextAnnotationElement(parameters);

        case _util.AnnotationType.WIDGET:
          const fieldType = parameters.data.fieldType;

          switch (fieldType) {
            case "Tx":
              return new TextWidgetAnnotationElement(parameters);

            case "Btn":
              if (parameters.data.radioButton) {
                return new RadioButtonWidgetAnnotationElement(parameters);
              } else if (parameters.data.checkBox) {
                return new CheckboxWidgetAnnotationElement(parameters);
              }

              return new PushButtonWidgetAnnotationElement(parameters);

            case "Ch":
              return new ChoiceWidgetAnnotationElement(parameters);
          }

          return new WidgetAnnotationElement(parameters);

        case _util.AnnotationType.POPUP:
          return new PopupAnnotationElement(parameters);

        case _util.AnnotationType.FREETEXT:
          return new FreeTextAnnotationElement(parameters);

        case _util.AnnotationType.LINE:
          return new LineAnnotationElement(parameters);

        case _util.AnnotationType.SQUARE:
          return new SquareAnnotationElement(parameters);

        case _util.AnnotationType.CIRCLE:
          return new CircleAnnotationElement(parameters);

        case _util.AnnotationType.POLYLINE:
          return new PolylineAnnotationElement(parameters);

        case _util.AnnotationType.CARET:
          return new CaretAnnotationElement(parameters);

        case _util.AnnotationType.INK:
          return new InkAnnotationElement(parameters);

        case _util.AnnotationType.POLYGON:
          return new PolygonAnnotationElement(parameters);

        case _util.AnnotationType.HIGHLIGHT:
          return new HighlightAnnotationElement(parameters);

        case _util.AnnotationType.UNDERLINE:
          return new UnderlineAnnotationElement(parameters);

        case _util.AnnotationType.SQUIGGLY:
          return new SquigglyAnnotationElement(parameters);

        case _util.AnnotationType.STRIKEOUT:
          return new StrikeOutAnnotationElement(parameters);

        case _util.AnnotationType.STAMP:
          return new StampAnnotationElement(parameters);

        case _util.AnnotationType.FILEATTACHMENT:
          return new FileAttachmentAnnotationElement(parameters);

        default:
          return new AnnotationElement(parameters);
      }
    }

  }

  class AnnotationElement {
    constructor(parameters, {
      isRenderable = false,
      ignoreBorder = false,
      createQuadrilaterals = false
    } = {}) {
      this.isRenderable = isRenderable;
      this.data = parameters.data;
      this.layer = parameters.layer;
      this.page = parameters.page;
      this.viewport = parameters.viewport;
      this.linkService = parameters.linkService;
      this.downloadManager = parameters.downloadManager;
      this.imageResourcesPath = parameters.imageResourcesPath;
      this.renderInteractiveForms = parameters.renderInteractiveForms;
      this.svgFactory = parameters.svgFactory;
      this.annotationStorage = parameters.annotationStorage;
      this.enableScripting = parameters.enableScripting;
      this.hasJSActions = parameters.hasJSActions;
      this._mouseState = parameters.mouseState;

      if (isRenderable) {
        this.container = this._createContainer(ignoreBorder);
      }

      if (createQuadrilaterals) {
        this.quadrilaterals = this._createQuadrilaterals(ignoreBorder);
      }
    }

    _createContainer(ignoreBorder = false) {
      const data = this.data,
            page = this.page,
            viewport = this.viewport;
      const container = document.createElement("section");
      let width = data.rect[2] - data.rect[0];
      let height = data.rect[3] - data.rect[1];
      container.setAttribute("data-annotation-id", data.id);

      const rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);

      container.style.transform = `matrix(${viewport.transform.join(",")})`;
      container.style.transformOrigin = `${-rect[0]}px ${-rect[1]}px`;

      if (!ignoreBorder && data.borderStyle.width > 0) {
        container.style.borderWidth = `${data.borderStyle.width}px`;

        if (data.borderStyle.style !== _util.AnnotationBorderStyleType.UNDERLINE) {
          width = width - 2 * data.borderStyle.width;
          height = height - 2 * data.borderStyle.width;
        }

        const horizontalRadius = data.borderStyle.horizontalCornerRadius;
        const verticalRadius = data.borderStyle.verticalCornerRadius;

        if (horizontalRadius > 0 || verticalRadius > 0) {
          const radius = `${horizontalRadius}px / ${verticalRadius}px`;
          container.style.borderRadius = radius;
        }

        switch (data.borderStyle.style) {
          case _util.AnnotationBorderStyleType.SOLID:
            container.style.borderStyle = "solid";
            break;

          case _util.AnnotationBorderStyleType.DASHED:
            container.style.borderStyle = "dashed";
            break;

          case _util.AnnotationBorderStyleType.BEVELED:
            (0, _util.warn)("Unimplemented border style: beveled");
            break;

          case _util.AnnotationBorderStyleType.INSET:
            (0, _util.warn)("Unimplemented border style: inset");
            break;

          case _util.AnnotationBorderStyleType.UNDERLINE:
            container.style.borderBottomStyle = "solid";
            break;

          default:
            break;
        }

        if (data.color) {
          container.style.borderColor = _util.Util.makeHexColor(data.color[0] | 0, data.color[1] | 0, data.color[2] | 0);
        } else {
          container.style.borderWidth = 0;
        }
      }

      container.style.left = `${rect[0]}px`;
      container.style.top = `${rect[1]}px`;
      container.style.width = `${width}px`;
      container.style.height = `${height}px`;
      return container;
    }

    _createQuadrilaterals(ignoreBorder = false) {
      if (!this.data.quadPoints) {
        return null;
      }

      const quadrilaterals = [];
      const savedRect = this.data.rect;

      for (const quadPoint of this.data.quadPoints) {
        this.data.rect = [quadPoint[2].x, quadPoint[2].y, quadPoint[1].x, quadPoint[1].y];
        quadrilaterals.push(this._createContainer(ignoreBorder));
      }

      this.data.rect = savedRect;
      return quadrilaterals;
    }

    _createPopup(trigger, data) {
      let container = this.container;

      if (this.quadrilaterals) {
        trigger = trigger || this.quadrilaterals;
        container = this.quadrilaterals[0];
      }

      if (!trigger) {
        trigger = document.createElement("div");
        trigger.style.height = container.style.height;
        trigger.style.width = container.style.width;
        container.appendChild(trigger);
      }

      const popupElement = new PopupElement({
        container,
        trigger,
        color: data.color,
        title: data.title,
        modificationDate: data.modificationDate,
        contents: data.contents,
        hideWrapper: true
      });
      const popup = popupElement.render();
      popup.style.left = container.style.width;
      container.appendChild(popup);
    }

    _renderQuadrilaterals(className) {
      this.quadrilaterals.forEach(quadrilateral => {
        quadrilateral.className = className;
      });
      return this.quadrilaterals;
    }

    render() {
      (0, _util.unreachable)("Abstract method `AnnotationElement.render` called");
    }

  }

  class LinkAnnotationElement extends AnnotationElement {
    constructor(parameters) {
      const isRenderable = !!(parameters.data.url || parameters.data.dest || parameters.data.action || parameters.data.isTooltipOnly || parameters.data.actions && (parameters.data.actions.Action || parameters.data.actions["Mouse Up"] || parameters.data.actions["Mouse Down"]));
      super(parameters, {
        isRenderable,
        createQuadrilaterals: true
      });
    }

    render() {
      const {
        data,
        linkService
      } = this;
      const link = document.createElement("a");

      if (data.url) {
        (0, _display_utils.addLinkAttributes)(link, {
          url: data.url,
          target: data.newWindow ? _display_utils.LinkTarget.BLANK : linkService.externalLinkTarget,
          rel: linkService.externalLinkRel,
          enabled: linkService.externalLinkEnabled
        });
      } else if (data.action) {
        this._bindNamedAction(link, data.action);
      } else if (data.dest) {
        this._bindLink(link, data.dest);
      } else if (data.actions && (data.actions.Action || data.actions["Mouse Up"] || data.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions) {
        this._bindJSAction(link, data);
      } else {
        this._bindLink(link, "");
      }

      if (this.quadrilaterals) {
        return this._renderQuadrilaterals("linkAnnotation").map((quadrilateral, index) => {
          const linkElement = index === 0 ? link : link.cloneNode();
          quadrilateral.appendChild(linkElement);
          return quadrilateral;
        });
      }

      this.container.className = "linkAnnotation";
      this.container.appendChild(link);
      return this.container;
    }

    _bindLink(link, destination) {
      link.href = this.linkService.getDestinationHash(destination);

      link.onclick = () => {
        if (destination) {
          this.linkService.goToDestination(destination);
        }

        return false;
      };

      if (destination || destination === "") {
        link.className = "internalLink";
      }
    }

    _bindNamedAction(link, action) {
      link.href = this.linkService.getAnchorUrl("");

      link.onclick = () => {
        this.linkService.executeNamedAction(action);
        return false;
      };

      link.className = "internalLink";
    }

    _bindJSAction(link, data) {
      link.href = this.linkService.getAnchorUrl("");
      const map = new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);

      for (const name of Object.keys(data.actions)) {
        const jsName = map.get(name);

        if (!jsName) {
          continue;
        }

        link[jsName] = () => {
          this.linkService.eventBus && this.linkService.eventBus.dispatch("dispatcheventinsandbox", { // lwf
            source: this,
            detail: {
              id: data.id,
              name
            }
          });
          return false;
        };
      }

      link.className = "internalLink";
    }

  }

  class TextAnnotationElement extends AnnotationElement {
    constructor(parameters) {
      const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
      super(parameters, {
        isRenderable
      });
    }

    render() {
      this.container.className = "textAnnotation";
      const image = document.createElement("img");
      image.style.height = this.container.style.height;
      image.style.width = this.container.style.width;
      image.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";
      image.alt = "[{{type}} Annotation]";
      image.dataset.l10nId = "text_annotation_type";
      image.dataset.l10nArgs = JSON.stringify({
        type: this.data.name
      });

      if (!this.data.hasPopup) {
        this._createPopup(image, this.data);
      }

      this.container.appendChild(image);
      return this.container;
    }

  }

  class WidgetAnnotationElement extends AnnotationElement {
    render() {
      if (this.data.alternativeText) {
        this.container.title = this.data.alternativeText;
      }

      return this.container;
    }

    _getKeyModifier(event) {
      return navigator.platform.includes("Win") && event.ctrlKey || navigator.platform.includes("Mac") && event.metaKey;
    }

    _setEventListener(element, baseName, eventName, valueGetter) {
      if (baseName.includes("mouse")) {
        element.addEventListener(baseName, event => {
          this.linkService.eventBus && this.linkService.eventBus.dispatch("dispatcheventinsandbox", { // lwf
            source: this,
            detail: {
              id: this.data.id,
              name: eventName,
              value: valueGetter(event),
              shift: event.shiftKey,
              modifier: this._getKeyModifier(event)
            }
          });
        });
      } else {
        element.addEventListener(baseName, event => {
          this.linkService.eventBus && this.linkService.eventBus.dispatch("dispatcheventinsandbox", { // lwf
            source: this,
            detail: {
              id: this.data.id,
              name: eventName,
              value: event.target.checked
            }
          });
        });
      }
    }

    _setEventListeners(element, names, getter) {
      for (const [baseName, eventName] of names) {
        if (eventName === "Action" || this.data.actions && this.data.actions[eventName]) { // lwf
          this._setEventListener(element, baseName, eventName, getter);
        }
      }
    }

  }

  class TextWidgetAnnotationElement extends WidgetAnnotationElement {
    constructor(parameters) {
      const isRenderable = parameters.renderInteractiveForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
      super(parameters, {
        isRenderable
      });
    }

    render() {
      const storage = this.annotationStorage;
      const id = this.data.id;
      this.container.className = "textWidgetAnnotation";
      let element = null;

      if (this.renderInteractiveForms) {
        const textContent = storage.getOrCreateValue(id, {
          value: this.data.fieldValue
        }).value;
        const elementData = {
          userValue: null,
          formattedValue: null,
          beforeInputSelectionRange: null,
          beforeInputValue: null
        };

        if (this.data.multiLine) {
          element = document.createElement("textarea");
          element.textContent = textContent;
        } else {
          element = document.createElement("input");
          element.type = "text";
          element.setAttribute("value", textContent);
        }

        elementData.userValue = textContent;
        element.setAttribute("id", id);
        element.addEventListener("input", function (event) {
          storage.setValue(id, {
            value: event.target.value
          });
        });

        let blurListener = event => {
          if (elementData.formattedValue) {
            event.target.value = elementData.formattedValue;
          }

          event.target.setSelectionRange(0, 0);
          elementData.beforeInputSelectionRange = null;
        };

        if (this.enableScripting && this.hasJSActions) {
          element.addEventListener("focus", event => {
            if (elementData.userValue) {
              event.target.value = elementData.userValue;
            }
          });
          element.addEventListener("updatefromsandbox", function (event) {
            const {
              detail
            } = event;
            const actions = {
              value() {
                elementData.userValue = detail.value || "";
                storage.setValue(id, {
                  value: elementData.userValue.toString()
                });

                if (!elementData.formattedValue) {
                  event.target.value = elementData.userValue;
                }
              },

              valueAsString() {
                elementData.formattedValue = detail.valueAsString || "";

                if (event.target !== document.activeElement) {
                  event.target.value = elementData.formattedValue;
                }

                storage.setValue(id, {
                  formattedValue: elementData.formattedValue
                });
              },

              focus() {
                setTimeout(() => event.target.focus({
                  preventScroll: false
                }), 0);
              },

              userName() {
                event.target.title = detail.userName;
              },

              hidden() {
                event.target.style.visibility = detail.hidden ? "hidden" : "visible";
                storage.setValue(id, {
                  hidden: detail.hidden
                });
              },

              editable() {
                event.target.disabled = !detail.editable;
              },

              selRange() {
                const [selStart, selEnd] = detail.selRange;

                if (selStart >= 0 && selEnd < event.target.value.length) {
                  event.target.setSelectionRange(selStart, selEnd);
                }
              },

              strokeColor() {
                const color = detail.strokeColor;
                event.target.style.color = _scripting_utils.ColorConverters[`${color[0]}_HTML`](color.slice(1));
              }

            };
            Object.keys(detail).filter(name => name in actions).forEach(name => actions[name]());
          });

          if (this.data.actions) {
            element.addEventListener("keydown", event => {
              elementData.beforeInputValue = event.target.value;
              let commitKey = -1;

              if (event.key === "Escape") {
                commitKey = 0;
              } else if (event.key === "Enter") {
                commitKey = 2;
              } else if (event.key === "Tab") {
                commitKey = 3;
              }

              if (commitKey === -1) {
                return;
              }

              elementData.userValue = event.target.value;
              this.linkService.eventBus && this.linkService.eventBus.dispatch("dispatcheventinsandbox", { // lwf
                source: this,
                detail: {
                  id,
                  name: "Keystroke",
                  value: event.target.value,
                  willCommit: true,
                  commitKey,
                  selStart: event.target.selectionStart,
                  selEnd: event.target.selectionEnd
                }
              });
            });
            const _blurListener = blurListener;
            blurListener = null;
            element.addEventListener("blur", event => {
              if (this._mouseState.isDown) {
                elementData.userValue = event.target.value;
                this.linkService.eventBus && this.linkService.eventBus.dispatch("dispatcheventinsandbox", { // lwf
                  source: this,
                  detail: {
                    id,
                    name: "Keystroke",
                    value: event.target.value,
                    willCommit: true,
                    commitKey: 1,
                    selStart: event.target.selectionStart,
                    selEnd: event.target.selectionEnd
                  }
                });
              }

              _blurListener(event);
            });
            element.addEventListener("mousedown", event => {
              elementData.beforeInputValue = event.target.value;
              elementData.beforeInputSelectionRange = null;
            });
            element.addEventListener("keyup", event => {
              if (event.target.selectionStart === event.target.selectionEnd) {
                elementData.beforeInputSelectionRange = null;
              }
            });
            element.addEventListener("select", event => {
              elementData.beforeInputSelectionRange = [event.target.selectionStart, event.target.selectionEnd];
            });

            if ("Keystroke" in this.data.actions) {
              element.addEventListener("input", event => {
                let selStart = -1;
                let selEnd = -1;

                if (elementData.beforeInputSelectionRange) {
                  [selStart, selEnd] = elementData.beforeInputSelectionRange;
                }

                this.linkService.eventBus && this.linkService.eventBus.dispatch("dispatcheventinsandbox", { // lwf
                  source: this,
                  detail: {
                    id,
                    name: "Keystroke",
                    value: elementData.beforeInputValue,
                    change: event.data,
                    willCommit: false,
                    selStart,
                    selEnd
                  }
                });
              });
            }

            this._setEventListeners(element, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], event => event.target.value);
          }
        }

        if (blurListener) {
          element.addEventListener("blur", blurListener);
        }

        element.disabled = this.data.readOnly;
        element.name = this.data.fieldName;

        if (this.data.maxLen !== null) {
          element.maxLength = this.data.maxLen;
        }

        if (this.data.comb) {
          const fieldWidth = this.data.rect[2] - this.data.rect[0];
          const combWidth = fieldWidth / this.data.maxLen;
          element.classList.add("comb");
          element.style.letterSpacing = `calc(${combWidth}px - 1ch)`;
        }
      } else {
        element = document.createElement("div");
        element.textContent = this.data.fieldValue;
        element.style.verticalAlign = "middle";
        element.style.display = "table-cell";
      }

      this._setTextStyle(element);

      this.container.appendChild(element);
      return this.container;
    }

    _setTextStyle(element) {
      const TEXT_ALIGNMENT = ["left", "center", "right"];
      const {
        fontSize,
        fontColor
      } = this.data.defaultAppearanceData;
      const style = element.style;

      if (fontSize) {
        style.fontSize = `${fontSize}px`;
      }

      style.color = _util.Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);

      if (this.data.textAlignment !== null) {
        style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
      }
    }

  }

  class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {
    constructor(parameters) {
      super(parameters, {
        isRenderable: parameters.renderInteractiveForms
      });
    }

    render() {
      const storage = this.annotationStorage;
      const data = this.data;
      const id = data.id;
      const value = storage.getOrCreateValue(id, {
        value: data.fieldValue && data.fieldValue !== "Off"
      }).value;
      this.container.className = "buttonWidgetAnnotation checkBox";
      const element = document.createElement("input");
      element.disabled = data.readOnly;
      element.type = "checkbox";
      element.name = this.data.fieldName;

      if (value) {
        element.setAttribute("checked", true);
      }

      element.setAttribute("id", id);
      element.addEventListener("change", function (event) {
        const name = event.target.name;

        for (const checkbox of document.getElementsByName(name)) {
          if (checkbox !== event.target) {
            checkbox.checked = false;
            storage.setValue(checkbox.parentNode.getAttribute("data-annotation-id"), {
              value: false
            });
          }
        }

        storage.setValue(id, {
          value: event.target.checked
        });
      });

      if (this.enableScripting && this.hasJSActions) {
        element.addEventListener("updatefromsandbox", event => {
          const {
            detail
          } = event;
          const actions = {
            value() {
              event.target.checked = detail.value !== "Off";
              storage.setValue(id, {
                value: event.target.checked
              });
            },

            focus() {
              setTimeout(() => event.target.focus({
                preventScroll: false
              }), 0);
            },

            hidden() {
              event.target.style.visibility = detail.hidden ? "hidden" : "visible";
              storage.setValue(id, {
                hidden: detail.hidden
              });
            },

            editable() {
              event.target.disabled = !detail.editable;
            }

          };
          Object.keys(detail).filter(name => name in actions).forEach(name => actions[name]());
        });

        this._setEventListeners(element, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], event => event.target.checked);
      }

      this.container.appendChild(element);
      return this.container;
    }

  }

  class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {
    constructor(parameters) {
      super(parameters, {
        isRenderable: parameters.renderInteractiveForms
      });
    }

    render() {
      this.container.className = "buttonWidgetAnnotation radioButton";
      const storage = this.annotationStorage;
      const data = this.data;
      const id = data.id;
      const value = storage.getOrCreateValue(id, {
        value: data.fieldValue === data.buttonValue
      }).value;
      const element = document.createElement("input");
      element.disabled = data.readOnly;
      element.type = "radio";
      element.name = data.fieldName;

      if (value) {
        element.setAttribute("checked", true);
      }

      element.setAttribute("pdfButtonValue", data.buttonValue);
      element.setAttribute("id", id);
      element.addEventListener("change", function (event) {
        const {
          target
        } = event;

        for (const radio of document.getElementsByName(target.name)) {
          if (radio !== target) {
            storage.setValue(radio.getAttribute("id"), {
              value: false
            });
          }
        }

        storage.setValue(id, {
          value: target.checked
        });
      });

      if (this.enableScripting && this.hasJSActions) {
        element.addEventListener("updatefromsandbox", event => {
          const {
            detail
          } = event;
          const actions = {
            value() {
              const fieldValue = detail.value;

              for (const radio of document.getElementsByName(event.target.name)) {
                const radioId = radio.getAttribute("id");

                if (fieldValue === radio.getAttribute("pdfButtonValue")) {
                  radio.setAttribute("checked", true);
                  storage.setValue(radioId, {
                    value: true
                  });
                } else {
                  storage.setValue(radioId, {
                    value: false
                  });
                }
              }
            },

            focus() {
              setTimeout(() => event.target.focus({
                preventScroll: false
              }), 0);
            },

            hidden() {
              event.target.style.visibility = detail.hidden ? "hidden" : "visible";
              storage.setValue(id, {
                hidden: detail.hidden
              });
            },

            editable() {
              event.target.disabled = !detail.editable;
            }

          };
          Object.keys(detail).filter(name => name in actions).forEach(name => actions[name]());
        });

        this._setEventListeners(element, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], event => event.target.checked);
      }

      this.container.appendChild(element);
      return this.container;
    }

  }

  class PushButtonWidgetAnnotationElement extends LinkAnnotationElement {
    render() {
      const container = super.render();
      container.className = "buttonWidgetAnnotation pushButton";

      if (this.data.alternativeText) {
        container.title = this.data.alternativeText;
      }

      return container;
    }

  }

  class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {
    constructor(parameters) {
      super(parameters, {
        isRenderable: parameters.renderInteractiveForms
      });
    }

    render() {
      this.container.className = "choiceWidgetAnnotation";
      const storage = this.annotationStorage;
      const id = this.data.id;
      storage.getOrCreateValue(id, {
        value: this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : undefined
      });
      const selectElement = document.createElement("select");
      selectElement.disabled = this.data.readOnly;
      selectElement.name = this.data.fieldName;
      selectElement.setAttribute("id", id);

      if (!this.data.combo) {
        selectElement.size = this.data.options.length;

        if (this.data.multiSelect) {
          selectElement.multiple = true;
        }
      }

      for (const option of this.data.options) {
        const optionElement = document.createElement("option");
        optionElement.textContent = option.displayValue;
        optionElement.value = option.exportValue;

        if (this.data.fieldValue.includes(option.exportValue)) {
          optionElement.setAttribute("selected", true);
        }

        selectElement.appendChild(optionElement);
      }

      function getValue(event) {
        const options = event.target.options;
        return options[options.selectedIndex].value;
      }

      if (this.enableScripting && this.hasJSActions) {
        selectElement.addEventListener("updatefromsandbox", event => {
          const {
            detail
          } = event;
          const actions = {
            value() {
              const options = event.target.options;
              const value = detail.value;
              const i = options.indexOf(value);

              if (i !== -1) {
                options.selectedIndex = i;
                storage.setValue(id, {
                  value
                });
              }
            },

            focus() {
              setTimeout(() => event.target.focus({
                preventScroll: false
              }), 0);
            },

            hidden() {
              event.target.style.visibility = detail.hidden ? "hidden" : "visible";
              storage.setValue(id, {
                hidden: detail.hidden
              });
            },

            editable() {
              event.target.disabled = !detail.editable;
            }

          };
          Object.keys(detail).filter(name => name in actions).forEach(name => actions[name]());
        });
        selectElement.addEventListener("input", event => {
          const value = getValue(event);
          storage.setValue(id, {
            value
          });
          this.linkService.eventBus && this.linkService.eventBus.dispatch("dispatcheventinsandbox", { //lwf
            source: this,
            detail: {
              id,
              name: "Keystroke",
              changeEx: value,
              willCommit: true,
              commitKey: 1,
              keyDown: false
            }
          });
        });

        this._setEventListeners(selectElement, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], event => event.target.checked);
      } else {
        selectElement.addEventListener("input", function (event) {
          storage.setValue(id, {
            value: getValue(event)
          });
        });
      }

      this.container.appendChild(selectElement);
      return this.container;
    }

  }

  class PopupAnnotationElement extends AnnotationElement {
    constructor(parameters) {
      const isRenderable = !!(parameters.data.title || parameters.data.contents);
      super(parameters, {
        isRenderable
      });
    }

    render() {
      const IGNORE_TYPES = ["Line", "Square", "Circle", "PolyLine", "Polygon", "Ink"];
      this.container.className = "popupAnnotation";

      if (IGNORE_TYPES.includes(this.data.parentType)) {
        return this.container;
      }

      const selector = `[data-annotation-id="${this.data.parentId}"]`;
      const parentElements = this.layer.querySelectorAll(selector);

      if (parentElements.length === 0) {
        return this.container;
      }

      const popup = new PopupElement({
        container: this.container,
        trigger: Array.from(parentElements),
        color: this.data.color,
        title: this.data.title,
        modificationDate: this.data.modificationDate,
        contents: this.data.contents
      });
      const page = this.page;

      const rect = _util.Util.normalizeRect([this.data.parentRect[0], page.view[3] - this.data.parentRect[1] + page.view[1], this.data.parentRect[2], page.view[3] - this.data.parentRect[3] + page.view[1]]);

      const popupLeft = rect[0] + this.data.parentRect[2] - this.data.parentRect[0];
      const popupTop = rect[1];
      this.container.style.transformOrigin = `${-popupLeft}px ${-popupTop}px`;
      this.container.style.left = `${popupLeft}px`;
      this.container.style.top = `${popupTop}px`;
      this.container.appendChild(popup.render());
      return this.container;
    }

  }

  class PopupElement {
    constructor(parameters) {
      this.container = parameters.container;
      this.trigger = parameters.trigger;
      this.color = parameters.color;
      this.title = parameters.title;
      this.modificationDate = parameters.modificationDate;
      this.contents = parameters.contents;
      this.hideWrapper = parameters.hideWrapper || false;
      this.pinned = false;
    }

    render() {
      const BACKGROUND_ENLIGHT = 0.7;
      const wrapper = document.createElement("div");
      wrapper.className = "popupWrapper";
      this.hideElement = this.hideWrapper ? wrapper : this.container;
      this.hideElement.setAttribute("hidden", true);
      const popup = document.createElement("div");
      popup.className = "popup";
      const color = this.color;

      if (color) {
        const r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];
        const g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];
        const b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];
        popup.style.backgroundColor = _util.Util.makeHexColor(r | 0, g | 0, b | 0);
      }

      const title = document.createElement("h1");
      title.textContent = this.title;
      popup.appendChild(title);

      const dateObject = _display_utils.PDFDateString.toDateObject(this.modificationDate);

      if (dateObject) {
        const modificationDate = document.createElement("span");
        modificationDate.textContent = "{{date}}, {{time}}";
        modificationDate.dataset.l10nId = "annotation_date_string";
        modificationDate.dataset.l10nArgs = JSON.stringify({
          date: dateObject.toLocaleDateString(),
          time: dateObject.toLocaleTimeString()
        });
        popup.appendChild(modificationDate);
      }

      const contents = this._formatContents(this.contents);

      popup.appendChild(contents);

      if (!Array.isArray(this.trigger)) {
        this.trigger = [this.trigger];
      }

      this.trigger.forEach(element => {
        element.addEventListener("click", this._toggle.bind(this));
        element.addEventListener("mouseover", this._show.bind(this, false));
        element.addEventListener("mouseout", this._hide.bind(this, false));
      });
      popup.addEventListener("click", this._hide.bind(this, true));
      wrapper.appendChild(popup);
      return wrapper;
    }

    _formatContents(contents) {
      const p = document.createElement("p");
      const lines = contents.split(/(?:\r\n?|\n)/);

      for (let i = 0, ii = lines.length; i < ii; ++i) {
        const line = lines[i];
        p.appendChild(document.createTextNode(line));

        if (i < ii - 1) {
          p.appendChild(document.createElement("br"));
        }
      }

      return p;
    }

    _toggle() {
      if (this.pinned) {
        this._hide(true);
      } else {
        this._show(true);
      }
    }

    _show(pin = false) {
      if (pin) {
        this.pinned = true;
      }

      if (this.hideElement.hasAttribute("hidden")) {
        this.hideElement.removeAttribute("hidden");
        this.container.style.zIndex += 1;
      }
    }

    _hide(unpin = true) {
      if (unpin) {
        this.pinned = false;
      }

      if (!this.hideElement.hasAttribute("hidden") && !this.pinned) {
        this.hideElement.setAttribute("hidden", true);
        this.container.style.zIndex -= 1;
      }
    }

  }

  class FreeTextAnnotationElement extends AnnotationElement {
    constructor(parameters) {
      const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
      super(parameters, {
        isRenderable,
        ignoreBorder: true
      });
    }

    render() {
      this.container.className = "freeTextAnnotation";

      if (!this.data.hasPopup) {
        this._createPopup(null, this.data);
      }

      return this.container;
    }

  }

  class LineAnnotationElement extends AnnotationElement {
    constructor(parameters) {
      const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
      super(parameters, {
        isRenderable,
        ignoreBorder: true
      });
    }

    render() {
      this.container.className = "lineAnnotation";
      const data = this.data;
      const width = data.rect[2] - data.rect[0];
      const height = data.rect[3] - data.rect[1];
      const svg = this.svgFactory.create(width, height);
      const line = this.svgFactory.createElement("svg:line");
      line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
      line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
      line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
      line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
      line.setAttribute("stroke-width", data.borderStyle.width || 1);
      line.setAttribute("stroke", "transparent");
      svg.appendChild(line);
      this.container.append(svg);

      this._createPopup(line, data);

      return this.container;
    }

  }

  class SquareAnnotationElement extends AnnotationElement {
    constructor(parameters) {
      const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
      super(parameters, {
        isRenderable,
        ignoreBorder: true
      });
    }

    render() {
      this.container.className = "squareAnnotation";
      const data = this.data;
      const width = data.rect[2] - data.rect[0];
      const height = data.rect[3] - data.rect[1];
      const svg = this.svgFactory.create(width, height);
      const borderWidth = data.borderStyle.width;
      const square = this.svgFactory.createElement("svg:rect");
      square.setAttribute("x", borderWidth / 2);
      square.setAttribute("y", borderWidth / 2);
      square.setAttribute("width", width - borderWidth);
      square.setAttribute("height", height - borderWidth);
      square.setAttribute("stroke-width", borderWidth || 1);
      square.setAttribute("stroke", "transparent");
      square.setAttribute("fill", "none");
      svg.appendChild(square);
      this.container.append(svg);

      this._createPopup(square, data);

      return this.container;
    }

  }

  class CircleAnnotationElement extends AnnotationElement {
    constructor(parameters) {
      const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
      super(parameters, {
        isRenderable,
        ignoreBorder: true
      });
    }

    render() {
      this.container.className = "circleAnnotation";
      const data = this.data;
      const width = data.rect[2] - data.rect[0];
      const height = data.rect[3] - data.rect[1];
      const svg = this.svgFactory.create(width, height);
      const borderWidth = data.borderStyle.width;
      const circle = this.svgFactory.createElement("svg:ellipse");
      circle.setAttribute("cx", width / 2);
      circle.setAttribute("cy", height / 2);
      circle.setAttribute("rx", width / 2 - borderWidth / 2);
      circle.setAttribute("ry", height / 2 - borderWidth / 2);
      circle.setAttribute("stroke-width", borderWidth || 1);
      circle.setAttribute("stroke", "transparent");
      circle.setAttribute("fill", "none");
      svg.appendChild(circle);
      this.container.append(svg);

      this._createPopup(circle, data);

      return this.container;
    }

  }

  class PolylineAnnotationElement extends AnnotationElement {
    constructor(parameters) {
      const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
      super(parameters, {
        isRenderable,
        ignoreBorder: true
      });
      this.containerClassName = "polylineAnnotation";
      this.svgElementName = "svg:polyline";
    }

    render() {
      this.container.className = this.containerClassName;
      const data = this.data;
      const width = data.rect[2] - data.rect[0];
      const height = data.rect[3] - data.rect[1];
      const svg = this.svgFactory.create(width, height);
      let points = [];

      for (const coordinate of data.vertices) {
        const x = coordinate.x - data.rect[0];
        const y = data.rect[3] - coordinate.y;
        points.push(x + "," + y);
      }

      points = points.join(" ");
      const polyline = this.svgFactory.createElement(this.svgElementName);
      polyline.setAttribute("points", points);
      polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
      polyline.setAttribute("stroke", "transparent");
      polyline.setAttribute("fill", "none");
      svg.appendChild(polyline);
      this.container.append(svg);

      this._createPopup(polyline, data);

      return this.container;
    }

  }

  class PolygonAnnotationElement extends PolylineAnnotationElement {
    constructor(parameters) {
      super(parameters);
      this.containerClassName = "polygonAnnotation";
      this.svgElementName = "svg:polygon";
    }

  }

  class CaretAnnotationElement extends AnnotationElement {
    constructor(parameters) {
      const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
      super(parameters, {
        isRenderable,
        ignoreBorder: true
      });
    }

    render() {
      this.container.className = "caretAnnotation";

      if (!this.data.hasPopup) {
        this._createPopup(null, this.data);
      }

      return this.container;
    }

  }

  class InkAnnotationElement extends AnnotationElement {
    constructor(parameters) {
      const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
      super(parameters, {
        isRenderable,
        ignoreBorder: true
      });
      this.containerClassName = "inkAnnotation";
      this.svgElementName = "svg:polyline";
    }

    render() {
      this.container.className = this.containerClassName;
      const data = this.data;
      const width = data.rect[2] - data.rect[0];
      const height = data.rect[3] - data.rect[1];
      const svg = this.svgFactory.create(width, height);

      for (const inkList of data.inkLists) {
        let points = [];

        for (const coordinate of inkList) {
          const x = coordinate.x - data.rect[0];
          const y = data.rect[3] - coordinate.y;
          points.push(`${x},${y}`);
        }

        points = points.join(" ");
        const polyline = this.svgFactory.createElement(this.svgElementName);
        polyline.setAttribute("points", points);
        polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
        polyline.setAttribute("stroke", "transparent");
        polyline.setAttribute("fill", "none");

        this._createPopup(polyline, data);

        svg.appendChild(polyline);
      }

      this.container.append(svg);
      return this.container;
    }

  }

  class HighlightAnnotationElement extends AnnotationElement {
    constructor(parameters) {
      const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
      super(parameters, {
        isRenderable,
        ignoreBorder: true,
        createQuadrilaterals: true
      });
    }

    render() {
      if (!this.data.hasPopup) {
        this._createPopup(null, this.data);
      }

      if (this.quadrilaterals) {
        return this._renderQuadrilaterals("highlightAnnotation");
      }

      this.container.className = "highlightAnnotation";
      return this.container;
    }

  }

  class UnderlineAnnotationElement extends AnnotationElement {
    constructor(parameters) {
      const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
      super(parameters, {
        isRenderable,
        ignoreBorder: true,
        createQuadrilaterals: true
      });
    }

    render() {
      if (!this.data.hasPopup) {
        this._createPopup(null, this.data);
      }

      if (this.quadrilaterals) {
        return this._renderQuadrilaterals("underlineAnnotation");
      }

      this.container.className = "underlineAnnotation";
      return this.container;
    }

  }

  class SquigglyAnnotationElement extends AnnotationElement {
    constructor(parameters) {
      const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
      super(parameters, {
        isRenderable,
        ignoreBorder: true,
        createQuadrilaterals: true
      });
    }

    render() {
      if (!this.data.hasPopup) {
        this._createPopup(null, this.data);
      }

      if (this.quadrilaterals) {
        return this._renderQuadrilaterals("squigglyAnnotation");
      }

      this.container.className = "squigglyAnnotation";
      return this.container;
    }

  }

  class StrikeOutAnnotationElement extends AnnotationElement {
    constructor(parameters) {
      const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
      super(parameters, {
        isRenderable,
        ignoreBorder: true,
        createQuadrilaterals: true
      });
    }

    render() {
      if (!this.data.hasPopup) {
        this._createPopup(null, this.data);
      }

      if (this.quadrilaterals) {
        return this._renderQuadrilaterals("strikeoutAnnotation");
      }

      this.container.className = "strikeoutAnnotation";
      return this.container;
    }

  }

  class StampAnnotationElement extends AnnotationElement {
    constructor(parameters) {
      const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
      super(parameters, {
        isRenderable,
        ignoreBorder: true
      });
    }

    render() {
      this.container.className = "stampAnnotation";

      if (!this.data.hasPopup) {
        this._createPopup(null, this.data);
      }

      return this.container;
    }

  }

  class FileAttachmentAnnotationElement extends AnnotationElement {
    constructor(parameters) {
      super(parameters, {
        isRenderable: true
      });
      const {
        filename,
        content
      } = this.data.file;
      this.filename = (0, _display_utils.getFilenameFromUrl)(filename);
      this.content = content;
      this.linkService.eventBus && this.linkService.eventBus.dispatch("fileattachmentannotation", { // lwf
        source: this,
        id: (0, _util.stringToPDFString)(filename),
        filename,
        content
      });
    }

    render() {
      this.container.className = "fileAttachmentAnnotation";
      const trigger = document.createElement("div");
      trigger.style.height = this.container.style.height;
      trigger.style.width = this.container.style.width;
      trigger.addEventListener("dblclick", this._download.bind(this));

      if (!this.data.hasPopup && (this.data.title || this.data.contents)) {
        this._createPopup(trigger, this.data);
      }

      this.container.appendChild(trigger);
      return this.container;
    }

    _download() {
      if (!this.downloadManager) {
        (0, _util.warn)("Download cannot be started due to unavailable download manager");
        return;
      }

      this.downloadManager.downloadData(this.content, this.filename, "");
    }

  }

  class AnnotationLayer {
    static render(parameters) {
      const sortedAnnotations = [],
            popupAnnotations = [];

      for (const data of parameters.annotations) {
        if (!data) {
          continue;
        }

        if (data.annotationType === _util.AnnotationType.POPUP) {
          popupAnnotations.push(data);
          continue;
        }

        sortedAnnotations.push(data);
      }

      if (popupAnnotations.length) {
        sortedAnnotations.push(...popupAnnotations);
      }

      for (const data of sortedAnnotations) {
        const element = AnnotationElementFactory.create({
          data,
          layer: parameters.div,
          page: parameters.page,
          viewport: parameters.viewport,
          linkService: parameters.linkService,
          downloadManager: parameters.downloadManager,
          imageResourcesPath: parameters.imageResourcesPath || "",
          renderInteractiveForms: typeof parameters.renderInteractiveForms === "boolean" ? parameters.renderInteractiveForms : true,
          svgFactory: new _display_utils.DOMSVGFactory(),
          annotationStorage: parameters.annotationStorage || new _annotation_storage.AnnotationStorage(),
          enableScripting: parameters.enableScripting,
          hasJSActions: parameters.hasJSActions,
          mouseState: parameters.mouseState || {
            isDown: false
          }
        });

        if (element.isRenderable) {
          const rendered = element.render();

          if (data.hidden) {
            rendered.style.visibility = "hidden";
          }

          if (Array.isArray(rendered)) {
            for (const renderedElement of rendered) {
              parameters.div.appendChild(renderedElement);
            }
          } else {
            if (element instanceof PopupAnnotationElement) {
              parameters.div.prepend(rendered);
            } else {
              parameters.div.appendChild(rendered);
            }
          }
        }
      }
    }

    static update(parameters) {
      const transform = `matrix(${parameters.viewport.transform.join(",")})`;

      for (const data of parameters.annotations) {
        const elements = parameters.div.querySelectorAll(`[data-annotation-id="${data.id}"]`);

        if (elements) {
          elements.forEach(element => {
            element.style.transform = transform;
          });
        }
      }

      parameters.div.removeAttribute("hidden");
    }

  }

  exports.AnnotationLayer = AnnotationLayer;

  /***/ }),
  /* 20 */
  /***/ ((__unused_webpack_module, exports) => {



  Object.defineProperty(exports, "__esModule", ({
    value: true
  }));
  exports.ColorConverters = void 0;

  function makeColorComp(n) {
    return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, "0");
  }

  class ColorConverters {
    static CMYK_G([c, y, m, k]) {
      return ["G", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];
    }

    static G_CMYK([g]) {
      return ["CMYK", 0, 0, 0, 1 - g];
    }

    static G_RGB([g]) {
      return ["RGB", g, g, g];
    }

    static G_HTML([g]) {
      const G = makeColorComp(g);
      return `#${G}${G}${G}`;
    }

    static RGB_G([r, g, b]) {
      return ["G", 0.3 * r + 0.59 * g + 0.11 * b];
    }

    static RGB_HTML([r, g, b]) {
      const R = makeColorComp(r);
      const G = makeColorComp(g);
      const B = makeColorComp(b);
      return `#${R}${G}${B}`;
    }

    static T_HTML() {
      return "#00000000";
    }

    static CMYK_RGB([c, y, m, k]) {
      return ["RGB", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];
    }

    static CMYK_HTML(components) {
      return this.RGB_HTML(this.CMYK_RGB(components));
    }

    static RGB_CMYK([r, g, b]) {
      const c = 1 - r;
      const m = 1 - g;
      const y = 1 - b;
      const k = Math.min(c, m, y);
      return ["CMYK", c, m, y, k];
    }

  }

  exports.ColorConverters = ColorConverters;

  /***/ }),
  /* 21 */
  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



  Object.defineProperty(exports, "__esModule", ({
    value: true
  }));
  exports.renderTextLayer = void 0;

  var _util = __w_pdfjs_require__(2);

  const renderTextLayer = function renderTextLayerClosure() {
    const MAX_TEXT_DIVS_TO_RENDER = 100000;
    const NonWhitespaceRegexp = /\S/;

    function isAllWhitespace(str) {
      return !NonWhitespaceRegexp.test(str);
    }

    function appendText(task, geom, styles) {
      const textDiv = document.createElement("span");
      const textDivProperties = {
        angle: 0,
        canvasWidth: 0,
        isWhitespace: false,
        originalTransform: null,
        paddingBottom: 0,
        paddingLeft: 0,
        paddingRight: 0,
        paddingTop: 0,
        scale: 1
      };

      task._textDivs.push(textDiv);

      if (isAllWhitespace(geom.str)) {
        textDivProperties.isWhitespace = true;

        task._textDivProperties.set(textDiv, textDivProperties);

        return;
      }

      const tx = _util.Util.transform(task._viewport.transform, geom.transform);

      let angle = Math.atan2(tx[1], tx[0]);
      const style = styles[geom.fontName];

      if (style.vertical) {
        angle += Math.PI / 2;
      }

      const fontHeight = Math.sqrt(tx[2] * tx[2] + tx[3] * tx[3]);
      let fontAscent = fontHeight;

      if (style.ascent) {
        fontAscent = style.ascent * fontAscent;
      } else if (style.descent) {
        fontAscent = (1 + style.descent) * fontAscent;
      }

      let left, top;

      if (angle === 0) {
        left = tx[4];
        top = tx[5] - fontAscent;
      } else {
        left = tx[4] + fontAscent * Math.sin(angle);
        top = tx[5] - fontAscent * Math.cos(angle);
      }

      textDiv.style.left = `${left}px`;
      textDiv.style.top = `${top}px`;
      textDiv.style.fontSize = `${fontHeight}px`;
      textDiv.style.fontFamily = style.fontFamily;
      textDiv.textContent = geom.str;

      if (task._fontInspectorEnabled) {
        textDiv.dataset.fontName = geom.fontName;
      }

      if (angle !== 0) {
        textDivProperties.angle = angle * (180 / Math.PI);
      }

      let shouldScaleText = false;

      if (geom.str.length > 1) {
        shouldScaleText = true;
      } else if (geom.transform[0] !== geom.transform[3]) {
        const absScaleX = Math.abs(geom.transform[0]),
              absScaleY = Math.abs(geom.transform[3]);

        if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {
          shouldScaleText = true;
        }
      }

      if (shouldScaleText) {
        if (style.vertical) {
          textDivProperties.canvasWidth = geom.height * task._viewport.scale;
        } else {
          textDivProperties.canvasWidth = geom.width * task._viewport.scale;
        }
      }

      task._textDivProperties.set(textDiv, textDivProperties);

      if (task._textContentStream) {
        task._layoutText(textDiv);
      }

      if (task._enhanceTextSelection) {
        let angleCos = 1,
            angleSin = 0;

        if (angle !== 0) {
          angleCos = Math.cos(angle);
          angleSin = Math.sin(angle);
        }

        const divWidth = (style.vertical ? geom.height : geom.width) * task._viewport.scale;
        const divHeight = fontHeight;
        let m, b;

        if (angle !== 0) {
          m = [angleCos, angleSin, -angleSin, angleCos, left, top];
          b = _util.Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m);
        } else {
          b = [left, top, left + divWidth, top + divHeight];
        }

        task._bounds.push({
          left: b[0],
          top: b[1],
          right: b[2],
          bottom: b[3],
          div: textDiv,
          size: [divWidth, divHeight],
          m
        });
      }
    }

    function render(task) {
      if (task._canceled) {
        return;
      }

      const textDivs = task._textDivs;
      const capability = task._capability;
      const textDivsLength = textDivs.length;

      if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {
        task._renderingDone = true;
        capability.resolve();
        return;
      }

      if (!task._textContentStream) {
        for (let i = 0; i < textDivsLength; i++) {
          task._layoutText(textDivs[i]);
        }
      }

      task._renderingDone = true;
      capability.resolve();
    }

    function findPositiveMin(ts, offset, count) {
      let result = 0;

      for (let i = 0; i < count; i++) {
        const t = ts[offset++];

        if (t > 0) {
          result = result ? Math.min(t, result) : t;
        }
      }

      return result;
    }

    function expand(task) {
      const bounds = task._bounds;
      const viewport = task._viewport;
      const expanded = expandBounds(viewport.width, viewport.height, bounds);

      for (let i = 0; i < expanded.length; i++) {
        const div = bounds[i].div;

        const divProperties = task._textDivProperties.get(div);

        if (divProperties.angle === 0) {
          divProperties.paddingLeft = bounds[i].left - expanded[i].left;
          divProperties.paddingTop = bounds[i].top - expanded[i].top;
          divProperties.paddingRight = expanded[i].right - bounds[i].right;
          divProperties.paddingBottom = expanded[i].bottom - bounds[i].bottom;

          task._textDivProperties.set(div, divProperties);

          continue;
        }

        const e = expanded[i],
              b = bounds[i];
        const m = b.m,
              c = m[0],
              s = m[1];
        const points = [[0, 0], [0, b.size[1]], [b.size[0], 0], b.size];
        const ts = new Float64Array(64);
        points.forEach(function (p, j) {
          const t = _util.Util.applyTransform(p, m);

          ts[j + 0] = c && (e.left - t[0]) / c;
          ts[j + 4] = s && (e.top - t[1]) / s;
          ts[j + 8] = c && (e.right - t[0]) / c;
          ts[j + 12] = s && (e.bottom - t[1]) / s;
          ts[j + 16] = s && (e.left - t[0]) / -s;
          ts[j + 20] = c && (e.top - t[1]) / c;
          ts[j + 24] = s && (e.right - t[0]) / -s;
          ts[j + 28] = c && (e.bottom - t[1]) / c;
          ts[j + 32] = c && (e.left - t[0]) / -c;
          ts[j + 36] = s && (e.top - t[1]) / -s;
          ts[j + 40] = c && (e.right - t[0]) / -c;
          ts[j + 44] = s && (e.bottom - t[1]) / -s;
          ts[j + 48] = s && (e.left - t[0]) / s;
          ts[j + 52] = c && (e.top - t[1]) / -c;
          ts[j + 56] = s && (e.right - t[0]) / s;
          ts[j + 60] = c && (e.bottom - t[1]) / -c;
        });
        const boxScale = 1 + Math.min(Math.abs(c), Math.abs(s));
        divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale;
        divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale;
        divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale;
        divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale;

        task._textDivProperties.set(div, divProperties);
      }
    }

    function expandBounds(width, height, boxes) {
      const bounds = boxes.map(function (box, i) {
        return {
          x1: box.left,
          y1: box.top,
          x2: box.right,
          y2: box.bottom,
          index: i,
          x1New: undefined,
          x2New: undefined
        };
      });
      expandBoundsLTR(width, bounds);
      const expanded = new Array(boxes.length);
      bounds.forEach(function (b) {
        const i = b.index;
        expanded[i] = {
          left: b.x1New,
          top: 0,
          right: b.x2New,
          bottom: 0
        };
      });
      boxes.map(function (box, i) {
        const e = expanded[i],
              b = bounds[i];
        b.x1 = box.top;
        b.y1 = width - e.right;
        b.x2 = box.bottom;
        b.y2 = width - e.left;
        b.index = i;
        b.x1New = undefined;
        b.x2New = undefined;
      });
      expandBoundsLTR(height, bounds);
      bounds.forEach(function (b) {
        const i = b.index;
        expanded[i].top = b.x1New;
        expanded[i].bottom = b.x2New;
      });
      return expanded;
    }

    function expandBoundsLTR(width, bounds) {
      bounds.sort(function (a, b) {
        return a.x1 - b.x1 || a.index - b.index;
      });
      const fakeBoundary = {
        x1: -Infinity,
        y1: -Infinity,
        x2: 0,
        y2: Infinity,
        index: -1,
        x1New: 0,
        x2New: 0
      };
      const horizon = [{
        start: -Infinity,
        end: Infinity,
        boundary: fakeBoundary
      }];
      bounds.forEach(function (boundary) {
        let i = 0;

        while (i < horizon.length && horizon[i].end <= boundary.y1) {
          i++;
        }

        let j = horizon.length - 1;

        while (j >= 0 && horizon[j].start >= boundary.y2) {
          j--;
        }

        let horizonPart, affectedBoundary;
        let q,
            k,
            maxXNew = -Infinity;

        for (q = i; q <= j; q++) {
          horizonPart = horizon[q];
          affectedBoundary = horizonPart.boundary;
          let xNew;

          if (affectedBoundary.x2 > boundary.x1) {
            xNew = affectedBoundary.index > boundary.index ? affectedBoundary.x1New : boundary.x1;
          } else if (affectedBoundary.x2New === undefined) {
            xNew = (affectedBoundary.x2 + boundary.x1) / 2;
          } else {
            xNew = affectedBoundary.x2New;
          }

          if (xNew > maxXNew) {
            maxXNew = xNew;
          }
        }

        boundary.x1New = maxXNew;

        for (q = i; q <= j; q++) {
          horizonPart = horizon[q];
          affectedBoundary = horizonPart.boundary;

          if (affectedBoundary.x2New === undefined) {
            if (affectedBoundary.x2 > boundary.x1) {
              if (affectedBoundary.index > boundary.index) {
                affectedBoundary.x2New = affectedBoundary.x2;
              }
            } else {
              affectedBoundary.x2New = maxXNew;
            }
          } else if (affectedBoundary.x2New > maxXNew) {
            affectedBoundary.x2New = Math.max(maxXNew, affectedBoundary.x2);
          }
        }

        const changedHorizon = [];
        let lastBoundary = null;

        for (q = i; q <= j; q++) {
          horizonPart = horizon[q];
          affectedBoundary = horizonPart.boundary;
          const useBoundary = affectedBoundary.x2 > boundary.x2 ? affectedBoundary : boundary;

          if (lastBoundary === useBoundary) {
            changedHorizon[changedHorizon.length - 1].end = horizonPart.end;
          } else {
            changedHorizon.push({
              start: horizonPart.start,
              end: horizonPart.end,
              boundary: useBoundary
            });
            lastBoundary = useBoundary;
          }
        }

        if (horizon[i].start < boundary.y1) {
          changedHorizon[0].start = boundary.y1;
          changedHorizon.unshift({
            start: horizon[i].start,
            end: boundary.y1,
            boundary: horizon[i].boundary
          });
        }

        if (boundary.y2 < horizon[j].end) {
          changedHorizon[changedHorizon.length - 1].end = boundary.y2;
          changedHorizon.push({
            start: boundary.y2,
            end: horizon[j].end,
            boundary: horizon[j].boundary
          });
        }

        for (q = i; q <= j; q++) {
          horizonPart = horizon[q];
          affectedBoundary = horizonPart.boundary;

          if (affectedBoundary.x2New !== undefined) {
            continue;
          }

          let used = false;

          for (k = i - 1; !used && k >= 0 && horizon[k].start >= affectedBoundary.y1; k--) {
            used = horizon[k].boundary === affectedBoundary;
          }

          for (k = j + 1; !used && k < horizon.length && horizon[k].end <= affectedBoundary.y2; k++) {
            used = horizon[k].boundary === affectedBoundary;
          }

          for (k = 0; !used && k < changedHorizon.length; k++) {
            used = changedHorizon[k].boundary === affectedBoundary;
          }

          if (!used) {
            affectedBoundary.x2New = maxXNew;
          }
        }

        Array.prototype.splice.apply(horizon, [i, j - i + 1].concat(changedHorizon));
      });
      horizon.forEach(function (horizonPart) {
        const affectedBoundary = horizonPart.boundary;

        if (affectedBoundary.x2New === undefined) {
          affectedBoundary.x2New = Math.max(width, affectedBoundary.x2);
        }
      });
    }

    function TextLayerRenderTask({
      textContent,
      textContentStream,
      container,
      viewport,
      textDivs,
      textContentItemsStr,
      enhanceTextSelection
    }) {
      this._textContent = textContent;
      this._textContentStream = textContentStream;
      this._container = container;
      this._document = container.ownerDocument;
      this._viewport = viewport;
      this._textDivs = textDivs || [];
      this._textContentItemsStr = textContentItemsStr || [];
      this._enhanceTextSelection = !!enhanceTextSelection;
      this._fontInspectorEnabled = !!(globalThis.FontInspector && globalThis.FontInspector.enabled); // lwf
      this._reader = null;
      this._layoutTextLastFontSize = null;
      this._layoutTextLastFontFamily = null;
      this._layoutTextCtx = null;
      this._textDivProperties = new WeakMap();
      this._renderingDone = false;
      this._canceled = false;
      this._capability = (0, _util.createPromiseCapability)();
      this._renderTimer = null;
      this._bounds = [];

      this._capability.promise.finally(() => {
        if (this._layoutTextCtx) {
          this._layoutTextCtx.canvas.width = 0;
          this._layoutTextCtx.canvas.height = 0;
          this._layoutTextCtx = null;
        }
      }).catch(() => {});
    }

    TextLayerRenderTask.prototype = {
      get promise() {
        return this._capability.promise;
      },

      cancel: function TextLayer_cancel() {
        this._canceled = true;

        if (this._reader) {
          this._reader.cancel(new _util.AbortException("TextLayer task cancelled."));

          this._reader = null;
        }

        if (this._renderTimer !== null) {
          clearTimeout(this._renderTimer);
          this._renderTimer = null;
        }

        this._capability.reject(new Error("TextLayer task cancelled."));
      },

      _processItems(items, styleCache) {
        for (let i = 0, len = items.length; i < len; i++) {
          this._textContentItemsStr.push(items[i].str);

          appendText(this, items[i], styleCache);
        }
      },

      _layoutText(textDiv) {
        const textDivProperties = this._textDivProperties.get(textDiv);

        if (textDivProperties.isWhitespace) {
          return;
        }

        let transform = "";

        if (textDivProperties.canvasWidth !== 0) {
          const {
            fontSize,
            fontFamily
          } = textDiv.style;

          if (fontSize !== this._layoutTextLastFontSize || fontFamily !== this._layoutTextLastFontFamily) {
            this._layoutTextCtx.font = `${fontSize} ${fontFamily}`;
            this._layoutTextLastFontSize = fontSize;
            this._layoutTextLastFontFamily = fontFamily;
          }

          const {
            width
          } = this._layoutTextCtx.measureText(textDiv.textContent);

          if (width > 0) {
            textDivProperties.scale = textDivProperties.canvasWidth / width;
            transform = `scaleX(${textDivProperties.scale})`;
          }
        }

        if (textDivProperties.angle !== 0) {
          transform = `rotate(${textDivProperties.angle}deg) ${transform}`;
        }

        if (transform.length > 0) {
          if (this._enhanceTextSelection) {
            textDivProperties.originalTransform = transform;
          }

          textDiv.style.transform = transform;
        }

        this._textDivProperties.set(textDiv, textDivProperties);

        this._container.appendChild(textDiv);
      },

      _render: function TextLayer_render(timeout) {
        const capability = (0, _util.createPromiseCapability)();
        let styleCache = Object.create(null);

        const canvas = this._document.createElement("canvas");

        canvas.mozOpaque = true;
        this._layoutTextCtx = canvas.getContext("2d", {
          alpha: false
        });

        if (this._textContent) {
          const textItems = this._textContent.items;
          const textStyles = this._textContent.styles;

          this._processItems(textItems, textStyles);

          capability.resolve();
        } else if (this._textContentStream) {
          const pump = () => {
            this._reader.read().then(({
              value,
              done
            }) => {
              if (done) {
                capability.resolve();
                return;
              }

              Object.assign(styleCache, value.styles);

              this._processItems(value.items, styleCache);

              pump();
            }, capability.reject);
          };

          this._reader = this._textContentStream.getReader();
          pump();
        } else {
          throw new Error('Neither "textContent" nor "textContentStream"' + " parameters specified.");
        }

        capability.promise.then(() => {
          styleCache = null;

          if (!timeout) {
            render(this);
          } else {
            this._renderTimer = setTimeout(() => {
              render(this);
              this._renderTimer = null;
            }, timeout);
          }
        }, this._capability.reject);
      },
      expandTextDivs: function TextLayer_expandTextDivs(expandDivs) {
        if (!this._enhanceTextSelection || !this._renderingDone) {
          return;
        }

        if (this._bounds !== null) {
          expand(this);
          this._bounds = null;
        }

        const transformBuf = [],
              paddingBuf = [];

        for (let i = 0, ii = this._textDivs.length; i < ii; i++) {
          const div = this._textDivs[i];

          const divProps = this._textDivProperties.get(div);

          if (divProps.isWhitespace) {
            continue;
          }

          if (expandDivs) {
            transformBuf.length = 0;
            paddingBuf.length = 0;

            if (divProps.originalTransform) {
              transformBuf.push(divProps.originalTransform);
            }

            if (divProps.paddingTop > 0) {
              paddingBuf.push(`${divProps.paddingTop}px`);
              transformBuf.push(`translateY(${-divProps.paddingTop}px)`);
            } else {
              paddingBuf.push(0);
            }

            if (divProps.paddingRight > 0) {
              paddingBuf.push(`${divProps.paddingRight / divProps.scale}px`);
            } else {
              paddingBuf.push(0);
            }

            if (divProps.paddingBottom > 0) {
              paddingBuf.push(`${divProps.paddingBottom}px`);
            } else {
              paddingBuf.push(0);
            }

            if (divProps.paddingLeft > 0) {
              paddingBuf.push(`${divProps.paddingLeft / divProps.scale}px`);
              transformBuf.push(`translateX(${-divProps.paddingLeft / divProps.scale}px)`);
            } else {
              paddingBuf.push(0);
            }

            div.style.padding = paddingBuf.join(" ");

            if (transformBuf.length) {
              div.style.transform = transformBuf.join(" ");
            }
          } else {
            div.style.padding = null;
            div.style.transform = divProps.originalTransform;
          }
        }
      }
    };

    function renderTextLayer(renderParameters) {
      const task = new TextLayerRenderTask({
        textContent: renderParameters.textContent,
        textContentStream: renderParameters.textContentStream,
        container: renderParameters.container,
        viewport: renderParameters.viewport,
        textDivs: renderParameters.textDivs,
        textContentItemsStr: renderParameters.textContentItemsStr,
        enhanceTextSelection: renderParameters.enhanceTextSelection
      });

      task._render(renderParameters.timeout);

      return task;
    }

    return renderTextLayer;
  }();

  exports.renderTextLayer = renderTextLayer;

  /***/ }),
  /* 22 */
  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



  Object.defineProperty(exports, "__esModule", ({
    value: true
  }));
  exports.SVGGraphics = void 0;

  var _util = __w_pdfjs_require__(2);

  var _display_utils = __w_pdfjs_require__(1);

  var _is_node = __w_pdfjs_require__(4);

  let SVGGraphics = function () {
    throw new Error("Not implemented: SVGGraphics");
  };

  exports.SVGGraphics = SVGGraphics;
  {
    const SVG_DEFAULTS = {
      fontStyle: "normal",
      fontWeight: "normal",
      fillColor: "#000000"
    };
    const XML_NS = "http://www.w3.org/XML/1998/namespace";
    const XLINK_NS = "http://www.w3.org/1999/xlink";
    const LINE_CAP_STYLES = ["butt", "round", "square"];
    const LINE_JOIN_STYLES = ["miter", "round", "bevel"];

    const convertImgDataToPng = function () {
      const PNG_HEADER = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);
      const CHUNK_WRAPPER_SIZE = 12;
      const crcTable = new Int32Array(256);

      for (let i = 0; i < 256; i++) {
        let c = i;

        for (let h = 0; h < 8; h++) {
          if (c & 1) {
            c = 0xedb88320 ^ c >> 1 & 0x7fffffff;
          } else {
            c = c >> 1 & 0x7fffffff;
          }
        }

        crcTable[i] = c;
      }

      function crc32(data, start, end) {
        let crc = -1;

        for (let i = start; i < end; i++) {
          const a = (crc ^ data[i]) & 0xff;
          const b = crcTable[a];
          crc = crc >>> 8 ^ b;
        }

        return crc ^ -1;
      }

      function writePngChunk(type, body, data, offset) {
        let p = offset;
        const len = body.length;
        data[p] = len >> 24 & 0xff;
        data[p + 1] = len >> 16 & 0xff;
        data[p + 2] = len >> 8 & 0xff;
        data[p + 3] = len & 0xff;
        p += 4;
        data[p] = type.charCodeAt(0) & 0xff;
        data[p + 1] = type.charCodeAt(1) & 0xff;
        data[p + 2] = type.charCodeAt(2) & 0xff;
        data[p + 3] = type.charCodeAt(3) & 0xff;
        p += 4;
        data.set(body, p);
        p += body.length;
        const crc = crc32(data, offset + 4, p);
        data[p] = crc >> 24 & 0xff;
        data[p + 1] = crc >> 16 & 0xff;
        data[p + 2] = crc >> 8 & 0xff;
        data[p + 3] = crc & 0xff;
      }

      function adler32(data, start, end) {
        let a = 1;
        let b = 0;

        for (let i = start; i < end; ++i) {
          a = (a + (data[i] & 0xff)) % 65521;
          b = (b + a) % 65521;
        }

        return b << 16 | a;
      }

      function deflateSync(literals) {
        if (!_is_node.isNodeJS) {
          return deflateSyncUncompressed(literals);
        }

        try {
          let input;

          if (parseInt(process.versions.node) >= 8) {
            input = literals;
          } else {
            input = Buffer.from(literals);
          }

          const output = require("zlib").deflateSync(input, {
            level: 9
          });

          return output instanceof Uint8Array ? output : new Uint8Array(output);
        } catch (e) {
          (0, _util.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + e);
        }

        return deflateSyncUncompressed(literals);
      }

      function deflateSyncUncompressed(literals) {
        let len = literals.length;
        const maxBlockLength = 0xffff;
        const deflateBlocks = Math.ceil(len / maxBlockLength);
        const idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);
        let pi = 0;
        idat[pi++] = 0x78;
        idat[pi++] = 0x9c;
        let pos = 0;

        while (len > maxBlockLength) {
          idat[pi++] = 0x00;
          idat[pi++] = 0xff;
          idat[pi++] = 0xff;
          idat[pi++] = 0x00;
          idat[pi++] = 0x00;
          idat.set(literals.subarray(pos, pos + maxBlockLength), pi);
          pi += maxBlockLength;
          pos += maxBlockLength;
          len -= maxBlockLength;
        }

        idat[pi++] = 0x01;
        idat[pi++] = len & 0xff;
        idat[pi++] = len >> 8 & 0xff;
        idat[pi++] = ~len & 0xffff & 0xff;
        idat[pi++] = (~len & 0xffff) >> 8 & 0xff;
        idat.set(literals.subarray(pos), pi);
        pi += literals.length - pos;
        const adler = adler32(literals, 0, literals.length);
        idat[pi++] = adler >> 24 & 0xff;
        idat[pi++] = adler >> 16 & 0xff;
        idat[pi++] = adler >> 8 & 0xff;
        idat[pi++] = adler & 0xff;
        return idat;
      }

      function encode(imgData, kind, forceDataSchema, isMask) {
        const width = imgData.width;
        const height = imgData.height;
        let bitDepth, colorType, lineSize;
        const bytes = imgData.data;

        switch (kind) {
          case _util.ImageKind.GRAYSCALE_1BPP:
            colorType = 0;
            bitDepth = 1;
            lineSize = width + 7 >> 3;
            break;

          case _util.ImageKind.RGB_24BPP:
            colorType = 2;
            bitDepth = 8;
            lineSize = width * 3;
            break;

          case _util.ImageKind.RGBA_32BPP:
            colorType = 6;
            bitDepth = 8;
            lineSize = width * 4;
            break;

          default:
            throw new Error("invalid format");
        }

        const literals = new Uint8Array((1 + lineSize) * height);
        let offsetLiterals = 0,
            offsetBytes = 0;

        for (let y = 0; y < height; ++y) {
          literals[offsetLiterals++] = 0;
          literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);
          offsetBytes += lineSize;
          offsetLiterals += lineSize;
        }

        if (kind === _util.ImageKind.GRAYSCALE_1BPP && isMask) {
          offsetLiterals = 0;

          for (let y = 0; y < height; y++) {
            offsetLiterals++;

            for (let i = 0; i < lineSize; i++) {
              literals[offsetLiterals++] ^= 0xff;
            }
          }
        }

        const ihdr = new Uint8Array([width >> 24 & 0xff, width >> 16 & 0xff, width >> 8 & 0xff, width & 0xff, height >> 24 & 0xff, height >> 16 & 0xff, height >> 8 & 0xff, height & 0xff, bitDepth, colorType, 0x00, 0x00, 0x00]);
        const idat = deflateSync(literals);
        const pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;
        const data = new Uint8Array(pngLength);
        let offset = 0;
        data.set(PNG_HEADER, offset);
        offset += PNG_HEADER.length;
        writePngChunk("IHDR", ihdr, data, offset);
        offset += CHUNK_WRAPPER_SIZE + ihdr.length;
        writePngChunk("IDATA", idat, data, offset);
        offset += CHUNK_WRAPPER_SIZE + idat.length;
        writePngChunk("IEND", new Uint8Array(0), data, offset);
        return (0, _util.createObjectURL)(data, "image/png", forceDataSchema);
      }

      return function convertImgDataToPng(imgData, forceDataSchema, isMask) {
        const kind = imgData.kind === undefined ? _util.ImageKind.GRAYSCALE_1BPP : imgData.kind;
        return encode(imgData, kind, forceDataSchema, isMask);
      };
    }();

    class SVGExtraState {
      constructor() {
        this.fontSizeScale = 1;
        this.fontWeight = SVG_DEFAULTS.fontWeight;
        this.fontSize = 0;
        this.textMatrix = _util.IDENTITY_MATRIX;
        this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
        this.leading = 0;
        this.textRenderingMode = _util.TextRenderingMode.FILL;
        this.textMatrixScale = 1;
        this.x = 0;
        this.y = 0;
        this.lineX = 0;
        this.lineY = 0;
        this.charSpacing = 0;
        this.wordSpacing = 0;
        this.textHScale = 1;
        this.textRise = 0;
        this.fillColor = SVG_DEFAULTS.fillColor;
        this.strokeColor = "#000000";
        this.fillAlpha = 1;
        this.strokeAlpha = 1;
        this.lineWidth = 1;
        this.lineJoin = "";
        this.lineCap = "";
        this.miterLimit = 0;
        this.dashArray = [];
        this.dashPhase = 0;
        this.dependencies = [];
        this.activeClipUrl = null;
        this.clipGroup = null;
        this.maskId = "";
      }

      clone() {
        return Object.create(this);
      }

      setCurrentPoint(x, y) {
        this.x = x;
        this.y = y;
      }

    }

    function opListToTree(opList) {
      let opTree = [];
      const tmp = [];

      for (const opListElement of opList) {
        if (opListElement.fn === "save") {
          opTree.push({
            fnId: 92,
            fn: "group",
            items: []
          });
          tmp.push(opTree);
          opTree = opTree[opTree.length - 1].items;
          continue;
        }

        if (opListElement.fn === "restore") {
          opTree = tmp.pop();
        } else {
          opTree.push(opListElement);
        }
      }

      return opTree;
    }

    function pf(value) {
      if (Number.isInteger(value)) {
        return value.toString();
      }

      const s = value.toFixed(10);
      let i = s.length - 1;

      if (s[i] !== "0") {
        return s;
      }

      do {
        i--;
      } while (s[i] === "0");

      return s.substring(0, s[i] === "." ? i : i + 1);
    }

    function pm(m) {
      if (m[4] === 0 && m[5] === 0) {
        if (m[1] === 0 && m[2] === 0) {
          if (m[0] === 1 && m[3] === 1) {
            return "";
          }

          return `scale(${pf(m[0])} ${pf(m[3])})`;
        }

        if (m[0] === m[3] && m[1] === -m[2]) {
          const a = Math.acos(m[0]) * 180 / Math.PI;
          return `rotate(${pf(a)})`;
        }
      } else {
        if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {
          return `translate(${pf(m[4])} ${pf(m[5])})`;
        }
      }

      return `matrix(${pf(m[0])} ${pf(m[1])} ${pf(m[2])} ${pf(m[3])} ${pf(m[4])} ` + `${pf(m[5])})`;
    }

    let clipCount = 0;
    let maskCount = 0;
    let shadingCount = 0;
    exports.SVGGraphics = SVGGraphics = class SVGGraphics {
      constructor(commonObjs, objs, forceDataSchema = false) {
        this.svgFactory = new _display_utils.DOMSVGFactory();
        this.current = new SVGExtraState();
        this.transformMatrix = _util.IDENTITY_MATRIX;
        this.transformStack = [];
        this.extraStack = [];
        this.commonObjs = commonObjs;
        this.objs = objs;
        this.pendingClip = null;
        this.pendingEOFill = false;
        this.embedFonts = false;
        this.embeddedFonts = Object.create(null);
        this.cssStyle = null;
        this.forceDataSchema = !!forceDataSchema;
        this._operatorIdMapping = [];

        for (const op in _util.OPS) {
          this._operatorIdMapping[_util.OPS[op]] = op;
        }
      }

      save() {
        this.transformStack.push(this.transformMatrix);
        const old = this.current;
        this.extraStack.push(old);
        this.current = old.clone();
      }

      restore() {
        this.transformMatrix = this.transformStack.pop();
        this.current = this.extraStack.pop();
        this.pendingClip = null;
        this.tgrp = null;
      }

      group(items) {
        this.save();
        this.executeOpTree(items);
        this.restore();
      }

      loadDependencies(operatorList) {
        const fnArray = operatorList.fnArray;
        const argsArray = operatorList.argsArray;

        for (let i = 0, ii = fnArray.length; i < ii; i++) {
          if (fnArray[i] !== _util.OPS.dependency) {
            continue;
          }

          for (const obj of argsArray[i]) {
            const objsPool = obj.startsWith("g_") ? this.commonObjs : this.objs;
            const promise = new Promise(resolve => {
              objsPool.get(obj, resolve);
            });
            this.current.dependencies.push(promise);
          }
        }

        return Promise.all(this.current.dependencies);
      }

      transform(a, b, c, d, e, f) {
        const transformMatrix = [a, b, c, d, e, f];
        this.transformMatrix = _util.Util.transform(this.transformMatrix, transformMatrix);
        this.tgrp = null;
      }

      getSVG(operatorList, viewport) {
        this.viewport = viewport;

        const svgElement = this._initialize(viewport);

        return this.loadDependencies(operatorList).then(() => {
          this.transformMatrix = _util.IDENTITY_MATRIX;
          this.executeOpTree(this.convertOpList(operatorList));
          return svgElement;
        });
      }

      convertOpList(operatorList) {
        const operatorIdMapping = this._operatorIdMapping;
        const argsArray = operatorList.argsArray;
        const fnArray = operatorList.fnArray;
        const opList = [];

        for (let i = 0, ii = fnArray.length; i < ii; i++) {
          const fnId = fnArray[i];
          opList.push({
            fnId,
            fn: operatorIdMapping[fnId],
            args: argsArray[i]
          });
        }

        return opListToTree(opList);
      }

      executeOpTree(opTree) {
        for (const opTreeElement of opTree) {
          const fn = opTreeElement.fn;
          const fnId = opTreeElement.fnId;
          const args = opTreeElement.args;

          switch (fnId | 0) {
            case _util.OPS.beginText:
              this.beginText();
              break;

            case _util.OPS.dependency:
              break;

            case _util.OPS.setLeading:
              this.setLeading(args);
              break;

            case _util.OPS.setLeadingMoveText:
              this.setLeadingMoveText(args[0], args[1]);
              break;

            case _util.OPS.setFont:
              this.setFont(args);
              break;

            case _util.OPS.showText:
              this.showText(args[0]);
              break;

            case _util.OPS.showSpacedText:
              this.showText(args[0]);
              break;

            case _util.OPS.endText:
              this.endText();
              break;

            case _util.OPS.moveText:
              this.moveText(args[0], args[1]);
              break;

            case _util.OPS.setCharSpacing:
              this.setCharSpacing(args[0]);
              break;

            case _util.OPS.setWordSpacing:
              this.setWordSpacing(args[0]);
              break;

            case _util.OPS.setHScale:
              this.setHScale(args[0]);
              break;

            case _util.OPS.setTextMatrix:
              this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
              break;

            case _util.OPS.setTextRise:
              this.setTextRise(args[0]);
              break;

            case _util.OPS.setTextRenderingMode:
              this.setTextRenderingMode(args[0]);
              break;

            case _util.OPS.setLineWidth:
              this.setLineWidth(args[0]);
              break;

            case _util.OPS.setLineJoin:
              this.setLineJoin(args[0]);
              break;

            case _util.OPS.setLineCap:
              this.setLineCap(args[0]);
              break;

            case _util.OPS.setMiterLimit:
              this.setMiterLimit(args[0]);
              break;

            case _util.OPS.setFillRGBColor:
              this.setFillRGBColor(args[0], args[1], args[2]);
              break;

            case _util.OPS.setStrokeRGBColor:
              this.setStrokeRGBColor(args[0], args[1], args[2]);
              break;

            case _util.OPS.setStrokeColorN:
              this.setStrokeColorN(args);
              break;

            case _util.OPS.setFillColorN:
              this.setFillColorN(args);
              break;

            case _util.OPS.shadingFill:
              this.shadingFill(args[0]);
              break;

            case _util.OPS.setDash:
              this.setDash(args[0], args[1]);
              break;

            case _util.OPS.setRenderingIntent:
              this.setRenderingIntent(args[0]);
              break;

            case _util.OPS.setFlatness:
              this.setFlatness(args[0]);
              break;

            case _util.OPS.setGState:
              this.setGState(args[0]);
              break;

            case _util.OPS.fill:
              this.fill();
              break;

            case _util.OPS.eoFill:
              this.eoFill();
              break;

            case _util.OPS.stroke:
              this.stroke();
              break;

            case _util.OPS.fillStroke:
              this.fillStroke();
              break;

            case _util.OPS.eoFillStroke:
              this.eoFillStroke();
              break;

            case _util.OPS.clip:
              this.clip("nonzero");
              break;

            case _util.OPS.eoClip:
              this.clip("evenodd");
              break;

            case _util.OPS.paintSolidColorImageMask:
              this.paintSolidColorImageMask();
              break;

            case _util.OPS.paintImageXObject:
              this.paintImageXObject(args[0]);
              break;

            case _util.OPS.paintInlineImageXObject:
              this.paintInlineImageXObject(args[0]);
              break;

            case _util.OPS.paintImageMaskXObject:
              this.paintImageMaskXObject(args[0]);
              break;

            case _util.OPS.paintFormXObjectBegin:
              this.paintFormXObjectBegin(args[0], args[1]);
              break;

            case _util.OPS.paintFormXObjectEnd:
              this.paintFormXObjectEnd();
              break;

            case _util.OPS.closePath:
              this.closePath();
              break;

            case _util.OPS.closeStroke:
              this.closeStroke();
              break;

            case _util.OPS.closeFillStroke:
              this.closeFillStroke();
              break;

            case _util.OPS.closeEOFillStroke:
              this.closeEOFillStroke();
              break;

            case _util.OPS.nextLine:
              this.nextLine();
              break;

            case _util.OPS.transform:
              this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);
              break;

            case _util.OPS.constructPath:
              this.constructPath(args[0], args[1]);
              break;

            case _util.OPS.endPath:
              this.endPath();
              break;

            case 92:
              this.group(opTreeElement.items);
              break;

            default:
              (0, _util.warn)(`Unimplemented operator ${fn}`);
              break;
          }
        }
      }

      setWordSpacing(wordSpacing) {
        this.current.wordSpacing = wordSpacing;
      }

      setCharSpacing(charSpacing) {
        this.current.charSpacing = charSpacing;
      }

      nextLine() {
        this.moveText(0, this.current.leading);
      }

      setTextMatrix(a, b, c, d, e, f) {
        const current = this.current;
        current.textMatrix = current.lineMatrix = [a, b, c, d, e, f];
        current.textMatrixScale = Math.sqrt(a * a + b * b);
        current.x = current.lineX = 0;
        current.y = current.lineY = 0;
        current.xcoords = [];
        current.ycoords = [];
        current.tspan = this.svgFactory.createElement("svg:tspan");
        current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
        current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
        current.tspan.setAttributeNS(null, "y", pf(-current.y));
        current.txtElement = this.svgFactory.createElement("svg:text");
        current.txtElement.appendChild(current.tspan);
      }

      beginText() {
        const current = this.current;
        current.x = current.lineX = 0;
        current.y = current.lineY = 0;
        current.textMatrix = _util.IDENTITY_MATRIX;
        current.lineMatrix = _util.IDENTITY_MATRIX;
        current.textMatrixScale = 1;
        current.tspan = this.svgFactory.createElement("svg:tspan");
        current.txtElement = this.svgFactory.createElement("svg:text");
        current.txtgrp = this.svgFactory.createElement("svg:g");
        current.xcoords = [];
        current.ycoords = [];
      }

      moveText(x, y) {
        const current = this.current;
        current.x = current.lineX += x;
        current.y = current.lineY += y;
        current.xcoords = [];
        current.ycoords = [];
        current.tspan = this.svgFactory.createElement("svg:tspan");
        current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
        current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
        current.tspan.setAttributeNS(null, "y", pf(-current.y));
      }

      showText(glyphs) {
        const current = this.current;
        const font = current.font;
        const fontSize = current.fontSize;

        if (fontSize === 0) {
          return;
        }

        const fontSizeScale = current.fontSizeScale;
        const charSpacing = current.charSpacing;
        const wordSpacing = current.wordSpacing;
        const fontDirection = current.fontDirection;
        const textHScale = current.textHScale * fontDirection;
        const vertical = font.vertical;
        const spacingDir = vertical ? 1 : -1;
        const defaultVMetrics = font.defaultVMetrics;
        const widthAdvanceScale = fontSize * current.fontMatrix[0];
        let x = 0;

        for (const glyph of glyphs) {
          if (glyph === null) {
            x += fontDirection * wordSpacing;
            continue;
          } else if ((0, _util.isNum)(glyph)) {
            x += spacingDir * glyph * fontSize / 1000;
            continue;
          }

          const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
          const character = glyph.fontChar;
          let scaledX, scaledY;
          let width = glyph.width;

          if (vertical) {
            let vx;
            const vmetric = glyph.vmetric || defaultVMetrics;
            vx = glyph.vmetric ? vmetric[1] : width * 0.5;
            vx = -vx * widthAdvanceScale;
            const vy = vmetric[2] * widthAdvanceScale;
            width = vmetric ? -vmetric[0] : width;
            scaledX = vx / fontSizeScale;
            scaledY = (x + vy) / fontSizeScale;
          } else {
            scaledX = x / fontSizeScale;
            scaledY = 0;
          }

          if (glyph.isInFont || font.missingFile) {
            current.xcoords.push(current.x + scaledX);

            if (vertical) {
              current.ycoords.push(-current.y + scaledY);
            }

            current.tspan.textContent += character;
          } else {}

          let charWidth;

          if (vertical) {
            charWidth = width * widthAdvanceScale - spacing * fontDirection;
          } else {
            charWidth = width * widthAdvanceScale + spacing * fontDirection;
          }

          x += charWidth;
        }

        current.tspan.setAttributeNS(null, "x", current.xcoords.map(pf).join(" "));

        if (vertical) {
          current.tspan.setAttributeNS(null, "y", current.ycoords.map(pf).join(" "));
        } else {
          current.tspan.setAttributeNS(null, "y", pf(-current.y));
        }

        if (vertical) {
          current.y -= x;
        } else {
          current.x += x * textHScale;
        }

        current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
        current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);

        if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {
          current.tspan.setAttributeNS(null, "font-style", current.fontStyle);
        }

        if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {
          current.tspan.setAttributeNS(null, "font-weight", current.fontWeight);
        }

        const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;

        if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
          if (current.fillColor !== SVG_DEFAULTS.fillColor) {
            current.tspan.setAttributeNS(null, "fill", current.fillColor);
          }

          if (current.fillAlpha < 1) {
            current.tspan.setAttributeNS(null, "fill-opacity", current.fillAlpha);
          }
        } else if (current.textRenderingMode === _util.TextRenderingMode.ADD_TO_PATH) {
          current.tspan.setAttributeNS(null, "fill", "transparent");
        } else {
          current.tspan.setAttributeNS(null, "fill", "none");
        }

        if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
          const lineWidthScale = 1 / (current.textMatrixScale || 1);

          this._setStrokeAttributes(current.tspan, lineWidthScale);
        }

        let textMatrix = current.textMatrix;

        if (current.textRise !== 0) {
          textMatrix = textMatrix.slice();
          textMatrix[5] += current.textRise;
        }

        current.txtElement.setAttributeNS(null, "transform", `${pm(textMatrix)} scale(${pf(textHScale)}, -1)`);
        current.txtElement.setAttributeNS(XML_NS, "xml:space", "preserve");
        current.txtElement.appendChild(current.tspan);
        current.txtgrp.appendChild(current.txtElement);

        this._ensureTransformGroup().appendChild(current.txtElement);
      }

      setLeadingMoveText(x, y) {
        this.setLeading(-y);
        this.moveText(x, y);
      }

      addFontStyle(fontObj) {
        if (!fontObj.data) {
          throw new Error("addFontStyle: No font data available, " + 'ensure that the "fontExtraProperties" API parameter is set.');
        }

        if (!this.cssStyle) {
          this.cssStyle = this.svgFactory.createElement("svg:style");
          this.cssStyle.setAttributeNS(null, "type", "text/css");
          this.defs.appendChild(this.cssStyle);
        }

        const url = (0, _util.createObjectURL)(fontObj.data, fontObj.mimetype, this.forceDataSchema);
        this.cssStyle.textContent += `@font-face { font-family: "${fontObj.loadedName}";` + ` src: url(${url}); }\n`;
      }

      setFont(details) {
        const current = this.current;
        const fontObj = this.commonObjs.get(details[0]);
        let size = details[1];
        current.font = fontObj;

        if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) {
          this.addFontStyle(fontObj);
          this.embeddedFonts[fontObj.loadedName] = fontObj;
        }

        current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;
        let bold = "normal";

        if (fontObj.black) {
          bold = "900";
        } else if (fontObj.bold) {
          bold = "bold";
        }

        const italic = fontObj.italic ? "italic" : "normal";

        if (size < 0) {
          size = -size;
          current.fontDirection = -1;
        } else {
          current.fontDirection = 1;
        }

        current.fontSize = size;
        current.fontFamily = fontObj.loadedName;
        current.fontWeight = bold;
        current.fontStyle = italic;
        current.tspan = this.svgFactory.createElement("svg:tspan");
        current.tspan.setAttributeNS(null, "y", pf(-current.y));
        current.xcoords = [];
        current.ycoords = [];
      }

      endText() {
        const current = this.current;

        if (current.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG && current.txtElement && current.txtElement.hasChildNodes()) { // lwf
          current.element = current.txtElement;
          this.clip("nonzero");
          this.endPath();
        }
      }

      setLineWidth(width) {
        if (width > 0) {
          this.current.lineWidth = width;
        }
      }

      setLineCap(style) {
        this.current.lineCap = LINE_CAP_STYLES[style];
      }

      setLineJoin(style) {
        this.current.lineJoin = LINE_JOIN_STYLES[style];
      }

      setMiterLimit(limit) {
        this.current.miterLimit = limit;
      }

      setStrokeAlpha(strokeAlpha) {
        this.current.strokeAlpha = strokeAlpha;
      }

      setStrokeRGBColor(r, g, b) {
        this.current.strokeColor = _util.Util.makeHexColor(r, g, b);
      }

      setFillAlpha(fillAlpha) {
        this.current.fillAlpha = fillAlpha;
      }

      setFillRGBColor(r, g, b) {
        this.current.fillColor = _util.Util.makeHexColor(r, g, b);
        this.current.tspan = this.svgFactory.createElement("svg:tspan");
        this.current.xcoords = [];
        this.current.ycoords = [];
      }

      setStrokeColorN(args) {
        this.current.strokeColor = this._makeColorN_Pattern(args);
      }

      setFillColorN(args) {
        this.current.fillColor = this._makeColorN_Pattern(args);
      }

      shadingFill(args) {
        const width = this.viewport.width;
        const height = this.viewport.height;

        const inv = _util.Util.inverseTransform(this.transformMatrix);

        const bl = _util.Util.applyTransform([0, 0], inv);

        const br = _util.Util.applyTransform([0, height], inv);

        const ul = _util.Util.applyTransform([width, 0], inv);

        const ur = _util.Util.applyTransform([width, height], inv);

        const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
        const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
        const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
        const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
        const rect = this.svgFactory.createElement("svg:rect");
        rect.setAttributeNS(null, "x", x0);
        rect.setAttributeNS(null, "y", y0);
        rect.setAttributeNS(null, "width", x1 - x0);
        rect.setAttributeNS(null, "height", y1 - y0);
        rect.setAttributeNS(null, "fill", this._makeShadingPattern(args));

        if (this.current.fillAlpha < 1) {
          rect.setAttributeNS(null, "fill-opacity", this.current.fillAlpha);
        }

        this._ensureTransformGroup().appendChild(rect);
      }

      _makeColorN_Pattern(args) {
        if (args[0] === "TilingPattern") {
          return this._makeTilingPattern(args);
        }

        return this._makeShadingPattern(args);
      }

      _makeTilingPattern(args) {
        const color = args[1];
        const operatorList = args[2];
        const matrix = args[3] || _util.IDENTITY_MATRIX;
        const [x0, y0, x1, y1] = args[4];
        const xstep = args[5];
        const ystep = args[6];
        const paintType = args[7];
        const tilingId = `shading${shadingCount++}`;

        const [tx0, ty0] = _util.Util.applyTransform([x0, y0], matrix);

        const [tx1, ty1] = _util.Util.applyTransform([x1, y1], matrix);

        const [xscale, yscale] = _util.Util.singularValueDecompose2dScale(matrix);

        const txstep = xstep * xscale;
        const tystep = ystep * yscale;
        const tiling = this.svgFactory.createElement("svg:pattern");
        tiling.setAttributeNS(null, "id", tilingId);
        tiling.setAttributeNS(null, "patternUnits", "userSpaceOnUse");
        tiling.setAttributeNS(null, "width", txstep);
        tiling.setAttributeNS(null, "height", tystep);
        tiling.setAttributeNS(null, "x", `${tx0}`);
        tiling.setAttributeNS(null, "y", `${ty0}`);
        const svg = this.svg;
        const transformMatrix = this.transformMatrix;
        const fillColor = this.current.fillColor;
        const strokeColor = this.current.strokeColor;
        const bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);
        this.svg = bbox;
        this.transformMatrix = matrix;

        if (paintType === 2) {
          const cssColor = _util.Util.makeHexColor(...color);

          this.current.fillColor = cssColor;
          this.current.strokeColor = cssColor;
        }

        this.executeOpTree(this.convertOpList(operatorList));
        this.svg = svg;
        this.transformMatrix = transformMatrix;
        this.current.fillColor = fillColor;
        this.current.strokeColor = strokeColor;
        tiling.appendChild(bbox.childNodes[0]);
        this.defs.appendChild(tiling);
        return `url(#${tilingId})`;
      }

      _makeShadingPattern(args) {
        switch (args[0]) {
          case "RadialAxial":
            const shadingId = `shading${shadingCount++}`;
            const colorStops = args[3];
            let gradient;

            switch (args[1]) {
              case "axial":
                const point0 = args[4];
                const point1 = args[5];
                gradient = this.svgFactory.createElement("svg:linearGradient");
                gradient.setAttributeNS(null, "id", shadingId);
                gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                gradient.setAttributeNS(null, "x1", point0[0]);
                gradient.setAttributeNS(null, "y1", point0[1]);
                gradient.setAttributeNS(null, "x2", point1[0]);
                gradient.setAttributeNS(null, "y2", point1[1]);
                break;

              case "radial":
                const focalPoint = args[4];
                const circlePoint = args[5];
                const focalRadius = args[6];
                const circleRadius = args[7];
                gradient = this.svgFactory.createElement("svg:radialGradient");
                gradient.setAttributeNS(null, "id", shadingId);
                gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                gradient.setAttributeNS(null, "cx", circlePoint[0]);
                gradient.setAttributeNS(null, "cy", circlePoint[1]);
                gradient.setAttributeNS(null, "r", circleRadius);
                gradient.setAttributeNS(null, "fx", focalPoint[0]);
                gradient.setAttributeNS(null, "fy", focalPoint[1]);
                gradient.setAttributeNS(null, "fr", focalRadius);
                break;

              default:
                throw new Error(`Unknown RadialAxial type: ${args[1]}`);
            }

            for (const colorStop of colorStops) {
              const stop = this.svgFactory.createElement("svg:stop");
              stop.setAttributeNS(null, "offset", colorStop[0]);
              stop.setAttributeNS(null, "stop-color", colorStop[1]);
              gradient.appendChild(stop);
            }

            this.defs.appendChild(gradient);
            return `url(#${shadingId})`;

          case "Mesh":
            (0, _util.warn)("Unimplemented pattern Mesh");
            return null;

          case "Dummy":
            return "hotpink";

          default:
            throw new Error(`Unknown IR type: ${args[0]}`);
        }
      }

      setDash(dashArray, dashPhase) {
        this.current.dashArray = dashArray;
        this.current.dashPhase = dashPhase;
      }

      constructPath(ops, args) {
        const current = this.current;
        let x = current.x,
            y = current.y;
        let d = [];
        let j = 0;

        for (const op of ops) {
          switch (op | 0) {
            case _util.OPS.rectangle:
              x = args[j++];
              y = args[j++];
              const width = args[j++];
              const height = args[j++];
              const xw = x + width;
              const yh = y + height;
              d.push("M", pf(x), pf(y), "L", pf(xw), pf(y), "L", pf(xw), pf(yh), "L", pf(x), pf(yh), "Z");
              break;

            case _util.OPS.moveTo:
              x = args[j++];
              y = args[j++];
              d.push("M", pf(x), pf(y));
              break;

            case _util.OPS.lineTo:
              x = args[j++];
              y = args[j++];
              d.push("L", pf(x), pf(y));
              break;

            case _util.OPS.curveTo:
              x = args[j + 4];
              y = args[j + 5];
              d.push("C", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));
              j += 6;
              break;

            case _util.OPS.curveTo2:
              d.push("C", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));
              x = args[j + 2];
              y = args[j + 3];
              j += 4;
              break;

            case _util.OPS.curveTo3:
              x = args[j + 2];
              y = args[j + 3];
              d.push("C", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));
              j += 4;
              break;

            case _util.OPS.closePath:
              d.push("Z");
              break;
          }
        }

        d = d.join(" ");

        if (current.path && ops.length > 0 && ops[0] !== _util.OPS.rectangle && ops[0] !== _util.OPS.moveTo) {
          d = current.path.getAttributeNS(null, "d") + d;
        } else {
          current.path = this.svgFactory.createElement("svg:path");

          this._ensureTransformGroup().appendChild(current.path);
        }

        current.path.setAttributeNS(null, "d", d);
        current.path.setAttributeNS(null, "fill", "none");
        current.element = current.path;
        current.setCurrentPoint(x, y);
      }

      endPath() {
        const current = this.current;
        current.path = null;

        if (!this.pendingClip) {
          return;
        }

        if (!current.element) {
          this.pendingClip = null;
          return;
        }

        const clipId = `clippath${clipCount++}`;
        const clipPath = this.svgFactory.createElement("svg:clipPath");
        clipPath.setAttributeNS(null, "id", clipId);
        clipPath.setAttributeNS(null, "transform", pm(this.transformMatrix));
        const clipElement = current.element.cloneNode(true);

        if (this.pendingClip === "evenodd") {
          clipElement.setAttributeNS(null, "clip-rule", "evenodd");
        } else {
          clipElement.setAttributeNS(null, "clip-rule", "nonzero");
        }

        this.pendingClip = null;
        clipPath.appendChild(clipElement);
        this.defs.appendChild(clipPath);

        if (current.activeClipUrl) {
          current.clipGroup = null;
          this.extraStack.forEach(function (prev) {
            prev.clipGroup = null;
          });
          clipPath.setAttributeNS(null, "clip-path", current.activeClipUrl);
        }

        current.activeClipUrl = `url(#${clipId})`;
        this.tgrp = null;
      }

      clip(type) {
        this.pendingClip = type;
      }

      closePath() {
        const current = this.current;

        if (current.path) {
          const d = `${current.path.getAttributeNS(null, "d")}Z`;
          current.path.setAttributeNS(null, "d", d);
        }
      }

      setLeading(leading) {
        this.current.leading = -leading;
      }

      setTextRise(textRise) {
        this.current.textRise = textRise;
      }

      setTextRenderingMode(textRenderingMode) {
        this.current.textRenderingMode = textRenderingMode;
      }

      setHScale(scale) {
        this.current.textHScale = scale / 100;
      }

      setRenderingIntent(intent) {}

      setFlatness(flatness) {}

      setGState(states) {
        for (const [key, value] of states) {
          switch (key) {
            case "LW":
              this.setLineWidth(value);
              break;

            case "LC":
              this.setLineCap(value);
              break;

            case "LJ":
              this.setLineJoin(value);
              break;

            case "ML":
              this.setMiterLimit(value);
              break;

            case "D":
              this.setDash(value[0], value[1]);
              break;

            case "RI":
              this.setRenderingIntent(value);
              break;

            case "FL":
              this.setFlatness(value);
              break;

            case "Font":
              this.setFont(value);
              break;

            case "CA":
              this.setStrokeAlpha(value);
              break;

            case "ca":
              this.setFillAlpha(value);
              break;

            default:
              (0, _util.warn)(`Unimplemented graphic state operator ${key}`);
              break;
          }
        }
      }

      fill() {
        const current = this.current;

        if (current.element) {
          current.element.setAttributeNS(null, "fill", current.fillColor);
          current.element.setAttributeNS(null, "fill-opacity", current.fillAlpha);
          this.endPath();
        }
      }

      stroke() {
        const current = this.current;

        if (current.element) {
          this._setStrokeAttributes(current.element);

          current.element.setAttributeNS(null, "fill", "none");
          this.endPath();
        }
      }

      _setStrokeAttributes(element, lineWidthScale = 1) {
        const current = this.current;
        let dashArray = current.dashArray;

        if (lineWidthScale !== 1 && dashArray.length > 0) {
          dashArray = dashArray.map(function (value) {
            return lineWidthScale * value;
          });
        }

        element.setAttributeNS(null, "stroke", current.strokeColor);
        element.setAttributeNS(null, "stroke-opacity", current.strokeAlpha);
        element.setAttributeNS(null, "stroke-miterlimit", pf(current.miterLimit));
        element.setAttributeNS(null, "stroke-linecap", current.lineCap);
        element.setAttributeNS(null, "stroke-linejoin", current.lineJoin);
        element.setAttributeNS(null, "stroke-width", pf(lineWidthScale * current.lineWidth) + "px");
        element.setAttributeNS(null, "stroke-dasharray", dashArray.map(pf).join(" "));
        element.setAttributeNS(null, "stroke-dashoffset", pf(lineWidthScale * current.dashPhase) + "px");
      }

      eoFill() {
        if (this.current.element) {
          this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
        }

        this.fill();
      }

      fillStroke() {
        this.stroke();
        this.fill();
      }

      eoFillStroke() {
        if (this.current.element) {
          this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
        }

        this.fillStroke();
      }

      closeStroke() {
        this.closePath();
        this.stroke();
      }

      closeFillStroke() {
        this.closePath();
        this.fillStroke();
      }

      closeEOFillStroke() {
        this.closePath();
        this.eoFillStroke();
      }

      paintSolidColorImageMask() {
        const rect = this.svgFactory.createElement("svg:rect");
        rect.setAttributeNS(null, "x", "0");
        rect.setAttributeNS(null, "y", "0");
        rect.setAttributeNS(null, "width", "1px");
        rect.setAttributeNS(null, "height", "1px");
        rect.setAttributeNS(null, "fill", this.current.fillColor);

        this._ensureTransformGroup().appendChild(rect);
      }

      paintImageXObject(objId) {
        const imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId);

        if (!imgData) {
          (0, _util.warn)(`Dependent image with object ID ${objId} is not ready yet`);
          return;
        }

        this.paintInlineImageXObject(imgData);
      }

      paintInlineImageXObject(imgData, mask) {
        const width = imgData.width;
        const height = imgData.height;
        const imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);
        const cliprect = this.svgFactory.createElement("svg:rect");
        cliprect.setAttributeNS(null, "x", "0");
        cliprect.setAttributeNS(null, "y", "0");
        cliprect.setAttributeNS(null, "width", pf(width));
        cliprect.setAttributeNS(null, "height", pf(height));
        this.current.element = cliprect;
        this.clip("nonzero");
        const imgEl = this.svgFactory.createElement("svg:image");
        imgEl.setAttributeNS(XLINK_NS, "xlink:href", imgSrc);
        imgEl.setAttributeNS(null, "x", "0");
        imgEl.setAttributeNS(null, "y", pf(-height));
        imgEl.setAttributeNS(null, "width", pf(width) + "px");
        imgEl.setAttributeNS(null, "height", pf(height) + "px");
        imgEl.setAttributeNS(null, "transform", `scale(${pf(1 / width)} ${pf(-1 / height)})`);

        if (mask) {
          mask.appendChild(imgEl);
        } else {
          this._ensureTransformGroup().appendChild(imgEl);
        }
      }

      paintImageMaskXObject(imgData) {
        const current = this.current;
        const width = imgData.width;
        const height = imgData.height;
        const fillColor = current.fillColor;
        current.maskId = `mask${maskCount++}`;
        const mask = this.svgFactory.createElement("svg:mask");
        mask.setAttributeNS(null, "id", current.maskId);
        const rect = this.svgFactory.createElement("svg:rect");
        rect.setAttributeNS(null, "x", "0");
        rect.setAttributeNS(null, "y", "0");
        rect.setAttributeNS(null, "width", pf(width));
        rect.setAttributeNS(null, "height", pf(height));
        rect.setAttributeNS(null, "fill", fillColor);
        rect.setAttributeNS(null, "mask", `url(#${current.maskId})`);
        this.defs.appendChild(mask);

        this._ensureTransformGroup().appendChild(rect);

        this.paintInlineImageXObject(imgData, mask);
      }

      paintFormXObjectBegin(matrix, bbox) {
        if (Array.isArray(matrix) && matrix.length === 6) {
          this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
        }

        if (bbox) {
          const width = bbox[2] - bbox[0];
          const height = bbox[3] - bbox[1];
          const cliprect = this.svgFactory.createElement("svg:rect");
          cliprect.setAttributeNS(null, "x", bbox[0]);
          cliprect.setAttributeNS(null, "y", bbox[1]);
          cliprect.setAttributeNS(null, "width", pf(width));
          cliprect.setAttributeNS(null, "height", pf(height));
          this.current.element = cliprect;
          this.clip("nonzero");
          this.endPath();
        }
      }

      paintFormXObjectEnd() {}

      _initialize(viewport) {
        const svg = this.svgFactory.create(viewport.width, viewport.height);
        const definitions = this.svgFactory.createElement("svg:defs");
        svg.appendChild(definitions);
        this.defs = definitions;
        const rootGroup = this.svgFactory.createElement("svg:g");
        rootGroup.setAttributeNS(null, "transform", pm(viewport.transform));
        svg.appendChild(rootGroup);
        this.svg = rootGroup;
        return svg;
      }

      _ensureClipGroup() {
        if (!this.current.clipGroup) {
          const clipGroup = this.svgFactory.createElement("svg:g");
          clipGroup.setAttributeNS(null, "clip-path", this.current.activeClipUrl);
          this.svg.appendChild(clipGroup);
          this.current.clipGroup = clipGroup;
        }

        return this.current.clipGroup;
      }

      _ensureTransformGroup() {
        if (!this.tgrp) {
          this.tgrp = this.svgFactory.createElement("svg:g");
          this.tgrp.setAttributeNS(null, "transform", pm(this.transformMatrix));

          if (this.current.activeClipUrl) {
            this._ensureClipGroup().appendChild(this.tgrp);
          } else {
            this.svg.appendChild(this.tgrp);
          }
        }

        return this.tgrp;
      }

    };
  }

  /***/ }),
  /* 23 */
  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



  Object.defineProperty(exports, "__esModule", ({
    value: true
  }));
  exports.PDFNodeStream = void 0;

  var _util = __w_pdfjs_require__(2);

  var _network_utils = __w_pdfjs_require__(24);

  ;

  const fs = require("fs");

  const http = require("http");

  const https = require("https");

  const url = require("url");

  const fileUriRegex = /^file:\/\/\/[a-zA-Z]:\//;

  function parseUrl(sourceUrl) {
    const parsedUrl = url.parse(sourceUrl);

    if (parsedUrl.protocol === "file:" || parsedUrl.host) {
      return parsedUrl;
    }

    if (/^[a-z]:[/\\]/i.test(sourceUrl)) {
      return url.parse(`file:///${sourceUrl}`);
    }

    if (!parsedUrl.host) {
      parsedUrl.protocol = "file:";
    }

    return parsedUrl;
  }

  class PDFNodeStream {
    constructor(source) {
      this.source = source;
      this.url = parseUrl(source.url);
      this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:";
      this.isFsUrl = this.url.protocol === "file:";
      this.httpHeaders = this.isHttp && source.httpHeaders || {};
      this._fullRequestReader = null;
      this._rangeRequestReaders = [];
    }

    get _progressiveDataLength() {
      return this._fullRequestReader && this._fullRequestReader._loaded || 0; // lwf
    }

    getFullReader() {
      (0, _util.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once.");
      this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);
      return this._fullRequestReader;
    }

    getRangeReader(start, end) {
      if (end <= this._progressiveDataLength) {
        return null;
      }

      const rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);

      this._rangeRequestReaders.push(rangeReader);

      return rangeReader;
    }

    cancelAllRequests(reason) {
      if (this._fullRequestReader) {
        this._fullRequestReader.cancel(reason);
      }

      const readers = this._rangeRequestReaders.slice(0);

      readers.forEach(function (reader) {
        reader.cancel(reason);
      });
    }

  }

  exports.PDFNodeStream = PDFNodeStream;

  class BaseFullReader {
    constructor(stream) {
      this._url = stream.url;
      this._done = false;
      this._storedError = null;
      this.onProgress = null;
      const source = stream.source;
      this._contentLength = source.length;
      this._loaded = 0;
      this._filename = null;
      this._disableRange = source.disableRange || false;
      this._rangeChunkSize = source.rangeChunkSize;

      if (!this._rangeChunkSize && !this._disableRange) {
        this._disableRange = true;
      }

      this._isStreamingSupported = !source.disableStream;
      this._isRangeSupported = !source.disableRange;
      this._readableStream = null;
      this._readCapability = (0, _util.createPromiseCapability)();
      this._headersCapability = (0, _util.createPromiseCapability)();
    }

    get headersReady() {
      return this._headersCapability.promise;
    }

    get filename() {
      return this._filename;
    }

    get contentLength() {
      return this._contentLength;
    }

    get isRangeSupported() {
      return this._isRangeSupported;
    }

    get isStreamingSupported() {
      return this._isStreamingSupported;
    }

    async read() {
      await this._readCapability.promise;

      if (this._done) {
        return {
          value: undefined,
          done: true
        };
      }

      if (this._storedError) {
        throw this._storedError;
      }

      const chunk = this._readableStream.read();

      if (chunk === null) {
        this._readCapability = (0, _util.createPromiseCapability)();
        return this.read();
      }

      this._loaded += chunk.length;

      if (this.onProgress) {
        this.onProgress({
          loaded: this._loaded,
          total: this._contentLength
        });
      }

      const buffer = new Uint8Array(chunk).buffer;
      return {
        value: buffer,
        done: false
      };
    }

    cancel(reason) {
      if (!this._readableStream) {
        this._error(reason);

        return;
      }

      this._readableStream.destroy(reason);
    }

    _error(reason) {
      this._storedError = reason;

      this._readCapability.resolve();
    }

    _setReadableStream(readableStream) {
      this._readableStream = readableStream;
      readableStream.on("readable", () => {
        this._readCapability.resolve();
      });
      readableStream.on("end", () => {
        readableStream.destroy();
        this._done = true;

        this._readCapability.resolve();
      });
      readableStream.on("error", reason => {
        this._error(reason);
      });

      if (!this._isStreamingSupported && this._isRangeSupported) {
        this._error(new _util.AbortException("streaming is disabled"));
      }

      if (this._storedError) {
        this._readableStream.destroy(this._storedError);
      }
    }

  }

  class BaseRangeReader {
    constructor(stream) {
      this._url = stream.url;
      this._done = false;
      this._storedError = null;
      this.onProgress = null;
      this._loaded = 0;
      this._readableStream = null;
      this._readCapability = (0, _util.createPromiseCapability)();
      const source = stream.source;
      this._isStreamingSupported = !source.disableStream;
    }

    get isStreamingSupported() {
      return this._isStreamingSupported;
    }

    async read() {
      await this._readCapability.promise;

      if (this._done) {
        return {
          value: undefined,
          done: true
        };
      }

      if (this._storedError) {
        throw this._storedError;
      }

      const chunk = this._readableStream.read();

      if (chunk === null) {
        this._readCapability = (0, _util.createPromiseCapability)();
        return this.read();
      }

      this._loaded += chunk.length;

      if (this.onProgress) {
        this.onProgress({
          loaded: this._loaded
        });
      }

      const buffer = new Uint8Array(chunk).buffer;
      return {
        value: buffer,
        done: false
      };
    }

    cancel(reason) {
      if (!this._readableStream) {
        this._error(reason);

        return;
      }

      this._readableStream.destroy(reason);
    }

    _error(reason) {
      this._storedError = reason;

      this._readCapability.resolve();
    }

    _setReadableStream(readableStream) {
      this._readableStream = readableStream;
      readableStream.on("readable", () => {
        this._readCapability.resolve();
      });
      readableStream.on("end", () => {
        readableStream.destroy();
        this._done = true;

        this._readCapability.resolve();
      });
      readableStream.on("error", reason => {
        this._error(reason);
      });

      if (this._storedError) {
        this._readableStream.destroy(this._storedError);
      }
    }

  }

  function createRequestOptions(parsedUrl, headers) {
    return {
      protocol: parsedUrl.protocol,
      auth: parsedUrl.auth,
      host: parsedUrl.hostname,
      port: parsedUrl.port,
      path: parsedUrl.path,
      method: "GET",
      headers
    };
  }

  class PDFNodeStreamFullReader extends BaseFullReader {
    constructor(stream) {
      super(stream);

      const handleResponse = response => {
        if (response.statusCode === 404) {
          const error = new _util.MissingPDFException(`Missing PDF "${this._url}".`);
          this._storedError = error;

          this._headersCapability.reject(error);

          return;
        }

        this._headersCapability.resolve();

        this._setReadableStream(response);

        const getResponseHeader = name => {
          return this._readableStream.headers[name.toLowerCase()];
        };

        const {
          allowRangeRequests,
          suggestedLength
        } = (0, _network_utils.validateRangeRequestCapabilities)({
          getResponseHeader,
          isHttp: stream.isHttp,
          rangeChunkSize: this._rangeChunkSize,
          disableRange: this._disableRange
        });
        this._isRangeSupported = allowRangeRequests;
        this._contentLength = suggestedLength || this._contentLength;
        this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
      };

      this._request = null;

      if (this._url.protocol === "http:") {
        this._request = http.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
      } else {
        this._request = https.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
      }

      this._request.on("error", reason => {
        this._storedError = reason;

        this._headersCapability.reject(reason);
      });

      this._request.end();
    }

  }

  class PDFNodeStreamRangeReader extends BaseRangeReader {
    constructor(stream, start, end) {
      super(stream);
      this._httpHeaders = {};

      for (const property in stream.httpHeaders) {
        const value = stream.httpHeaders[property];

        if (typeof value === "undefined") {
          continue;
        }

        this._httpHeaders[property] = value;
      }

      this._httpHeaders.Range = `bytes=${start}-${end - 1}`;

      const handleResponse = response => {
        if (response.statusCode === 404) {
          const error = new _util.MissingPDFException(`Missing PDF "${this._url}".`);
          this._storedError = error;
          return;
        }

        this._setReadableStream(response);
      };

      this._request = null;

      if (this._url.protocol === "http:") {
        this._request = http.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
      } else {
        this._request = https.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
      }

      this._request.on("error", reason => {
        this._storedError = reason;
      });

      this._request.end();
    }

  }

  class PDFNodeStreamFsFullReader extends BaseFullReader {
    constructor(stream) {
      super(stream);
      let path = decodeURIComponent(this._url.path);

      if (fileUriRegex.test(this._url.href)) {
        path = path.replace(/^\//, "");
      }

      fs.lstat(path, (error, stat) => {
        if (error) {
          if (error.code === "ENOENT") {
            error = new _util.MissingPDFException(`Missing PDF "${path}".`);
          }

          this._storedError = error;

          this._headersCapability.reject(error);

          return;
        }

        this._contentLength = stat.size;

        this._setReadableStream(fs.createReadStream(path));

        this._headersCapability.resolve();
      });
    }

  }

  class PDFNodeStreamFsRangeReader extends BaseRangeReader {
    constructor(stream, start, end) {
      super(stream);
      let path = decodeURIComponent(this._url.path);

      if (fileUriRegex.test(this._url.href)) {
        path = path.replace(/^\//, "");
      }

      this._setReadableStream(fs.createReadStream(path, {
        start,
        end: end - 1
      }));
    }

  }

  /***/ }),
  /* 24 */
  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



  Object.defineProperty(exports, "__esModule", ({
    value: true
  }));
  exports.createResponseStatusError = createResponseStatusError;
  exports.extractFilenameFromHeader = extractFilenameFromHeader;
  exports.validateRangeRequestCapabilities = validateRangeRequestCapabilities;
  exports.validateResponseStatus = validateResponseStatus;

  var _util = __w_pdfjs_require__(2);

  var _content_disposition = __w_pdfjs_require__(25);

  function validateRangeRequestCapabilities({
    getResponseHeader,
    isHttp,
    rangeChunkSize,
    disableRange
  }) {
    (0, _util.assert)(rangeChunkSize > 0, "Range chunk size must be larger than zero");
    const returnValues = {
      allowRangeRequests: false,
      suggestedLength: undefined
    };
    const length = parseInt(getResponseHeader("Content-Length"), 10);

    if (!Number.isInteger(length)) {
      return returnValues;
    }

    returnValues.suggestedLength = length;

    if (length <= 2 * rangeChunkSize) {
      return returnValues;
    }

    if (disableRange || !isHttp) {
      return returnValues;
    }

    if (getResponseHeader("Accept-Ranges") !== "bytes") {
      return returnValues;
    }

    const contentEncoding = getResponseHeader("Content-Encoding") || "identity";

    if (contentEncoding !== "identity") {
      return returnValues;
    }

    returnValues.allowRangeRequests = true;
    return returnValues;
  }

  function extractFilenameFromHeader(getResponseHeader) {
    const contentDisposition = getResponseHeader("Content-Disposition");

    if (contentDisposition) {
      let filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);

      if (filename.includes("%")) {
        try {
          filename = decodeURIComponent(filename);
        } catch (ex) {}
      }

      if (/\.pdf$/i.test(filename)) {
        return filename;
      }
    }

    return null;
  }

  function createResponseStatusError(status, url) {
    if (status === 404 || status === 0 && url.startsWith("file:")) {
      return new _util.MissingPDFException('Missing PDF "' + url + '".');
    }

    return new _util.UnexpectedResponseException("Unexpected server response (" + status + ') while retrieving PDF "' + url + '".', status);
  }

  function validateResponseStatus(status) {
    return status === 200 || status === 206;
  }

  /***/ }),
  /* 25 */
  /***/ ((__unused_webpack_module, exports) => {



  Object.defineProperty(exports, "__esModule", ({
    value: true
  }));
  exports.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;

  function getFilenameFromContentDispositionHeader(contentDisposition) {
    let needsEncodingFixup = true;
    let tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition);

    if (tmp) {
      tmp = tmp[1];
      let filename = rfc2616unquote(tmp);
      filename = unescape(filename);
      filename = rfc5987decode(filename);
      filename = rfc2047decode(filename);
      return fixupEncoding(filename);
    }

    tmp = rfc2231getparam(contentDisposition);

    if (tmp) {
      const filename = rfc2047decode(tmp);
      return fixupEncoding(filename);
    }

    tmp = toParamRegExp("filename", "i").exec(contentDisposition);

    if (tmp) {
      tmp = tmp[1];
      let filename = rfc2616unquote(tmp);
      filename = rfc2047decode(filename);
      return fixupEncoding(filename);
    }

    function toParamRegExp(attributePattern, flags) {
      return new RegExp("(?:^|;)\\s*" + attributePattern + "\\s*=\\s*" + "(" + '[^";\\s][^;\\s]*' + "|" + '"(?:[^"\\\\]|\\\\"?)+"?' + ")", flags);
    }

    function textdecode(encoding, value) {
      if (encoding) {
        if (!/^[\x00-\xFF]+$/.test(value)) {
          return value;
        }

        try {
          const decoder = new TextDecoder(encoding, {
            fatal: true
          });
          const bytes = Array.from(value, function (ch) {
            return ch.charCodeAt(0) & 0xff;
          });
          value = decoder.decode(new Uint8Array(bytes));
          needsEncodingFixup = false;
        } catch (e) {
          if (/^utf-?8$/i.test(encoding)) {
            try {
              value = decodeURIComponent(escape(value));
              needsEncodingFixup = false;
            } catch (err) {}
          }
        }
      }

      return value;
    }

    function fixupEncoding(value) {
      if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
        value = textdecode("utf-8", value);

        if (needsEncodingFixup) {
          value = textdecode("iso-8859-1", value);
        }
      }

      return value;
    }

    function rfc2231getparam(contentDispositionStr) {
      const matches = [];
      let match;
      const iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");

      while ((match = iter.exec(contentDispositionStr)) !== null) {
        let [, n, quot, part] = match;
        n = parseInt(n, 10);

        if (n in matches) {
          if (n === 0) {
            break;
          }

          continue;
        }

        matches[n] = [quot, part];
      }

      const parts = [];

      for (let n = 0; n < matches.length; ++n) {
        if (!(n in matches)) {
          break;
        }

        let [quot, part] = matches[n];
        part = rfc2616unquote(part);

        if (quot) {
          part = unescape(part);

          if (n === 0) {
            part = rfc5987decode(part);
          }
        }

        parts.push(part);
      }

      return parts.join("");
    }

    function rfc2616unquote(value) {
      if (value.startsWith('"')) {
        const parts = value.slice(1).split('\\"');

        for (let i = 0; i < parts.length; ++i) {
          const quotindex = parts[i].indexOf('"');

          if (quotindex !== -1) {
            parts[i] = parts[i].slice(0, quotindex);
            parts.length = i + 1;
          }

          parts[i] = parts[i].replace(/\\(.)/g, "$1");
        }

        value = parts.join('"');
      }

      return value;
    }

    function rfc5987decode(extvalue) {
      const encodingend = extvalue.indexOf("'");

      if (encodingend === -1) {
        return extvalue;
      }

      const encoding = extvalue.slice(0, encodingend);
      const langvalue = extvalue.slice(encodingend + 1);
      const value = langvalue.replace(/^[^']*'/, "");
      return textdecode(encoding, value);
    }

    function rfc2047decode(value) {
      if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) {
        return value;
      }

      return value.replace(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function (matches, charset, encoding, text) {
        if (encoding === "q" || encoding === "Q") {
          text = text.replace(/_/g, " ");
          text = text.replace(/=([0-9a-fA-F]{2})/g, function (match, hex) {
            return String.fromCharCode(parseInt(hex, 16));
          });
          return textdecode(charset, text);
        }

        try {
          text = atob(text);
        } catch (e) {}

        return textdecode(charset, text);
      });
    }

    return "";
  }

  /***/ }),
  /* 26 */
  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



  Object.defineProperty(exports, "__esModule", ({
    value: true
  }));
  exports.PDFNetworkStream = void 0;

  var _util = __w_pdfjs_require__(2);

  var _network_utils = __w_pdfjs_require__(24);

  ;
  const OK_RESPONSE = 200;
  const PARTIAL_CONTENT_RESPONSE = 206;

  function getArrayBuffer(xhr) {
    const data = xhr.response;

    if (typeof data !== "string") {
      return data;
    }

    const array = (0, _util.stringToBytes)(data);
    return array.buffer;
  }

  class NetworkManager {
    constructor(url, args) {
      this.url = url;
      args = args || {};
      this.isHttp = /^https?:/i.test(url);
      this.httpHeaders = this.isHttp && args.httpHeaders || {};
      this.withCredentials = args.withCredentials || false;

      this.getXhr = args.getXhr || function NetworkManager_getXhr() {
        return new XMLHttpRequest();
      };

      this.currXhrId = 0;
      this.pendingRequests = Object.create(null);
    }

    requestRange(begin, end, listeners) {
      const args = {
        begin,
        end
      };

      for (const prop in listeners) {
        args[prop] = listeners[prop];
      }

      return this.request(args);
    }

    requestFull(listeners) {
      return this.request(listeners);
    }

    request(args) {
      const xhr = this.getXhr();
      const xhrId = this.currXhrId++;
      const pendingRequest = this.pendingRequests[xhrId] = {
        xhr
      };
      xhr.open("GET", this.url);
      xhr.withCredentials = this.withCredentials;

      for (const property in this.httpHeaders) {
        const value = this.httpHeaders[property];

        if (typeof value === "undefined") {
          continue;
        }

        xhr.setRequestHeader(property, value);
      }

      if (this.isHttp && "begin" in args && "end" in args) {
        xhr.setRequestHeader("Range", `bytes=${args.begin}-${args.end - 1}`);
        pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;
      } else {
        pendingRequest.expectedStatus = OK_RESPONSE;
      }

      xhr.responseType = "arraybuffer";

      if (args.onError) {
        xhr.onerror = function (evt) {
          args.onError(xhr.status);
        };
      }

      xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
      xhr.onprogress = this.onProgress.bind(this, xhrId);
      pendingRequest.onHeadersReceived = args.onHeadersReceived;
      pendingRequest.onDone = args.onDone;
      pendingRequest.onError = args.onError;
      pendingRequest.onProgress = args.onProgress;
      xhr.send(null);
      return xhrId;
    }

    onProgress(xhrId, evt) {
      const pendingRequest = this.pendingRequests[xhrId];

      if (!pendingRequest) {
        return;
      }

      if (pendingRequest.onProgress) {
        pendingRequest.onProgress(evt);
      }
    }

    onStateChange(xhrId, evt) {
      const pendingRequest = this.pendingRequests[xhrId];

      if (!pendingRequest) {
        return;
      }

      const xhr = pendingRequest.xhr;

      if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
        pendingRequest.onHeadersReceived();
        delete pendingRequest.onHeadersReceived;
      }

      if (xhr.readyState !== 4) {
        return;
      }

      if (!(xhrId in this.pendingRequests)) {
        return;
      }

      delete this.pendingRequests[xhrId];

      if (xhr.status === 0 && this.isHttp) {
        if (pendingRequest.onError) {
          pendingRequest.onError(xhr.status);
        }

        return;
      }

      const xhrStatus = xhr.status || OK_RESPONSE;
      const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;

      if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
        if (pendingRequest.onError) {
          pendingRequest.onError(xhr.status);
        }

        return;
      }

      const chunk = getArrayBuffer(xhr);

      if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
        const rangeHeader = xhr.getResponseHeader("Content-Range");
        const matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
        pendingRequest.onDone({
          begin: parseInt(matches[1], 10),
          chunk
        });
      } else if (chunk) {
        pendingRequest.onDone({
          begin: 0,
          chunk
        });
      } else if (pendingRequest.onError) {
        pendingRequest.onError(xhr.status);
      }
    }

    getRequestXhr(xhrId) {
      return this.pendingRequests[xhrId].xhr;
    }

    isPendingRequest(xhrId) {
      return xhrId in this.pendingRequests;
    }

    abortRequest(xhrId) {
      const xhr = this.pendingRequests[xhrId].xhr;
      delete this.pendingRequests[xhrId];
      xhr.abort();
    }

  }

  class PDFNetworkStream {
    constructor(source) {
      this._source = source;
      this._manager = new NetworkManager(source.url, {
        httpHeaders: source.httpHeaders,
        withCredentials: source.withCredentials
      });
      this._rangeChunkSize = source.rangeChunkSize;
      this._fullRequestReader = null;
      this._rangeRequestReaders = [];
    }

    _onRangeRequestReaderClosed(reader) {
      const i = this._rangeRequestReaders.indexOf(reader);

      if (i >= 0) {
        this._rangeRequestReaders.splice(i, 1);
      }
    }

    getFullReader() {
      (0, _util.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once.");
      this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
      return this._fullRequestReader;
    }

    getRangeReader(begin, end) {
      const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);
      reader.onClosed = this._onRangeRequestReaderClosed.bind(this);

      this._rangeRequestReaders.push(reader);

      return reader;
    }

    cancelAllRequests(reason) {
      if (this._fullRequestReader) {
        this._fullRequestReader.cancel(reason);
      }

      const readers = this._rangeRequestReaders.slice(0);

      readers.forEach(function (reader) {
        reader.cancel(reason);
      });
    }

  }

  exports.PDFNetworkStream = PDFNetworkStream;

  class PDFNetworkStreamFullRequestReader {
    constructor(manager, source) {
      this._manager = manager;
      const args = {
        onHeadersReceived: this._onHeadersReceived.bind(this),
        onDone: this._onDone.bind(this),
        onError: this._onError.bind(this),
        onProgress: this._onProgress.bind(this)
      };
      this._url = source.url;
      this._fullRequestId = manager.requestFull(args);
      this._headersReceivedCapability = (0, _util.createPromiseCapability)();
      this._disableRange = source.disableRange || false;
      this._contentLength = source.length;
      this._rangeChunkSize = source.rangeChunkSize;

      if (!this._rangeChunkSize && !this._disableRange) {
        this._disableRange = true;
      }

      this._isStreamingSupported = false;
      this._isRangeSupported = false;
      this._cachedChunks = [];
      this._requests = [];
      this._done = false;
      this._storedError = undefined;
      this._filename = null;
      this.onProgress = null;
    }

    _onHeadersReceived() {
      const fullRequestXhrId = this._fullRequestId;

      const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);

      const getResponseHeader = name => {
        return fullRequestXhr.getResponseHeader(name);
      };

      const {
        allowRangeRequests,
        suggestedLength
      } = (0, _network_utils.validateRangeRequestCapabilities)({
        getResponseHeader,
        isHttp: this._manager.isHttp,
        rangeChunkSize: this._rangeChunkSize,
        disableRange: this._disableRange
      });

      if (allowRangeRequests) {
        this._isRangeSupported = true;
      }

      this._contentLength = suggestedLength || this._contentLength;
      this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);

      if (this._isRangeSupported) {
        this._manager.abortRequest(fullRequestXhrId);
      }

      this._headersReceivedCapability.resolve();
    }

    _onDone(args) {
      if (args) {
        if (this._requests.length > 0) {
          const requestCapability = this._requests.shift();

          requestCapability.resolve({
            value: args.chunk,
            done: false
          });
        } else {
          this._cachedChunks.push(args.chunk);
        }
      }

      this._done = true;

      if (this._cachedChunks.length > 0) {
        return;
      }

      this._requests.forEach(function (requestCapability) {
        requestCapability.resolve({
          value: undefined,
          done: true
        });
      });

      this._requests = [];
    }

    _onError(status) {
      const url = this._url;
      const exception = (0, _network_utils.createResponseStatusError)(status, url);
      this._storedError = exception;

      this._headersReceivedCapability.reject(exception);

      this._requests.forEach(function (requestCapability) {
        requestCapability.reject(exception);
      });

      this._requests = [];
      this._cachedChunks = [];
    }

    _onProgress(data) {
      if (this.onProgress) {
        this.onProgress({
          loaded: data.loaded,
          total: data.lengthComputable ? data.total : this._contentLength
        });
      }
    }

    get filename() {
      return this._filename;
    }

    get isRangeSupported() {
      return this._isRangeSupported;
    }

    get isStreamingSupported() {
      return this._isStreamingSupported;
    }

    get contentLength() {
      return this._contentLength;
    }

    get headersReady() {
      return this._headersReceivedCapability.promise;
    }

    async read() {
      if (this._storedError) {
        throw this._storedError;
      }

      if (this._cachedChunks.length > 0) {
        const chunk = this._cachedChunks.shift();

        return {
          value: chunk,
          done: false
        };
      }

      if (this._done) {
        return {
          value: undefined,
          done: true
        };
      }

      const requestCapability = (0, _util.createPromiseCapability)();

      this._requests.push(requestCapability);

      return requestCapability.promise;
    }

    cancel(reason) {
      this._done = true;

      this._headersReceivedCapability.reject(reason);

      this._requests.forEach(function (requestCapability) {
        requestCapability.resolve({
          value: undefined,
          done: true
        });
      });

      this._requests = [];

      if (this._manager.isPendingRequest(this._fullRequestId)) {
        this._manager.abortRequest(this._fullRequestId);
      }

      this._fullRequestReader = null;
    }

  }

  class PDFNetworkStreamRangeRequestReader {
    constructor(manager, begin, end) {
      this._manager = manager;
      const args = {
        onDone: this._onDone.bind(this),
        onProgress: this._onProgress.bind(this)
      };
      this._requestId = manager.requestRange(begin, end, args);
      this._requests = [];
      this._queuedChunk = null;
      this._done = false;
      this.onProgress = null;
      this.onClosed = null;
    }

    _close() {
      if (this.onClosed) {
        this.onClosed(this);
      }
    }

    _onDone(data) {
      const chunk = data.chunk;

      if (this._requests.length > 0) {
        const requestCapability = this._requests.shift();

        requestCapability.resolve({
          value: chunk,
          done: false
        });
      } else {
        this._queuedChunk = chunk;
      }

      this._done = true;

      this._requests.forEach(function (requestCapability) {
        requestCapability.resolve({
          value: undefined,
          done: true
        });
      });

      this._requests = [];

      this._close();
    }

    _onProgress(evt) {
      if (!this.isStreamingSupported && this.onProgress) {
        this.onProgress({
          loaded: evt.loaded
        });
      }
    }

    get isStreamingSupported() {
      return false;
    }

    async read() {
      if (this._queuedChunk !== null) {
        const chunk = this._queuedChunk;
        this._queuedChunk = null;
        return {
          value: chunk,
          done: false
        };
      }

      if (this._done) {
        return {
          value: undefined,
          done: true
        };
      }

      const requestCapability = (0, _util.createPromiseCapability)();

      this._requests.push(requestCapability);

      return requestCapability.promise;
    }

    cancel(reason) {
      this._done = true;

      this._requests.forEach(function (requestCapability) {
        requestCapability.resolve({
          value: undefined,
          done: true
        });
      });

      this._requests = [];

      if (this._manager.isPendingRequest(this._requestId)) {
        this._manager.abortRequest(this._requestId);
      }

      this._close();
    }

  }

  /***/ }),
  /* 27 */
  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



  Object.defineProperty(exports, "__esModule", ({
    value: true
  }));
  exports.PDFFetchStream = void 0;

  var _util = __w_pdfjs_require__(2);

  var _network_utils = __w_pdfjs_require__(24);

  ;

  function createFetchOptions(headers, withCredentials, abortController) {
    return {
      method: "GET",
      headers,
      signal: abortController && abortController.signal, // lwf
      mode: "cors",
      credentials: withCredentials ? "include" : "same-origin",
      redirect: "follow"
    };
  }

  function createHeaders(httpHeaders) {
    const headers = new Headers();

    for (const property in httpHeaders) {
      const value = httpHeaders[property];

      if (typeof value === "undefined") {
        continue;
      }

      headers.append(property, value);
    }

    return headers;
  }

  class PDFFetchStream {
    constructor(source) {
      this.source = source;
      this.isHttp = /^https?:/i.test(source.url);
      this.httpHeaders = this.isHttp && source.httpHeaders || {};
      this._fullRequestReader = null;
      this._rangeRequestReaders = [];
    }

    get _progressiveDataLength() {
      return this._fullRequestReader && this._fullRequestReader._loaded || 0; // lwf
    }

    getFullReader() {
      (0, _util.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once.");
      this._fullRequestReader = new PDFFetchStreamReader(this);
      return this._fullRequestReader;
    }

    getRangeReader(begin, end) {
      if (end <= this._progressiveDataLength) {
        return null;
      }

      const reader = new PDFFetchStreamRangeReader(this, begin, end);

      this._rangeRequestReaders.push(reader);

      return reader;
    }

    cancelAllRequests(reason) {
      if (this._fullRequestReader) {
        this._fullRequestReader.cancel(reason);
      }

      const readers = this._rangeRequestReaders.slice(0);

      readers.forEach(function (reader) {
        reader.cancel(reason);
      });
    }

  }

  exports.PDFFetchStream = PDFFetchStream;

  class PDFFetchStreamReader {
    constructor(stream) {
      this._stream = stream;
      this._reader = null;
      this._loaded = 0;
      this._filename = null;
      const source = stream.source;
      this._withCredentials = source.withCredentials || false;
      this._contentLength = source.length;
      this._headersCapability = (0, _util.createPromiseCapability)();
      this._disableRange = source.disableRange || false;
      this._rangeChunkSize = source.rangeChunkSize;

      if (!this._rangeChunkSize && !this._disableRange) {
        this._disableRange = true;
      }

      if (typeof AbortController !== "undefined") {
        this._abortController = new AbortController();
      }

      this._isStreamingSupported = !source.disableStream;
      this._isRangeSupported = !source.disableRange;
      this._headers = createHeaders(this._stream.httpHeaders);
      const url = source.url;
      fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {
        if (!(0, _network_utils.validateResponseStatus)(response.status)) {
          throw (0, _network_utils.createResponseStatusError)(response.status, url);
        }

        this._reader = response.body.getReader();

        this._headersCapability.resolve();

        const getResponseHeader = name => {
          return response.headers.get(name);
        };

        const {
          allowRangeRequests,
          suggestedLength
        } = (0, _network_utils.validateRangeRequestCapabilities)({
          getResponseHeader,
          isHttp: this._stream.isHttp,
          rangeChunkSize: this._rangeChunkSize,
          disableRange: this._disableRange
        });
        this._isRangeSupported = allowRangeRequests;
        this._contentLength = suggestedLength || this._contentLength;
        this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);

        if (!this._isStreamingSupported && this._isRangeSupported) {
          this.cancel(new _util.AbortException("Streaming is disabled."));
        }
      }).catch(this._headersCapability.reject);
      this.onProgress = null;
    }

    get headersReady() {
      return this._headersCapability.promise;
    }

    get filename() {
      return this._filename;
    }

    get contentLength() {
      return this._contentLength;
    }

    get isRangeSupported() {
      return this._isRangeSupported;
    }

    get isStreamingSupported() {
      return this._isStreamingSupported;
    }

    async read() {
      await this._headersCapability.promise;
      const {
        value,
        done
      } = await this._reader.read();

      if (done) {
        return {
          value,
          done
        };
      }

      this._loaded += value.byteLength;

      if (this.onProgress) {
        this.onProgress({
          loaded: this._loaded,
          total: this._contentLength
        });
      }

      const buffer = new Uint8Array(value).buffer;
      return {
        value: buffer,
        done: false
      };
    }

    cancel(reason) {
      if (this._reader) {
        this._reader.cancel(reason);
      }

      if (this._abortController) {
        this._abortController.abort();
      }
    }

  }

  class PDFFetchStreamRangeReader {
    constructor(stream, begin, end) {
      this._stream = stream;
      this._reader = null;
      this._loaded = 0;
      const source = stream.source;
      this._withCredentials = source.withCredentials || false;
      this._readCapability = (0, _util.createPromiseCapability)();
      this._isStreamingSupported = !source.disableStream;

      if (typeof AbortController !== "undefined") {
        this._abortController = new AbortController();
      }

      this._headers = createHeaders(this._stream.httpHeaders);

      this._headers.append("Range", `bytes=${begin}-${end - 1}`);

      const url = source.url;
      fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {
        if (!(0, _network_utils.validateResponseStatus)(response.status)) {
          throw (0, _network_utils.createResponseStatusError)(response.status, url);
        }

        this._readCapability.resolve();

        this._reader = response.body.getReader();
      }).catch(reason => {
        if (reason && reason.name === "AbortError") { // lwf
          return;
        }

        throw reason;
      });
      this.onProgress = null;
    }

    get isStreamingSupported() {
      return this._isStreamingSupported;
    }

    async read() {
      await this._readCapability.promise;
      const {
        value,
        done
      } = await this._reader.read();

      if (done) {
        return {
          value,
          done
        };
      }

      this._loaded += value.byteLength;

      if (this.onProgress) {
        this.onProgress({
          loaded: this._loaded
        });
      }

      const buffer = new Uint8Array(value).buffer;
      return {
        value: buffer,
        done: false
      };
    }

    cancel(reason) {
      if (this._reader) {
        this._reader.cancel(reason);
      }

      if (this._abortController) {
        this._abortController.abort();
      }
    }

  }
/***/ })
/******/  ]);
/************************************************************************/
/******/  // The module cache
/******/  var __webpack_module_cache__ = {};
/******/  
/******/  // The require function
/******/  function __w_pdfjs_require__(moduleId) {
/******/    // Check if module is in cache
/******/    if(__webpack_module_cache__[moduleId]) {
/******/      return __webpack_module_cache__[moduleId].exports;
/******/    }
/******/    // Create a new module (and put it into the cache)
/******/    var module = __webpack_module_cache__[moduleId] = {
/******/      // no module.id needed
/******/      // no module.loaded needed
/******/      exports: {}
/******/    };
/******/  
/******/    // Execute the module function
/******/    __webpack_modules__[moduleId](module, module.exports, __w_pdfjs_require__);
/******/  
/******/    // Return the exports of the module
/******/    return module.exports;
/******/  }
/******/  
/************************************************************************/
/******/  // module exports must be returned from runtime so entry inlining is disabled
/******/  // startup
/******/  // Load entry module and return exports
/******/  return __w_pdfjs_require__(0);
/******/ })()
;
});

define('skylark-pdfjs-display/main',[
	"./display"
],function(display) {
	return display;
});
define('skylark-pdfjs-display', ['skylark-pdfjs-display/main'], function (main) { return main; });

define('skylark-viewerjs/ui_utils',[
    "./viewerjs"
],function(viewerjs) {
  'use strict';

  var CSS_UNITS = 96.0 / 72.0;
  var DEFAULT_SCALE = 'auto';
  var UNKNOWN_SCALE = 0;
  var MAX_AUTO_SCALE = 1.25;
  var SCROLLBAR_PADDING = 40;
  var VERTICAL_PADDING = 5;

  // optimised CSS custom property getter/setter
  var CustomStyle = (function CustomStyleClosure() {

    // As noted on: http://www.zachstronaut.com/posts/2009/02/17/
    //              animate-css-transforms-firefox-webkit.html
    // in some versions of IE9 it is critical that ms appear in this list
    // before Moz
    var prefixes = ['ms', 'Moz', 'Webkit', 'O'];
    var _cache = {};

    function CustomStyle() {}

    CustomStyle.getProp = function get(propName, element) {
      // check cache only when no element is given
      if (arguments.length === 1 && typeof _cache[propName] === 'string') {
        return _cache[propName];
      }

      element = element || document.documentElement;
      var style = element.style, prefixed, uPropName;

      // test standard property first
      if (typeof style[propName] === 'string') {
        return (_cache[propName] = propName);
      }

      // capitalize
      uPropName = propName.charAt(0).toUpperCase() + propName.slice(1);

      // test vendor specific properties
      for (var i = 0, l = prefixes.length; i < l; i++) {
        prefixed = prefixes[i] + uPropName;
        if (typeof style[prefixed] === 'string') {
          return (_cache[propName] = prefixed);
        }
      }

      //if all fails then set to undefined
      return (_cache[propName] = 'undefined');
    };

    CustomStyle.setProp = function set(propName, element, str) {
      var prop = this.getProp(propName);
      if (prop !== 'undefined') {
        element.style[prop] = str;
      }
    };

    return CustomStyle;
  })();

  function getFileName(url) {
    var anchor = url.indexOf('#');
    var query = url.indexOf('?');
    var end = Math.min(
      anchor > 0 ? anchor : url.length,
      query > 0 ? query : url.length);
    return url.substring(url.lastIndexOf('/', end) + 1, end);
  }

  /**
   * Returns scale factor for the canvas. It makes sense for the HiDPI displays.
   * @return {Object} The object with horizontal (sx) and vertical (sy)
                      scales. The scaled property is set to false if scaling is
                      not required, true otherwise.
   */
  function getOutputScale(ctx) {
    var devicePixelRatio = window.devicePixelRatio || 1;
    var backingStoreRatio = ctx.webkitBackingStorePixelRatio ||
                            ctx.mozBackingStorePixelRatio ||
                            ctx.msBackingStorePixelRatio ||
                            ctx.oBackingStorePixelRatio ||
                            ctx.backingStorePixelRatio || 1;
    var pixelRatio = devicePixelRatio / backingStoreRatio;
    return {
      sx: pixelRatio,
      sy: pixelRatio,
      scaled: pixelRatio !== 1
    };
  }

  /**
   * Scrolls specified element into view of its parent.
   * element {Object} The element to be visible.
   * spot {Object} An object with optional top and left properties,
   *               specifying the offset from the top left edge.
   */
  function scrollIntoView(element, spot) {
    // Assuming offsetParent is available (it's not available when viewer is in
    // hidden iframe or object). We have to scroll: if the offsetParent is not set
    // producing the error. See also animationStartedClosure.
    var parent = element.offsetParent;
    var offsetY = element.offsetTop + element.clientTop;
    var offsetX = element.offsetLeft + element.clientLeft;
    if (!parent) {
      console.error('offsetParent is not set -- cannot scroll');
      return;
    }
    while (parent.clientHeight === parent.scrollHeight) {
      if (parent.dataset._scaleY) {
        offsetY /= parent.dataset._scaleY;
        offsetX /= parent.dataset._scaleX;
      }
      offsetY += parent.offsetTop;
      offsetX += parent.offsetLeft;
      parent = parent.offsetParent;
      if (!parent) {
        return; // no need to scroll
      }
    }
    if (spot) {
      if (spot.top !== undefined) {
        offsetY += spot.top;
      }
      if (spot.left !== undefined) {
        offsetX += spot.left;
        parent.scrollLeft = offsetX;
      }
    }
    parent.scrollTop = offsetY;
  }

  /**
   * Helper function to start monitoring the scroll event and converting them into
   * PDF.js friendly one: with scroll debounce and scroll direction.
   */
  function watchScroll(viewAreaElement, callback) {
    var debounceScroll = function debounceScroll(evt) {
      if (rAF) {
        return;
      }
      // schedule an invocation of scroll for next animation frame.
      rAF = window.requestAnimationFrame(function viewAreaElementScrolled() {
        rAF = null;

        var currentY = viewAreaElement.scrollTop;
        var lastY = state.lastY;
        if (currentY !== lastY) {
          state.down = currentY > lastY;
        }
        state.lastY = currentY;
        callback(state);
      });
    };

    var state = {
      down: true,
      lastY: viewAreaElement.scrollTop,
      _eventHandler: debounceScroll
    };

    var rAF = null;
    viewAreaElement.addEventListener('scroll', debounceScroll, true);
    return state;
  }

  /**
   * Use binary search to find the index of the first item in a given array which
   * passes a given condition. The items are expected to be sorted in the sense
   * that if the condition is true for one item in the array, then it is also true
   * for all following items.
   *
   * @returns {Number} Index of the first array element to pass the test,
   *                   or |items.length| if no such element exists.
   */
  function binarySearchFirstItem(items, condition) {
    var minIndex = 0;
    var maxIndex = items.length - 1;

    if (items.length === 0 || !condition(items[maxIndex])) {
      return items.length;
    }
    if (condition(items[minIndex])) {
      return minIndex;
    }

    while (minIndex < maxIndex) {
      var currentIndex = (minIndex + maxIndex) >> 1;
      var currentItem = items[currentIndex];
      if (condition(currentItem)) {
        maxIndex = currentIndex;
      } else {
        minIndex = currentIndex + 1;
      }
    }
    return minIndex; /* === maxIndex */
  }

  /**
   * Generic helper to find out what elements are visible within a scroll pane.
   */
  function getVisibleElements(scrollEl, views, sortByVisibility) {
    var top = scrollEl.scrollTop, bottom = top + scrollEl.clientHeight;
    var left = scrollEl.scrollLeft, right = left + scrollEl.clientWidth;

    function isElementBottomBelowViewTop(view) {
      var element = view.div;
      var elementBottom =
        element.offsetTop + element.clientTop + element.clientHeight;
      return elementBottom > top;
    }

    var visible = [], view, element;
    var currentHeight, viewHeight, hiddenHeight, percentHeight;
    var currentWidth, viewWidth;
    var firstVisibleElementInd = (views.length === 0) ? 0 :
      binarySearchFirstItem(views, isElementBottomBelowViewTop);

    for (var i = firstVisibleElementInd, ii = views.length; i < ii; i++) {
      view = views[i];
      element = view.div;
      currentHeight = element.offsetTop + element.clientTop;
      viewHeight = element.clientHeight;

      if (currentHeight > bottom) {
        break;
      }

      currentWidth = element.offsetLeft + element.clientLeft;
      viewWidth = element.clientWidth;
      if (currentWidth + viewWidth < left || currentWidth > right) {
        continue;
      }
      hiddenHeight = Math.max(0, top - currentHeight) +
        Math.max(0, currentHeight + viewHeight - bottom);
      percentHeight = ((viewHeight - hiddenHeight) * 100 / viewHeight) | 0;

      visible.push({
        id: view.id,
        x: currentWidth,
        y: currentHeight,
        view: view,
        percent: percentHeight
      });
    }

    var first = visible[0];
    var last = visible[visible.length - 1];

    if (sortByVisibility) {
      visible.sort(function(a, b) {
        var pc = a.percent - b.percent;
        if (Math.abs(pc) > 0.001) {
          return -pc;
        }
        return a.id - b.id; // ensure stability
      });
    }
    return {first: first, last: last, views: visible};
  }

  /**
   * Event handler to suppress context menu.
   */
  function noContextMenuHandler(e) {
    e.preventDefault();
  }

  /**
   * Returns the filename or guessed filename from the url (see issue 3455).
   * url {String} The original PDF location.
   * @return {String} Guessed PDF file name.
   */
  function getPDFFileNameFromURL(url) {
    var reURI = /^(?:([^:]+:)?\/\/[^\/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/;
    //            SCHEME      HOST         1.PATH  2.QUERY   3.REF
    // Pattern to get last matching NAME.pdf
    var reFilename = /[^\/?#=]+\.pdf\b(?!.*\.pdf\b)/i;
    var splitURI = reURI.exec(url);
    var suggestedFilename = reFilename.exec(splitURI[1]) ||
                             reFilename.exec(splitURI[2]) ||
                             reFilename.exec(splitURI[3]);
    if (suggestedFilename) {
      suggestedFilename = suggestedFilename[0];
      if (suggestedFilename.indexOf('%') !== -1) {
        // URL-encoded %2Fpath%2Fto%2Ffile.pdf should be file.pdf
        try {
          suggestedFilename =
            reFilename.exec(decodeURIComponent(suggestedFilename))[0];
        } catch(e) { // Possible (extremely rare) errors:
          // URIError "Malformed URI", e.g. for "%AA.pdf"
          // TypeError "null has no properties", e.g. for "%2F.pdf"
        }
      }
    }
    return suggestedFilename || 'document.pdf';
  }

  var ProgressBar = (function ProgressBarClosure() {

    function clamp(v, min, max) {
      return Math.min(Math.max(v, min), max);
    }

    function ProgressBar(id, opts) {
      this.visible = true;

      // Fetch the sub-elements for later.
      this.div = document.querySelector(id + ' .progress');

      // Get the loading bar element, so it can be resized to fit the viewer.
      this.bar = this.div.parentNode;

      // Get options, with sensible defaults.
      this.height = opts.height || 100;
      this.width = opts.width || 100;
      this.units = opts.units || '%';

      // Initialize heights.
      this.div.style.height = this.height + this.units;
      this.percent = 0;
    }

    ProgressBar.prototype = {

      updateBar: function ProgressBar_updateBar() {
        if (this._indeterminate) {
          this.div.classList.add('indeterminate');
          this.div.style.width = this.width + this.units;
          return;
        }

        this.div.classList.remove('indeterminate');
        var progressSize = this.width * this._percent / 100;
        this.div.style.width = progressSize + this.units;
      },

      get percent() {
        return this._percent;
      },

      set percent(val) {
        this._indeterminate = isNaN(val);
        this._percent = clamp(val, 0, 100);
        this.updateBar();
      },

      setWidth: function ProgressBar_setWidth(viewer) {
        if (viewer) {
          var container = viewer.parentNode;
          var scrollbarWidth = container.offsetWidth - viewer.offsetWidth;
          if (scrollbarWidth > 0) {
            this.bar.setAttribute('style', 'width: calc(100% - ' +
                                           scrollbarWidth + 'px);');
          }
        }
      },

      hide: function ProgressBar_hide() {
        if (!this.visible) {
          return;
        }
        this.visible = false;
        this.bar.classList.add('hidden');
        document.body.classList.remove('loadingInProgress');
      },

      show: function ProgressBar_show() {
        if (this.visible) {
          return;
        }
        this.visible = true;
        document.body.classList.add('loadingInProgress');
        this.bar.classList.remove('hidden');
      }
    };

    return ProgressBar;
  })();

  return viewerjs.uiutils = {
    CustomStyle,
    getFileName,
    getOutputScale,
    scrollIntoView,
    watchScroll,
    binarySearchFirstItem,
    getVisibleElements,
    getPDFFileNameFromURL,
    ProgressBar
  };
});
define('skylark-viewerjs/text_layer_builder',[
    "skylark-pdfjs-display",
    "./viewerjs",
    "./ui_utils"
],function(PDFJS,viewerjs,uiutils) {
  'use strict';

  var MAX_TEXT_DIVS_TO_RENDER = 100000;

  var NonWhitespaceRegexp = /\S/;

  function isAllWhitespace(str) {
    return !NonWhitespaceRegexp.test(str);
  }

  /**
   * @typedef {Object} TextLayerBuilderOptions
   * @property {HTMLDivElement} textLayerDiv - The text layer container.
   * @property {number} pageIndex - The page index.
   * @property {PageViewport} viewport - The viewport of the text layer.
   * @property {PDFFindController} findController
   */

  /**
   * TextLayerBuilder provides text-selection functionality for the PDF.
   * It does this by creating overlay divs over the PDF text. These divs
   * contain text that matches the PDF text they are overlaying. This object
   * also provides a way to highlight text that is being searched for.
   * @class
   */
  function TextLayerBuilder(options) {
    this.textLayerDiv = options.textLayerDiv;
    this.renderingDone = false;
    this.divContentDone = false;
    this.pageIdx = options.pageIndex;
    this.pageNumber = this.pageIdx + 1;
    this.matches = [];
    this.viewport = options.viewport;
    this.textDivs = [];
    this.findController = options.findController || null;
  }

  TextLayerBuilder.prototype = {
    _finishRendering: function TextLayerBuilder_finishRendering() {
      this.renderingDone = true;

      var event = document.createEvent('CustomEvent');
      event.initCustomEvent('textlayerrendered', true, true, {
        pageNumber: this.pageNumber
      });
      this.textLayerDiv.dispatchEvent(event);
    },

    renderLayer: function TextLayerBuilder_renderLayer() {
      var textLayerFrag = document.createDocumentFragment();
      var textDivs = this.textDivs;
      var textDivsLength = textDivs.length;
      var canvas = document.createElement('canvas');
      var ctx = canvas.getContext('2d');

      // No point in rendering many divs as it would make the browser
      // unusable even after the divs are rendered.
      if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {
        this._finishRendering();
        return;
      }

      var lastFontSize;
      var lastFontFamily;
      for (var i = 0; i < textDivsLength; i++) {
        var textDiv = textDivs[i];
        if (textDiv.dataset.isWhitespace !== undefined) {
          continue;
        }

        var fontSize = textDiv.style.fontSize;
        var fontFamily = textDiv.style.fontFamily;

        // Only build font string and set to context if different from last.
        if (fontSize !== lastFontSize || fontFamily !== lastFontFamily) {
          ctx.font = fontSize + ' ' + fontFamily;
          lastFontSize = fontSize;
          lastFontFamily = fontFamily;
        }

        var width = ctx.measureText(textDiv.textContent).width;
        if (width > 0) {
          textLayerFrag.appendChild(textDiv);
          var transform;
          if (textDiv.dataset.canvasWidth !== undefined) {
            // Dataset values come of type string.
            var textScale = textDiv.dataset.canvasWidth / width;
            transform = 'scaleX(' + textScale + ')';
          } else {
            transform = '';
          }
          var rotation = textDiv.dataset.angle;
          if (rotation) {
            transform = 'rotate(' + rotation + 'deg) ' + transform;
          }
          if (transform) {
            uiutils.CustomStyle.setProp('transform' , textDiv, transform);
          }
        }
      }

      this.textLayerDiv.appendChild(textLayerFrag);
      this._finishRendering();
      this.updateMatches();
    },

    /**
     * Renders the text layer.
     * @param {number} timeout (optional) if specified, the rendering waits
     *   for specified amount of ms.
     */
    render: function TextLayerBuilder_render(timeout) {
      if (!this.divContentDone || this.renderingDone) {
        return;
      }

      if (this.renderTimer) {
        clearTimeout(this.renderTimer);
        this.renderTimer = null;
      }

      if (!timeout) { // Render right away
        this.renderLayer();
      } else { // Schedule
        var self = this;
        this.renderTimer = setTimeout(function() {
          self.renderLayer();
          self.renderTimer = null;
        }, timeout);
      }
    },

    appendText: function TextLayerBuilder_appendText(geom, styles) {
      var style = styles[geom.fontName];
      var textDiv = document.createElement('div');
      this.textDivs.push(textDiv);
      if (isAllWhitespace(geom.str)) {
        textDiv.dataset.isWhitespace = true;
        return;
      }
      var tx = PDFJS.Util.transform(this.viewport.transform, geom.transform);
      var angle = Math.atan2(tx[1], tx[0]);
      if (style.vertical) {
        angle += Math.PI / 2;
      }
      var fontHeight = Math.sqrt((tx[2] * tx[2]) + (tx[3] * tx[3]));
      var fontAscent = fontHeight;
      if (style.ascent) {
        fontAscent = style.ascent * fontAscent;
      } else if (style.descent) {
        fontAscent = (1 + style.descent) * fontAscent;
      }

      var left;
      var top;
      if (angle === 0) {
        left = tx[4];
        top = tx[5] - fontAscent;
      } else {
        left = tx[4] + (fontAscent * Math.sin(angle));
        top = tx[5] - (fontAscent * Math.cos(angle));
      }
      textDiv.style.left = left + 'px';
      textDiv.style.top = top + 'px';
      textDiv.style.fontSize = fontHeight + 'px';
      textDiv.style.fontFamily = style.fontFamily;

      textDiv.textContent = geom.str;
      // |fontName| is only used by the Font Inspector. This test will succeed
      // when e.g. the Font Inspector is off but the Stepper is on, but it's
      // not worth the effort to do a more accurate test.
      if (PDFJS.pdfBug) {
        textDiv.dataset.fontName = geom.fontName;
      }
      // Storing into dataset will convert number into string.
      if (angle !== 0) {
        textDiv.dataset.angle = angle * (180 / Math.PI);
      }
      // We don't bother scaling single-char text divs, because it has very
      // little effect on text highlighting. This makes scrolling on docs with
      // lots of such divs a lot faster.
      if (textDiv.textContent.length > 1) {
        if (style.vertical) {
          textDiv.dataset.canvasWidth = geom.height * this.viewport.scale;
        } else {
          textDiv.dataset.canvasWidth = geom.width * this.viewport.scale;
        }
      }
    },

    setTextContent: function TextLayerBuilder_setTextContent(textContent) {
      this.textContent = textContent;

      var textItems = textContent.items;
      for (var i = 0, len = textItems.length; i < len; i++) {
        this.appendText(textItems[i], textContent.styles);
      }
      this.divContentDone = true;
    },

    convertMatches: function TextLayerBuilder_convertMatches(matches) {
      var i = 0;
      var iIndex = 0;
      var bidiTexts = this.textContent.items;
      var end = bidiTexts.length - 1;
      var queryLen = (this.findController === null ?
                      0 : this.findController.state.query.length);
      var ret = [];

      for (var m = 0, len = matches.length; m < len; m++) {
        // Calculate the start position.
        var matchIdx = matches[m];

        // Loop over the divIdxs.
        while (i !== end && matchIdx >= (iIndex + bidiTexts[i].str.length)) {
          iIndex += bidiTexts[i].str.length;
          i++;
        }

        if (i === bidiTexts.length) {
          console.error('Could not find a matching mapping');
        }

        var match = {
          begin: {
            divIdx: i,
            offset: matchIdx - iIndex
          }
        };

        // Calculate the end position.
        matchIdx += queryLen;

        // Somewhat the same array as above, but use > instead of >= to get
        // the end position right.
        while (i !== end && matchIdx > (iIndex + bidiTexts[i].str.length)) {
          iIndex += bidiTexts[i].str.length;
          i++;
        }

        match.end = {
          divIdx: i,
          offset: matchIdx - iIndex
        };
        ret.push(match);
      }

      return ret;
    },

    renderMatches: function TextLayerBuilder_renderMatches(matches) {
      // Early exit if there is nothing to render.
      if (matches.length === 0) {
        return;
      }

      var bidiTexts = this.textContent.items;
      var textDivs = this.textDivs;
      var prevEnd = null;
      var pageIdx = this.pageIdx;
      var isSelectedPage = (this.findController === null ?
        false : (pageIdx === this.findController.selected.pageIdx));
      var selectedMatchIdx = (this.findController === null ?
                              -1 : this.findController.selected.matchIdx);
      var highlightAll = (this.findController === null ?
                          false : this.findController.state.highlightAll);
      var infinity = {
        divIdx: -1,
        offset: undefined
      };

      function beginText(begin, className) {
        var divIdx = begin.divIdx;
        textDivs[divIdx].textContent = '';
        appendTextToDiv(divIdx, 0, begin.offset, className);
      }

      function appendTextToDiv(divIdx, fromOffset, toOffset, className) {
        var div = textDivs[divIdx];
        var content = bidiTexts[divIdx].str.substring(fromOffset, toOffset);
        var node = document.createTextNode(content);
        if (className) {
          var span = document.createElement('span');
          span.className = className;
          span.appendChild(node);
          div.appendChild(span);
          return;
        }
        div.appendChild(node);
      }

      var i0 = selectedMatchIdx, i1 = i0 + 1;
      if (highlightAll) {
        i0 = 0;
        i1 = matches.length;
      } else if (!isSelectedPage) {
        // Not highlighting all and this isn't the selected page, so do nothing.
        return;
      }

      for (var i = i0; i < i1; i++) {
        var match = matches[i];
        var begin = match.begin;
        var end = match.end;
        var isSelected = (isSelectedPage && i === selectedMatchIdx);
        var highlightSuffix = (isSelected ? ' selected' : '');

        if (this.findController) {
          this.findController.updateMatchPosition(pageIdx, i, textDivs,
                                                  begin.divIdx, end.divIdx);
        }

        // Match inside new div.
        if (!prevEnd || begin.divIdx !== prevEnd.divIdx) {
          // If there was a previous div, then add the text at the end.
          if (prevEnd !== null) {
            appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);
          }
          // Clear the divs and set the content until the starting point.
          beginText(begin);
        } else {
          appendTextToDiv(prevEnd.divIdx, prevEnd.offset, begin.offset);
        }

        if (begin.divIdx === end.divIdx) {
          appendTextToDiv(begin.divIdx, begin.offset, end.offset,
                          'highlight' + highlightSuffix);
        } else {
          appendTextToDiv(begin.divIdx, begin.offset, infinity.offset,
                          'highlight begin' + highlightSuffix);
          for (var n0 = begin.divIdx + 1, n1 = end.divIdx; n0 < n1; n0++) {
            textDivs[n0].className = 'highlight middle' + highlightSuffix;
          }
          beginText(end, 'highlight end' + highlightSuffix);
        }
        prevEnd = end;
      }

      if (prevEnd) {
        appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);
      }
    },

    updateMatches: function TextLayerBuilder_updateMatches() {
      // Only show matches when all rendering is done.
      if (!this.renderingDone) {
        return;
      }

      // Clear all matches.
      var matches = this.matches;
      var textDivs = this.textDivs;
      var bidiTexts = this.textContent.items;
      var clearedUntilDivIdx = -1;

      // Clear all current matches.
      for (var i = 0, len = matches.length; i < len; i++) {
        var match = matches[i];
        var begin = Math.max(clearedUntilDivIdx, match.begin.divIdx);
        for (var n = begin, end = match.end.divIdx; n <= end; n++) {
          var div = textDivs[n];
          div.textContent = bidiTexts[n].str;
          div.className = '';
        }
        clearedUntilDivIdx = match.end.divIdx + 1;
      }

      if (this.findController === null || !this.findController.active) {
        return;
      }

      // Convert the matches on the page controller into the match format
      // used for the textLayer.
      this.matches = this.convertMatches(this.findController === null ?
        [] : (this.findController.pageMatches[this.pageIdx] || []));
      this.renderMatches(this.matches);
    }
  };

  /**
   * @constructor
   * @implements IPDFTextLayerFactory
   */
  function DefaultTextLayerFactory() {}
  DefaultTextLayerFactory.prototype = {
    /**
     * @param {HTMLDivElement} textLayerDiv
     * @param {number} pageIndex
     * @param {PageViewport} viewport
     * @returns {TextLayerBuilder}
     */
    createTextLayerBuilder: function (textLayerDiv, pageIndex, viewport) {
      return new TextLayerBuilder({
        textLayerDiv: textLayerDiv,
        pageIndex: pageIndex,
        viewport: viewport
      });
    }
  };

  TextLayerBuilder.DefaultTextLayerFactory = DefaultTextLayerFactory;

  return viewerjs.TextLayerBuilder = TextLayerBuilder
});
define('skylark-viewerjs/PDFViewerPlugin',[
    "skylark-pdfjs-display",
    "./viewerjs",
    "./ui_utils",
    "./text_layer_builder"
],function(PDFJS,viewerjs,uiutils,TextLayerBuilder) {
    function PDFViewerPlugin() {
        "use strict";

        function loadScript(path, callback) {
            var script = document.createElement('script');
            script.async = false;
            script.src = path;
            script.type = 'text/javascript';
            script.onload = callback || script.onload;
            document.getElementsByTagName('head')[0].appendChild(script);
        }

        function init(callback) {
            var pluginCSS;

            /*
            loadScript('./compatibility.js', function () {
                loadScript('./pdf.js');
                loadScript('./ui_utils.js');
                loadScript('./text_layer_builder.js');
                loadScript('./pdfjsversion.js', callback);
            });
            */
            callback();

        }

        var self = this,
            pages = [],
            domPages = [],
            pageText = [],
            renderingStates = [],
            RENDERING = {
                BLANK: 0,
                RUNNING: 1,
                FINISHED: 2,
                RUNNINGOUTDATED: 3
            },
            TEXT_LAYER_RENDER_DELAY = 200, // ms
            container = null,
            pdfDocument = null,
            pageViewScroll = null,
            isGuessedSlideshow = true, // assume true as default, any non-matching page will unset this
            isPresentationMode = false,
            scale = 1,
            currentPage = 1,
            maxPageWidth = 0,
            maxPageHeight = 0,
            createdPageCount = 0;

        function scrollIntoView(elem) {
            elem.parentNode.scrollTop = elem.offsetTop;
        }

        function isScrolledIntoView(elem) {
            if (elem.style.display === "none") {
                return false;
            }

            var docViewTop = container.scrollTop,
                docViewBottom = docViewTop + container.clientHeight,
                elemTop = elem.offsetTop,
                elemBottom = elemTop + elem.clientHeight;

            // Is in view if either the top or the bottom of the page is between the
            // document viewport bounds,
            // or if the top is above the viewport and the bottom is below it.
            return (elemTop >= docViewTop && elemTop < docViewBottom)
                    || (elemBottom >= docViewTop && elemBottom < docViewBottom)
                    || (elemTop < docViewTop && elemBottom >= docViewBottom);
        }

        function getDomPage(page) {
            return domPages[page.pageNumber-1]; //modified by lwf for new pdf version
        }
        function getPageText(page) {
            return pageText[page.pageNumber-1];//modified by lwf for new pdf version
        }
        function getRenderingStatus(page) {
            return renderingStates[page.pageNumber-1];//modified by lwf for new pdf version
        }
        function setRenderingStatus(page, renderStatus) {
            renderingStates[page.pageNumber-1] = renderStatus;//modified by lwf for new pdf version
        }

        function updatePageDimensions(page, width, height) {
            var domPage = getDomPage(page),
                canvas = domPage.getElementsByTagName('canvas')[0],
                textLayer = domPage.getElementsByTagName('div')[0],
                cssScale = 'scale(' + scale + ', ' + scale + ')';

            domPage.style.width = width + "px";
            domPage.style.height = height + "px";

            canvas.width = width;
            canvas.height = height;
            canvas.style.width = width + "px";
            canvas.style.height = height + "px";


            textLayer.style.width = width + "px";
            textLayer.style.height = height + "px";

            uiutils.CustomStyle.setProp('transform', textLayer, cssScale);
            uiutils.CustomStyle.setProp('transformOrigin', textLayer, '0% 0%');

            if (getRenderingStatus(page) === RENDERING.RUNNING) {
                // TODO: should be able to cancel that rendering
                setRenderingStatus(page, RENDERING.RUNNINGOUTDATED);
            } else {
                // Once the page dimension is updated, the rendering state is blank.
                setRenderingStatus(page, RENDERING.BLANK);
            }
        }

        function ensurePageRendered(page) {
            var domPage, textLayer, canvas;

            if (getRenderingStatus(page) === RENDERING.BLANK) {
                setRenderingStatus(page, RENDERING.RUNNING);

                domPage = getDomPage(page);
                textLayer = getPageText(page);
                canvas = domPage.getElementsByTagName('canvas')[0];

                page.render({
                    canvasContext: canvas.getContext('2d'),
                    textLayer: textLayer,
                    viewport: page.getViewport({scale}) //modified by lwf for new pdf version
                }).promise.then(function () {
                    /*
                    if (getRenderingStatus(page) === RENDERING.RUNNINGOUTDATED) {
                        // restart
                        setRenderingStatus(page, RENDERING.BLANK);
                        ensurePageRendered(page);
                    } else {
                        setRenderingStatus(page, RENDERING.FINISHED);
                    }
                    */
                });
            }
        }

        function completeLoading() {
            var allPagesVisible = !self.isSlideshow();
            domPages.forEach(function (domPage) {
                if (allPagesVisible) {
                    domPage.style.display = "block";
                }
                container.appendChild(domPage);
            });

            self.onLoad();
            self.showPage(1);
        }

        function createPage(page) {
            var pageNumber,
                textLayerDiv,
                textLayer,
                canvas,
                domPage,
                viewport;

            pageNumber = page.pageNumber; // page.pageIndex + 1; modified by lwf for new pdf version

            viewport = page.getViewport({scale});//viewport = page.getViewport(scale);modified by lwf for new pdf version

            domPage = document.createElement('div');
            domPage.id = 'pageContainer' + pageNumber;
            domPage.className = 'page';
            domPage.style.display = "none";

            canvas = document.createElement('canvas');
            canvas.id = 'canvas' + pageNumber;

            textLayerDiv = document.createElement('div');
            textLayerDiv.className = 'textLayer';
            textLayerDiv.id = 'textLayer' + pageNumber;

            domPage.appendChild(canvas);
            domPage.appendChild(textLayerDiv);

            pages[page.pageNumber-1] = page; //modified by lwf for new pdf version
            domPages[page.pageNumber-1] = domPage; //modified by lwf for new pdf version
            renderingStates[page.pageNumber-1] = RENDERING.BLANK;

            updatePageDimensions(page, viewport.width, viewport.height);
            if (maxPageWidth < viewport.width) {
                maxPageWidth = viewport.width;
            }
            if (maxPageHeight < viewport.height) {
                maxPageHeight = viewport.height;
            }
            // A very simple but generally true guess - if any page has the height greater than the width, treat it no longer as a slideshow
            if (viewport.width < viewport.height) {
                isGuessedSlideshow = false;
            }

            textLayer = new TextLayerBuilder({
                textLayerDiv: textLayerDiv,
                viewport: viewport,
                pageIndex: pageNumber - 1
            });
            page.getTextContent().then(function (textContent) {
                textLayer.setTextContent(textContent);
                textLayer.render(TEXT_LAYER_RENDER_DELAY);
            });
            pageText[page.pageNumber-1] = textLayer; //modified by lwf for new pdf version

            createdPageCount += 1;
            if (createdPageCount === (pdfDocument.numPages)) {
                completeLoading();
            }
        }

        this.initialize = function (viewContainer, location) {
            var self = this,
                i,
                pluginCSS;


            init(function () {
                PDFJS.GlobalWorkerOptions.workerSrc = "./skylark-pdfjs-worker-all.js"; //PDFJS.workerSrc = "./skylark-pdfjs-worker-all.js"; modified by lwf for new pdf version
                //PDFJS.getDocument(location).then(function loadPDF(doc) {
                PDFJS.getDocument(location).promise.then(function loadPDF(doc) {
                    pdfDocument = doc;
                    container = viewContainer;

                    for (i = 0; i < pdfDocument.numPages; i += 1) {
                        pdfDocument.getPage(i + 1).then(createPage);
                    }
                });
            });
        };

        this.isSlideshow = function () {
            return isGuessedSlideshow;
        };

        this.onLoad = function () {};

        this.getPages = function () {
            return domPages;
        };

        this.fitToWidth = function (width) {
            var zoomLevel;

            if (maxPageWidth === width) {
                return;
            }
            zoomLevel = width / maxPageWidth;
            self.setZoomLevel(zoomLevel);
        };

        this.fitToHeight = function (height) {
            var zoomLevel;

            if (maxPageHeight === height) {
                return;
            }
            zoomLevel = height / maxPageHeight;
            self.setZoomLevel(zoomLevel);
        };

        this.fitToPage = function (width, height) {
            var zoomLevel = width / maxPageWidth;
            if (height / maxPageHeight < zoomLevel) {
                zoomLevel = height / maxPageHeight;
            }
            self.setZoomLevel(zoomLevel);
        };

        this.fitSmart = function (width, height) {
            var zoomLevel = width / maxPageWidth;
            if (height && (height / maxPageHeight) < zoomLevel) {
                zoomLevel = height / maxPageHeight;
            }
            zoomLevel = Math.min(1.0, zoomLevel);
            self.setZoomLevel(zoomLevel);
        };

        this.setZoomLevel = function (zoomLevel) {
            var i, viewport;

            if (scale !== zoomLevel) {
                scale = zoomLevel;

                for (i = 0; i < pages.length; i += 1) {
                    viewport = pages[i].getViewport({scale}); //modified by lwf for new pdf version
                    updatePageDimensions(pages[i], viewport.width, viewport.height);
                }
            }
        };

        this.getZoomLevel = function () {
            return scale;
        };

        this.onScroll = function () {
            var i;

            for (i = 0; i < domPages.length; i += 1) {
                if (isScrolledIntoView(domPages[i])) {
                    ensurePageRendered(pages[i]);
                }
            }
        };

        this.getPageInView = function () {
            var i;

            if (self.isSlideshow()) {
                return currentPage;
            } else {
                for (i = 0; i < domPages.length; i += 1) {
                    if (isScrolledIntoView(domPages[i])) {
                        return i + 1;
                    }
                }
            }
        };

        this.showPage = function (n) {
            if (self.isSlideshow()) {
                domPages[currentPage - 1].style.display = "none";
                currentPage = n;
                ensurePageRendered(pages[n - 1]);
                domPages[n - 1].style.display = "block";
            } else {
                scrollIntoView(domPages[n - 1]);
            }
        };

        this.getPluginName = function () {
            return "PDF.js"
        };

        this.getPluginVersion = function () {
            var version = (String(typeof pdfjs_version) !== "undefined"
                ? pdfjs_version
                : "From Source"
            );
            return version;
        };

        this.getPluginURL = function () {
            return "https://github.com/mozilla/pdf.js/";
        };
    }

    return viewerjs.PDFViewerPlugin = PDFViewerPlugin;
});
define('skylark-viewerjs/plugin_registry',[
    "./viewerjs",
    "./ODFViewerPlugin",
    "./PDFViewerPlugin"
],function(viewerjs,ODFViewerPlugin,PDFViewerPlugin) {
    var css,
        pluginRegistry = [
        (function() {
            var odfMimetypes = [
                'application/vnd.oasis.opendocument.text',
                'application/vnd.oasis.opendocument.text-flat-xml',
                'application/vnd.oasis.opendocument.text-template',
                'application/vnd.oasis.opendocument.presentation',
                'application/vnd.oasis.opendocument.presentation-flat-xml',
                'application/vnd.oasis.opendocument.presentation-template',
                'application/vnd.oasis.opendocument.spreadsheet',
                'application/vnd.oasis.opendocument.spreadsheet-flat-xml',
                'application/vnd.oasis.opendocument.spreadsheet-template'];
            var odfFileExtensions = [
                'odt',
                'fodt',
                'ott',
                'odp',
                'fodp',
                'otp',
                'ods',
                'fods',
                'ots'];

            return {
                supportsMimetype: function(mimetype) {
                    return (odfMimetypes.indexOf(mimetype) !== -1);
                },
                supportsFileExtension: function(extension) {
                    return (odfFileExtensions.indexOf(extension) !== -1);
                },
                path: "./ODFViewerPlugin",
                getClass: function() { return ODFViewerPlugin; }
            };
        }()),
        {
            supportsMimetype: function(mimetype) {
                return (mimetype === 'application/pdf');
            },
            supportsFileExtension: function(extension) {
                return (extension === 'pdf');
            },
            path: "./PDFViewerPlugin",
            getClass: function() { return PDFViewerPlugin; }
        }
    ];



    return viewerjs.pluginRegistry = pluginRegistry

});

define('skylark-viewerjs/init',[
    "./viewerjs",
	"./viewer",
	"./plugin_registry"

],function(viewerjs,Viewer,pluginRegistry){
	var viewer;

    function parseSearchParameters(location) {
        var parameters = {},
            search = location.search || "?";

        search.substr(1).split('&').forEach(function (q) {
            // skip empty strings
            if (!q) {
                return;
            }
            // if there is no '=', have it handled as if given key was set to undefined
            var s = q.split('=', 2);
            parameters[decodeURIComponent(s[0])] = decodeURIComponent(s[1]);
        });

        return parameters;
    }

    function estimateTypeByHeaderContentType(documentUrl, cb) {
        var xhr = new XMLHttpRequest();
        xhr.onreadystatechange = function() {
            var mimetype, matchingPluginData;
            if (xhr.readyState === 4) {
                if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 0) {
                    mimetype = xhr.getResponseHeader('content-type');

                    if (mimetype) {
                        pluginRegistry.some(function(pluginData) {
                            if (pluginData.supportsMimetype(mimetype)) {
                                matchingPluginData = pluginData;
                                console.log('Found plugin by mimetype and xhr head: ' + mimetype);
                                return true;
                            }
                            return false;
                        });
                    }
                }
                cb(matchingPluginData);
            }
        };
        xhr.open("HEAD", documentUrl, true);
        xhr.send();
    }


    function doEstimateTypeByFileExtension(extension) {
        var matchingPluginData;

        pluginRegistry.some(function(pluginData) {
            if (pluginData.supportsFileExtension(extension)) {
                matchingPluginData = pluginData;
                return true;
            }
            return false;
        });

        return matchingPluginData;
    }


    function estimateTypeByFileExtension(extension) {
        var matchingPluginData = doEstimateTypeByFileExtension(extension)

        if (matchingPluginData) {
            console.log('Found plugin by parameter type: ' + extension);
        }

        return matchingPluginData;
    }


    function estimateTypeByFileExtensionFromPath(documentUrl) {
        // See to get any path from the url and grep what could be a file extension
        var documentPath = documentUrl.split('?')[0],
            extension = documentPath.split('.').pop(),
            matchingPluginData = doEstimateTypeByFileExtension(extension)

        if (matchingPluginData) {
            console.log('Found plugin by file extension from path: ' + extension);
        }

        return matchingPluginData;
    }

	function init() {
	   window.onload = function () {
	        var viewer,
	            documentUrl = document.location.hash.substring(1),
	            parameters = parseSearchParameters(document.location),
	            Plugin;

	        if (documentUrl) {
	            // try to guess the title as filename from the location, if not set by parameter
	            if (!parameters.title) {
	                parameters.title = documentUrl.replace(/^.*[\\\/]/, '');
	            }

	            parameters.documentUrl = documentUrl;

	            // trust the server most
	            estimateTypeByHeaderContentType(documentUrl, function(pluginData) {
	                if (!pluginData) {
	                    if (parameters.type) {
	                        pluginData = estimateTypeByFileExtension(parameters.type);
	                    } else {
	                        // last ressort: try to guess from path
	                        pluginData = estimateTypeByFileExtensionFromPath(documentUrl);
	                    }
	                }

	                if (pluginData) {
	                    if (String(typeof loadPlugin) !== "undefined") {
	                        loadPlugin(pluginData.path, function () {
	                            Plugin = pluginData.getClass();
	                            viewer = new Viewer(new Plugin(), parameters);
	                        });
	                    } else {
	                        Plugin = pluginData.getClass();
	                        viewer = new Viewer(new Plugin(), parameters);
	                    }
	                } else {
	                    viewer = new Viewer();
	                }
	            });
	        } else {
	            viewer = new Viewer();
	        }
	    };
	}
 
 	return viewerjs.init = init;
});



define('skylark-viewerjs/main',[
	"./viewerjs",
	"./viewer",
	"./ODFViewerPlugin",
	"./PDFViewerPlugin",
	"./plugin_registry",
	"./text_layer_builder",
	"./ui_utils",
	"./init"
],function(viewerjs) {
	return viewerjs;
});
define('skylark-viewerjs', ['skylark-viewerjs/main'], function (main) { return main; });


},this);
//# sourceMappingURL=sourcemaps/skylark-viewerjs-all.js.map
