{"version":3,"sources":["skylark-viewerjs-all.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-viewerjs-all.js","sourcesContent":["define('skylark-langx-ns/_attach',[],function(){\r\n    return  function attach(obj1,path,obj2) {\r\n        if (typeof path == \"string\") {\r\n            path = path.split(\".\");//[path]\r\n        };\r\n        var length = path.length,\r\n            ns=obj1,\r\n            i=0,\r\n            name = path[i++];\r\n\r\n        while (i < length) {\r\n            ns = ns[name] = ns[name] || {};\r\n            name = path[i++];\r\n        }\r\n\r\n        ns[name] = obj2 || {};\r\n        return ns[name];\r\n    }\r\n});\ndefine('skylark-langx-ns/ns',[\r\n    \"./_attach\"\r\n], function(_attach) {\r\n    var skylark = {\r\n    \tattach : function(path,obj) {\r\n    \t\treturn _attach(skylark,path,obj);\r\n    \t}\r\n    };\r\n    return skylark;\r\n});\r\n\ndefine('skylark-langx-ns/main',[\r\n\t\"./ns\"\r\n],function(skylark){\r\n\treturn skylark;\r\n});\ndefine('skylark-langx-ns', ['skylark-langx-ns/main'], function (main) { return main; });\n\ndefine('skylark-viewerjs/viewerjs',[\r\n\t\"skylark-langx-ns\"\r\n],function(skylark) {\r\n\treturn skylark.attach(\"intg.viewerjs\");\r\n});\ndefine('skylark-viewerjs/viewer',[\n    \"./viewerjs\"\n],function(viewerjs) {\n    /*global document, window*/\n\n    function Viewer(viewerPlugin, parameters) {\n        \"use strict\";\n\n        var self = this,\n            kScrollbarPadding = 40,\n            kMinScale = 0.25,\n            kMaxScale = 4.0,\n            kDefaultScaleDelta = 1.1,\n            kDefaultScale = 'auto',\n            presentationMode = false,\n            isFullScreen = false,\n            initialized = false,\n            url,\n            viewerElement = document.getElementById('viewer'),\n            canvasContainer = document.getElementById('canvasContainer'),\n            overlayNavigator = document.getElementById('overlayNavigator'),\n            titlebar = document.getElementById('titlebar'),\n            toolbar = document.getElementById('toolbarContainer'),\n            pageSwitcher = document.getElementById('toolbarLeft'),\n            zoomWidget = document.getElementById('toolbarMiddleContainer'),\n            scaleSelector = document.getElementById('scaleSelect'),\n            dialogOverlay = document.getElementById('dialogOverlay'),\n            toolbarRight = document.getElementById('toolbarRight'),\n            aboutDialog,\n            pages = [],\n            currentPage,\n            scaleChangeTimer,\n            touchTimer,\n            toolbarTouchTimer,\n            /**@const*/\n            UI_FADE_DURATION = 5000;\n\n        function isBlankedOut() {\n            return (blanked.style.display === 'block');\n        }\n\n        function initializeAboutInformation() {\n            var aboutDialogCentererTable, aboutDialogCentererCell, aboutButton, pluginName, pluginVersion, pluginURL,\n                version;\n\n            version = (String(typeof ViewerJS_version) !== \"undefined\" ? ViewerJS_version : \"From Source\");\n            if (viewerPlugin) {\n                pluginName = viewerPlugin.getPluginName();\n                pluginVersion = viewerPlugin.getPluginVersion();\n                pluginURL = viewerPlugin.getPluginURL();\n            }\n\n            // Create dialog\n            aboutDialogCentererTable = document.createElement('div');\n            aboutDialogCentererTable.id = \"aboutDialogCentererTable\";\n            aboutDialogCentererCell = document.createElement('div');\n            aboutDialogCentererCell.id = \"aboutDialogCentererCell\";\n            aboutDialog = document.createElement('div');\n            aboutDialog.id = \"aboutDialog\";\n            aboutDialog.innerHTML =\n                \"<h1>ViewerJS</h1>\" +\n                \"<p>Open Source document viewer for webpages, built with HTML and JavaScript.</p>\" +\n                \"<p>Learn more and get your own copy on the <a href=\\\"http://viewerjs.org/\\\" target=\\\"_blank\\\">ViewerJS website</a>.</p>\" +\n                (viewerPlugin ? (\"<p>Using the <a href = \\\"\"+ pluginURL + \"\\\" target=\\\"_blank\\\">\" + pluginName + \"</a> \" +\n                                \"(<span id = \\\"pluginVersion\\\">\" + pluginVersion + \"</span>) \" +\n                                \"plugin to show you this document.</p>\")\n                             : \"\") +\n                \"<p>Version \" + version + \"</p>\" +\n                \"<p>Supported by <a href=\\\"https://nlnet.nl\\\" target=\\\"_blank\\\"><br><img src=\\\"images\\/nlnet.png\\\" width=\\\"160\\\" height=\\\"60\\\" alt=\\\"NLnet Foundation\\\"></a></p>\" +\n                \"<p>Made by <a href=\\\"http://kogmbh.com\\\" target=\\\"_blank\\\"><br><img src=\\\"images\\/kogmbh.png\\\" width=\\\"172\\\" height=\\\"40\\\" alt=\\\"KO GmbH\\\"></a></p>\" +\n                \"<button id = \\\"aboutDialogCloseButton\\\" class = \\\"toolbarButton textButton\\\">Close</button>\";\n            dialogOverlay.appendChild(aboutDialogCentererTable);\n            aboutDialogCentererTable.appendChild(aboutDialogCentererCell);\n            aboutDialogCentererCell.appendChild(aboutDialog);\n\n            // Create button to open dialog that says \"ViewerJS\"\n            aboutButton = document.createElement('button');\n            aboutButton.id = \"about\";\n            aboutButton.className = \"toolbarButton textButton about\";\n            aboutButton.title = \"About\";\n            aboutButton.innerHTML = \"ViewerJS\"\n            toolbarRight.appendChild(aboutButton);\n\n            // Attach events to the above\n            aboutButton.addEventListener('click', function () {\n                    showAboutDialog();\n            });\n            document.getElementById('aboutDialogCloseButton').addEventListener('click', function () {\n                    hideAboutDialog();\n            });\n\n        }\n\n        function showAboutDialog() {\n            dialogOverlay.style.display = \"block\";\n        }\n\n        function hideAboutDialog() {\n            dialogOverlay.style.display = \"none\";\n        }\n\n        function selectScaleOption(value) {\n            // Retrieve the options from the zoom level <select> element\n            var options = scaleSelector.options,\n                option,\n                predefinedValueFound = false,\n                i;\n\n            for (i = 0; i < options.length; i += 1) {\n                option = options[i];\n                if (option.value !== value) {\n                    option.selected = false;\n                    continue;\n                }\n                option.selected = true;\n                predefinedValueFound = true;\n            }\n            return predefinedValueFound;\n        }\n\n        function getPages() {\n            return viewerPlugin.getPages();\n        }\n\n        function setScale(val, resetAutoSettings) {\n            if (val === self.getZoomLevel()) {\n                return;\n            }\n\n            self.setZoomLevel(val);\n\n            var event = document.createEvent('UIEvents');\n            event.initUIEvent('scalechange', false, false, window, 0);\n            event.scale = val;\n            event.resetAutoSettings = resetAutoSettings;\n            window.dispatchEvent(event);\n        }\n\n        function onScroll() {\n            var pageNumber;\n\n            if (viewerPlugin.onScroll) {\n                viewerPlugin.onScroll();\n            }\n            if (viewerPlugin.getPageInView) {\n                pageNumber = viewerPlugin.getPageInView();\n                if (pageNumber) {\n                    currentPage = pageNumber;\n                    document.getElementById('pageNumber').value = pageNumber;\n                }\n            }\n        }\n\n        function delayedRefresh(milliseconds) {\n            window.clearTimeout(scaleChangeTimer);\n            scaleChangeTimer = window.setTimeout(function () {\n                onScroll();\n            }, milliseconds);\n        }\n\n        function parseScale(value, resetAutoSettings) {\n            var scale,\n                maxWidth,\n                maxHeight;\n\n            if (value === 'custom') {\n                scale = parseFloat(document.getElementById('customScaleOption').textContent) / 100;\n            } else {\n                scale = parseFloat(value);\n            }\n\n            if (scale) {\n                setScale(scale, true);\n                delayedRefresh(300);\n                return;\n            }\n\n            maxWidth = canvasContainer.clientWidth - kScrollbarPadding;\n            maxHeight = canvasContainer.clientHeight - kScrollbarPadding;\n\n            switch (value) {\n            case 'page-actual':\n                setScale(1, resetAutoSettings);\n                break;\n            case 'page-width':\n                viewerPlugin.fitToWidth(maxWidth);\n                break;\n            case 'page-height':\n                viewerPlugin.fitToHeight(maxHeight);\n                break;\n            case 'page-fit':\n                viewerPlugin.fitToPage(maxWidth, maxHeight);\n                break;\n            case 'auto':\n                if (viewerPlugin.isSlideshow()) {\n                    viewerPlugin.fitToPage(maxWidth + kScrollbarPadding, maxHeight + kScrollbarPadding);\n                } else {\n                    viewerPlugin.fitSmart(maxWidth);\n                }\n                break;\n            }\n\n            selectScaleOption(value);\n            delayedRefresh(300);\n        }\n\n        function readZoomParameter(zoom) {\n            var validZoomStrings = [\"auto\", \"page-actual\", \"page-width\"],\n                number;\n\n            if (validZoomStrings.indexOf(zoom) !== -1) {\n                return zoom;\n            }\n            number = parseFloat(zoom);\n            if (number && kMinScale <= number && number <= kMaxScale) {\n                return zoom;\n            }\n            return kDefaultScale;\n        }\n\n        function readStartPageParameter(startPage) {\n            var result = parseInt(startPage, 10);\n            return isNaN(result) ? 1 : result;\n        }\n\n        this.initialize = function () {\n            var initialScale,\n                element;\n\n            initialScale = readZoomParameter(parameters.zoom);\n\n            url = parameters.documentUrl;\n            document.title = parameters.title;\n            var documentName = document.getElementById('documentName');\n            documentName.innerHTML = \"\";\n            documentName.appendChild(documentName.ownerDocument.createTextNode(parameters.title));\n\n            viewerPlugin.onLoad = function () {\n                document.getElementById('pluginVersion').innerHTML = viewerPlugin.getPluginVersion();\n\n                if (viewerPlugin.isSlideshow()) {\n                    // Slideshow pages should be centered\n                    canvasContainer.classList.add(\"slideshow\");\n                    // Show page nav controls only for presentations\n                    pageSwitcher.style.visibility = 'visible';\n                } else {\n                    // For text documents, show the zoom widget.\n                    zoomWidget.style.visibility = 'visible';\n                    // Only show the page switcher widget if the plugin supports page numbers\n                    if (viewerPlugin.getPageInView) {\n                        pageSwitcher.style.visibility = 'visible';\n                    }\n                }\n\n                initialized = true;\n                pages = getPages();\n                document.getElementById('numPages').innerHTML = 'of ' + pages.length;\n\n\n                // Set default scale\n                parseScale(initialScale);\n\n\n                self.showPage(readStartPageParameter(parameters.startpage));\n\n                canvasContainer.onscroll = onScroll;\n                delayedRefresh();\n            };\n\n            viewerPlugin.initialize(canvasContainer, url);\n        };\n\n        /**\n         * Shows the 'n'th page. If n is larger than the page count,\n         * shows the last page. If n is less than 1, shows the first page.\n         * @return {undefined}\n         */\n        this.showPage = function (n) {\n            if (n <= 0) {\n                n = 1;\n            } else if (n > pages.length) {\n                n = pages.length;\n            }\n\n            viewerPlugin.showPage(n);\n\n            currentPage = n;\n            document.getElementById('pageNumber').value = currentPage;\n        };\n\n        /**\n         * Shows the next page. If there is no subsequent page, does nothing.\n         * @return {undefined}\n         */\n        this.showNextPage = function () {\n            self.showPage(currentPage + 1);\n        };\n\n        /**\n         * Shows the previous page. If there is no previous page, does nothing.\n         * @return {undefined}\n         */\n        this.showPreviousPage = function () {\n            self.showPage(currentPage - 1);\n        };\n\n        /**\n         * Attempts to 'download' the file.\n         * @return {undefined}\n         */\n        this.download = function () {\n            var documentUrl = url.split('#')[0];\n            documentUrl += '#viewer.action=download';\n            window.open(documentUrl, '_parent');\n        };\n\n        /**\n         * Toggles the fullscreen state of the viewer\n         * @return {undefined}\n         */\n        this.toggleFullScreen = function () {\n            var elem = viewerElement;\n            if (!isFullScreen) {\n                if (elem.requestFullscreen) {\n                    elem.requestFullscreen();\n                } else if (elem.mozRequestFullScreen) {\n                    elem.mozRequestFullScreen();\n                } else if (elem.webkitRequestFullscreen) {\n                    elem.webkitRequestFullscreen();\n                } else if (elem.webkitRequestFullScreen) {\n                    elem.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT);\n                } else if (elem.msRequestFullscreen) {\n                    elem.msRequestFullscreen();\n                }\n            } else {\n                if (document.exitFullscreen) {\n                    document.exitFullscreen();\n                } else if (document.cancelFullScreen) {\n                    document.cancelFullScreen();\n                } else if (document.mozCancelFullScreen) {\n                    document.mozCancelFullScreen();\n                } else if (document.webkitExitFullscreen) {\n                    document.webkitExitFullscreen();\n                } else if (document.webkitCancelFullScreen) {\n                    document.webkitCancelFullScreen();\n                } else if (document.msExitFullscreen) {\n                    document.msExitFullscreen();\n                }\n            }\n        };\n\n        /**\n         * Toggles the presentation mode of the viewer.\n         * Presentation mode involves fullscreen + hidden UI controls\n         */\n        this.togglePresentationMode = function () {\n            var overlayCloseButton = document.getElementById('overlayCloseButton');\n\n            if (!presentationMode) {\n                titlebar.style.display = toolbar.style.display = 'none';\n                overlayCloseButton.style.display = 'block';\n                canvasContainer.classList.add('presentationMode');\n                canvasContainer.onmousedown = function (event) {\n                    event.preventDefault();\n                };\n                canvasContainer.oncontextmenu = function (event) {\n                    event.preventDefault();\n                };\n                canvasContainer.onmouseup = function (event) {\n                    event.preventDefault();\n                    if (event.which === 1) {\n                        self.showNextPage();\n                    } else {\n                        self.showPreviousPage();\n                    }\n                };\n                parseScale('page-fit');\n            } else {\n                if (isBlankedOut()) {\n                    leaveBlankOut();\n                }\n                titlebar.style.display = toolbar.style.display = 'block';\n                overlayCloseButton.style.display = 'none';\n                canvasContainer.classList.remove('presentationMode');\n                canvasContainer.onmouseup = function () {};\n                canvasContainer.oncontextmenu = function () {};\n                canvasContainer.onmousedown = function () {};\n                parseScale('auto');\n            }\n\n            presentationMode = !presentationMode;\n        };\n\n        /**\n         * Gets the zoom level of the document\n         * @return {!number}\n         */\n        this.getZoomLevel = function () {\n            return viewerPlugin.getZoomLevel();\n        };\n\n        /**\n         * Set the zoom level of the document\n         * @param {!number} value\n         * @return {undefined}\n         */\n        this.setZoomLevel = function (value) {\n            viewerPlugin.setZoomLevel(value);\n        };\n\n        /**\n         * Zoom out by 10 %\n         * @return {undefined}\n         */\n        this.zoomOut = function () {\n            // 10 % decrement\n            var newScale = (self.getZoomLevel() / kDefaultScaleDelta).toFixed(2);\n            newScale = Math.max(kMinScale, newScale);\n            parseScale(newScale, true);\n        };\n\n        /**\n         * Zoom in by 10%\n         * @return {undefined}\n         */\n        this.zoomIn = function () {\n            // 10 % increment\n            var newScale = (self.getZoomLevel() * kDefaultScaleDelta).toFixed(2);\n            newScale = Math.min(kMaxScale, newScale);\n            parseScale(newScale, true);\n        };\n\n        function cancelPresentationMode() {\n            if (presentationMode && !isFullScreen) {\n                self.togglePresentationMode();\n            }\n        }\n\n        function handleFullScreenChange() {\n            isFullScreen = !isFullScreen;\n            cancelPresentationMode();\n        }\n\n        function showOverlayNavigator() {\n            if (presentationMode || viewerPlugin.isSlideshow()) {\n                overlayNavigator.className = 'viewer-touched';\n                window.clearTimeout(touchTimer);\n                touchTimer = window.setTimeout(function () {\n                    overlayNavigator.className = '';\n                }, UI_FADE_DURATION);\n            }\n        }\n\n        /**\n         * @param {!boolean} timed Fade after a while\n         */\n        function showToolbars() {\n            titlebar.classList.add('viewer-touched');\n            toolbar.classList.add('viewer-touched');\n            window.clearTimeout(toolbarTouchTimer);\n            toolbarTouchTimer = window.setTimeout(function () {\n                hideToolbars();\n            }, UI_FADE_DURATION);\n        }\n\n        function hideToolbars() {\n            titlebar.classList.remove('viewer-touched');\n            toolbar.classList.remove('viewer-touched');\n        }\n\n        function toggleToolbars() {\n            if (titlebar.classList.contains('viewer-touched')) {\n                hideToolbars();\n            } else {\n                showToolbars();\n            }\n        }\n\n        function blankOut(value) {\n            blanked.style.display = 'block';\n            blanked.style.backgroundColor = value;\n            hideToolbars();\n        }\n\n        function leaveBlankOut() {\n            blanked.style.display = 'none';\n            toggleToolbars();\n        }\n\n        function setButtonClickHandler(buttonId, handler) {\n            var button = document.getElementById(buttonId);\n\n            button.addEventListener('click', function () {\n                handler();\n                button.blur();\n            });\n        }\n\n        function init() {\n\n            initializeAboutInformation();\n\n            if (viewerPlugin) {\n                self.initialize();\n\n                if (!(document.exitFullscreen || document.cancelFullScreen || document.mozCancelFullScreen || document.webkitExitFullscreen || document.webkitCancelFullScreen || document.msExitFullscreen)) {\n                    document.getElementById('fullscreen').style.visibility = 'hidden';\n                    document.getElementById('presentation').style.visibility = 'hidden';\n                }\n\n                setButtonClickHandler('overlayCloseButton', self.toggleFullScreen);\n                setButtonClickHandler('fullscreen', self.toggleFullScreen);\n                setButtonClickHandler('presentation', function () {\n                    if (!isFullScreen) {\n                        self.toggleFullScreen();\n                    }\n                    self.togglePresentationMode();\n                });\n\n                document.addEventListener('fullscreenchange', handleFullScreenChange);\n                document.addEventListener('webkitfullscreenchange', handleFullScreenChange);\n                document.addEventListener('mozfullscreenchange', handleFullScreenChange);\n                document.addEventListener('MSFullscreenChange', handleFullScreenChange);\n\n                setButtonClickHandler('download', self.download);\n\n                setButtonClickHandler('zoomOut', self.zoomOut);\n                setButtonClickHandler('zoomIn', self.zoomIn);\n\n                setButtonClickHandler('previous', self.showPreviousPage);\n                setButtonClickHandler('next', self.showNextPage);\n\n                setButtonClickHandler('previousPage', self.showPreviousPage);\n                setButtonClickHandler('nextPage', self.showNextPage);\n\n                document.getElementById('pageNumber').addEventListener('change', function () {\n                    self.showPage(this.value);\n                });\n\n                document.getElementById('scaleSelect').addEventListener('change', function () {\n                    parseScale(this.value);\n                });\n\n                canvasContainer.addEventListener('click', showOverlayNavigator);\n                overlayNavigator.addEventListener('click', showOverlayNavigator);\n                canvasContainer.addEventListener('click', toggleToolbars);\n                titlebar.addEventListener('click', showToolbars);\n                toolbar.addEventListener('click', showToolbars);\n\n                window.addEventListener('scalechange', function (evt) {\n                    var customScaleOption = document.getElementById('customScaleOption'),\n                        predefinedValueFound = selectScaleOption(String(evt.scale));\n\n                    customScaleOption.selected = false;\n\n                    if (!predefinedValueFound) {\n                        customScaleOption.textContent = Math.round(evt.scale * 10000) / 100 + '%';\n                        customScaleOption.selected = true;\n                    }\n                }, true);\n\n                window.addEventListener('resize', function (evt) {\n                    if (initialized &&\n                              (document.getElementById('pageWidthOption').selected ||\n                              document.getElementById('pageAutoOption').selected)) {\n                        parseScale(document.getElementById('scaleSelect').value);\n                    }\n                    showOverlayNavigator();\n                });\n\n                window.addEventListener('keydown', function (evt) {\n                    var key = evt.keyCode,\n                        shiftKey = evt.shiftKey;\n\n                    // blanked-out mode?\n                    if (isBlankedOut()) {\n                        switch (key) {\n                        case 16: // Shift\n                        case 17: // Ctrl\n                        case 18: // Alt\n                        case 91: // LeftMeta\n                        case 93: // RightMeta\n                        case 224: // MetaInMozilla\n                        case 225: // AltGr\n                            // ignore modifier keys alone\n                            break;\n                        default:\n                            leaveBlankOut();\n                            break;\n                        }\n                    } else {\n                        switch (key) {\n                        case 8: // backspace\n                        case 33: // pageUp\n                        case 37: // left arrow\n                        case 38: // up arrow\n                        case 80: // key 'p'\n                            self.showPreviousPage();\n                            break;\n                        case 13: // enter\n                        case 34: // pageDown\n                        case 39: // right arrow\n                        case 40: // down arrow\n                        case 78: // key 'n'\n                            self.showNextPage();\n                            break;\n                        case 32: // space\n                            shiftKey ? self.showPreviousPage() : self.showNextPage();\n                            break;\n                        case 66:  // key 'b' blanks screen (to black) or returns to the document\n                        case 190: // and so does the key '.' (dot)\n                            if (presentationMode) {\n                                blankOut('#000');\n                            }\n                            break;\n                        case 87:  // key 'w' blanks page (to white) or returns to the document\n                        case 188: // and so does the key ',' (comma)\n                            if (presentationMode) {\n                                blankOut('#FFF');\n                            }\n                            break;\n                        case 36: // key 'Home' goes to first page\n                            self.showPage(1);\n                            break;\n                        case 35: // key 'End' goes to last page\n                            self.showPage(pages.length);\n                            break;\n                        }\n                    }\n                });\n            }\n        }\n\n        init();\n    }\n\n    return viewerjs.Viewer = Viewer;\n});\ndefine('skylark-webodf/webodf',[],function() {\n\tvar webodf_version = \"0.5.9\";\n\tfunction Runtime() {}\n\tRuntime.prototype.getVariable = function(g) {}\n\t;\n\tRuntime.prototype.toJson = function(g) {}\n\t;\n\tRuntime.prototype.fromJson = function(g) {}\n\t;\n\tRuntime.prototype.byteArrayFromString = function(g, k) {}\n\t;\n\tRuntime.prototype.byteArrayToString = function(g, k) {}\n\t;\n\tRuntime.prototype.read = function(g, k, d, b) {}\n\t;\n\tRuntime.prototype.readFile = function(g, k, d) {}\n\t;\n\tRuntime.prototype.readFileSync = function(g, k) {}\n\t;\n\tRuntime.prototype.loadXML = function(g, k) {}\n\t;\n\tRuntime.prototype.writeFile = function(g, k, d) {}\n\t;\n\tRuntime.prototype.deleteFile = function(g, k) {}\n\t;\n\tRuntime.prototype.log = function(g, k) {}\n\t;\n\tRuntime.prototype.setTimeout = function(g, k) {}\n\t;\n\tRuntime.prototype.clearTimeout = function(g) {}\n\t;\n\tRuntime.prototype.libraryPaths = function() {}\n\t;\n\tRuntime.prototype.currentDirectory = function() {}\n\t;\n\tRuntime.prototype.setCurrentDirectory = function(g) {}\n\t;\n\tRuntime.prototype.type = function() {}\n\t;\n\tRuntime.prototype.getDOMImplementation = function() {}\n\t;\n\tRuntime.prototype.parseXML = function(g) {}\n\t;\n\tRuntime.prototype.exit = function(g) {}\n\t;\n\tRuntime.prototype.getWindow = function() {}\n\t;\n\tRuntime.prototype.requestAnimationFrame = function(g) {}\n\t;\n\tRuntime.prototype.cancelAnimationFrame = function(g) {}\n\t;\n\tRuntime.prototype.assert = function(g, k) {}\n\t;\n\tvar IS_COMPILED_CODE = !0;\n\tRuntime.byteArrayToString = function(g, k) {\n\t    function d(b) {\n\t        var d = \"\", r, q = b.length;\n\t        for (r = 0; r < q; r += 1)\n\t            d += String.fromCharCode(b[r] & 255);\n\t        return d\n\t    }\n\t    function b(b) {\n\t        var d = \"\", r, q = b.length, e = [], l, a, c, m;\n\t        for (r = 3 <= q && 239 === b[0] && 187 === b[1] && 191 === b[2] ? 3 : 0; r < q; r += 1)\n\t            l = b[r],\n\t            128 > l ? e.push(l) : (r += 1,\n\t            a = b[r],\n\t            194 <= l && 224 > l ? e.push((l & 31) << 6 | a & 63) : (r += 1,\n\t            c = b[r],\n\t            224 <= l && 240 > l ? e.push((l & 15) << 12 | (a & 63) << 6 | c & 63) : (r += 1,\n\t            m = b[r],\n\t            240 <= l && 245 > l && (l = (l & 7) << 18 | (a & 63) << 12 | (c & 63) << 6 | m & 63,\n\t            l -= 65536,\n\t            e.push((l >> 10) + 55296, (l & 1023) + 56320))))),\n\t            1E3 <= e.length && (d += String.fromCharCode.apply(null, e),\n\t            e.length = 0);\n\t        return d + String.fromCharCode.apply(null, e)\n\t    }\n\t    var f;\n\t    \"utf8\" === k ? f = b(g) : (\"binary\" !== k && this.log(\"Unsupported encoding: \" + k),\n\t    f = d(g));\n\t    return f\n\t}\n\t;\n\tRuntime.getVariable = function(g) {\n\t    try {\n\t        return eval(g)\n\t    } catch (k) {}\n\t}\n\t;\n\tRuntime.toJson = function(g) {\n\t    return JSON.stringify(g)\n\t}\n\t;\n\tRuntime.fromJson = function(g) {\n\t    return JSON.parse(g)\n\t}\n\t;\n\tRuntime.getFunctionName = function(g) {\n\t    return void 0 === g.name ? (g = /function\\s+(\\w+)/.exec(g)) && g[1] : g.name\n\t}\n\t;\n\tRuntime.assert = function(g, k) {\n\t    if (!g)\n\t        throw this.log(\"alert\", \"ASSERTION FAILED:\\n\" + k),\n\t        Error(k);\n\t}\n\t;\n\tfunction BrowserRuntime() {\n\t    function g(b) {\n\t        var e = b.length, l, a, c = 0;\n\t        for (l = 0; l < e; l += 1)\n\t            a = b.charCodeAt(l),\n\t            c += 1 + (128 < a) + (2048 < a),\n\t            55040 < a && 57344 > a && (c += 1,\n\t            l += 1);\n\t        return c\n\t    }\n\t    function k(b, e, l) {\n\t        var a = b.length, c, m;\n\t        e = new Uint8Array(new ArrayBuffer(e));\n\t        l ? (e[0] = 239,\n\t        e[1] = 187,\n\t        e[2] = 191,\n\t        m = 3) : m = 0;\n\t        for (l = 0; l < a; l += 1)\n\t            c = b.charCodeAt(l),\n\t            128 > c ? (e[m] = c,\n\t            m += 1) : 2048 > c ? (e[m] = 192 | c >>> 6,\n\t            e[m + 1] = 128 | c & 63,\n\t            m += 2) : 55040 >= c || 57344 <= c ? (e[m] = 224 | c >>> 12 & 15,\n\t            e[m + 1] = 128 | c >>> 6 & 63,\n\t            e[m + 2] = 128 | c & 63,\n\t            m += 3) : (l += 1,\n\t            c = (c - 55296 << 10 | b.charCodeAt(l) - 56320) + 65536,\n\t            e[m] = 240 | c >>> 18 & 7,\n\t            e[m + 1] = 128 | c >>> 12 & 63,\n\t            e[m + 2] = 128 | c >>> 6 & 63,\n\t            e[m + 3] = 128 | c & 63,\n\t            m += 4);\n\t        return e\n\t    }\n\t    function d(b) {\n\t        var e = b.length, l = new Uint8Array(new ArrayBuffer(e)), a;\n\t        for (a = 0; a < e; a += 1)\n\t            l[a] = b.charCodeAt(a) & 255;\n\t        return l\n\t    }\n\t    function b(b, e) {\n\t        var l;\n\t        void 0 !== e ? l = b : e = b;\n\t        console.log(e);\n\t        r.enableAlerts && \"alert\" === l && alert(e)\n\t    }\n\t    function f(b, e, l) {\n\t        if (0 !== l.status || l.responseText)\n\t            if (200 === l.status || 0 === l.status) {\n\t                if (l.response && \"string\" !== typeof l.response)\n\t                    \"binary\" === e ? (l = l.response,\n\t                    l = new Uint8Array(l)) : l = String(l.response);\n\t                else if (\"binary\" === e)\n\t                    if (null !== l.responseBody && \"undefined\" !== String(typeof VBArray)) {\n\t                        l = (new VBArray(l.responseBody)).toArray();\n\t                        var a = l.length;\n\t                        e = new Uint8Array(new ArrayBuffer(a));\n\t                        for (b = 0; b < a; b += 1)\n\t                            e[b] = l[b];\n\t                        l = e\n\t                    } else {\n\t                        (b = l.getResponseHeader(\"Content-Length\")) && (b = parseInt(b, 10));\n\t                        if (b && b !== l.responseText.length)\n\t                            a: {\n\t                                a = l.responseText;\n\t                                e = !1;\n\t                                var c = g(a);\n\t                                if (\"number\" === typeof b) {\n\t                                    if (b !== c && b !== c + 3) {\n\t                                        a = void 0;\n\t                                        break a\n\t                                    }\n\t                                    e = c + 3 === b;\n\t                                    c = b\n\t                                }\n\t                                a = k(a, c, e)\n\t                            }\n\t                        void 0 === a && (a = d(l.responseText));\n\t                        l = a\n\t                    }\n\t                else\n\t                    l = l.responseText;\n\t                l = {\n\t                    err: null,\n\t                    data: l\n\t                }\n\t            } else\n\t                l = {\n\t                    err: l.responseText || l.statusText,\n\t                    data: null\n\t                };\n\t        else\n\t            l = {\n\t                err: \"File \" + b + \" is empty.\",\n\t                data: null\n\t            };\n\t        return l\n\t    }\n\t    function n(b, e, l) {\n\t        var a = new XMLHttpRequest;\n\t        a.open(\"GET\", b, l);\n\t        a.overrideMimeType && (\"binary\" !== e ? a.overrideMimeType(\"text/plain; charset=\" + e) : a.overrideMimeType(\"text/plain; charset=x-user-defined\"));\n\t        return a\n\t    }\n\t    function p(b, e, l) {\n\t        var a = n(b, e, !0);\n\t        a.onreadystatechange = function() {\n\t            var c;\n\t            4 === a.readyState && (c = f(b, e, a),\n\t            l(c.err, c.data))\n\t        }\n\t        ;\n\t        try {\n\t            a.send(null)\n\t        } catch (c) {\n\t            l(c.message, null)\n\t        }\n\t    }\n\t    var r = this;\n\t    this.byteArrayFromString = function(b, e) {\n\t        var l;\n\t        \"utf8\" === e ? l = k(b, g(b), !1) : (\"binary\" !== e && r.log(\"unknown encoding: \" + e),\n\t        l = d(b));\n\t        return l\n\t    }\n\t    ;\n\t    this.byteArrayToString = Runtime.byteArrayToString;\n\t    this.getVariable = Runtime.getVariable;\n\t    this.fromJson = Runtime.fromJson;\n\t    this.toJson = Runtime.toJson;\n\t    this.readFile = p;\n\t    this.read = function(b, e, l, a) {\n\t        p(b, \"binary\", function(c, m) {\n\t            var h = null;\n\t            if (m) {\n\t                if (\"string\" === typeof m)\n\t                    throw \"This should not happen.\";\n\t                h = m.subarray(e, e + l)\n\t            }\n\t            a(c, h)\n\t        })\n\t    }\n\t    ;\n\t    this.readFileSync = function(b, e) {\n\t        var l = n(b, e, !1), a;\n\t        try {\n\t            l.send(null);\n\t            a = f(b, e, l);\n\t            if (a.err)\n\t                throw a.err;\n\t            if (null === a.data)\n\t                throw \"No data read from \" + b + \".\";\n\t        } catch (c) {\n\t            throw c;\n\t        }\n\t        return a.data\n\t    }\n\t    ;\n\t    this.writeFile = function(b, e, l) {\n\t        var a = new XMLHttpRequest, c;\n\t        a.open(\"PUT\", b, !0);\n\t        a.onreadystatechange = function() {\n\t            4 === a.readyState && (0 !== a.status || a.responseText ? 200 <= a.status && 300 > a.status || 0 === a.status ? l(null) : l(\"Status \" + String(a.status) + \": \" + a.responseText || a.statusText) : l(\"File \" + b + \" is empty.\"))\n\t        }\n\t        ;\n\t        c = e.buffer && !a.sendAsBinary ? e.buffer : r.byteArrayToString(e, \"binary\");\n\t        try {\n\t            a.sendAsBinary ? a.sendAsBinary(c) : a.send(c)\n\t        } catch (m) {\n\t            r.log(\"HUH? \" + m + \" \" + e),\n\t            l(m.message)\n\t        }\n\t    }\n\t    ;\n\t    this.deleteFile = function(b, e) {\n\t        var l = new XMLHttpRequest;\n\t        l.open(\"DELETE\", b, !0);\n\t        l.onreadystatechange = function() {\n\t            4 === l.readyState && (200 > l.status && 300 <= l.status ? e(l.responseText) : e(null))\n\t        }\n\t        ;\n\t        l.send(null)\n\t    }\n\t    ;\n\t    this.loadXML = function(b, e) {\n\t        var l = new XMLHttpRequest;\n\t        l.open(\"GET\", b, !0);\n\t        l.overrideMimeType && l.overrideMimeType(\"text/xml\");\n\t        l.onreadystatechange = function() {\n\t            4 === l.readyState && (0 !== l.status || l.responseText ? 200 === l.status || 0 === l.status ? e(null, l.responseXML) : e(l.responseText, null) : e(\"File \" + b + \" is empty.\", null))\n\t        }\n\t        ;\n\t        try {\n\t            l.send(null)\n\t        } catch (a) {\n\t            e(a.message, null)\n\t        }\n\t    }\n\t    ;\n\t    this.log = b;\n\t    this.enableAlerts = !0;\n\t    this.assert = Runtime.assert;\n\t    this.setTimeout = function(b, e) {\n\t        return setTimeout(function() {\n\t            b()\n\t        }, e)\n\t    }\n\t    ;\n\t    this.clearTimeout = function(b) {\n\t        clearTimeout(b)\n\t    }\n\t    ;\n\t    this.libraryPaths = function() {\n\t        return [\"lib\"]\n\t    }\n\t    ;\n\t    this.setCurrentDirectory = function() {}\n\t    ;\n\t    this.currentDirectory = function() {\n\t        return \"\"\n\t    }\n\t    ;\n\t    this.type = function() {\n\t        return \"BrowserRuntime\"\n\t    }\n\t    ;\n\t    this.getDOMImplementation = function() {\n\t        return window.document.implementation\n\t    }\n\t    ;\n\t    this.parseXML = function(b) {\n\t        return (new DOMParser).parseFromString(b, \"text/xml\")\n\t    }\n\t    ;\n\t    this.exit = function(d) {\n\t        b(\"Calling exit with code \" + String(d) + \", but exit() is not implemented.\")\n\t    }\n\t    ;\n\t    this.getWindow = function() {\n\t        return window\n\t    }\n\t    ;\n\t    this.requestAnimationFrame = function(b) {\n\t        var e = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame\n\t          , l = 0;\n\t        if (e)\n\t            e.bind(window),\n\t            l = e(b);\n\t        else\n\t            return setTimeout(b, 15);\n\t        return l\n\t    }\n\t    ;\n\t    this.cancelAnimationFrame = function(b) {\n\t        var e = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame;\n\t        e ? (e.bind(window),\n\t        e(b)) : clearTimeout(b)\n\t    }\n\t}\n\tfunction NodeJSRuntime() {\n\t    function g(b) {\n\t        var e = b.length, l, a = new Uint8Array(new ArrayBuffer(e));\n\t        for (l = 0; l < e; l += 1)\n\t            a[l] = b[l];\n\t        return a\n\t    }\n\t    function k(d, e, l) {\n\t        function a(a, m) {\n\t            if (a)\n\t                return l(a, null);\n\t            if (!m)\n\t                return l(\"No data for \" + d + \".\", null);\n\t            if (\"string\" === typeof m)\n\t                return l(a, m);\n\t            l(a, g(m))\n\t        }\n\t        d = f.resolve(n, d);\n\t        \"binary\" !== e ? b.readFile(d, e, a) : b.readFile(d, null, a)\n\t    }\n\t    var d = this, b = require(\"fs\"), f = require(\"path\"), n = \"\", p, r;\n\t    this.byteArrayFromString = function(b, e) {\n\t        var l = new Buffer(b,e), a, c = l.length, m = new Uint8Array(new ArrayBuffer(c));\n\t        for (a = 0; a < c; a += 1)\n\t            m[a] = l[a];\n\t        return m\n\t    }\n\t    ;\n\t    this.byteArrayToString = Runtime.byteArrayToString;\n\t    this.getVariable = Runtime.getVariable;\n\t    this.fromJson = Runtime.fromJson;\n\t    this.toJson = Runtime.toJson;\n\t    this.readFile = k;\n\t    this.loadXML = function(b, e) {\n\t        k(b, \"utf-8\", function(l, a) {\n\t            if (l)\n\t                return e(l, null);\n\t            if (!a)\n\t                return e(\"No data for \" + b + \".\", null);\n\t            e(null, d.parseXML(a))\n\t        })\n\t    }\n\t    ;\n\t    this.writeFile = function(d, e, l) {\n\t        e = new Buffer(e);\n\t        d = f.resolve(n, d);\n\t        b.writeFile(d, e, \"binary\", function(a) {\n\t            l(a || null)\n\t        })\n\t    }\n\t    ;\n\t    this.deleteFile = function(d, e) {\n\t        d = f.resolve(n, d);\n\t        b.unlink(d, e)\n\t    }\n\t    ;\n\t    this.read = function(d, e, l, a) {\n\t        d = f.resolve(n, d);\n\t        b.open(d, \"r+\", 666, function(c, m) {\n\t            if (c)\n\t                a(c, null);\n\t            else {\n\t                var h = new Buffer(l);\n\t                b.read(m, h, 0, l, e, function(c) {\n\t                    b.close(m);\n\t                    a(c, g(h))\n\t                })\n\t            }\n\t        })\n\t    }\n\t    ;\n\t    this.readFileSync = function(d, e) {\n\t        var l;\n\t        l = b.readFileSync(d, \"binary\" === e ? null : e);\n\t        if (null === l)\n\t            throw \"File \" + d + \" could not be read.\";\n\t        \"binary\" === e && (l = g(l));\n\t        return l\n\t    }\n\t    ;\n\t    this.log = function(b, e) {\n\t        var l;\n\t        void 0 !== e ? l = b : e = b;\n\t        \"alert\" === l && process.stderr.write(\"\\n!!!!! ALERT !!!!!\\n\");\n\t        process.stderr.write(e + \"\\n\");\n\t        \"alert\" === l && process.stderr.write(\"!!!!! ALERT !!!!!\\n\")\n\t    }\n\t    ;\n\t    this.assert = Runtime.assert;\n\t    this.setTimeout = function(b, e) {\n\t        return setTimeout(function() {\n\t            b()\n\t        }, e)\n\t    }\n\t    ;\n\t    this.clearTimeout = function(b) {\n\t        clearTimeout(b)\n\t    }\n\t    ;\n\t    this.libraryPaths = function() {\n\t        return [__dirname]\n\t    }\n\t    ;\n\t    this.setCurrentDirectory = function(b) {\n\t        n = b\n\t    }\n\t    ;\n\t    this.currentDirectory = function() {\n\t        return n\n\t    }\n\t    ;\n\t    this.type = function() {\n\t        return \"NodeJSRuntime\"\n\t    }\n\t    ;\n\t    this.getDOMImplementation = function() {\n\t        return r\n\t    }\n\t    ;\n\t    this.parseXML = function(b) {\n\t        return p.parseFromString(b, \"text/xml\")\n\t    }\n\t    ;\n\t    this.exit = process.exit;\n\t    this.getWindow = function() {\n\t        return null\n\t    }\n\t    ;\n\t    this.requestAnimationFrame = function(b) {\n\t        return setTimeout(b, 15)\n\t    }\n\t    ;\n\t    this.cancelAnimationFrame = function(b) {\n\t        clearTimeout(b)\n\t    }\n\t    ;\n\t    p = new (require(\"xmldom\").DOMParser);\n\t    r = d.parseXML(\"<a/>\").implementation\n\t}\n\tfunction RhinoRuntime() {\n\t    var g = this, k = {}, d = k.javax.xml.parsers.DocumentBuilderFactory.newInstance(), b, f, n = \"\";\n\t    d.setValidating(!1);\n\t    d.setNamespaceAware(!0);\n\t    d.setExpandEntityReferences(!1);\n\t    d.setSchema(null);\n\t    f = k.org.xml.sax.EntityResolver({\n\t        resolveEntity: function(b, d) {\n\t            var f = new k.java.io.FileReader(d);\n\t            return new k.org.xml.sax.InputSource(f)\n\t        }\n\t    });\n\t    b = d.newDocumentBuilder();\n\t    b.setEntityResolver(f);\n\t    this.byteArrayFromString = function(b, d) {\n\t        var f, e = b.length, l = new Uint8Array(new ArrayBuffer(e));\n\t        for (f = 0; f < e; f += 1)\n\t            l[f] = b.charCodeAt(f) & 255;\n\t        return l\n\t    }\n\t    ;\n\t    this.byteArrayToString = Runtime.byteArrayToString;\n\t    this.getVariable = Runtime.getVariable;\n\t    this.fromJson = Runtime.fromJson;\n\t    this.toJson = Runtime.toJson;\n\t    this.loadXML = function(d, f) {\n\t        var n = new k.java.io.File(d)\n\t          , e = null;\n\t        try {\n\t            e = b.parse(n)\n\t        } catch (l) {\n\t            return print(l),\n\t            f(l, null)\n\t        }\n\t        f(null, e)\n\t    }\n\t    ;\n\t    this.readFile = function(b, d, f) {\n\t        n && (b = n + \"/\" + b);\n\t        var e = new k.java.io.File(b)\n\t          , l = \"binary\" === d ? \"latin1\" : d;\n\t        e.isFile() ? ((b = readFile(b, l)) && \"binary\" === d && (b = g.byteArrayFromString(b, \"binary\")),\n\t        f(null, b)) : f(b + \" is not a file.\", null)\n\t    }\n\t    ;\n\t    this.writeFile = function(b, d, f) {\n\t        n && (b = n + \"/\" + b);\n\t        b = new k.java.io.FileOutputStream(b);\n\t        var e, l = d.length;\n\t        for (e = 0; e < l; e += 1)\n\t            b.write(d[e]);\n\t        b.close();\n\t        f(null)\n\t    }\n\t    ;\n\t    this.deleteFile = function(b, d) {\n\t        n && (b = n + \"/\" + b);\n\t        var f = new k.java.io.File(b)\n\t          , e = b + Math.random()\n\t          , e = new k.java.io.File(e);\n\t        f.rename(e) ? (e.deleteOnExit(),\n\t        d(null)) : d(\"Could not delete \" + b)\n\t    }\n\t    ;\n\t    this.read = function(b, d, f, e) {\n\t        n && (b = n + \"/\" + b);\n\t        var l;\n\t        l = b;\n\t        var a = \"binary\";\n\t        (new k.java.io.File(l)).isFile() ? (\"binary\" === a && (a = \"latin1\"),\n\t        l = readFile(l, a)) : l = null;\n\t        l ? e(null, this.byteArrayFromString(l.substring(d, d + f), \"binary\")) : e(\"Cannot read \" + b, null)\n\t    }\n\t    ;\n\t    this.readFileSync = function(b, d) {\n\t        if (!d)\n\t            return \"\";\n\t        var f = readFile(b, d);\n\t        if (null === f)\n\t            throw \"File could not be read.\";\n\t        return f\n\t    }\n\t    ;\n\t    this.log = function(b, d) {\n\t        var f;\n\t        void 0 !== d ? f = b : d = b;\n\t        \"alert\" === f && print(\"\\n!!!!! ALERT !!!!!\");\n\t        print(d);\n\t        \"alert\" === f && print(\"!!!!! ALERT !!!!!\")\n\t    }\n\t    ;\n\t    this.assert = Runtime.assert;\n\t    this.setTimeout = function(b) {\n\t        b();\n\t        return 0\n\t    }\n\t    ;\n\t    this.clearTimeout = function() {}\n\t    ;\n\t    this.libraryPaths = function() {\n\t        return [\"lib\"]\n\t    }\n\t    ;\n\t    this.setCurrentDirectory = function(b) {\n\t        n = b\n\t    }\n\t    ;\n\t    this.currentDirectory = function() {\n\t        return n\n\t    }\n\t    ;\n\t    this.type = function() {\n\t        return \"RhinoRuntime\"\n\t    }\n\t    ;\n\t    this.getDOMImplementation = function() {\n\t        return b.getDOMImplementation()\n\t    }\n\t    ;\n\t    this.parseXML = function(d) {\n\t        d = new k.java.io.StringReader(d);\n\t        d = new k.org.xml.sax.InputSource(d);\n\t        return b.parse(d)\n\t    }\n\t    ;\n\t    this.exit = quit;\n\t    this.getWindow = function() {\n\t        return null\n\t    }\n\t    ;\n\t    this.requestAnimationFrame = function(b) {\n\t        b();\n\t        return 0\n\t    }\n\t    ;\n\t    this.cancelAnimationFrame = function() {}\n\t}\n\tRuntime.create = function() {\n\t    return \"undefined\" !== String(typeof window) ? new BrowserRuntime : \"undefined\" !== String(typeof require) ? new NodeJSRuntime : new RhinoRuntime\n\t}\n\t;\n\tvar runtime = Runtime.create()\n\t  , core = {}\n\t  , gui = {}\n\t  , xmldom = {}\n\t  , odf = {}\n\t  , ops = {}\n\t  , webodf = {};\n\t(function() {\n\t    webodf.Version = \"undefined\" !== String(typeof webodf_version) ? webodf_version : \"From Source\"\n\t}\n\t)();\n\t(function() {\n\t    function g(b, d, e) {\n\t        var l = b + \"/manifest.json\", a, c;\n\t        runtime.log(\"Loading manifest: \" + l);\n\t        try {\n\t            a = runtime.readFileSync(l, \"utf-8\")\n\t        } catch (m) {\n\t            if (e)\n\t                runtime.log(\"No loadable manifest found.\");\n\t            else\n\t                throw console.log(String(m)),\n\t                m;\n\t            return\n\t        }\n\t        e = JSON.parse(a);\n\t        for (c in e)\n\t            e.hasOwnProperty(c) && (d[c] = {\n\t                dir: b,\n\t                deps: e[c]\n\t            })\n\t    }\n\t    function k(b, d, e) {\n\t        function l(h) {\n\t            if (!m[h] && !e(h)) {\n\t                if (c[h])\n\t                    throw \"Circular dependency detected for \" + h + \".\";\n\t                c[h] = !0;\n\t                if (!d[h])\n\t                    throw \"Missing dependency information for class \" + h + \".\";\n\t                var b = d[h], f = b.deps, n, r = f.length;\n\t                for (n = 0; n < r; n += 1)\n\t                    l(f[n]);\n\t                c[h] = !1;\n\t                m[h] = !0;\n\t                a.push(b.dir + \"/\" + h.replace(\".\", \"/\") + \".js\")\n\t            }\n\t        }\n\t        var a = []\n\t          , c = {}\n\t          , m = {};\n\t        b.forEach(l);\n\t        return a\n\t    }\n\t    function d(b, d) {\n\t        return d + (\"\\n//# sourceURL=\" + b)\n\t    }\n\t    function b(b) {\n\t        var f, e;\n\t        for (f = 0; f < b.length; f += 1)\n\t            e = runtime.readFileSync(b[f], \"utf-8\"),\n\t            e = d(b[f], e),\n\t            eval(e)\n\t    }\n\t    function f(b) {\n\t        b = b.split(\".\");\n\t        var d, e = p, l = b.length;\n\t        for (d = 0; d < l; d += 1) {\n\t            if (!e.hasOwnProperty(b[d]))\n\t                return !1;\n\t            e = e[b[d]]\n\t        }\n\t        return !0\n\t    }\n\t    var n, p = {\n\t        core: core,\n\t        gui: gui,\n\t        xmldom: xmldom,\n\t        odf: odf,\n\t        ops: ops\n\t    };\n\t    runtime.loadClasses = function(d, p) {\n\t        if (IS_COMPILED_CODE || 0 === d.length)\n\t            return p && p();\n\t        var e;\n\t        if (!(e = n)) {\n\t            e = [];\n\t            var l = runtime.libraryPaths(), a;\n\t            runtime.currentDirectory() && -1 === l.indexOf(runtime.currentDirectory()) && g(runtime.currentDirectory(), e, !0);\n\t            for (a = 0; a < l.length; a += 1)\n\t                g(l[a], e)\n\t        }\n\t        n = e;\n\t        d = k(d, n, f);\n\t        if (0 === d.length)\n\t            return p && p();\n\t        if (\"BrowserRuntime\" === runtime.type() && p) {\n\t            e = d;\n\t            l = document.currentScript || document.documentElement.lastChild;\n\t            a = document.createDocumentFragment();\n\t            var c, m;\n\t            for (m = 0; m < e.length; m += 1)\n\t                c = document.createElement(\"script\"),\n\t                c.type = \"text/javascript\",\n\t                c.charset = \"utf-8\",\n\t                c.async = !1,\n\t                c.setAttribute(\"src\", e[m]),\n\t                a.appendChild(c);\n\t            p && (c.onload = p);\n\t            l.parentNode.insertBefore(a, l)\n\t        } else\n\t            b(d),\n\t            p && p()\n\t    }\n\t    ;\n\t    runtime.loadClass = function(b, d) {\n\t        runtime.loadClasses([b], d)\n\t    }\n\t}\n\t)();\n\t(function() {\n\t    var g = function(g) {\n\t        return g\n\t    };\n\t    runtime.getTranslator = function() {\n\t        return g\n\t    }\n\t    ;\n\t    runtime.setTranslator = function(k) {\n\t        g = k\n\t    }\n\t    ;\n\t    runtime.tr = function(k) {\n\t        var d = g(k);\n\t        return d && \"string\" === String(typeof d) ? d : k\n\t    }\n\t}\n\t)();\n\t(function(g) {\n\t    function k(d) {\n\t        if (d.length) {\n\t            var b = d[0];\n\t            runtime.readFile(b, \"utf8\", function(f, n) {\n\t                function g() {\n\t                    var b;\n\t                    (b = eval(k)) && runtime.exit(b)\n\t                }\n\t                var r = \"\"\n\t                  , r = b.lastIndexOf(\"/\")\n\t                  , k = n\n\t                  , r = -1 !== r ? b.substring(0, r) : \".\";\n\t                runtime.setCurrentDirectory(r);\n\t                f ? (runtime.log(f),\n\t                runtime.exit(1)) : null === k ? (runtime.log(\"No code found for \" + b),\n\t                runtime.exit(1)) : g.apply(null, d)\n\t            })\n\t        }\n\t    }\n\t    g = g ? Array.prototype.slice.call(g) : [];\n\t    \"NodeJSRuntime\" === runtime.type() ? k(process.argv.slice(2)) : \"RhinoRuntime\" === runtime.type() ? k(g) : k(g.slice(1))\n\t}\n\t)(\"undefined\" !== String(typeof arguments) && arguments);\n\t(function() {\n\t    core.Async = function() {\n\t        return {\n\t            forEach: function(g, k, d) {\n\t                function b(b) {\n\t                    p !== n && (b ? (p = n,\n\t                    d(b)) : (p += 1,\n\t                    p === n && d(null)))\n\t                }\n\t                var f, n = g.length, p = 0;\n\t                for (f = 0; f < n; f += 1)\n\t                    k(g[f], b)\n\t            },\n\t            destroyAll: function(g, k) {\n\t                function d(b, f) {\n\t                    if (f)\n\t                        k(f);\n\t                    else if (b < g.length)\n\t                        g[b](function(f) {\n\t                            d(b + 1, f)\n\t                        });\n\t                    else\n\t                        k()\n\t                }\n\t                d(0, void 0)\n\t            }\n\t        }\n\t    }()\n\t}\n\t)();\n\tfunction makeBase64() {\n\t    function g(a) {\n\t        var c, m = a.length, h = new Uint8Array(new ArrayBuffer(m));\n\t        for (c = 0; c < m; c += 1)\n\t            h[c] = a.charCodeAt(c) & 255;\n\t        return h\n\t    }\n\t    function k(a) {\n\t        var c, m = \"\", h, b = a.length - 2;\n\t        for (h = 0; h < b; h += 3)\n\t            c = a[h] << 16 | a[h + 1] << 8 | a[h + 2],\n\t            m += \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"[c >>> 18],\n\t            m += \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"[c >>> 12 & 63],\n\t            m += \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"[c >>> 6 & 63],\n\t            m += \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"[c & 63];\n\t        h === b + 1 ? (c = a[h] << 4,\n\t        m += \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"[c >>> 6],\n\t        m += \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"[c & 63],\n\t        m += \"==\") : h === b && (c = a[h] << 10 | a[h + 1] << 2,\n\t        m += \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"[c >>> 12],\n\t        m += \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"[c >>> 6 & 63],\n\t        m += \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"[c & 63],\n\t        m += \"=\");\n\t        return m\n\t    }\n\t    function d(a) {\n\t        a = a.replace(/[^A-Za-z0-9+\\/]+/g, \"\");\n\t        var c = a.length, m = new Uint8Array(new ArrayBuffer(3 * c)), b = a.length % 4, d = 0, l, e;\n\t        for (l = 0; l < c; l += 4)\n\t            e = (h[a.charAt(l)] || 0) << 18 | (h[a.charAt(l + 1)] || 0) << 12 | (h[a.charAt(l + 2)] || 0) << 6 | (h[a.charAt(l + 3)] || 0),\n\t            m[d] = e >> 16,\n\t            m[d + 1] = e >> 8 & 255,\n\t            m[d + 2] = e & 255,\n\t            d += 3;\n\t        c = 3 * c - [0, 0, 2, 1][b];\n\t        return m.subarray(0, c)\n\t    }\n\t    function b(a) {\n\t        var c, m, h = a.length, b = 0, d = new Uint8Array(new ArrayBuffer(3 * h));\n\t        for (c = 0; c < h; c += 1)\n\t            m = a[c],\n\t            128 > m ? d[b++] = m : (2048 > m ? d[b++] = 192 | m >>> 6 : (d[b++] = 224 | m >>> 12 & 15,\n\t            d[b++] = 128 | m >>> 6 & 63),\n\t            d[b++] = 128 | m & 63);\n\t        return d.subarray(0, b)\n\t    }\n\t    function f(a) {\n\t        var c, m, h, b, d = a.length, l = new Uint8Array(new ArrayBuffer(d)), e = 0;\n\t        for (c = 0; c < d; c += 1)\n\t            m = a[c],\n\t            128 > m ? l[e++] = m : (c += 1,\n\t            h = a[c],\n\t            224 > m ? l[e++] = (m & 31) << 6 | h & 63 : (c += 1,\n\t            b = a[c],\n\t            l[e++] = (m & 15) << 12 | (h & 63) << 6 | b & 63));\n\t        return l.subarray(0, e)\n\t    }\n\t    function n(a) {\n\t        return k(g(a))\n\t    }\n\t    function p(a) {\n\t        return String.fromCharCode.apply(String, d(a))\n\t    }\n\t    function r(a) {\n\t        return f(g(a))\n\t    }\n\t    function q(a) {\n\t        a = f(a);\n\t        for (var c = \"\", m = 0; m < a.length; )\n\t            c += String.fromCharCode.apply(String, a.subarray(m, m + 45E3)),\n\t            m += 45E3;\n\t        return c\n\t    }\n\t    function e(a, c, m) {\n\t        var h, b, d, l = \"\";\n\t        for (d = c; d < m; d += 1)\n\t            c = a.charCodeAt(d) & 255,\n\t            128 > c ? l += String.fromCharCode(c) : (d += 1,\n\t            h = a.charCodeAt(d) & 255,\n\t            224 > c ? l += String.fromCharCode((c & 31) << 6 | h & 63) : (d += 1,\n\t            b = a.charCodeAt(d) & 255,\n\t            l += String.fromCharCode((c & 15) << 12 | (h & 63) << 6 | b & 63)));\n\t        return l\n\t    }\n\t    function l(a, c) {\n\t        function m() {\n\t            var d = b + 1E5;\n\t            d > a.length && (d = a.length);\n\t            h += e(a, b, d);\n\t            b = d;\n\t            d = b === a.length;\n\t            c(h, d) && !d && runtime.setTimeout(m, 0)\n\t        }\n\t        var h = \"\"\n\t          , b = 0;\n\t        1E5 > a.length ? c(e(a, 0, a.length), !0) : (\"string\" !== typeof a && (a = a.slice()),\n\t        m())\n\t    }\n\t    function a(a) {\n\t        return b(g(a))\n\t    }\n\t    function c(a) {\n\t        return String.fromCharCode.apply(String, b(a))\n\t    }\n\t    function m(a) {\n\t        return String.fromCharCode.apply(String, b(g(a)))\n\t    }\n\t    var h = function(a) {\n\t        var c = {}, m, h;\n\t        m = 0;\n\t        for (h = a.length; m < h; m += 1)\n\t            c[a.charAt(m)] = m;\n\t        return c\n\t    }(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"), y, x, z = runtime.getWindow(), w, v;\n\t    z && z.btoa ? (w = z.btoa,\n\t    y = function(a) {\n\t        return w(m(a))\n\t    }\n\t    ) : (w = n,\n\t    y = function(c) {\n\t        return k(a(c))\n\t    }\n\t    );\n\t    z && z.atob ? (v = z.atob,\n\t    x = function(a) {\n\t        a = v(a);\n\t        return e(a, 0, a.length)\n\t    }\n\t    ) : (v = p,\n\t    x = function(a) {\n\t        return q(d(a))\n\t    }\n\t    );\n\t    core.Base64 = function() {\n\t        this.convertByteArrayToBase64 = this.convertUTF8ArrayToBase64 = k;\n\t        this.convertBase64ToByteArray = this.convertBase64ToUTF8Array = d;\n\t        this.convertUTF16ArrayToByteArray = this.convertUTF16ArrayToUTF8Array = b;\n\t        this.convertByteArrayToUTF16Array = this.convertUTF8ArrayToUTF16Array = f;\n\t        this.convertUTF8StringToBase64 = n;\n\t        this.convertBase64ToUTF8String = p;\n\t        this.convertUTF8StringToUTF16Array = r;\n\t        this.convertByteArrayToUTF16String = this.convertUTF8ArrayToUTF16String = q;\n\t        this.convertUTF8StringToUTF16String = l;\n\t        this.convertUTF16StringToByteArray = this.convertUTF16StringToUTF8Array = a;\n\t        this.convertUTF16ArrayToUTF8String = c;\n\t        this.convertUTF16StringToUTF8String = m;\n\t        this.convertUTF16StringToBase64 = y;\n\t        this.convertBase64ToUTF16String = x;\n\t        this.fromBase64 = p;\n\t        this.toBase64 = n;\n\t        this.atob = v;\n\t        this.btoa = w;\n\t        this.utob = m;\n\t        this.btou = l;\n\t        this.encode = y;\n\t        this.encodeURI = function(a) {\n\t            return y(a).replace(/[+\\/]/g, function(a) {\n\t                return \"+\" === a ? \"-\" : \"_\"\n\t            }).replace(/\\\\=+$/, \"\")\n\t        }\n\t        ;\n\t        this.decode = function(a) {\n\t            return x(a.replace(/[\\-_]/g, function(a) {\n\t                return \"-\" === a ? \"+\" : \"/\"\n\t            }))\n\t        }\n\t        ;\n\t        return this\n\t    }\n\t    ;\n\t    return core.Base64\n\t}\n\tcore.Base64 = makeBase64();\n\tcore.CSSUnits = function() {\n\t    var g = this\n\t      , k = {\n\t        \"in\": 1,\n\t        cm: 2.54,\n\t        mm: 25.4,\n\t        pt: 72,\n\t        pc: 12,\n\t        px: 96\n\t    };\n\t    this.convert = function(d, b, f) {\n\t        return d * k[f] / k[b]\n\t    }\n\t    ;\n\t    this.convertMeasure = function(d, b) {\n\t        var f, n;\n\t        d && b && (f = parseFloat(d),\n\t        n = d.replace(f.toString(), \"\"),\n\t        f = g.convert(f, n, b));\n\t        return f\n\t    }\n\t    ;\n\t    this.getUnits = function(d) {\n\t        return d.substr(d.length - 2, d.length)\n\t    }\n\t}\n\t;\n\t(function() {\n\t    function g() {\n\t        var b, f, n, g, r, k, e, l, a;\n\t        void 0 === d && (f = (b = runtime.getWindow()) && b.document,\n\t        k = f.documentElement,\n\t        e = f.body,\n\t        d = {\n\t            rangeBCRIgnoresElementBCR: !1,\n\t            unscaledRangeClientRects: !1,\n\t            elementBCRIgnoresBodyScroll: !1\n\t        },\n\t        f && (g = f.createElement(\"div\"),\n\t        g.style.position = \"absolute\",\n\t        g.style.left = \"-99999px\",\n\t        g.style.transform = \"scale(2)\",\n\t        g.style[\"-webkit-transform\"] = \"scale(2)\",\n\t        r = f.createElement(\"div\"),\n\t        g.appendChild(r),\n\t        e.appendChild(g),\n\t        b = f.createRange(),\n\t        b.selectNode(r),\n\t        d.rangeBCRIgnoresElementBCR = 0 === b.getClientRects().length,\n\t        r.appendChild(f.createTextNode(\"Rect transform test\")),\n\t        f = r.getBoundingClientRect(),\n\t        n = b.getBoundingClientRect(),\n\t        d.unscaledRangeClientRects = 2 < Math.abs(f.height - n.height),\n\t        g.style.transform = \"\",\n\t        g.style[\"-webkit-transform\"] = \"\",\n\t        f = k.style.overflow,\n\t        n = e.style.overflow,\n\t        l = e.style.height,\n\t        a = e.scrollTop,\n\t        k.style.overflow = \"visible\",\n\t        e.style.overflow = \"visible\",\n\t        e.style.height = \"200%\",\n\t        e.scrollTop = e.scrollHeight,\n\t        d.elementBCRIgnoresBodyScroll = b.getBoundingClientRect().top !== r.getBoundingClientRect().top,\n\t        e.scrollTop = a,\n\t        e.style.height = l,\n\t        e.style.overflow = n,\n\t        k.style.overflow = f,\n\t        b.detach(),\n\t        e.removeChild(g),\n\t        b = Object.keys(d).map(function(a) {\n\t            return a + \":\" + String(d[a])\n\t        }).join(\", \"),\n\t        runtime.log(\"Detected browser quirks - \" + b)));\n\t        return d\n\t    }\n\t    function k(b, d, n) {\n\t        for (b = b ? b.firstElementChild : null; b; ) {\n\t            if (b.localName === n && b.namespaceURI === d)\n\t                return b;\n\t            b = b.nextElementSibling\n\t        }\n\t        return null\n\t    }\n\t    var d;\n\t    core.DomUtilsImpl = function() {\n\t        function b(a, c) {\n\t            for (var b = 0, d; a.parentNode !== c; )\n\t                runtime.assert(null !== a.parentNode, \"parent is null\"),\n\t                a = a.parentNode;\n\t            for (d = c.firstChild; d !== a; )\n\t                b += 1,\n\t                d = d.nextSibling;\n\t            return b\n\t        }\n\t        function d(a, c) {\n\t            return 0 >= a.compareBoundaryPoints(Range.START_TO_START, c) && 0 <= a.compareBoundaryPoints(Range.END_TO_END, c)\n\t        }\n\t        function n(a, c) {\n\t            return 0 >= a.compareBoundaryPoints(Range.END_TO_START, c) && 0 <= a.compareBoundaryPoints(Range.START_TO_END, c)\n\t        }\n\t        function p(a, c) {\n\t            var b = null;\n\t            a.nodeType === Node.TEXT_NODE && (0 === a.length ? (a.parentNode.removeChild(a),\n\t            c.nodeType === Node.TEXT_NODE && (b = c)) : (c.nodeType === Node.TEXT_NODE && (a.appendData(c.data),\n\t            c.parentNode.removeChild(c)),\n\t            b = a));\n\t            return b\n\t        }\n\t        function r(a) {\n\t            for (var c = a.parentNode; a.firstChild; )\n\t                c.insertBefore(a.firstChild, a);\n\t            c.removeChild(a);\n\t            return c\n\t        }\n\t        function q(a, c) {\n\t            var b = a.parentNode, d = a.firstChild, l = c(a), e;\n\t            if (l === NodeFilter.FILTER_SKIP)\n\t                return b;\n\t            for (; d; )\n\t                e = d.nextSibling,\n\t                q(d, c),\n\t                d = e;\n\t            b && l === NodeFilter.FILTER_REJECT && r(a);\n\t            return b\n\t        }\n\t        function e(a, c) {\n\t            return a === c || Boolean(a.compareDocumentPosition(c) & Node.DOCUMENT_POSITION_CONTAINED_BY)\n\t        }\n\t        function l(a, c) {\n\t            return g().unscaledRangeClientRects ? a : a / c\n\t        }\n\t        function a(c, h, b) {\n\t            Object.keys(h).forEach(function(d) {\n\t                var l = d.split(\":\")\n\t                  , e = l[1]\n\t                  , f = b(l[0])\n\t                  , l = h[d]\n\t                  , n = typeof l;\n\t                \"object\" === n ? Object.keys(l).length && (d = f ? c.getElementsByTagNameNS(f, e)[0] || c.ownerDocument.createElementNS(f, d) : c.getElementsByTagName(e)[0] || c.ownerDocument.createElement(d),\n\t                c.appendChild(d),\n\t                a(d, l, b)) : f && (runtime.assert(\"number\" === n || \"string\" === n, \"attempting to map unsupported type '\" + n + \"' (key: \" + d + \")\"),\n\t                c.setAttributeNS(f, d, String(l)))\n\t            })\n\t        }\n\t        var c = null;\n\t        this.splitBoundaries = function(a) {\n\t            var c, d = [], l, e, f;\n\t            if (a.startContainer.nodeType === Node.TEXT_NODE || a.endContainer.nodeType === Node.TEXT_NODE) {\n\t                l = a.endContainer;\n\t                e = a.endContainer.nodeType !== Node.TEXT_NODE ? a.endOffset === a.endContainer.childNodes.length : !1;\n\t                f = a.endOffset;\n\t                c = a.endContainer;\n\t                if (f < c.childNodes.length)\n\t                    for (c = c.childNodes.item(f),\n\t                    f = 0; c.firstChild; )\n\t                        c = c.firstChild;\n\t                else\n\t                    for (; c.lastChild; )\n\t                        c = c.lastChild,\n\t                        f = c.nodeType === Node.TEXT_NODE ? c.textContent.length : c.childNodes.length;\n\t                c === l && (l = null);\n\t                a.setEnd(c, f);\n\t                f = a.endContainer;\n\t                0 !== a.endOffset && f.nodeType === Node.TEXT_NODE && (c = f,\n\t                a.endOffset !== c.length && (d.push(c.splitText(a.endOffset)),\n\t                d.push(c)));\n\t                f = a.startContainer;\n\t                0 !== a.startOffset && f.nodeType === Node.TEXT_NODE && (c = f,\n\t                a.startOffset !== c.length && (f = c.splitText(a.startOffset),\n\t                d.push(c),\n\t                d.push(f),\n\t                a.setStart(f, 0)));\n\t                if (null !== l) {\n\t                    for (f = a.endContainer; f.parentNode && f.parentNode !== l; )\n\t                        f = f.parentNode;\n\t                    e = e ? l.childNodes.length : b(f, l);\n\t                    a.setEnd(l, e)\n\t                }\n\t            }\n\t            return d\n\t        }\n\t        ;\n\t        this.containsRange = d;\n\t        this.rangesIntersect = n;\n\t        this.rangeIntersection = function(a, c) {\n\t            var b;\n\t            n(a, c) && (b = a.cloneRange(),\n\t            -1 === a.compareBoundaryPoints(Range.START_TO_START, c) && b.setStart(c.startContainer, c.startOffset),\n\t            1 === a.compareBoundaryPoints(Range.END_TO_END, c) && b.setEnd(c.endContainer, c.endOffset));\n\t            return b\n\t        }\n\t        ;\n\t        this.getNodesInRange = function(a, c, b) {\n\t            var d = []\n\t              , l = a.commonAncestorContainer\n\t              , l = l.nodeType === Node.TEXT_NODE ? l.parentNode : l;\n\t            b = a.startContainer.ownerDocument.createTreeWalker(l, b, c, !1);\n\t            var e, f;\n\t            a.endContainer.childNodes[a.endOffset - 1] ? (e = a.endContainer.childNodes[a.endOffset - 1],\n\t            f = Node.DOCUMENT_POSITION_PRECEDING | Node.DOCUMENT_POSITION_CONTAINED_BY) : (e = a.endContainer,\n\t            f = Node.DOCUMENT_POSITION_PRECEDING);\n\t            if (a.startContainer.childNodes[a.startOffset])\n\t                a = a.startContainer.childNodes[a.startOffset],\n\t                b.currentNode = a;\n\t            else {\n\t                var n = a.startContainer;\n\t                a.startOffset === (n.nodeType === Node.TEXT_NODE ? n.length : n.childNodes.length) ? (a = a.startContainer,\n\t                b.currentNode = a,\n\t                b.lastChild(),\n\t                a = b.nextNode()) : (a = a.startContainer,\n\t                b.currentNode = a)\n\t            }\n\t            if (a) {\n\t                a = b.currentNode;\n\t                if (a !== l)\n\t                    for (a = a.parentNode; a && a !== l; )\n\t                        c(a) === NodeFilter.FILTER_REJECT && (b.currentNode = a),\n\t                        a = a.parentNode;\n\t                a = b.currentNode;\n\t                switch (c(a)) {\n\t                case NodeFilter.FILTER_REJECT:\n\t                    for (a = b.nextSibling(); !a && b.parentNode(); )\n\t                        a = b.nextSibling();\n\t                    break;\n\t                case NodeFilter.FILTER_SKIP:\n\t                    a = b.nextNode()\n\t                }\n\t                for (; a; ) {\n\t                    c = e.compareDocumentPosition(a);\n\t                    if (0 !== c && 0 === (c & f))\n\t                        break;\n\t                    d.push(a);\n\t                    a = b.nextNode()\n\t                }\n\t            }\n\t            return d\n\t        }\n\t        ;\n\t        this.normalizeTextNodes = function(a) {\n\t            a && a.nextSibling && (a = p(a, a.nextSibling));\n\t            a && a.previousSibling && p(a.previousSibling, a)\n\t        }\n\t        ;\n\t        this.rangeContainsNode = function(a, c) {\n\t            var b = c.ownerDocument.createRange(), l = c.ownerDocument.createRange(), e;\n\t            b.setStart(a.startContainer, a.startOffset);\n\t            b.setEnd(a.endContainer, a.endOffset);\n\t            l.selectNodeContents(c);\n\t            e = d(b, l);\n\t            b.detach();\n\t            l.detach();\n\t            return e\n\t        }\n\t        ;\n\t        this.mergeIntoParent = r;\n\t        this.removeUnwantedNodes = q;\n\t        this.removeAllChildNodes = function(a) {\n\t            for (; a.firstChild; )\n\t                a.removeChild(a.firstChild)\n\t        }\n\t        ;\n\t        this.getElementsByTagNameNS = function(a, c, b) {\n\t            var d = [];\n\t            a = a.getElementsByTagNameNS(c, b);\n\t            d.length = b = a.length;\n\t            for (c = 0; c < b; c += 1)\n\t                d[c] = a.item(c);\n\t            return d\n\t        }\n\t        ;\n\t        this.getElementsByTagName = function(a, c) {\n\t            var b = [], d, l, e;\n\t            d = a.getElementsByTagName(c);\n\t            b.length = e = d.length;\n\t            for (l = 0; l < e; l += 1)\n\t                b[l] = d.item(l);\n\t            return b\n\t        }\n\t        ;\n\t        this.containsNode = function(a, c) {\n\t            return a === c || a.contains(c)\n\t        }\n\t        ;\n\t        this.comparePoints = function(a, c, d, l) {\n\t            if (a === d)\n\t                return l - c;\n\t            var e = a.compareDocumentPosition(d);\n\t            2 === e ? e = -1 : 4 === e ? e = 1 : 10 === e ? (c = b(a, d),\n\t            e = c < l ? 1 : -1) : (l = b(d, a),\n\t            e = l < c ? -1 : 1);\n\t            return e\n\t        }\n\t        ;\n\t        this.adaptRangeDifferenceToZoomLevel = l;\n\t        this.translateRect = function(a, c, b) {\n\t            return {\n\t                top: l(a.top - c.top, b),\n\t                left: l(a.left - c.left, b),\n\t                bottom: l(a.bottom - c.top, b),\n\t                right: l(a.right - c.left, b),\n\t                width: l(a.width, b),\n\t                height: l(a.height, b)\n\t            }\n\t        }\n\t        ;\n\t        this.getBoundingClientRect = function(a) {\n\t            var b = a.ownerDocument\n\t              , d = g()\n\t              , l = b.body;\n\t            if ((!1 === d.unscaledRangeClientRects || d.rangeBCRIgnoresElementBCR) && a.nodeType === Node.ELEMENT_NODE)\n\t                return a = a.getBoundingClientRect(),\n\t                d.elementBCRIgnoresBodyScroll ? {\n\t                    left: a.left + l.scrollLeft,\n\t                    right: a.right + l.scrollLeft,\n\t                    top: a.top + l.scrollTop,\n\t                    bottom: a.bottom + l.scrollTop,\n\t                    width: a.width,\n\t                    height: a.height\n\t                } : a;\n\t            var e;\n\t            c ? e = c : c = e = b.createRange();\n\t            d = e;\n\t            d.selectNode(a);\n\t            return d.getBoundingClientRect()\n\t        }\n\t        ;\n\t        this.mapKeyValObjOntoNode = function(a, c, b) {\n\t            Object.keys(c).forEach(function(d) {\n\t                var l = d.split(\":\")\n\t                  , e = l[1]\n\t                  , l = b(l[0])\n\t                  , f = c[d];\n\t                l ? (e = a.getElementsByTagNameNS(l, e)[0],\n\t                e || (e = a.ownerDocument.createElementNS(l, d),\n\t                a.appendChild(e)),\n\t                e.textContent = f) : runtime.log(\"Key ignored: \" + d)\n\t            })\n\t        }\n\t        ;\n\t        this.removeKeyElementsFromNode = function(a, c, b) {\n\t            c.forEach(function(c) {\n\t                var d = c.split(\":\")\n\t                  , h = d[1];\n\t                (d = b(d[0])) ? (h = a.getElementsByTagNameNS(d, h)[0]) ? h.parentNode.removeChild(h) : runtime.log(\"Element for \" + c + \" not found.\") : runtime.log(\"Property Name ignored: \" + c)\n\t            })\n\t        }\n\t        ;\n\t        this.getKeyValRepresentationOfNode = function(a, c) {\n\t            for (var b = {}, d = a.firstElementChild, l; d; ) {\n\t                if (l = c(d.namespaceURI))\n\t                    b[l + \":\" + d.localName] = d.textContent;\n\t                d = d.nextElementSibling\n\t            }\n\t            return b\n\t        }\n\t        ;\n\t        this.mapObjOntoNode = a;\n\t        this.cloneEvent = function(a) {\n\t            var c = Object.create(null);\n\t            Object.keys(a.constructor.prototype).forEach(function(b) {\n\t                c[b] = a[b]\n\t            });\n\t            c.prototype = a.constructor.prototype;\n\t            return c\n\t        }\n\t        ;\n\t        this.getDirectChild = k;\n\t        (function(a) {\n\t            var c, b;\n\t            b = runtime.getWindow();\n\t            null !== b && (c = b.navigator.appVersion.toLowerCase(),\n\t            b = -1 === c.indexOf(\"chrome\") && (-1 !== c.indexOf(\"applewebkit\") || -1 !== c.indexOf(\"safari\")),\n\t            c = -1 !== c.indexOf(\"msie\") || -1 !== c.indexOf(\"trident\"),\n\t            b || c) && (a.containsNode = e)\n\t        }\n\t        )(this)\n\t    }\n\t    ;\n\t    core.DomUtils = new core.DomUtilsImpl\n\t}\n\t)();\n\tcore.Cursor = function(g, k) {\n\t    function d(a) {\n\t        a.parentNode && (r.push(a.previousSibling),\n\t        r.push(a.nextSibling),\n\t        a.parentNode.removeChild(a))\n\t    }\n\t    function b(a, c, b) {\n\t        if (c.nodeType === Node.TEXT_NODE) {\n\t            runtime.assert(Boolean(c), \"putCursorIntoTextNode: invalid container\");\n\t            var d = c.parentNode;\n\t            runtime.assert(Boolean(d), \"putCursorIntoTextNode: container without parent\");\n\t            runtime.assert(0 <= b && b <= c.length, \"putCursorIntoTextNode: offset is out of bounds\");\n\t            0 === b ? d.insertBefore(a, c) : (b !== c.length && c.splitText(b),\n\t            d.insertBefore(a, c.nextSibling))\n\t        } else\n\t            c.nodeType === Node.ELEMENT_NODE && c.insertBefore(a, c.childNodes.item(b));\n\t        r.push(a.previousSibling);\n\t        r.push(a.nextSibling)\n\t    }\n\t    var f = g.createElementNS(\"urn:webodf:names:cursor\", \"cursor\"), n = g.createElementNS(\"urn:webodf:names:cursor\", \"anchor\"), p, r = [], q = g.createRange(), e, l = core.DomUtils;\n\t    this.getNode = function() {\n\t        return f\n\t    }\n\t    ;\n\t    this.getAnchorNode = function() {\n\t        return n.parentNode ? n : f\n\t    }\n\t    ;\n\t    this.getSelectedRange = function() {\n\t        e ? (q.setStartBefore(f),\n\t        q.collapse(!0)) : (q.setStartAfter(p ? n : f),\n\t        q.setEndBefore(p ? f : n));\n\t        return q\n\t    }\n\t    ;\n\t    this.setSelectedRange = function(a, c) {\n\t        q && q !== a && q.detach();\n\t        q = a;\n\t        p = !1 !== c;\n\t        (e = a.collapsed) ? (d(n),\n\t        d(f),\n\t        b(f, a.startContainer, a.startOffset)) : (d(n),\n\t        d(f),\n\t        b(p ? f : n, a.endContainer, a.endOffset),\n\t        b(p ? n : f, a.startContainer, a.startOffset));\n\t        r.forEach(l.normalizeTextNodes);\n\t        r.length = 0\n\t    }\n\t    ;\n\t    this.hasForwardSelection = function() {\n\t        return p\n\t    }\n\t    ;\n\t    this.remove = function() {\n\t        d(f);\n\t        r.forEach(l.normalizeTextNodes);\n\t        r.length = 0\n\t    }\n\t    ;\n\t    f.setAttributeNS(\"urn:webodf:names:cursor\", \"memberId\", k);\n\t    n.setAttributeNS(\"urn:webodf:names:cursor\", \"memberId\", k)\n\t}\n\t;\n\tcore.Destroyable = function() {}\n\t;\n\tcore.Destroyable.prototype.destroy = function(g) {}\n\t;\n\tcore.EventSource = function() {}\n\t;\n\tcore.EventSource.prototype.subscribe = function(g, k) {}\n\t;\n\tcore.EventSource.prototype.unsubscribe = function(g, k) {}\n\t;\n\tcore.EventNotifier = function(g) {\n\t    function k(b) {\n\t        runtime.assert(!d.hasOwnProperty(b), 'Duplicated event ids: \"' + b + '\" registered more than once.');\n\t        d[b] = []\n\t    }\n\t    var d = {};\n\t    this.emit = function(b, f) {\n\t        var n, g;\n\t        runtime.assert(d.hasOwnProperty(b), 'unknown event fired \"' + b + '\"');\n\t        g = d[b];\n\t        for (n = 0; n < g.length; n += 1)\n\t            g[n](f)\n\t    }\n\t    ;\n\t    this.subscribe = function(b, f) {\n\t        runtime.assert(d.hasOwnProperty(b), 'tried to subscribe to unknown event \"' + b + '\"');\n\t        d[b].push(f)\n\t    }\n\t    ;\n\t    this.unsubscribe = function(b, f) {\n\t        var n;\n\t        runtime.assert(d.hasOwnProperty(b), 'tried to unsubscribe from unknown event \"' + b + '\"');\n\t        n = d[b].indexOf(f);\n\t        runtime.assert(-1 !== n, 'tried to unsubscribe unknown callback from event \"' + b + '\"');\n\t        -1 !== n && d[b].splice(n, 1)\n\t    }\n\t    ;\n\t    this.register = k;\n\t    g && g.forEach(k)\n\t}\n\t;\n\tcore.ScheduledTask = function(g, k, d) {\n\t    function b() {\n\t        p && (d(n),\n\t        p = !1)\n\t    }\n\t    function f() {\n\t        b();\n\t        g.apply(void 0, r);\n\t        r = null\n\t    }\n\t    var n, p = !1, r = [], q = !1;\n\t    this.trigger = function() {\n\t        runtime.assert(!1 === q, \"Can't trigger destroyed ScheduledTask instance\");\n\t        r = Array.prototype.slice.call(arguments);\n\t        p || (p = !0,\n\t        n = k(f))\n\t    }\n\t    ;\n\t    this.triggerImmediate = function() {\n\t        runtime.assert(!1 === q, \"Can't trigger destroyed ScheduledTask instance\");\n\t        r = Array.prototype.slice.call(arguments);\n\t        f()\n\t    }\n\t    ;\n\t    this.processRequests = function() {\n\t        p && f()\n\t    }\n\t    ;\n\t    this.cancel = b;\n\t    this.restart = function() {\n\t        runtime.assert(!1 === q, \"Can't trigger destroyed ScheduledTask instance\");\n\t        b();\n\t        p = !0;\n\t        n = k(f)\n\t    }\n\t    ;\n\t    this.destroy = function(d) {\n\t        b();\n\t        q = !0;\n\t        d()\n\t    }\n\t}\n\t;\n\t(function() {\n\t    var g;\n\t    core.Task = {};\n\t    core.Task.SUPPRESS_MANUAL_PROCESSING = !1;\n\t    core.Task.processTasks = function() {\n\t        core.Task.SUPPRESS_MANUAL_PROCESSING || g.performRedraw()\n\t    }\n\t    ;\n\t    core.Task.createRedrawTask = function(k) {\n\t        return new core.ScheduledTask(k,g.requestRedrawTask,g.cancelRedrawTask)\n\t    }\n\t    ;\n\t    core.Task.createTimeoutTask = function(g, d) {\n\t        return new core.ScheduledTask(g,function(b) {\n\t            return runtime.setTimeout(b, d)\n\t        }\n\t        ,runtime.clearTimeout)\n\t    }\n\t    ;\n\t    g = new function() {\n\t        var g = {};\n\t        this.requestRedrawTask = function(d) {\n\t            var b = runtime.requestAnimationFrame(function() {\n\t                d();\n\t                delete g[b]\n\t            });\n\t            g[b] = d;\n\t            return b\n\t        }\n\t        ;\n\t        this.performRedraw = function() {\n\t            Object.keys(g).forEach(function(d) {\n\t                g[d]();\n\t                runtime.cancelAnimationFrame(parseInt(d, 10))\n\t            });\n\t            g = {}\n\t        }\n\t        ;\n\t        this.cancelRedrawTask = function(d) {\n\t            runtime.cancelAnimationFrame(d);\n\t            delete g[d]\n\t        }\n\t    }\n\t}\n\t)();\n\tcore.EventSubscriptions = function() {\n\t    function g(b, f, n) {\n\t        b.subscribe(f, n);\n\t        d.push({\n\t            eventSource: b,\n\t            eventid: f,\n\t            callback: n\n\t        })\n\t    }\n\t    function k() {\n\t        var n = [];\n\t        d.forEach(function(b) {\n\t            b.eventSource.unsubscribe(b.eventid, b.callback)\n\t        });\n\t        d.length = 0;\n\t        Object.keys(f).forEach(function(b) {\n\t            f[b].forEach(function(b) {\n\t                n.push(b.task.destroy)\n\t            });\n\t            delete f[b]\n\t        });\n\t        core.Async.destroyAll(n, function() {});\n\t        b = new core.EventNotifier\n\t    }\n\t    var d = []\n\t      , b = new core.EventNotifier\n\t      , f = {}\n\t      , n = 0;\n\t    this.addSubscription = g;\n\t    this.addFrameSubscription = function(d, k, q) {\n\t        var e, l, a, c;\n\t        f.hasOwnProperty(k) || (f[k] = []);\n\t        a = f[k];\n\t        for (c = 0; c < a.length; c += 1)\n\t            if (a[c].eventSource === d) {\n\t                e = a[c];\n\t                break\n\t            }\n\t        e || (l = \"s\" + n,\n\t        n += 1,\n\t        b.register(l),\n\t        e = {\n\t            frameEventId: l,\n\t            eventSource: d,\n\t            task: core.Task.createRedrawTask(function() {\n\t                b.emit(l, void 0)\n\t            })\n\t        },\n\t        a.push(e),\n\t        g(d, k, e.task.trigger));\n\t        b.subscribe(e.frameEventId, q)\n\t    }\n\t    ;\n\t    this.unsubscribeAll = k;\n\t    this.destroy = function(b) {\n\t        k();\n\t        b()\n\t    }\n\t}\n\t;\n\tcore.LazyProperty = function(g) {\n\t    var k, d = !1;\n\t    this.value = function() {\n\t        d || (k = g(),\n\t        d = !0);\n\t        return k\n\t    }\n\t    ;\n\t    this.reset = function() {\n\t        d = !1\n\t    }\n\t}\n\t;\n\tcore.LoopWatchDog = function(g, k) {\n\t    var d = Date.now()\n\t      , b = 0;\n\t    this.check = function() {\n\t        var f;\n\t        if (g && (f = Date.now(),\n\t        f - d > g))\n\t            throw runtime.log(\"alert\", \"watchdog timeout\"),\n\t            \"timeout!\";\n\t        if (0 < k && (b += 1,\n\t        b > k))\n\t            throw runtime.log(\"alert\", \"watchdog loop overflow\"),\n\t            \"loop overflow\";\n\t    }\n\t}\n\t;\n\tcore.NodeFilterChain = function(g) {\n\t    var k = NodeFilter.FILTER_REJECT\n\t      , d = NodeFilter.FILTER_ACCEPT;\n\t    this.acceptNode = function(b) {\n\t        var f;\n\t        for (f = 0; f < g.length; f += 1)\n\t            if (g[f].acceptNode(b) === k)\n\t                return k;\n\t        return d\n\t    }\n\t}\n\t;\n\tcore.PositionIterator = function(g, k, d, b) {\n\t    function f() {\n\t        this.acceptNode = function(a) {\n\t            return !a || a.nodeType === m && 0 === a.length ? x : y\n\t        }\n\t    }\n\t    function n(a) {\n\t        this.acceptNode = function(c) {\n\t            return !c || c.nodeType === m && 0 === c.length ? x : a.acceptNode(c)\n\t        }\n\t    }\n\t    function p() {\n\t        var c = l.currentNode\n\t          , b = c.nodeType;\n\t        a = b === m ? c.length - 1 : b === h ? 1 : 0\n\t    }\n\t    function r() {\n\t        if (null === l.previousSibling()) {\n\t            if (!l.parentNode() || l.currentNode === g)\n\t                return l.firstChild(),\n\t                !1;\n\t            a = 0\n\t        } else\n\t            p();\n\t        return !0\n\t    }\n\t    function q() {\n\t        var b = l.currentNode, d;\n\t        d = c(b);\n\t        if (b !== g)\n\t            for (b = b.parentNode; b && b !== g; )\n\t                c(b) === x && (l.currentNode = b,\n\t                d = x),\n\t                b = b.parentNode;\n\t        d === x ? (a = l.currentNode.nodeType === m ? b.length : 1,\n\t        b = e.nextPosition()) : b = d === y ? !0 : e.nextPosition();\n\t        b && runtime.assert(c(l.currentNode) === y, \"moveToAcceptedNode did not result in walker being on an accepted node\");\n\t        return b\n\t    }\n\t    var e = this, l, a, c, m = Node.TEXT_NODE, h = Node.ELEMENT_NODE, y = NodeFilter.FILTER_ACCEPT, x = NodeFilter.FILTER_REJECT;\n\t    this.nextPosition = function() {\n\t        var c = l.currentNode\n\t          , b = c.nodeType;\n\t        if (c === g)\n\t            return !1;\n\t        if (0 === a && b === h)\n\t            null === l.firstChild() && (a = 1);\n\t        else if (b === m && a + 1 < c.length)\n\t            a += 1;\n\t        else if (null !== l.nextSibling())\n\t            a = 0;\n\t        else if (l.parentNode())\n\t            a = 1;\n\t        else\n\t            return !1;\n\t        return !0\n\t    }\n\t    ;\n\t    this.previousPosition = function() {\n\t        var c = !0\n\t          , b = l.currentNode;\n\t        0 === a ? c = r() : b.nodeType === m ? --a : null !== l.lastChild() ? p() : b === g ? c = !1 : a = 0;\n\t        return c\n\t    }\n\t    ;\n\t    this.previousNode = r;\n\t    this.container = function() {\n\t        var c = l.currentNode\n\t          , b = c.nodeType;\n\t        0 === a && b !== m && (c = c.parentNode);\n\t        return c\n\t    }\n\t    ;\n\t    this.rightNode = function() {\n\t        var b = l.currentNode\n\t          , d = b.nodeType;\n\t        if (d === m && a === b.length)\n\t            for (b = b.nextSibling; b && c(b) !== y; )\n\t                b = b.nextSibling;\n\t        else\n\t            d === h && 1 === a && (b = null);\n\t        return b\n\t    }\n\t    ;\n\t    this.leftNode = function() {\n\t        var b = l.currentNode;\n\t        if (0 === a)\n\t            for (b = b.previousSibling; b && c(b) !== y; )\n\t                b = b.previousSibling;\n\t        else if (b.nodeType === h)\n\t            for (b = b.lastChild; b && c(b) !== y; )\n\t                b = b.previousSibling;\n\t        return b\n\t    }\n\t    ;\n\t    this.getCurrentNode = function() {\n\t        return l.currentNode\n\t    }\n\t    ;\n\t    this.unfilteredDomOffset = function() {\n\t        if (l.currentNode.nodeType === m)\n\t            return a;\n\t        for (var c = 0, b = l.currentNode, b = 1 === a ? b.lastChild : b.previousSibling; b; )\n\t            c += 1,\n\t            b = b.previousSibling;\n\t        return c\n\t    }\n\t    ;\n\t    this.getPreviousSibling = function() {\n\t        var a = l.currentNode\n\t          , c = l.previousSibling();\n\t        l.currentNode = a;\n\t        return c\n\t    }\n\t    ;\n\t    this.getNextSibling = function() {\n\t        var a = l.currentNode\n\t          , c = l.nextSibling();\n\t        l.currentNode = a;\n\t        return c\n\t    }\n\t    ;\n\t    this.setPositionBeforeElement = function(c) {\n\t        runtime.assert(Boolean(c), \"setPositionBeforeElement called without element\");\n\t        l.currentNode = c;\n\t        a = 0;\n\t        return q()\n\t    }\n\t    ;\n\t    this.setUnfilteredPosition = function(c, b) {\n\t        runtime.assert(Boolean(c), \"PositionIterator.setUnfilteredPosition called without container\");\n\t        l.currentNode = c;\n\t        c.nodeType === m ? (a = b,\n\t        runtime.assert(b <= c.length, \"Error in setPosition: \" + b + \" > \" + c.length),\n\t        runtime.assert(0 <= b, \"Error in setPosition: \" + b + \" < 0\"),\n\t        b === c.length && (l.nextSibling() ? a = 0 : l.parentNode() ? a = 1 : runtime.assert(!1, \"Error in setUnfilteredPosition: position not valid.\"))) : b < c.childNodes.length ? (l.currentNode = c.childNodes.item(b),\n\t        a = 0) : a = 1;\n\t        return q()\n\t    }\n\t    ;\n\t    this.moveToEnd = function() {\n\t        l.currentNode = g;\n\t        a = 1\n\t    }\n\t    ;\n\t    this.moveToEndOfNode = function(c) {\n\t        c.nodeType === m ? e.setUnfilteredPosition(c, c.length) : (l.currentNode = c,\n\t        a = 1)\n\t    }\n\t    ;\n\t    this.isBeforeNode = function() {\n\t        return 0 === a\n\t    }\n\t    ;\n\t    this.getNodeFilter = function() {\n\t        return c\n\t    }\n\t    ;\n\t    c = (d ? new n(d) : new f).acceptNode;\n\t    c.acceptNode = c;\n\t    k = k || NodeFilter.SHOW_ALL;\n\t    runtime.assert(g.nodeType !== Node.TEXT_NODE, \"Internet Explorer doesn't allow tree walker roots to be text nodes\");\n\t    l = g.ownerDocument.createTreeWalker(g, k, c, b);\n\t    a = 0;\n\t    null === l.firstChild() && (a = 1)\n\t}\n\t;\n\tcore.PositionFilter = function() {}\n\t;\n\tcore.PositionFilter.FilterResult = {\n\t    FILTER_ACCEPT: 1,\n\t    FILTER_REJECT: 2,\n\t    FILTER_SKIP: 3\n\t};\n\tcore.PositionFilter.prototype.acceptPosition = function(g) {}\n\t;\n\tcore.PositionFilterChain = function() {\n\t    var g = []\n\t      , k = core.PositionFilter.FilterResult.FILTER_ACCEPT\n\t      , d = core.PositionFilter.FilterResult.FILTER_REJECT;\n\t    this.acceptPosition = function(b) {\n\t        var f;\n\t        for (f = 0; f < g.length; f += 1)\n\t            if (g[f].acceptPosition(b) === d)\n\t                return d;\n\t        return k\n\t    }\n\t    ;\n\t    this.addFilter = function(b) {\n\t        g.push(b)\n\t    }\n\t}\n\t;\n\tcore.StepDirection = {\n\t    PREVIOUS: 1,\n\t    NEXT: 2\n\t};\n\tcore.StepIterator = function(g, k) {\n\t    function d() {\n\t        a = null;\n\t        m = c = void 0\n\t    }\n\t    function b() {\n\t        void 0 === m && (m = g.acceptPosition(k) === e);\n\t        return m\n\t    }\n\t    function f(a, c) {\n\t        d();\n\t        return k.setUnfilteredPosition(a, c)\n\t    }\n\t    function n() {\n\t        a || (a = k.container());\n\t        return a\n\t    }\n\t    function p() {\n\t        void 0 === c && (c = k.unfilteredDomOffset());\n\t        return c\n\t    }\n\t    function r() {\n\t        for (d(); k.nextPosition(); )\n\t            if (d(),\n\t            b())\n\t                return !0;\n\t        return !1\n\t    }\n\t    function q() {\n\t        for (d(); k.previousPosition(); )\n\t            if (d(),\n\t            b())\n\t                return !0;\n\t        return !1\n\t    }\n\t    var e = core.PositionFilter.FilterResult.FILTER_ACCEPT, l = core.StepDirection.NEXT, a, c, m;\n\t    this.isStep = b;\n\t    this.setPosition = f;\n\t    this.container = n;\n\t    this.offset = p;\n\t    this.nextStep = r;\n\t    this.previousStep = q;\n\t    this.advanceStep = function(a) {\n\t        return a === l ? r() : q()\n\t    }\n\t    ;\n\t    this.roundToClosestStep = function() {\n\t        var a, c, d = b();\n\t        d || (a = n(),\n\t        c = p(),\n\t        d = q(),\n\t        d || (f(a, c),\n\t        d = r()));\n\t        return d\n\t    }\n\t    ;\n\t    this.roundToPreviousStep = function() {\n\t        var a = b();\n\t        a || (a = q());\n\t        return a\n\t    }\n\t    ;\n\t    this.roundToNextStep = function() {\n\t        var a = b();\n\t        a || (a = r());\n\t        return a\n\t    }\n\t    ;\n\t    this.leftNode = function() {\n\t        return k.leftNode()\n\t    }\n\t    ;\n\t    this.snapshot = function() {\n\t        return new core.StepIterator.StepSnapshot(n(),p())\n\t    }\n\t    ;\n\t    this.restore = function(a) {\n\t        f(a.container, a.offset)\n\t    }\n\t}\n\t;\n\tcore.StepIterator.StepSnapshot = function(g, k) {\n\t    this.container = g;\n\t    this.offset = k\n\t}\n\t;\n\tcore.Utils = function() {\n\t    function g(k, d) {\n\t        if (d && Array.isArray(d)) {\n\t            k = k || [];\n\t            if (!Array.isArray(k))\n\t                throw \"Destination is not an array.\";\n\t            k = k.concat(d.map(function(b) {\n\t                return g(null, b)\n\t            }))\n\t        } else if (d && \"object\" === typeof d) {\n\t            k = k || {};\n\t            if (\"object\" !== typeof k)\n\t                throw \"Destination is not an object.\";\n\t            Object.keys(d).forEach(function(b) {\n\t                k[b] = g(k[b], d[b])\n\t            })\n\t        } else\n\t            k = d;\n\t        return k\n\t    }\n\t    this.hashString = function(g) {\n\t        var d = 0, b, f;\n\t        b = 0;\n\t        for (f = g.length; b < f; b += 1)\n\t            d = (d << 5) - d + g.charCodeAt(b),\n\t            d |= 0;\n\t        return d\n\t    }\n\t    ;\n\t    this.mergeObjects = function(k, d) {\n\t        Object.keys(d).forEach(function(b) {\n\t            k[b] = g(k[b], d[b])\n\t        });\n\t        return k\n\t    }\n\t}\n\t;\n\tcore.Zip = function(g, k) {\n\t    function d(b, d) {\n\t        var a = r.file(b);\n\t        a ? d(null, a.asUint8Array()) : d(b + \" not found.\", null)\n\t    }\n\t    function b(b, l) {\n\t        d(b, function(a, c) {\n\t            if (a || null === c)\n\t                return l(a, null);\n\t            var b = runtime.byteArrayToString(c, \"utf8\");\n\t            l(null, b)\n\t        })\n\t    }\n\t    function f(b, d) {\n\t        try {\n\t            b(r.generate({\n\t                type: \"uint8array\",\n\t                compression: \"STORE\"\n\t            }))\n\t        } catch (a) {\n\t            d(a.message)\n\t        }\n\t    }\n\t    function n(b, d) {\n\t        f(function(a) {\n\t            runtime.writeFile(b, a, d)\n\t        }, d)\n\t    }\n\t    var p = this, r, q = new core.Base64;\n\t    this.load = d;\n\t    this.save = function(b, d, a, c) {\n\t        r.file(b, d, {\n\t            date: c,\n\t            compression: a ? \"DEFLATE\" : \"STORE\"\n\t        })\n\t    }\n\t    ;\n\t    this.remove = function(b) {\n\t        var d = null !== r.file(b);\n\t        r.remove(b);\n\t        return d\n\t    }\n\t    ;\n\t    this.write = function(b) {\n\t        n(g, b)\n\t    }\n\t    ;\n\t    this.writeAs = n;\n\t    this.createByteArray = f;\n\t    this.loadContentXmlAsFragments = function(d, l) {\n\t        b(d, function(a, c) {\n\t            if (a)\n\t                return l.rootElementReady(a);\n\t            l.rootElementReady(null, c, !0)\n\t        })\n\t    }\n\t    ;\n\t    this.loadAsString = b;\n\t    this.loadAsDOM = function(d, l) {\n\t        b(d, function(a, c) {\n\t            if (a || null === c)\n\t                l(a, null);\n\t            else {\n\t                var b = (new DOMParser).parseFromString(c, \"text/xml\");\n\t                l(null, b)\n\t            }\n\t        })\n\t    }\n\t    ;\n\t    this.loadAsDataURL = function(b, l, a) {\n\t        d(b, function(c, b) {\n\t            if (c || !b)\n\t                return a(c, null);\n\t            var d = 0, e;\n\t            l || (l = 80 === b[1] && 78 === b[2] && 71 === b[3] ? \"image/png\" : 255 === b[0] && 216 === b[1] && 255 === b[2] ? \"image/jpeg\" : 71 === b[0] && 73 === b[1] && 70 === b[2] ? \"image/gif\" : \"\");\n\t            for (e = \"data:\" + l + \";base64,\"; d < b.length; )\n\t                e += q.convertUTF8ArrayToBase64(b.subarray(d, Math.min(d + 45E3, b.length))),\n\t                d += 45E3;\n\t            a(null, e)\n\t        })\n\t    }\n\t    ;\n\t    this.getEntries = function() {\n\t        return Object.keys(r.files).map(function(b) {\n\t            return {\n\t                filename: b,\n\t                date: r.files[b].date\n\t            }\n\t        })\n\t    }\n\t    ;\n\t    r = new externs.JSZip;\n\t    null !== k && runtime.readFile(g, \"binary\", function(b, d) {\n\t        \"string\" === typeof d && (b = \"file was read as a string. Should be Uint8Array.\");\n\t        if (b || !d || 0 === d.length)\n\t            k(\"File '\" + g + \"' cannot be read. Err: \" + (b || \"[none]\"), p);\n\t        else\n\t            try {\n\t                r.load(d, {\n\t                    checkCRC32: !1\n\t                }),\n\t                k(null, p)\n\t            } catch (a) {\n\t                k(a.message, p)\n\t            }\n\t    })\n\t}\n\t;\n\tcore.SimpleClientRect = null;\n\tgui.CommonConstraints = {\n\t    EDIT: {\n\t        ANNOTATIONS: {\n\t            ONLY_DELETE_OWN: \"onlyDeleteOwn\"\n\t        },\n\t        REVIEW_MODE: \"reviewMode\"\n\t    }\n\t};\n\tgui.SessionConstraints = function() {\n\t    function g(b) {\n\t        k.hasOwnProperty(b) || (k[b] = !1,\n\t        d.register(b))\n\t    }\n\t    var k = {}\n\t      , d = new core.EventNotifier;\n\t    this.registerConstraint = g;\n\t    this.subscribe = function(b, f) {\n\t        g(b);\n\t        d.subscribe(b, f)\n\t    }\n\t    ;\n\t    this.unsubscribe = function(b, f) {\n\t        d.unsubscribe(b, f)\n\t    }\n\t    ;\n\t    this.setState = function(b, f) {\n\t        runtime.assert(!0 === k.hasOwnProperty(b), \"No such constraint\");\n\t        k[b] !== f && (k[b] = f,\n\t        d.emit(b, f))\n\t    }\n\t    ;\n\t    this.getState = function(b) {\n\t        runtime.assert(!0 === k.hasOwnProperty(b), \"No such constraint\");\n\t        return k[b]\n\t    }\n\t}\n\t;\n\tgui.BlacklistNamespaceNodeFilter = function(g) {\n\t    var k = {}\n\t      , d = NodeFilter.FILTER_REJECT\n\t      , b = NodeFilter.FILTER_ACCEPT;\n\t    this.acceptNode = function(f) {\n\t        return !f || k.hasOwnProperty(f.namespaceURI) ? d : b\n\t    }\n\t    ;\n\t    (function() {\n\t        g.forEach(function(b) {\n\t            k[b] = !0\n\t        })\n\t    }\n\t    )()\n\t}\n\t;\n\todf.Namespaces = {\n\t    namespaceMap: {\n\t        config: \"urn:oasis:names:tc:opendocument:xmlns:config:1.0\",\n\t        db: \"urn:oasis:names:tc:opendocument:xmlns:database:1.0\",\n\t        dc: \"http://purl.org/dc/elements/1.1/\",\n\t        dr3d: \"urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0\",\n\t        draw: \"urn:oasis:names:tc:opendocument:xmlns:drawing:1.0\",\n\t        chart: \"urn:oasis:names:tc:opendocument:xmlns:chart:1.0\",\n\t        fo: \"urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0\",\n\t        form: \"urn:oasis:names:tc:opendocument:xmlns:form:1.0\",\n\t        math: \"http://www.w3.org/1998/Math/MathML\",\n\t        meta: \"urn:oasis:names:tc:opendocument:xmlns:meta:1.0\",\n\t        number: \"urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0\",\n\t        office: \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\",\n\t        presentation: \"urn:oasis:names:tc:opendocument:xmlns:presentation:1.0\",\n\t        style: \"urn:oasis:names:tc:opendocument:xmlns:style:1.0\",\n\t        svg: \"urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0\",\n\t        table: \"urn:oasis:names:tc:opendocument:xmlns:table:1.0\",\n\t        text: \"urn:oasis:names:tc:opendocument:xmlns:text:1.0\",\n\t        xforms: \"http://www.w3.org/2002/xforms\",\n\t        xlink: \"http://www.w3.org/1999/xlink\",\n\t        xml: \"http://www.w3.org/XML/1998/namespace\"\n\t    },\n\t    prefixMap: {},\n\t    configns: \"urn:oasis:names:tc:opendocument:xmlns:config:1.0\",\n\t    dbns: \"urn:oasis:names:tc:opendocument:xmlns:database:1.0\",\n\t    dcns: \"http://purl.org/dc/elements/1.1/\",\n\t    dr3dns: \"urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0\",\n\t    drawns: \"urn:oasis:names:tc:opendocument:xmlns:drawing:1.0\",\n\t    chartns: \"urn:oasis:names:tc:opendocument:xmlns:chart:1.0\",\n\t    fons: \"urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0\",\n\t    formns: \"urn:oasis:names:tc:opendocument:xmlns:form:1.0\",\n\t    mathns: \"http://www.w3.org/1998/Math/MathML\",\n\t    metans: \"urn:oasis:names:tc:opendocument:xmlns:meta:1.0\",\n\t    numberns: \"urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0\",\n\t    officens: \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\",\n\t    presentationns: \"urn:oasis:names:tc:opendocument:xmlns:presentation:1.0\",\n\t    stylens: \"urn:oasis:names:tc:opendocument:xmlns:style:1.0\",\n\t    svgns: \"urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0\",\n\t    tablens: \"urn:oasis:names:tc:opendocument:xmlns:table:1.0\",\n\t    textns: \"urn:oasis:names:tc:opendocument:xmlns:text:1.0\",\n\t    xformsns: \"http://www.w3.org/2002/xforms\",\n\t    xlinkns: \"http://www.w3.org/1999/xlink\",\n\t    xmlns: \"http://www.w3.org/XML/1998/namespace\"\n\t};\n\t(function() {\n\t    var g = odf.Namespaces.namespaceMap, k = odf.Namespaces.prefixMap, d;\n\t    for (d in g)\n\t        g.hasOwnProperty(d) && (k[g[d]] = d)\n\t}\n\t)();\n\todf.Namespaces.forEachPrefix = function(g) {\n\t    var k = odf.Namespaces.namespaceMap, d;\n\t    for (d in k)\n\t        k.hasOwnProperty(d) && g(d, k[d])\n\t}\n\t;\n\todf.Namespaces.lookupNamespaceURI = function(g) {\n\t    var k = null;\n\t    odf.Namespaces.namespaceMap.hasOwnProperty(g) && (k = odf.Namespaces.namespaceMap[g]);\n\t    return k\n\t}\n\t;\n\todf.Namespaces.lookupPrefix = function(g) {\n\t    var k = odf.Namespaces.prefixMap;\n\t    return k.hasOwnProperty(g) ? k[g] : null\n\t}\n\t;\n\todf.Namespaces.lookupNamespaceURI.lookupNamespaceURI = odf.Namespaces.lookupNamespaceURI;\n\t(function() {\n\t    odf.OdfSchemaImpl = function() {\n\t        var g = [[\"config:config-item\", \"uncategorized\"], [\"form:item\", \"object\"], [\"form:option\", \"uncategorized\"], [\"math:math\", \"field\"], [\"meta:user-defined\", \"uncategorized\"], [\"number:currency-symbol\", \"uncategorized\"], [\"number:embedded-text\", \"uncategorized\"], [\"number:text\", \"uncategorized\"], [\"presentation:date-time-decl\", \"uncategorized\"], [\"presentation:footer-decl\", \"uncategorized\"], [\"presentation:header-decl\", \"uncategorized\"], [\"svg:desc\", \"text\"], [\"svg:title\", \"text\"], [\"table:desc\", \"uncategorized\"], [\"table:title\", \"uncategorized\"], [\"text:a\", \"text\"], [\"text:author-initials\", \"field\"], [\"text:author-name\", \"field\"], [\"text:bibliography-mark\", \"field\"], [\"text:bookmark-ref\", \"field\"], [\"text:chapter\", \"field\"], [\"text:character-count\", \"field\"], [\"text:conditional-text\", \"field\"], [\"text:creation-date\", \"field\"], [\"text:creation-time\", \"field\"], [\"text:creator\", \"field\"], [\"text:database-display\", \"field\"], [\"text:database-name\", \"field\"], [\"text:database-row-number\", \"field\"], [\"text:date\", \"field\"], [\"text:dde-connection\", \"field\"], [\"text:description\", \"field\"], [\"text:editing-cycles\", \"field\"], [\"text:editing-duration\", \"field\"], [\"text:execute-macro\", \"uncategorized\"], [\"text:expression\", \"uncategorized\"], [\"text:file-name\", \"field\"], [\"text:h\", \"text\"], [\"text:hidden-paragraph\", \"text\"], [\"text:hidden-text\", \"text\"], [\"text:image-count\", \"field\"], [\"text:index-entry-span\", \"uncategorized\"], [\"text:index-title-template\", \"uncategorized\"], [\"text:initial-creator\", \"field\"], [\"text:keywords\", \"field\"], [\"text:linenumbering-separator\", \"style\"], [\"text:measure\", \"uncategorized\"], [\"text:meta\", \"uncategorized\"], [\"text:meta-field\", \"uncategorized\"], [\"text:modification-date\", \"field\"], [\"text:modification-time\", \"field\"], [\"text:note-citation\", \"field\"], [\"text:note-continuation-notice-backward\", \"style\"], [\"text:note-continuation-notice-forward\", \"style\"], [\"text:note-ref\", \"field\"], [\"text:object-count\", \"field\"], [\"text:p\", \"text\"], [\"text:page-continuation\", \"uncategorized\"], [\"text:page-count\", \"field\"], [\"text:page-number\", \"field\"], [\"text:page-variable-get\", \"field\"], [\"text:page-variable-set\", \"field\"], [\"text:paragraph-count\", \"field\"], [\"text:placeholder\", \"field\"], [\"text:print-date\", \"field\"], [\"text:print-time\", \"field\"], [\"text:printed-by\", \"field\"], [\"text:reference-ref\", \"field\"], [\"text:ruby-base\", \"text\"], [\"text:ruby-text\", \"text\"], [\"text:script\", \"text\"], [\"text:sender-city\", \"field\"], [\"text:sender-company\", \"field\"], [\"text:sender-country\", \"field\"], [\"text:sender-email\", \"field\"], [\"text:sender-fax\", \"field\"], [\"text:sender-firstname\", \"field\"], [\"text:sender-initials\", \"field\"], [\"text:sender-lastname\", \"field\"], [\"text:sender-phone-private\", \"field\"], [\"text:sender-phone-work\", \"field\"], [\"text:sender-position\", \"field\"], [\"text:sender-postal-code\", \"field\"], [\"text:sender-state-or-province\", \"field\"], [\"text:sender-street\", \"field\"], [\"text:sender-title\", \"field\"], [\"text:sequence\", \"uncategorized\"], [\"text:sequence-ref\", \"uncategorized\"], [\"text:sheet-name\", \"uncategorized\"], [\"text:span\", \"text\"], [\"text:subject\", \"field\"], [\"text:table-count\", \"field\"], [\"text:table-formula\", \"deprecated\"], [\"text:template-name\", \"uncategorized\"], [\"text:text-input\", \"field\"], [\"text:time\", \"field\"], [\"text:title\", \"field\"], [\"text:user-defined\", \"field\"], [\"text:user-field-get\", \"field\"], [\"text:user-field-input\", \"field\"], [\"text:variable-get\", \"field\"], [\"text:variable-input\", \"field\"], [\"text:variable-set\", \"field\"], [\"text:word-count\", \"field\"], [\"xforms:model\", \"uncategorized\"]]\n\t          , k = {};\n\t        this.isTextContainer = function(d, b) {\n\t            return \"text\" === k[d + \":\" + b]\n\t        }\n\t        ;\n\t        this.isField = function(d, b) {\n\t            return \"field\" === k[d + \":\" + b]\n\t        }\n\t        ;\n\t        this.getFields = function() {\n\t            return g.filter(function(d) {\n\t                return \"field\" === d[1]\n\t            }).map(function(d) {\n\t                return d[0]\n\t            })\n\t        }\n\t        ;\n\t        (function() {\n\t            g.forEach(function(d) {\n\t                var b = d[1]\n\t                  , f = d[0].split(\":\");\n\t                d = f[0];\n\t                var f = f[1]\n\t                  , n = odf.Namespaces.lookupNamespaceURI(d);\n\t                n ? k[n + \":\" + f] = b : runtime.log(\"DEBUG: OdfSchema - unknown prefix '\" + d + \"'\")\n\t            })\n\t        }\n\t        )()\n\t    }\n\t    ;\n\t    odf.OdfSchema = new odf.OdfSchemaImpl\n\t}\n\t)();\n\todf.OdfUtilsImpl = function() {\n\t    function g(a) {\n\t        return \"image\" === (a && a.localName) && a.namespaceURI === R\n\t    }\n\t    function k(a) {\n\t        return null !== a && a.nodeType === Node.ELEMENT_NODE && \"frame\" === a.localName && a.namespaceURI === R && \"as-char\" === a.getAttributeNS(J, \"anchor-type\")\n\t    }\n\t    function d(a) {\n\t        var c;\n\t        (c = \"annotation\" === (a && a.localName) && a.namespaceURI === odf.Namespaces.officens) || (c = \"div\" === (a && a.localName) && \"annotationWrapper\" === a.className);\n\t        return c\n\t    }\n\t    function b(a) {\n\t        return \"a\" === (a && a.localName) && a.namespaceURI === J\n\t    }\n\t    function f(a) {\n\t        var c = a && a.localName;\n\t        return (\"p\" === c || \"h\" === c) && a.namespaceURI === J\n\t    }\n\t    function n(a, c) {\n\t        for (a && void 0 !== c && !f(a) && a.childNodes.item(c) && (a = a.childNodes.item(c)); a && !f(a); )\n\t            a = a.parentNode;\n\t        return a\n\t    }\n\t    function p(a, c) {\n\t        for (; a && a !== c; ) {\n\t            if (a.namespaceURI === odf.Namespaces.officens && \"annotation\" === a.localName)\n\t                return a;\n\t            a = a.parentNode\n\t        }\n\t        return null\n\t    }\n\t    function r(a) {\n\t        return /^[ \\t\\r\\n]+$/.test(a)\n\t    }\n\t    function q(a) {\n\t        if (null === a || a.nodeType !== Node.ELEMENT_NODE)\n\t            return !1;\n\t        var c = a.localName;\n\t        return fa.isTextContainer(a.namespaceURI, c) || \"span\" === c && \"webodf-annotationHighlight\" === a.className\n\t    }\n\t    function e(a) {\n\t        return null === a || a.nodeType !== Node.ELEMENT_NODE ? !1 : fa.isField(a.namespaceURI, a.localName)\n\t    }\n\t    function l(a) {\n\t        var c = a && a.localName\n\t          , b = !1;\n\t        c && (a = a.namespaceURI,\n\t        a === J && (b = \"s\" === c || \"tab\" === c || \"line-break\" === c));\n\t        return b\n\t    }\n\t    function a(a) {\n\t        return l(a) || e(a) || k(a) || d(a)\n\t    }\n\t    function c(a) {\n\t        var c = a && a.localName\n\t          , b = !1;\n\t        c && (a = a.namespaceURI,\n\t        a === J && (b = \"s\" === c));\n\t        return b\n\t    }\n\t    function m(a) {\n\t        return -1 !== S.indexOf(a.namespaceURI)\n\t    }\n\t    function h(a) {\n\t        if (l(a) || e(a))\n\t            return !1;\n\t        if (q(a.parentNode) && a.nodeType === Node.TEXT_NODE)\n\t            return 0 === a.textContent.length;\n\t        for (a = a.firstChild; a; ) {\n\t            if (m(a) || !h(a))\n\t                return !1;\n\t            a = a.nextSibling\n\t        }\n\t        return !0\n\t    }\n\t    function y(a) {\n\t        for (; null !== a.firstChild && q(a); )\n\t            a = a.firstChild;\n\t        return a\n\t    }\n\t    function x(a) {\n\t        for (; null !== a.lastChild && q(a); )\n\t            a = a.lastChild;\n\t        return a\n\t    }\n\t    function z(a) {\n\t        for (; !f(a) && null === a.previousSibling; )\n\t            a = a.parentNode;\n\t        return f(a) ? null : x(a.previousSibling)\n\t    }\n\t    function w(a) {\n\t        for (; !f(a) && null === a.nextSibling; )\n\t            a = a.parentNode;\n\t        return f(a) ? null : y(a.nextSibling)\n\t    }\n\t    function v(b) {\n\t        for (var d = !1; b; )\n\t            if (b.nodeType === Node.TEXT_NODE)\n\t                if (0 === b.length)\n\t                    b = z(b);\n\t                else\n\t                    return !r(b.data.substr(b.length - 1, 1));\n\t            else\n\t                a(b) ? (d = !1 === c(b),\n\t                b = null) : b = z(b);\n\t        return d\n\t    }\n\t    function u(c) {\n\t        var b = !1, d;\n\t        for (c = c && y(c); c; ) {\n\t            d = c.nodeType === Node.TEXT_NODE ? c.length : 0;\n\t            if (0 < d && !r(c.data)) {\n\t                b = !0;\n\t                break\n\t            }\n\t            if (a(c)) {\n\t                b = !0;\n\t                break\n\t            }\n\t            c = w(c)\n\t        }\n\t        return b\n\t    }\n\t    function t(a, c) {\n\t        return r(a.data.substr(c)) ? !u(w(a)) : !1\n\t    }\n\t    function A(c, b) {\n\t        var d = c.data, m;\n\t        if (!r(d[b]) || a(c.parentNode))\n\t            return !1;\n\t        0 < b ? r(d[b - 1]) || (m = !0) : v(z(c)) && (m = !0);\n\t        return !0 === m ? t(c, b) ? !1 : !0 : !1\n\t    }\n\t    function I(a) {\n\t        return (a = /(-?[0-9]*[0-9][0-9]*(\\.[0-9]*)?|0+\\.[0-9]*[1-9][0-9]*|\\.[0-9]*[1-9][0-9]*)((cm)|(mm)|(in)|(pt)|(pc)|(px)|(%))/.exec(a)) ? {\n\t            value: parseFloat(a[1]),\n\t            unit: a[3]\n\t        } : null\n\t    }\n\t    function K(a) {\n\t        return (a = I(a)) && (0 > a.value || \"%\" === a.unit) ? null : a\n\t    }\n\t    function L(a) {\n\t        return (a = I(a)) && \"%\" !== a.unit ? null : a\n\t    }\n\t    function E(a) {\n\t        switch (a.namespaceURI) {\n\t        case odf.Namespaces.drawns:\n\t        case odf.Namespaces.svgns:\n\t        case odf.Namespaces.dr3dns:\n\t            return !1;\n\t        case odf.Namespaces.textns:\n\t            switch (a.localName) {\n\t            case \"note-body\":\n\t            case \"ruby-text\":\n\t                return !1\n\t            }\n\t            break;\n\t        case odf.Namespaces.officens:\n\t            switch (a.localName) {\n\t            case \"annotation\":\n\t            case \"binary-data\":\n\t            case \"event-listeners\":\n\t                return !1\n\t            }\n\t            break;\n\t        default:\n\t            switch (a.localName) {\n\t            case \"cursor\":\n\t            case \"editinfo\":\n\t                return !1\n\t            }\n\t        }\n\t        return !0\n\t    }\n\t    function N(a) {\n\t        return Boolean(n(a) && (!r(a.textContent) || A(a, 0)))\n\t    }\n\t    function O(a, c) {\n\t        for (; 0 < c.length && !aa.rangeContainsNode(a, c[0]); )\n\t            c.shift();\n\t        for (; 0 < c.length && !aa.rangeContainsNode(a, c[c.length - 1]); )\n\t            c.pop()\n\t    }\n\t    function D(c, b, m) {\n\t        var h;\n\t        h = aa.getNodesInRange(c, function(c) {\n\t            var b = NodeFilter.FILTER_REJECT;\n\t            if (l(c.parentNode) || e(c.parentNode) || d(c))\n\t                b = NodeFilter.FILTER_REJECT;\n\t            else if (c.nodeType === Node.TEXT_NODE) {\n\t                if (m || N(c))\n\t                    b = NodeFilter.FILTER_ACCEPT\n\t            } else if (a(c))\n\t                b = NodeFilter.FILTER_ACCEPT;\n\t            else if (E(c) || q(c))\n\t                b = NodeFilter.FILTER_SKIP;\n\t            return b\n\t        }, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT);\n\t        b || O(c, h);\n\t        return h\n\t    }\n\t    function V(a, c, b) {\n\t        for (; a; ) {\n\t            if (b(a)) {\n\t                c[0] !== a && c.unshift(a);\n\t                break\n\t            }\n\t            if (d(a))\n\t                break;\n\t            a = a.parentNode\n\t        }\n\t    }\n\t    function W(a, c) {\n\t        var b = a;\n\t        if (c < b.childNodes.length - 1)\n\t            b = b.childNodes[c + 1];\n\t        else {\n\t            for (; !b.nextSibling; )\n\t                b = b.parentNode;\n\t            b = b.nextSibling\n\t        }\n\t        for (; b.firstChild; )\n\t            b = b.firstChild;\n\t        return b\n\t    }\n\t    var J = odf.Namespaces.textns\n\t      , R = odf.Namespaces.drawns\n\t      , P = odf.Namespaces.xlinkns\n\t      , aa = core.DomUtils\n\t      , S = [odf.Namespaces.dbns, odf.Namespaces.dcns, odf.Namespaces.dr3dns, odf.Namespaces.drawns, odf.Namespaces.chartns, odf.Namespaces.formns, odf.Namespaces.numberns, odf.Namespaces.officens, odf.Namespaces.presentationns, odf.Namespaces.stylens, odf.Namespaces.svgns, odf.Namespaces.tablens, odf.Namespaces.textns]\n\t      , fa = odf.OdfSchema;\n\t    this.isImage = g;\n\t    this.isCharacterFrame = k;\n\t    this.isInlineRoot = d;\n\t    this.isTextSpan = function(a) {\n\t        return \"span\" === (a && a.localName) && a.namespaceURI === J\n\t    }\n\t    ;\n\t    this.isHyperlink = b;\n\t    this.getHyperlinkTarget = function(a) {\n\t        return a.getAttributeNS(P, \"href\") || \"\"\n\t    }\n\t    ;\n\t    this.isParagraph = f;\n\t    this.getParagraphElement = n;\n\t    this.getParentAnnotation = p;\n\t    this.isWithinAnnotation = function(a, c) {\n\t        return Boolean(p(a, c))\n\t    }\n\t    ;\n\t    this.getAnnotationCreator = function(a) {\n\t        return a.getElementsByTagNameNS(odf.Namespaces.dcns, \"creator\")[0].textContent\n\t    }\n\t    ;\n\t    this.isListItem = function(a) {\n\t        return \"list-item\" === (a && a.localName) && a.namespaceURI === J\n\t    }\n\t    ;\n\t    this.isLineBreak = function(a) {\n\t        return \"line-break\" === (a && a.localName) && a.namespaceURI === J\n\t    }\n\t    ;\n\t    this.isODFWhitespace = r;\n\t    this.isGroupingElement = q;\n\t    this.isFieldElement = e;\n\t    this.isCharacterElement = l;\n\t    this.isAnchoredAsCharacterElement = a;\n\t    this.isSpaceElement = c;\n\t    this.isODFNode = m;\n\t    this.hasNoODFContent = h;\n\t    this.firstChild = y;\n\t    this.lastChild = x;\n\t    this.previousNode = z;\n\t    this.nextNode = w;\n\t    this.scanLeftForNonSpace = v;\n\t    this.lookLeftForCharacter = function(c) {\n\t        var b, d = b = 0;\n\t        c.nodeType === Node.TEXT_NODE && (d = c.length);\n\t        0 < d ? (b = c.data,\n\t        b = r(b.substr(d - 1, 1)) ? 1 === d ? v(z(c)) ? 2 : 0 : r(b.substr(d - 2, 1)) ? 0 : 2 : 1) : a(c) && (b = 1);\n\t        return b\n\t    }\n\t    ;\n\t    this.lookRightForCharacter = function(c) {\n\t        var b = !1\n\t          , d = 0;\n\t        c && c.nodeType === Node.TEXT_NODE && (d = c.length);\n\t        0 < d ? b = !r(c.data.substr(0, 1)) : a(c) && (b = !0);\n\t        return b\n\t    }\n\t    ;\n\t    this.scanLeftForAnyCharacter = function(c) {\n\t        var b = !1, d;\n\t        for (c = c && x(c); c; ) {\n\t            d = c.nodeType === Node.TEXT_NODE ? c.length : 0;\n\t            if (0 < d && !r(c.data)) {\n\t                b = !0;\n\t                break\n\t            }\n\t            if (a(c)) {\n\t                b = !0;\n\t                break\n\t            }\n\t            c = z(c)\n\t        }\n\t        return b\n\t    }\n\t    ;\n\t    this.scanRightForAnyCharacter = u;\n\t    this.isTrailingWhitespace = t;\n\t    this.isSignificantWhitespace = A;\n\t    this.isDowngradableSpaceElement = function(a) {\n\t        return c(a) ? v(z(a)) && u(w(a)) : !1\n\t    }\n\t    ;\n\t    this.parseLength = I;\n\t    this.parseNonNegativeLength = K;\n\t    this.parseFoFontSize = function(a) {\n\t        var c;\n\t        c = (c = I(a)) && (0 >= c.value || \"%\" === c.unit) ? null : c;\n\t        return c || L(a)\n\t    }\n\t    ;\n\t    this.parseFoLineHeight = function(a) {\n\t        return K(a) || L(a)\n\t    }\n\t    ;\n\t    this.isTextContentContainingNode = E;\n\t    this.getTextNodes = function(a, c) {\n\t        var b;\n\t        b = aa.getNodesInRange(a, function(a) {\n\t            var c = NodeFilter.FILTER_REJECT;\n\t            a.nodeType === Node.TEXT_NODE ? N(a) && (c = NodeFilter.FILTER_ACCEPT) : E(a) && (c = NodeFilter.FILTER_SKIP);\n\t            return c\n\t        }, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT);\n\t        c || O(a, b);\n\t        return b\n\t    }\n\t    ;\n\t    this.getTextElements = D;\n\t    this.getParagraphElements = function(a) {\n\t        var c;\n\t        c = aa.getNodesInRange(a, function(a) {\n\t            var c = NodeFilter.FILTER_REJECT;\n\t            if (f(a))\n\t                c = NodeFilter.FILTER_ACCEPT;\n\t            else if (E(a) || q(a))\n\t                c = NodeFilter.FILTER_SKIP;\n\t            return c\n\t        }, NodeFilter.SHOW_ELEMENT);\n\t        V(a.startContainer, c, f);\n\t        return c\n\t    }\n\t    ;\n\t    this.getImageElements = function(a) {\n\t        var c;\n\t        c = aa.getNodesInRange(a, function(a) {\n\t            var c = NodeFilter.FILTER_SKIP;\n\t            g(a) && (c = NodeFilter.FILTER_ACCEPT);\n\t            return c\n\t        }, NodeFilter.SHOW_ELEMENT);\n\t        V(a.startContainer, c, g);\n\t        return c\n\t    }\n\t    ;\n\t    this.getHyperlinkElements = function(a) {\n\t        var c = []\n\t          , d = a.cloneRange();\n\t        a.collapsed && a.endContainer.nodeType === Node.ELEMENT_NODE && (a = W(a.endContainer, a.endOffset),\n\t        a.nodeType === Node.TEXT_NODE && d.setEnd(a, 1));\n\t        D(d, !0, !1).forEach(function(a) {\n\t            for (a = a.parentNode; !f(a); ) {\n\t                if (b(a) && -1 === c.indexOf(a)) {\n\t                    c.push(a);\n\t                    break\n\t                }\n\t                a = a.parentNode\n\t            }\n\t        });\n\t        d.detach();\n\t        return c\n\t    }\n\t    ;\n\t    this.getNormalizedFontFamilyName = function(a) {\n\t        /^([\"'])(?:.|[\\n\\r])*?\\1$/.test(a) || (a = a.replace(/^[ \\t\\r\\n\\f]*((?:.|[\\n\\r])*?)[ \\t\\r\\n\\f]*$/, \"$1\"),\n\t        /[ \\t\\r\\n\\f]/.test(a) && (a = \"'\" + a.replace(/[ \\t\\r\\n\\f]+/g, \" \") + \"'\"));\n\t        return a\n\t    }\n\t}\n\t;\n\todf.OdfUtils = new odf.OdfUtilsImpl;\n\tgui.OdfTextBodyNodeFilter = function() {\n\t    var g = odf.OdfUtils\n\t      , k = Node.TEXT_NODE\n\t      , d = NodeFilter.FILTER_REJECT\n\t      , b = NodeFilter.FILTER_ACCEPT\n\t      , f = odf.Namespaces.textns;\n\t    this.acceptNode = function(n) {\n\t        if (n.nodeType === k) {\n\t            if (!g.isGroupingElement(n.parentNode))\n\t                return d\n\t        } else if (n.namespaceURI === f && \"tracked-changes\" === n.localName)\n\t            return d;\n\t        return b\n\t    }\n\t}\n\t;\n\txmldom.LSSerializerFilter = function() {}\n\t;\n\txmldom.LSSerializerFilter.prototype.acceptNode = function(g) {}\n\t;\n\todf.OdfNodeFilter = function() {\n\t    this.acceptNode = function(g) {\n\t        return \"http://www.w3.org/1999/xhtml\" === g.namespaceURI ? NodeFilter.FILTER_SKIP : g.namespaceURI && g.namespaceURI.match(/^urn:webodf:/) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT\n\t    }\n\t}\n\t;\n\txmldom.XPathIterator = function() {}\n\t;\n\txmldom.XPathIterator.prototype.next = function() {}\n\t;\n\txmldom.XPathIterator.prototype.reset = function() {}\n\t;\n\tfunction createXPathSingleton() {\n\t    function g(b, a, c) {\n\t        return -1 !== b && (b < a || -1 === a) && (b < c || -1 === c)\n\t    }\n\t    function k(b) {\n\t        for (var a = [], c = 0, d = b.length, h; c < d; ) {\n\t            var f = b\n\t              , n = d\n\t              , k = a\n\t              , r = \"\"\n\t              , p = []\n\t              , q = f.indexOf(\"[\", c)\n\t              , t = f.indexOf(\"/\", c)\n\t              , A = f.indexOf(\"=\", c);\n\t            g(t, q, A) ? (r = f.substring(c, t),\n\t            c = t + 1) : g(q, t, A) ? (r = f.substring(c, q),\n\t            c = e(f, q, p)) : g(A, t, q) ? (r = f.substring(c, A),\n\t            c = A) : (r = f.substring(c, n),\n\t            c = n);\n\t            k.push({\n\t                location: r,\n\t                predicates: p\n\t            });\n\t            if (c < d && \"=\" === b[c]) {\n\t                h = b.substring(c + 1, d);\n\t                if (2 < h.length && (\"'\" === h[0] || '\"' === h[0]))\n\t                    h = h.slice(1, h.length - 1);\n\t                else\n\t                    try {\n\t                        h = parseInt(h, 10)\n\t                    } catch (I) {}\n\t                c = d\n\t            }\n\t        }\n\t        return {\n\t            steps: a,\n\t            value: h\n\t        }\n\t    }\n\t    function d() {\n\t        var b = null\n\t          , a = !1;\n\t        this.setNode = function(a) {\n\t            b = a\n\t        }\n\t        ;\n\t        this.reset = function() {\n\t            a = !1\n\t        }\n\t        ;\n\t        this.next = function() {\n\t            var c = a ? null : b;\n\t            a = !0;\n\t            return c\n\t        }\n\t    }\n\t    function b(b, a, c) {\n\t        this.reset = function() {\n\t            b.reset()\n\t        }\n\t        ;\n\t        this.next = function() {\n\t            for (var d = b.next(); d; ) {\n\t                d.nodeType === Node.ELEMENT_NODE && (d = d.getAttributeNodeNS(a, c));\n\t                if (d)\n\t                    break;\n\t                d = b.next()\n\t            }\n\t            return d\n\t        }\n\t    }\n\t    function f(b, a) {\n\t        var c = b.next()\n\t          , d = null;\n\t        this.reset = function() {\n\t            b.reset();\n\t            c = b.next();\n\t            d = null\n\t        }\n\t        ;\n\t        this.next = function() {\n\t            for (; c; ) {\n\t                if (d)\n\t                    if (a && d.firstChild)\n\t                        d = d.firstChild;\n\t                    else {\n\t                        for (; !d.nextSibling && d !== c; )\n\t                            d = d.parentNode;\n\t                        d === c ? c = b.next() : d = d.nextSibling\n\t                    }\n\t                else {\n\t                    do\n\t                        (d = c.firstChild) || (c = b.next());\n\t                    while (c && !d)\n\t                }\n\t                if (d && d.nodeType === Node.ELEMENT_NODE)\n\t                    return d\n\t            }\n\t            return null\n\t        }\n\t    }\n\t    function n(b, a) {\n\t        this.reset = function() {\n\t            b.reset()\n\t        }\n\t        ;\n\t        this.next = function() {\n\t            for (var c = b.next(); c && !a(c); )\n\t                c = b.next();\n\t            return c\n\t        }\n\t    }\n\t    function p(b, a, c) {\n\t        a = a.split(\":\", 2);\n\t        var d = c(a[0])\n\t          , h = a[1];\n\t        return new n(b,function(a) {\n\t            return a.localName === h && a.namespaceURI === d\n\t        }\n\t        )\n\t    }\n\t    function r(b, a, c) {\n\t        var m = new d\n\t          , h = q(m, a, c)\n\t          , e = a.value;\n\t        return void 0 === e ? new n(b,function(a) {\n\t            m.setNode(a);\n\t            h.reset();\n\t            return null !== h.next()\n\t        }\n\t        ) : new n(b,function(a) {\n\t            m.setNode(a);\n\t            h.reset();\n\t            return (a = h.next()) ? a.nodeValue === e : !1\n\t        }\n\t        )\n\t    }\n\t    var q, e;\n\t    e = function(b, a, c) {\n\t        for (var d = a, h = b.length, e = 0; d < h; )\n\t            \"]\" === b[d] ? (--e,\n\t            0 >= e && c.push(k(b.substring(a, d)))) : \"[\" === b[d] && (0 >= e && (a = d + 1),\n\t            e += 1),\n\t            d += 1;\n\t        return d\n\t    }\n\t    ;\n\t    q = function(d, a, c) {\n\t        var m, h, e, n;\n\t        for (m = 0; m < a.steps.length; m += 1) {\n\t            e = a.steps[m];\n\t            h = e.location;\n\t            if (\"\" === h)\n\t                d = new f(d,!1);\n\t            else if (\"@\" === h[0]) {\n\t                h = h.substr(1).split(\":\", 2);\n\t                n = c(h[0]);\n\t                if (!n)\n\t                    throw \"No namespace associated with the prefix \" + h[0];\n\t                d = new b(d,n,h[1])\n\t            } else\n\t                \".\" !== h && (d = new f(d,!1),\n\t                -1 !== h.indexOf(\":\") && (d = p(d, h, c)));\n\t            for (h = 0; h < e.predicates.length; h += 1)\n\t                n = e.predicates[h],\n\t                d = r(d, n, c)\n\t        }\n\t        return d\n\t    }\n\t    ;\n\t    return {\n\t        getODFElementsWithXPath: function(b, a, c) {\n\t            var m = b.ownerDocument\n\t              , h = []\n\t              , e = null;\n\t            if (m && \"function\" === typeof m.evaluate)\n\t                for (c = m.evaluate(a, b, c, XPathResult.UNORDERED_NODE_ITERATOR_TYPE, null),\n\t                e = c.iterateNext(); null !== e; )\n\t                    e.nodeType === Node.ELEMENT_NODE && h.push(e),\n\t                    e = c.iterateNext();\n\t            else {\n\t                h = new d;\n\t                h.setNode(b);\n\t                b = k(a);\n\t                h = q(h, b, c);\n\t                b = [];\n\t                for (c = h.next(); c; )\n\t                    b.push(c),\n\t                    c = h.next();\n\t                h = b\n\t            }\n\t            return h\n\t        }\n\t    }\n\t}\n\txmldom.XPath = createXPathSingleton();\n\todf.StyleInfo = function() {\n\t    function g(a, c) {\n\t        var b, d, h, m, e, l = 0;\n\t        if (b = K[a.localName])\n\t            if (h = b[a.namespaceURI])\n\t                l = h.length;\n\t        for (b = 0; b < l; b += 1)\n\t            d = h[b],\n\t            m = d.ns,\n\t            e = d.localname,\n\t            (d = a.getAttributeNS(m, e)) && a.setAttributeNS(m, A[m] + e, c + d);\n\t        for (h = a.firstElementChild; h; )\n\t            g(h, c),\n\t            h = h.nextElementSibling\n\t    }\n\t    function k(a, c) {\n\t        var b, d, h, m, e, l = 0;\n\t        if (b = K[a.localName])\n\t            if (h = b[a.namespaceURI])\n\t                l = h.length;\n\t        for (b = 0; b < l; b += 1)\n\t            if (d = h[b],\n\t            m = d.ns,\n\t            e = d.localname,\n\t            d = a.getAttributeNS(m, e))\n\t                d = d.replace(c, \"\"),\n\t                a.setAttributeNS(m, A[m] + e, d);\n\t        for (h = a.firstElementChild; h; )\n\t            k(h, c),\n\t            h = h.nextElementSibling\n\t    }\n\t    function d(a, c) {\n\t        var b, d, h, m, e, l = 0;\n\t        if (b = K[a.localName])\n\t            if (h = b[a.namespaceURI])\n\t                l = h.length;\n\t        for (b = 0; b < l; b += 1)\n\t            if (m = h[b],\n\t            d = m.ns,\n\t            e = m.localname,\n\t            d = a.getAttributeNS(d, e))\n\t                c = c || {},\n\t                m = m.keyname,\n\t                c.hasOwnProperty(m) ? c[m][d] = 1 : (e = {},\n\t                e[d] = 1,\n\t                c[m] = e);\n\t        return c\n\t    }\n\t    function b(a, c) {\n\t        var h, m;\n\t        d(a, c);\n\t        for (h = a.firstChild; h; )\n\t            h.nodeType === Node.ELEMENT_NODE && (m = h,\n\t            b(m, c)),\n\t            h = h.nextSibling\n\t    }\n\t    function f(a, c, b) {\n\t        this.key = a;\n\t        this.name = c;\n\t        this.family = b;\n\t        this.requires = {}\n\t    }\n\t    function n(a, c, b) {\n\t        var d = a + '\"' + c\n\t          , h = b[d];\n\t        h || (h = b[d] = new f(d,a,c));\n\t        return h\n\t    }\n\t    function p(a, c, b) {\n\t        var d, h, m, e, l, f = 0;\n\t        d = a.getAttributeNS(v, \"name\");\n\t        e = a.getAttributeNS(v, \"family\");\n\t        d && e && (c = n(d, e, b));\n\t        if (c) {\n\t            if (d = K[a.localName])\n\t                if (m = d[a.namespaceURI])\n\t                    f = m.length;\n\t            for (d = 0; d < f; d += 1)\n\t                if (e = m[d],\n\t                h = e.ns,\n\t                l = e.localname,\n\t                h = a.getAttributeNS(h, l))\n\t                    e = e.keyname,\n\t                    e = n(h, e, b),\n\t                    c.requires[e.key] = e\n\t        }\n\t        for (a = a.firstElementChild; a; )\n\t            p(a, c, b),\n\t            a = a.nextElementSibling;\n\t        return b\n\t    }\n\t    function r(a, c) {\n\t        var b = c[a.family];\n\t        b || (b = c[a.family] = {});\n\t        b[a.name] = 1;\n\t        Object.keys(a.requires).forEach(function(b) {\n\t            r(a.requires[b], c)\n\t        })\n\t    }\n\t    function q(a, c) {\n\t        var b = p(a, null, {});\n\t        Object.keys(b).forEach(function(a) {\n\t            a = b[a];\n\t            var d = c[a.family];\n\t            d && d.hasOwnProperty(a.name) && r(a, c)\n\t        })\n\t    }\n\t    function e(a, c) {\n\t        function b(c) {\n\t            (c = m.getAttributeNS(v, c)) && (a[c] = !0)\n\t        }\n\t        var d = [\"font-name\", \"font-name-asian\", \"font-name-complex\"], h, m;\n\t        for (h = c && c.firstElementChild; h; )\n\t            m = h,\n\t            d.forEach(b),\n\t            e(a, m),\n\t            h = h.nextElementSibling\n\t    }\n\t    function l(a, c) {\n\t        function b(a) {\n\t            var d = m.getAttributeNS(v, a);\n\t            d && c.hasOwnProperty(d) && m.setAttributeNS(v, \"style:\" + a, c[d])\n\t        }\n\t        var d = [\"font-name\", \"font-name-asian\", \"font-name-complex\"], h, m;\n\t        for (h = a && a.firstElementChild; h; )\n\t            m = h,\n\t            d.forEach(b),\n\t            l(m, c),\n\t            h = h.nextElementSibling\n\t    }\n\t    var a = odf.Namespaces.chartns, c = odf.Namespaces.dbns, m = odf.Namespaces.dr3dns, h = odf.Namespaces.drawns, y = odf.Namespaces.formns, x = odf.Namespaces.numberns, z = odf.Namespaces.officens, w = odf.Namespaces.presentationns, v = odf.Namespaces.stylens, u = odf.Namespaces.tablens, t = odf.Namespaces.textns, A = {\n\t        \"urn:oasis:names:tc:opendocument:xmlns:chart:1.0\": \"chart:\",\n\t        \"urn:oasis:names:tc:opendocument:xmlns:database:1.0\": \"db:\",\n\t        \"urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0\": \"dr3d:\",\n\t        \"urn:oasis:names:tc:opendocument:xmlns:drawing:1.0\": \"draw:\",\n\t        \"urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0\": \"fo:\",\n\t        \"urn:oasis:names:tc:opendocument:xmlns:form:1.0\": \"form:\",\n\t        \"urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0\": \"number:\",\n\t        \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\": \"office:\",\n\t        \"urn:oasis:names:tc:opendocument:xmlns:presentation:1.0\": \"presentation:\",\n\t        \"urn:oasis:names:tc:opendocument:xmlns:style:1.0\": \"style:\",\n\t        \"urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0\": \"svg:\",\n\t        \"urn:oasis:names:tc:opendocument:xmlns:table:1.0\": \"table:\",\n\t        \"urn:oasis:names:tc:opendocument:xmlns:text:1.0\": \"chart:\",\n\t        \"http://www.w3.org/XML/1998/namespace\": \"xml:\"\n\t    }, I = {\n\t        text: [{\n\t            ens: v,\n\t            en: \"tab-stop\",\n\t            ans: v,\n\t            a: \"leader-text-style\"\n\t        }, {\n\t            ens: v,\n\t            en: \"drop-cap\",\n\t            ans: v,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"notes-configuration\",\n\t            ans: t,\n\t            a: \"citation-body-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"notes-configuration\",\n\t            ans: t,\n\t            a: \"citation-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"a\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"alphabetical-index\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"linenumbering-configuration\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"list-level-style-number\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"ruby-text\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"span\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"a\",\n\t            ans: t,\n\t            a: \"visited-style-name\"\n\t        }, {\n\t            ens: v,\n\t            en: \"text-properties\",\n\t            ans: v,\n\t            a: \"text-line-through-text-style\"\n\t        }, {\n\t            ens: t,\n\t            en: \"alphabetical-index-source\",\n\t            ans: t,\n\t            a: \"main-entry-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"index-entry-bibliography\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"index-entry-chapter\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"index-entry-link-end\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"index-entry-link-start\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"index-entry-page-number\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"index-entry-span\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"index-entry-tab-stop\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"index-entry-text\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"index-title-template\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"list-level-style-bullet\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"outline-level-style\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }],\n\t        paragraph: [{\n\t            ens: h,\n\t            en: \"caption\",\n\t            ans: h,\n\t            a: \"text-style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"circle\",\n\t            ans: h,\n\t            a: \"text-style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"connector\",\n\t            ans: h,\n\t            a: \"text-style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"control\",\n\t            ans: h,\n\t            a: \"text-style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"custom-shape\",\n\t            ans: h,\n\t            a: \"text-style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"ellipse\",\n\t            ans: h,\n\t            a: \"text-style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"frame\",\n\t            ans: h,\n\t            a: \"text-style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"line\",\n\t            ans: h,\n\t            a: \"text-style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"measure\",\n\t            ans: h,\n\t            a: \"text-style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"path\",\n\t            ans: h,\n\t            a: \"text-style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"polygon\",\n\t            ans: h,\n\t            a: \"text-style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"polyline\",\n\t            ans: h,\n\t            a: \"text-style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"rect\",\n\t            ans: h,\n\t            a: \"text-style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"regular-polygon\",\n\t            ans: h,\n\t            a: \"text-style-name\"\n\t        }, {\n\t            ens: z,\n\t            en: \"annotation\",\n\t            ans: h,\n\t            a: \"text-style-name\"\n\t        }, {\n\t            ens: y,\n\t            en: \"column\",\n\t            ans: y,\n\t            a: \"text-style-name\"\n\t        }, {\n\t            ens: v,\n\t            en: \"style\",\n\t            ans: v,\n\t            a: \"next-style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"body\",\n\t            ans: u,\n\t            a: \"paragraph-style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"even-columns\",\n\t            ans: u,\n\t            a: \"paragraph-style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"even-rows\",\n\t            ans: u,\n\t            a: \"paragraph-style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"first-column\",\n\t            ans: u,\n\t            a: \"paragraph-style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"first-row\",\n\t            ans: u,\n\t            a: \"paragraph-style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"last-column\",\n\t            ans: u,\n\t            a: \"paragraph-style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"last-row\",\n\t            ans: u,\n\t            a: \"paragraph-style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"odd-columns\",\n\t            ans: u,\n\t            a: \"paragraph-style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"odd-rows\",\n\t            ans: u,\n\t            a: \"paragraph-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"notes-configuration\",\n\t            ans: t,\n\t            a: \"default-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"alphabetical-index-entry-template\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"bibliography-entry-template\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"h\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"illustration-index-entry-template\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"index-source-style\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"object-index-entry-template\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"p\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"table-index-entry-template\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"table-of-content-entry-template\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"table-index-entry-template\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"user-index-entry-template\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: v,\n\t            en: \"page-layout-properties\",\n\t            ans: v,\n\t            a: \"register-truth-ref-style-name\"\n\t        }],\n\t        chart: [{\n\t            ens: a,\n\t            en: \"axis\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: a,\n\t            en: \"chart\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: a,\n\t            en: \"data-label\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: a,\n\t            en: \"data-point\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: a,\n\t            en: \"equation\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: a,\n\t            en: \"error-indicator\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: a,\n\t            en: \"floor\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: a,\n\t            en: \"footer\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: a,\n\t            en: \"grid\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: a,\n\t            en: \"legend\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: a,\n\t            en: \"mean-value\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: a,\n\t            en: \"plot-area\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: a,\n\t            en: \"regression-curve\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: a,\n\t            en: \"series\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: a,\n\t            en: \"stock-gain-marker\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: a,\n\t            en: \"stock-loss-marker\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: a,\n\t            en: \"stock-range-line\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: a,\n\t            en: \"subtitle\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: a,\n\t            en: \"title\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: a,\n\t            en: \"wall\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }],\n\t        section: [{\n\t            ens: t,\n\t            en: \"alphabetical-index\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"bibliography\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"illustration-index\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"index-title\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"object-index\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"section\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"table-of-content\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"table-index\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"user-index\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }],\n\t        ruby: [{\n\t            ens: t,\n\t            en: \"ruby\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }],\n\t        table: [{\n\t            ens: c,\n\t            en: \"query\",\n\t            ans: c,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: c,\n\t            en: \"table-representation\",\n\t            ans: c,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"background\",\n\t            ans: u,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"table\",\n\t            ans: u,\n\t            a: \"style-name\"\n\t        }],\n\t        \"table-column\": [{\n\t            ens: c,\n\t            en: \"column\",\n\t            ans: c,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"table-column\",\n\t            ans: u,\n\t            a: \"style-name\"\n\t        }],\n\t        \"table-row\": [{\n\t            ens: c,\n\t            en: \"query\",\n\t            ans: c,\n\t            a: \"default-row-style-name\"\n\t        }, {\n\t            ens: c,\n\t            en: \"table-representation\",\n\t            ans: c,\n\t            a: \"default-row-style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"table-row\",\n\t            ans: u,\n\t            a: \"style-name\"\n\t        }],\n\t        \"table-cell\": [{\n\t            ens: c,\n\t            en: \"column\",\n\t            ans: c,\n\t            a: \"default-cell-style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"table-column\",\n\t            ans: u,\n\t            a: \"default-cell-style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"table-row\",\n\t            ans: u,\n\t            a: \"default-cell-style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"body\",\n\t            ans: u,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"covered-table-cell\",\n\t            ans: u,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"even-columns\",\n\t            ans: u,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"covered-table-cell\",\n\t            ans: u,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"even-columns\",\n\t            ans: u,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"even-rows\",\n\t            ans: u,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"first-column\",\n\t            ans: u,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"first-row\",\n\t            ans: u,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"last-column\",\n\t            ans: u,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"last-row\",\n\t            ans: u,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"odd-columns\",\n\t            ans: u,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"odd-rows\",\n\t            ans: u,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"table-cell\",\n\t            ans: u,\n\t            a: \"style-name\"\n\t        }],\n\t        graphic: [{\n\t            ens: m,\n\t            en: \"cube\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: m,\n\t            en: \"extrude\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: m,\n\t            en: \"rotate\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: m,\n\t            en: \"scene\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: m,\n\t            en: \"sphere\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"caption\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"circle\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"connector\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"control\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"custom-shape\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"ellipse\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"frame\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"g\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"line\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"measure\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"page-thumbnail\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"path\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"polygon\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"polyline\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"rect\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"regular-polygon\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: z,\n\t            en: \"annotation\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }],\n\t        presentation: [{\n\t            ens: m,\n\t            en: \"cube\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: m,\n\t            en: \"extrude\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: m,\n\t            en: \"rotate\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: m,\n\t            en: \"scene\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: m,\n\t            en: \"sphere\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"caption\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"circle\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"connector\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"control\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"custom-shape\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"ellipse\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"frame\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"g\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"line\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"measure\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"page-thumbnail\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"path\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"polygon\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"polyline\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"rect\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"regular-polygon\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: z,\n\t            en: \"annotation\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }],\n\t        \"drawing-page\": [{\n\t            ens: h,\n\t            en: \"page\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: w,\n\t            en: \"notes\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: v,\n\t            en: \"handout-master\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: v,\n\t            en: \"master-page\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }],\n\t        \"list-style\": [{\n\t            ens: t,\n\t            en: \"list\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"numbered-paragraph\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"list-item\",\n\t            ans: t,\n\t            a: \"style-override\"\n\t        }, {\n\t            ens: v,\n\t            en: \"style\",\n\t            ans: v,\n\t            a: \"list-style-name\"\n\t        }],\n\t        data: [{\n\t            ens: v,\n\t            en: \"style\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: v,\n\t            en: \"style\",\n\t            ans: v,\n\t            a: \"percentage-data-style-name\"\n\t        }, {\n\t            ens: w,\n\t            en: \"date-time-decl\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"creation-date\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"creation-time\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"database-display\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"date\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"editing-duration\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"expression\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"meta-field\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"modification-date\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"modification-time\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"print-date\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"print-time\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"table-formula\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"time\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"user-defined\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"user-field-get\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"user-field-input\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"variable-get\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"variable-input\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"variable-set\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }],\n\t        \"page-layout\": [{\n\t            ens: w,\n\t            en: \"notes\",\n\t            ans: v,\n\t            a: \"page-layout-name\"\n\t        }, {\n\t            ens: v,\n\t            en: \"handout-master\",\n\t            ans: v,\n\t            a: \"page-layout-name\"\n\t        }, {\n\t            ens: v,\n\t            en: \"master-page\",\n\t            ans: v,\n\t            a: \"page-layout-name\"\n\t        }]\n\t    }, K, L = xmldom.XPath;\n\t    this.collectUsedFontFaces = e;\n\t    this.changeFontFaceNames = l;\n\t    this.UsedStyleList = function(a, c) {\n\t        var d = {};\n\t        this.uses = function(a) {\n\t            var c = a.localName\n\t              , b = a.getAttributeNS(h, \"name\") || a.getAttributeNS(v, \"name\");\n\t            a = \"style\" === c ? a.getAttributeNS(v, \"family\") : a.namespaceURI === x ? \"data\" : c;\n\t            return (a = d[a]) ? 0 < a[b] : !1\n\t        }\n\t        ;\n\t        b(a, d);\n\t        c && q(c, d)\n\t    }\n\t    ;\n\t    this.getStyleName = function(a, c) {\n\t        var b, d, h = K[c.localName];\n\t        if (h && (h = h[c.namespaceURI]))\n\t            for (d = 0; d < h.length; d += 1)\n\t                if (h[d].keyname === a && (h = h[d],\n\t                c.hasAttributeNS(h.ns, h.localname))) {\n\t                    b = c.getAttributeNS(h.ns, h.localname);\n\t                    break\n\t                }\n\t        return b\n\t    }\n\t    ;\n\t    this.hasDerivedStyles = function(a, c, b) {\n\t        var d = b.getAttributeNS(v, \"name\");\n\t        b = b.getAttributeNS(v, \"family\");\n\t        return L.getODFElementsWithXPath(a, '//style:*[@style:parent-style-name=\"' + d + '\"][@style:family=\"' + b + '\"]', c).length ? !0 : !1\n\t    }\n\t    ;\n\t    this.prefixStyleNames = function(a, c, b) {\n\t        var d;\n\t        if (a) {\n\t            for (d = a.firstChild; d; ) {\n\t                if (d.nodeType === Node.ELEMENT_NODE) {\n\t                    var m = d\n\t                      , e = c\n\t                      , l = m.getAttributeNS(h, \"name\")\n\t                      , f = void 0;\n\t                    l ? f = h : (l = m.getAttributeNS(v, \"name\")) && (f = v);\n\t                    f && m.setAttributeNS(f, A[f] + \"name\", e + l)\n\t                }\n\t                d = d.nextSibling\n\t            }\n\t            g(a, c);\n\t            b && g(b, c)\n\t        }\n\t    }\n\t    ;\n\t    this.removePrefixFromStyleNames = function(a, c, b) {\n\t        var d = new RegExp(\"^\" + c);\n\t        if (a) {\n\t            for (c = a.firstChild; c; ) {\n\t                if (c.nodeType === Node.ELEMENT_NODE) {\n\t                    var m = c\n\t                      , e = d\n\t                      , l = m.getAttributeNS(h, \"name\")\n\t                      , f = void 0;\n\t                    l ? f = h : (l = m.getAttributeNS(v, \"name\")) && (f = v);\n\t                    f && (l = l.replace(e, \"\"),\n\t                    m.setAttributeNS(f, A[f] + \"name\", l))\n\t                }\n\t                c = c.nextSibling\n\t            }\n\t            k(a, d);\n\t            b && k(b, d)\n\t        }\n\t    }\n\t    ;\n\t    this.determineStylesForNode = d;\n\t    K = function() {\n\t        var a, c, b, d, h, m = {}, e, l, f, n;\n\t        for (b in I)\n\t            if (I.hasOwnProperty(b))\n\t                for (d = I[b],\n\t                c = d.length,\n\t                a = 0; a < c; a += 1)\n\t                    h = d[a],\n\t                    f = h.en,\n\t                    n = h.ens,\n\t                    m.hasOwnProperty(f) ? e = m[f] : m[f] = e = {},\n\t                    e.hasOwnProperty(n) ? l = e[n] : e[n] = l = [],\n\t                    l.push({\n\t                        ns: h.ans,\n\t                        localname: h.a,\n\t                        keyname: b\n\t                    });\n\t        return m\n\t    }()\n\t}\n\t;\n\t\"function\" !== typeof Object.create && (Object.create = function(g) {\n\t    var k = function() {};\n\t    k.prototype = g;\n\t    return new k\n\t}\n\t);\n\txmldom.LSSerializer = function() {\n\t    function g(b) {\n\t        var d = b || {}\n\t          , g = function(b) {\n\t            var a = {}, c;\n\t            for (c in b)\n\t                b.hasOwnProperty(c) && (a[b[c]] = c);\n\t            return a\n\t        }(b)\n\t          , k = [d]\n\t          , q = [g]\n\t          , e = 0;\n\t        this.push = function() {\n\t            e += 1;\n\t            d = k[e] = Object.create(d);\n\t            g = q[e] = Object.create(g)\n\t        }\n\t        ;\n\t        this.pop = function() {\n\t            k.pop();\n\t            q.pop();\n\t            --e;\n\t            d = k[e];\n\t            g = q[e]\n\t        }\n\t        ;\n\t        this.getLocalNamespaceDefinitions = function() {\n\t            return g\n\t        }\n\t        ;\n\t        this.getQName = function(b) {\n\t            var a = b.namespaceURI, c = 0, m;\n\t            if (!a)\n\t                return b.localName;\n\t            if (m = g[a])\n\t                return m + \":\" + b.localName;\n\t            do {\n\t                m || !b.prefix ? (m = \"ns\" + c,\n\t                c += 1) : m = b.prefix;\n\t                if (d[m] === a)\n\t                    break;\n\t                if (!d[m]) {\n\t                    d[m] = a;\n\t                    g[a] = m;\n\t                    break\n\t                }\n\t                m = null\n\t            } while (null === m);\n\t            return m + \":\" + b.localName\n\t        }\n\t    }\n\t    function k(b) {\n\t        return b.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/'/g, \"&apos;\").replace(/\"/g, \"&quot;\")\n\t    }\n\t    function d(f, n) {\n\t        var g = \"\", r = b.filter ? b.filter.acceptNode(n) : NodeFilter.FILTER_ACCEPT, q;\n\t        if (r === NodeFilter.FILTER_ACCEPT && n.nodeType === Node.ELEMENT_NODE) {\n\t            f.push();\n\t            q = f.getQName(n);\n\t            var e, l = n.attributes, a, c, m, h = \"\", y;\n\t            e = \"<\" + q;\n\t            a = l.length;\n\t            for (c = 0; c < a; c += 1)\n\t                m = l.item(c),\n\t                \"http://www.w3.org/2000/xmlns/\" !== m.namespaceURI && (y = b.filter ? b.filter.acceptNode(m) : NodeFilter.FILTER_ACCEPT,\n\t                y === NodeFilter.FILTER_ACCEPT && (y = f.getQName(m),\n\t                m = \"string\" === typeof m.value ? k(m.value) : m.value,\n\t                h += \" \" + (y + '=\"' + m + '\"')));\n\t            a = f.getLocalNamespaceDefinitions();\n\t            for (c in a)\n\t                a.hasOwnProperty(c) && ((l = a[c]) ? \"xmlns\" !== l && (e += \" xmlns:\" + a[c] + '=\"' + c + '\"') : e += ' xmlns=\"' + c + '\"');\n\t            g += e + (h + \">\")\n\t        }\n\t        if (r === NodeFilter.FILTER_ACCEPT || r === NodeFilter.FILTER_SKIP) {\n\t            for (r = n.firstChild; r; )\n\t                g += d(f, r),\n\t                r = r.nextSibling;\n\t            n.nodeValue && (g += k(n.nodeValue))\n\t        }\n\t        q && (g += \"</\" + q + \">\",\n\t        f.pop());\n\t        return g\n\t    }\n\t    var b = this;\n\t    this.filter = null;\n\t    this.writeToString = function(b, n) {\n\t        if (!b)\n\t            return \"\";\n\t        var k = new g(n);\n\t        return d(k, b)\n\t    }\n\t}\n\t;\n\t(function() {\n\t    function g(b) {\n\t        var a, c = r.length;\n\t        for (a = 0; a < c; a += 1)\n\t            if (\"urn:oasis:names:tc:opendocument:xmlns:office:1.0\" === b.namespaceURI && b.localName === r[a])\n\t                return a;\n\t        return -1\n\t    }\n\t    function k(b, a) {\n\t        var c = new f.UsedStyleList(b,a)\n\t          , d = new odf.OdfNodeFilter;\n\t        this.acceptNode = function(b) {\n\t            var e = d.acceptNode(b);\n\t            e === NodeFilter.FILTER_ACCEPT && b.parentNode === a && b.nodeType === Node.ELEMENT_NODE && (e = c.uses(b) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT);\n\t            return e\n\t        }\n\t    }\n\t    function d(b, a) {\n\t        var c = new k(b,a);\n\t        this.acceptNode = function(a) {\n\t            var b = c.acceptNode(a);\n\t            b !== NodeFilter.FILTER_ACCEPT || !a.parentNode || a.parentNode.namespaceURI !== odf.Namespaces.textns || \"s\" !== a.parentNode.localName && \"tab\" !== a.parentNode.localName || (b = NodeFilter.FILTER_REJECT);\n\t            return b\n\t        }\n\t    }\n\t    function b(b, a) {\n\t        if (a) {\n\t            var c = g(a), d, h = b.firstChild;\n\t            if (-1 !== c) {\n\t                for (; h; ) {\n\t                    d = g(h);\n\t                    if (-1 !== d && d > c)\n\t                        break;\n\t                    h = h.nextSibling\n\t                }\n\t                b.insertBefore(a, h)\n\t            }\n\t        }\n\t    }\n\t    var f = new odf.StyleInfo\n\t      , n = core.DomUtils\n\t      , p = odf.Namespaces.stylens\n\t      , r = \"meta settings scripts font-face-decls styles automatic-styles master-styles body\".split(\" \")\n\t      , q = Date.now() + \"_webodf_\"\n\t      , e = new core.Base64;\n\t    odf.ODFElement = function() {}\n\t    ;\n\t    odf.ODFDocumentElement = function() {}\n\t    ;\n\t    odf.ODFDocumentElement.prototype = new odf.ODFElement;\n\t    odf.ODFDocumentElement.prototype.constructor = odf.ODFDocumentElement;\n\t    odf.ODFDocumentElement.prototype.fontFaceDecls = null;\n\t    odf.ODFDocumentElement.prototype.manifest = null;\n\t    odf.ODFDocumentElement.prototype.settings = null;\n\t    odf.ODFDocumentElement.namespaceURI = \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\";\n\t    odf.ODFDocumentElement.localName = \"document\";\n\t    odf.AnnotationElement = function() {}\n\t    ;\n\t    odf.OdfPart = function(b, a, c, d) {\n\t        var h = this;\n\t        this.size = 0;\n\t        this.type = null;\n\t        this.name = b;\n\t        this.container = c;\n\t        this.url = null;\n\t        this.mimetype = a;\n\t        this.onstatereadychange = this.document = null;\n\t        this.EMPTY = 0;\n\t        this.LOADING = 1;\n\t        this.DONE = 2;\n\t        this.state = this.EMPTY;\n\t        this.data = \"\";\n\t        this.load = function() {\n\t            null !== d && (this.mimetype = a,\n\t            d.loadAsDataURL(b, a, function(a, c) {\n\t                a && runtime.log(a);\n\t                h.url = c;\n\t                if (h.onchange)\n\t                    h.onchange(h);\n\t                if (h.onstatereadychange)\n\t                    h.onstatereadychange(h)\n\t            }))\n\t        }\n\t    }\n\t    ;\n\t    odf.OdfPart.prototype.load = function() {}\n\t    ;\n\t    odf.OdfPart.prototype.getUrl = function() {\n\t        return this.data ? \"data:;base64,\" + e.toBase64(this.data) : null\n\t    }\n\t    ;\n\t    odf.OdfContainer = function a(c, m) {\n\t        function h(a) {\n\t            for (var c = a.firstChild, b; c; )\n\t                b = c.nextSibling,\n\t                c.nodeType === Node.ELEMENT_NODE ? h(c) : c.nodeType === Node.PROCESSING_INSTRUCTION_NODE && a.removeChild(c),\n\t                c = b\n\t        }\n\t        function g(a) {\n\t            var c = {}, b, d, h = a.ownerDocument.createNodeIterator(a, NodeFilter.SHOW_ELEMENT, null, !1);\n\t            for (a = h.nextNode(); a; )\n\t                \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\" === a.namespaceURI && (\"annotation\" === a.localName ? (b = a.getAttributeNS(\"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"name\")) && (c.hasOwnProperty(b) ? runtime.log(\"Warning: annotation name used more than once with <office:annotation/>: '\" + b + \"'\") : c[b] = a) : \"annotation-end\" === a.localName && ((b = a.getAttributeNS(\"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"name\")) ? c.hasOwnProperty(b) ? (d = c[b],\n\t                d.annotationEndElement ? runtime.log(\"Warning: annotation name used more than once with <office:annotation-end/>: '\" + b + \"'\") : d.annotationEndElement = a) : runtime.log(\"Warning: annotation end without an annotation start, name: '\" + b + \"'\") : runtime.log(\"Warning: annotation end without a name found\"))),\n\t                a = h.nextNode()\n\t        }\n\t        function r(a, c) {\n\t            for (var b = a && a.firstChild; b; )\n\t                b.nodeType === Node.ELEMENT_NODE && b.setAttributeNS(\"urn:webodf:names:scope\", \"scope\", c),\n\t                b = b.nextSibling\n\t        }\n\t        function z(a, c) {\n\t            for (var b = B.rootElement.meta, b = b && b.firstChild; b && (b.namespaceURI !== a || b.localName !== c); )\n\t                b = b.nextSibling;\n\t            for (b = b && b.firstChild; b && b.nodeType !== Node.TEXT_NODE; )\n\t                b = b.nextSibling;\n\t            return b ? b.data : null\n\t        }\n\t        function w(a) {\n\t            var c = {}, b;\n\t            for (a = a.firstChild; a; )\n\t                a.nodeType === Node.ELEMENT_NODE && a.namespaceURI === p && \"font-face\" === a.localName && (b = a.getAttributeNS(p, \"name\"),\n\t                c[b] = a),\n\t                a = a.nextSibling;\n\t            return c\n\t        }\n\t        function v(a, c) {\n\t            var b = null, d, h, e;\n\t            if (a)\n\t                for (b = a.cloneNode(!0),\n\t                d = b.firstElementChild; d; )\n\t                    h = d.nextElementSibling,\n\t                    (e = d.getAttributeNS(\"urn:webodf:names:scope\", \"scope\")) && e !== c && b.removeChild(d),\n\t                    d = h;\n\t            return b\n\t        }\n\t        function u(a, c) {\n\t            var b, d, h, e = null, m = {};\n\t            if (a)\n\t                for (c.forEach(function(a) {\n\t                    f.collectUsedFontFaces(m, a)\n\t                }),\n\t                e = a.cloneNode(!0),\n\t                b = e.firstElementChild; b; )\n\t                    d = b.nextElementSibling,\n\t                    h = b.getAttributeNS(p, \"name\"),\n\t                    m[h] || e.removeChild(b),\n\t                    b = d;\n\t            return e\n\t        }\n\t        function t(a) {\n\t            var c = B.rootElement.ownerDocument, b;\n\t            if (a) {\n\t                h(a.documentElement);\n\t                try {\n\t                    b = c.importNode(a.documentElement, !0)\n\t                } catch (d) {}\n\t            }\n\t            return b\n\t        }\n\t        function A(a) {\n\t            B.state = a;\n\t            if (B.onchange)\n\t                B.onchange(B);\n\t            if (B.onstatereadychange)\n\t                B.onstatereadychange(B)\n\t        }\n\t        function I(a) {\n\t            Q = null;\n\t            B.rootElement = a;\n\t            a.fontFaceDecls = n.getDirectChild(a, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"font-face-decls\");\n\t            a.styles = n.getDirectChild(a, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"styles\");\n\t            a.automaticStyles = n.getDirectChild(a, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"automatic-styles\");\n\t            a.masterStyles = n.getDirectChild(a, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"master-styles\");\n\t            a.body = n.getDirectChild(a, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"body\");\n\t            a.meta = n.getDirectChild(a, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"meta\");\n\t            a.settings = n.getDirectChild(a, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"settings\");\n\t            a.scripts = n.getDirectChild(a, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"scripts\");\n\t            g(a)\n\t        }\n\t        function K(c) {\n\t            var d = t(c), h = B.rootElement, e;\n\t            d && \"document-styles\" === d.localName && \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\" === d.namespaceURI ? (h.fontFaceDecls = n.getDirectChild(d, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"font-face-decls\"),\n\t            b(h, h.fontFaceDecls),\n\t            e = n.getDirectChild(d, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"styles\"),\n\t            h.styles = e || c.createElementNS(\"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"styles\"),\n\t            b(h, h.styles),\n\t            e = n.getDirectChild(d, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"automatic-styles\"),\n\t            h.automaticStyles = e || c.createElementNS(\"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"automatic-styles\"),\n\t            r(h.automaticStyles, \"document-styles\"),\n\t            b(h, h.automaticStyles),\n\t            d = n.getDirectChild(d, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"master-styles\"),\n\t            h.masterStyles = d || c.createElementNS(\"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"master-styles\"),\n\t            b(h, h.masterStyles),\n\t            f.prefixStyleNames(h.automaticStyles, q, h.masterStyles)) : A(a.INVALID)\n\t        }\n\t        function L(c) {\n\t            c = t(c);\n\t            var d, h, e, m;\n\t            if (c && \"document-content\" === c.localName && \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\" === c.namespaceURI) {\n\t                d = B.rootElement;\n\t                e = n.getDirectChild(c, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"font-face-decls\");\n\t                if (d.fontFaceDecls && e) {\n\t                    m = d.fontFaceDecls;\n\t                    var g, k, O, q, D = {};\n\t                    h = w(m);\n\t                    q = w(e);\n\t                    for (e = e.firstElementChild; e; ) {\n\t                        g = e.nextElementSibling;\n\t                        if (e.namespaceURI === p && \"font-face\" === e.localName)\n\t                            if (k = e.getAttributeNS(p, \"name\"),\n\t                            h.hasOwnProperty(k)) {\n\t                                if (!e.isEqualNode(h[k])) {\n\t                                    O = k;\n\t                                    for (var y = h, E = q, u = 0, W = void 0, W = O = O.replace(/\\d+$/, \"\"); y.hasOwnProperty(W) || E.hasOwnProperty(W); )\n\t                                        u += 1,\n\t                                        W = O + u;\n\t                                    O = W;\n\t                                    e.setAttributeNS(p, \"style:name\", O);\n\t                                    m.appendChild(e);\n\t                                    h[O] = e;\n\t                                    delete q[k];\n\t                                    D[k] = O\n\t                                }\n\t                            } else\n\t                                m.appendChild(e),\n\t                                h[k] = e,\n\t                                delete q[k];\n\t                        e = g\n\t                    }\n\t                    m = D\n\t                } else\n\t                    e && (d.fontFaceDecls = e,\n\t                    b(d, e));\n\t                h = n.getDirectChild(c, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"automatic-styles\");\n\t                r(h, \"document-content\");\n\t                m && f.changeFontFaceNames(h, m);\n\t                if (d.automaticStyles && h)\n\t                    for (m = h.firstChild; m; )\n\t                        d.automaticStyles.appendChild(m),\n\t                        m = h.firstChild;\n\t                else\n\t                    h && (d.automaticStyles = h,\n\t                    b(d, h));\n\t                c = n.getDirectChild(c, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"body\");\n\t                if (null === c)\n\t                    throw \"<office:body/> tag is mising.\";\n\t                d.body = c;\n\t                b(d, d.body)\n\t            } else\n\t                A(a.INVALID)\n\t        }\n\t        function E(a) {\n\t            a = t(a);\n\t            var c;\n\t            a && \"document-meta\" === a.localName && \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\" === a.namespaceURI && (c = B.rootElement,\n\t            c.meta = n.getDirectChild(a, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"meta\"),\n\t            b(c, c.meta))\n\t        }\n\t        function N(a) {\n\t            a = t(a);\n\t            var c;\n\t            a && \"document-settings\" === a.localName && \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\" === a.namespaceURI && (c = B.rootElement,\n\t            c.settings = n.getDirectChild(a, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"settings\"),\n\t            b(c, c.settings))\n\t        }\n\t        function O(a) {\n\t            a = t(a);\n\t            var c;\n\t            if (a && \"manifest\" === a.localName && \"urn:oasis:names:tc:opendocument:xmlns:manifest:1.0\" === a.namespaceURI)\n\t                for (c = B.rootElement,\n\t                c.manifest = a,\n\t                a = c.manifest.firstElementChild; a; )\n\t                    \"file-entry\" === a.localName && \"urn:oasis:names:tc:opendocument:xmlns:manifest:1.0\" === a.namespaceURI && (M[a.getAttributeNS(\"urn:oasis:names:tc:opendocument:xmlns:manifest:1.0\", \"full-path\")] = a.getAttributeNS(\"urn:oasis:names:tc:opendocument:xmlns:manifest:1.0\", \"media-type\")),\n\t                    a = a.nextElementSibling\n\t        }\n\t        function D(a, c, b) {\n\t            a = n.getElementsByTagName(a, c);\n\t            var d;\n\t            for (d = 0; d < a.length; d += 1)\n\t                c = a[d],\n\t                b.hasOwnProperty(c.namespaceURI) || c.parentNode.removeChild(c)\n\t        }\n\t        function V(a) {\n\t            D(a, \"script\", {\n\t                \"urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0\": !0,\n\t                \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\": !0,\n\t                \"urn:oasis:names:tc:opendocument:xmlns:table:1.0\": !0,\n\t                \"urn:oasis:names:tc:opendocument:xmlns:text:1.0\": !0,\n\t                \"urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0\": !0\n\t            });\n\t            D(a, \"style\", {\n\t                \"urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0\": !0,\n\t                \"urn:oasis:names:tc:opendocument:xmlns:drawing:1.0\": !0,\n\t                \"urn:oasis:names:tc:opendocument:xmlns:style:1.0\": !0\n\t            })\n\t        }\n\t        function W(a) {\n\t            var c = a.firstElementChild, b = [], d, h, e, m = a.attributes, f = m.length;\n\t            for (d = 0; d < f; d += 1)\n\t                e = m.item(d),\n\t                h = e.localName.substr(0, 2).toLowerCase(),\n\t                null === e.namespaceURI && \"on\" === h && b.push(e);\n\t            f = b.length;\n\t            for (d = 0; d < f; d += 1)\n\t                a.removeAttributeNode(b[d]);\n\t            for (; c; )\n\t                W(c),\n\t                c = c.nextElementSibling\n\t        }\n\t        function J(c) {\n\t            var b = c.shift();\n\t            b ? Y.loadAsDOM(b.path, function(d, h) {\n\t                h && (V(h),\n\t                W(h.documentElement));\n\t                b.handler(h);\n\t                B.state === a.INVALID ? d ? runtime.log(\"ERROR: Unable to load \" + b.path + \" - \" + d) : runtime.log(\"ERROR: Unable to load \" + b.path) : (d && runtime.log(\"DEBUG: Unable to load \" + b.path + \" - \" + d),\n\t                J(c))\n\t            }) : (g(B.rootElement),\n\t            A(a.DONE))\n\t        }\n\t        function R(a) {\n\t            var c = \"\";\n\t            odf.Namespaces.forEachPrefix(function(a, b) {\n\t                c += \" xmlns:\" + a + '=\"' + b + '\"'\n\t            });\n\t            return '<?xml version=\"1.0\" encoding=\"UTF-8\"?><office:' + a + \" \" + c + ' office:version=\"1.2\">'\n\t        }\n\t        function P() {\n\t            var a = new xmldom.LSSerializer\n\t              , c = R(\"document-meta\");\n\t            a.filter = new odf.OdfNodeFilter;\n\t            c += a.writeToString(B.rootElement.meta, odf.Namespaces.namespaceMap);\n\t            return c + \"</office:document-meta>\"\n\t        }\n\t        function aa(a, c) {\n\t            var b = document.createElementNS(\"urn:oasis:names:tc:opendocument:xmlns:manifest:1.0\", \"manifest:file-entry\");\n\t            b.setAttributeNS(\"urn:oasis:names:tc:opendocument:xmlns:manifest:1.0\", \"manifest:full-path\", a);\n\t            b.setAttributeNS(\"urn:oasis:names:tc:opendocument:xmlns:manifest:1.0\", \"manifest:media-type\", c);\n\t            return b\n\t        }\n\t        function S() {\n\t            var a = runtime.parseXML('<manifest:manifest xmlns:manifest=\"urn:oasis:names:tc:opendocument:xmlns:manifest:1.0\" manifest:version=\"1.2\"></manifest:manifest>'), c = a.documentElement, b = new xmldom.LSSerializer, d;\n\t            for (d in M)\n\t                M.hasOwnProperty(d) && c.appendChild(aa(d, M[d]));\n\t            b.filter = new odf.OdfNodeFilter;\n\t            return '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\\n' + b.writeToString(a, odf.Namespaces.namespaceMap)\n\t        }\n\t        function fa() {\n\t            var a, c, b, d = odf.Namespaces.namespaceMap, h = new xmldom.LSSerializer, e = R(\"document-styles\");\n\t            c = v(B.rootElement.automaticStyles, \"document-styles\");\n\t            b = B.rootElement.masterStyles.cloneNode(!0);\n\t            a = u(B.rootElement.fontFaceDecls, [b, B.rootElement.styles, c]);\n\t            f.removePrefixFromStyleNames(c, q, b);\n\t            h.filter = new k(b,c);\n\t            e += h.writeToString(a, d);\n\t            e += h.writeToString(B.rootElement.styles, d);\n\t            e += h.writeToString(c, d);\n\t            e += h.writeToString(b, d);\n\t            return e + \"</office:document-styles>\"\n\t        }\n\t        function ha() {\n\t            var a, c, b = odf.Namespaces.namespaceMap, h = new xmldom.LSSerializer, e = R(\"document-content\");\n\t            c = v(B.rootElement.automaticStyles, \"document-content\");\n\t            a = u(B.rootElement.fontFaceDecls, [c]);\n\t            h.filter = new d(B.rootElement.body,c);\n\t            e += h.writeToString(a, b);\n\t            e += h.writeToString(c, b);\n\t            e += h.writeToString(B.rootElement.body, b);\n\t            return e + \"</office:document-content>\"\n\t        }\n\t        function C(c, b) {\n\t            runtime.loadXML(c, function(c, d) {\n\t                if (c)\n\t                    b(c);\n\t                else if (d) {\n\t                    V(d);\n\t                    W(d.documentElement);\n\t                    var h = t(d);\n\t                    h && \"document\" === h.localName && \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\" === h.namespaceURI ? (I(h),\n\t                    A(a.DONE)) : A(a.INVALID)\n\t                } else\n\t                    b(\"No DOM was loaded.\")\n\t            })\n\t        }\n\t        function Z(a, c) {\n\t            var d;\n\t            d = B.rootElement;\n\t            var h = d.meta;\n\t            h || (d.meta = h = document.createElementNS(\"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"meta\"),\n\t            b(d, h));\n\t            d = h;\n\t            a && n.mapKeyValObjOntoNode(d, a, odf.Namespaces.lookupNamespaceURI);\n\t            c && n.removeKeyElementsFromNode(d, c, odf.Namespaces.lookupNamespaceURI)\n\t        }\n\t        function ba(c, b) {\n\t            function d(a, c) {\n\t                var b;\n\t                c || (c = a);\n\t                b = document.createElementNS(\"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", c);\n\t                f[a] = b;\n\t                f.appendChild(b)\n\t            }\n\t            var h = new core.Zip(\"\",null)\n\t              , e = \"application/vnd.oasis.opendocument.\" + c + (!0 === b ? \"-template\" : \"\")\n\t              , m = runtime.byteArrayFromString(e, \"utf8\")\n\t              , f = B.rootElement\n\t              , g = document.createElementNS(\"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", c);\n\t            h.save(\"mimetype\", m, !1, new Date);\n\t            d(\"meta\");\n\t            d(\"settings\");\n\t            d(\"scripts\");\n\t            d(\"fontFaceDecls\", \"font-face-decls\");\n\t            d(\"styles\");\n\t            d(\"automaticStyles\", \"automatic-styles\");\n\t            d(\"masterStyles\", \"master-styles\");\n\t            d(\"body\");\n\t            f.body.appendChild(g);\n\t            M[\"/\"] = e;\n\t            M[\"settings.xml\"] = \"text/xml\";\n\t            M[\"meta.xml\"] = \"text/xml\";\n\t            M[\"styles.xml\"] = \"text/xml\";\n\t            M[\"content.xml\"] = \"text/xml\";\n\t            A(a.DONE);\n\t            return h\n\t        }\n\t        function U() {\n\t            var a, c = new Date, b = \"\";\n\t            B.rootElement.settings && B.rootElement.settings.firstElementChild && (a = new xmldom.LSSerializer,\n\t            b = R(\"document-settings\"),\n\t            a.filter = new odf.OdfNodeFilter,\n\t            b += a.writeToString(B.rootElement.settings, odf.Namespaces.namespaceMap),\n\t            b += \"</office:document-settings>\");\n\t            (a = b) ? (a = runtime.byteArrayFromString(a, \"utf8\"),\n\t            Y.save(\"settings.xml\", a, !0, c)) : Y.remove(\"settings.xml\");\n\t            b = runtime.getWindow();\n\t            a = \"WebODF/\" + webodf.Version;\n\t            b && (a = a + \" \" + b.navigator.userAgent);\n\t            Z({\n\t                \"meta:generator\": a\n\t            }, null);\n\t            a = runtime.byteArrayFromString(P(), \"utf8\");\n\t            Y.save(\"meta.xml\", a, !0, c);\n\t            a = runtime.byteArrayFromString(fa(), \"utf8\");\n\t            Y.save(\"styles.xml\", a, !0, c);\n\t            a = runtime.byteArrayFromString(ha(), \"utf8\");\n\t            Y.save(\"content.xml\", a, !0, c);\n\t            a = runtime.byteArrayFromString(S(), \"utf8\");\n\t            Y.save(\"META-INF/manifest.xml\", a, !0, c)\n\t        }\n\t        function ga(a, c) {\n\t            U();\n\t            Y.writeAs(a, function(a) {\n\t                c(a)\n\t            })\n\t        }\n\t        var B = this, Y, M = {}, Q, F = \"\";\n\t        this.onstatereadychange = m;\n\t        this.state = this.onchange = null;\n\t        this.getMetadata = z;\n\t        this.setRootElement = I;\n\t        this.getContentElement = function() {\n\t            var a;\n\t            Q || (a = B.rootElement.body,\n\t            Q = n.getDirectChild(a, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"text\") || n.getDirectChild(a, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"presentation\") || n.getDirectChild(a, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"spreadsheet\"));\n\t            if (!Q)\n\t                throw \"Could not find content element in <office:body/>.\";\n\t            return Q\n\t        }\n\t        ;\n\t        this.getDocumentType = function() {\n\t            var a = B.getContentElement();\n\t            return a && a.localName\n\t        }\n\t        ;\n\t        this.isTemplate = function() {\n\t            return \"-template\" === M[\"/\"].substr(-9)\n\t        }\n\t        ;\n\t        this.setIsTemplate = function(a) {\n\t            var c = M[\"/\"]\n\t              , b = \"-template\" === c.substr(-9);\n\t            a !== b && (c = a ? c + \"-template\" : c.substr(0, c.length - 9),\n\t            M[\"/\"] = c,\n\t            a = runtime.byteArrayFromString(c, \"utf8\"),\n\t            Y.save(\"mimetype\", a, !1, new Date))\n\t        }\n\t        ;\n\t        this.getPart = function(a) {\n\t            return new odf.OdfPart(a,M[a],B,Y)\n\t        }\n\t        ;\n\t        this.getPartData = function(a, c) {\n\t            Y.load(a, c)\n\t        }\n\t        ;\n\t        this.setMetadata = Z;\n\t        this.incrementEditingCycles = function() {\n\t            var a = z(odf.Namespaces.metans, \"editing-cycles\")\n\t              , a = a ? parseInt(a, 10) : 0;\n\t            isNaN(a) && (a = 0);\n\t            Z({\n\t                \"meta:editing-cycles\": a + 1\n\t            }, null);\n\t            return a + 1\n\t        }\n\t        ;\n\t        this.createByteArray = function(a, c) {\n\t            U();\n\t            Y.createByteArray(a, c)\n\t        }\n\t        ;\n\t        this.saveAs = ga;\n\t        this.save = function(a) {\n\t            ga(F, a)\n\t        }\n\t        ;\n\t        this.getUrl = function() {\n\t            return F\n\t        }\n\t        ;\n\t        this.setBlob = function(a, c, b) {\n\t            b = e.convertBase64ToByteArray(b);\n\t            Y.save(a, b, !1, new Date);\n\t            M.hasOwnProperty(a) && runtime.log(a + \" has been overwritten.\");\n\t            M[a] = c\n\t        }\n\t        ;\n\t        this.removeBlob = function(a) {\n\t            var c = Y.remove(a);\n\t            runtime.assert(c, \"file is not found: \" + a);\n\t            delete M[a]\n\t        }\n\t        ;\n\t        this.state = a.LOADING;\n\t        this.rootElement = function(a) {\n\t            var c = document.createElementNS(a.namespaceURI, a.localName), b;\n\t            a = new a.Type;\n\t            for (b in a)\n\t                a.hasOwnProperty(b) && (c[b] = a[b]);\n\t            return c\n\t        }({\n\t            Type: odf.ODFDocumentElement,\n\t            namespaceURI: odf.ODFDocumentElement.namespaceURI,\n\t            localName: odf.ODFDocumentElement.localName\n\t        });\n\t        c === odf.OdfContainer.DocumentType.TEXT ? Y = ba(\"text\") : c === odf.OdfContainer.DocumentType.TEXT_TEMPLATE ? Y = ba(\"text\", !0) : c === odf.OdfContainer.DocumentType.PRESENTATION ? Y = ba(\"presentation\") : c === odf.OdfContainer.DocumentType.PRESENTATION_TEMPLATE ? Y = ba(\"presentation\", !0) : c === odf.OdfContainer.DocumentType.SPREADSHEET ? Y = ba(\"spreadsheet\") : c === odf.OdfContainer.DocumentType.SPREADSHEET_TEMPLATE ? Y = ba(\"spreadsheet\", !0) : (F = c,\n\t        Y = new core.Zip(F,function(c, b) {\n\t            Y = b;\n\t            c ? C(F, function(b) {\n\t                c && (Y.error = c + \"\\n\" + b,\n\t                A(a.INVALID))\n\t            }) : J([{\n\t                path: \"styles.xml\",\n\t                handler: K\n\t            }, {\n\t                path: \"content.xml\",\n\t                handler: L\n\t            }, {\n\t                path: \"meta.xml\",\n\t                handler: E\n\t            }, {\n\t                path: \"settings.xml\",\n\t                handler: N\n\t            }, {\n\t                path: \"META-INF/manifest.xml\",\n\t                handler: O\n\t            }])\n\t        }\n\t        ))\n\t    }\n\t    ;\n\t    odf.OdfContainer.EMPTY = 0;\n\t    odf.OdfContainer.LOADING = 1;\n\t    odf.OdfContainer.DONE = 2;\n\t    odf.OdfContainer.INVALID = 3;\n\t    odf.OdfContainer.SAVING = 4;\n\t    odf.OdfContainer.MODIFIED = 5;\n\t    odf.OdfContainer.getContainer = function(a) {\n\t        return new odf.OdfContainer(a,null)\n\t    }\n\t}\n\t)();\n\todf.OdfContainer.DocumentType = {\n\t    TEXT: 1,\n\t    TEXT_TEMPLATE: 2,\n\t    PRESENTATION: 3,\n\t    PRESENTATION_TEMPLATE: 4,\n\t    SPREADSHEET: 5,\n\t    SPREADSHEET_TEMPLATE: 6\n\t};\n\tgui.AnnotatableCanvas = function() {}\n\t;\n\tgui.AnnotatableCanvas.prototype.refreshSize = function() {}\n\t;\n\tgui.AnnotatableCanvas.prototype.getZoomLevel = function() {}\n\t;\n\tgui.AnnotatableCanvas.prototype.getSizer = function() {}\n\t;\n\tgui.AnnotationViewManager = function(g, k, d, b) {\n\t    function f(c) {\n\t        var b = c.annotationEndElement\n\t          , d = l.createRange()\n\t          , e = c.getAttributeNS(odf.Namespaces.officens, \"name\");\n\t        b && (d.setStart(c, c.childNodes.length),\n\t        d.setEnd(b, 0),\n\t        c = a.getTextNodes(d, !1),\n\t        c.forEach(function(a) {\n\t            var c;\n\t            a: {\n\t                for (c = a.parentNode; c.namespaceURI !== odf.Namespaces.officens || \"body\" !== c.localName; ) {\n\t                    if (\"http://www.w3.org/1999/xhtml\" === c.namespaceURI && \"webodf-annotationHighlight\" === c.className && c.getAttribute(\"annotation\") === e) {\n\t                        c = !0;\n\t                        break a\n\t                    }\n\t                    c = c.parentNode\n\t                }\n\t                c = !1\n\t            }\n\t            c || (c = l.createElement(\"span\"),\n\t            c.className = \"webodf-annotationHighlight\",\n\t            c.setAttribute(\"annotation\", e),\n\t            a.parentNode.replaceChild(c, a),\n\t            c.appendChild(a))\n\t        }));\n\t        d.detach()\n\t    }\n\t    function n(a) {\n\t        var b = g.getSizer();\n\t        a ? (d.style.display = \"inline-block\",\n\t        b.style.paddingRight = c.getComputedStyle(d).width) : (d.style.display = \"none\",\n\t        b.style.paddingRight = 0);\n\t        g.refreshSize()\n\t    }\n\t    function p() {\n\t        e.sort(function(a, c) {\n\t            return 0 !== (a.compareDocumentPosition(c) & Node.DOCUMENT_POSITION_FOLLOWING) ? -1 : 1\n\t        })\n\t    }\n\t    function r() {\n\t        var a;\n\t        for (a = 0; a < e.length; a += 1) {\n\t            var c = e[a]\n\t              , b = c.parentNode\n\t              , f = b.nextElementSibling\n\t              , l = f.nextElementSibling\n\t              , n = b.parentNode\n\t              , k = 0\n\t              , k = e[e.indexOf(c) - 1]\n\t              , r = void 0\n\t              , c = g.getZoomLevel();\n\t            b.style.left = (d.getBoundingClientRect().left - n.getBoundingClientRect().left) / c + \"px\";\n\t            b.style.width = d.getBoundingClientRect().width / c + \"px\";\n\t            f.style.width = parseFloat(b.style.left) - 30 + \"px\";\n\t            k ? (r = k.parentNode.getBoundingClientRect(),\n\t            20 >= (n.getBoundingClientRect().top - r.bottom) / c ? b.style.top = Math.abs(n.getBoundingClientRect().top - r.bottom) / c + 20 + \"px\" : b.style.top = \"0px\") : b.style.top = \"0px\";\n\t            l.style.left = f.getBoundingClientRect().width / c + \"px\";\n\t            var f = l.style\n\t              , n = l.getBoundingClientRect().left / c\n\t              , k = l.getBoundingClientRect().top / c\n\t              , r = b.getBoundingClientRect().left / c\n\t              , p = b.getBoundingClientRect().top / c\n\t              , q = 0\n\t              , I = 0\n\t              , q = r - n\n\t              , q = q * q\n\t              , I = p - k\n\t              , I = I * I\n\t              , n = Math.sqrt(q + I);\n\t            f.width = n + \"px\";\n\t            k = Math.asin((b.getBoundingClientRect().top - l.getBoundingClientRect().top) / (c * parseFloat(l.style.width)));\n\t            l.style.transform = \"rotate(\" + k + \"rad)\";\n\t            l.style.MozTransform = \"rotate(\" + k + \"rad)\";\n\t            l.style.WebkitTransform = \"rotate(\" + k + \"rad)\";\n\t            l.style.msTransform = \"rotate(\" + k + \"rad)\"\n\t        }\n\t    }\n\t    function q(a) {\n\t        var c = e.indexOf(a)\n\t          , b = a.parentNode.parentNode;\n\t        \"div\" === b.localName && (b.parentNode.insertBefore(a, b),\n\t        b.parentNode.removeChild(b));\n\t        a = a.getAttributeNS(odf.Namespaces.officens, \"name\");\n\t        a = l.querySelectorAll('span.webodf-annotationHighlight[annotation=\"' + a + '\"]');\n\t        for (var d, b = 0; b < a.length; b += 1) {\n\t            for (d = a.item(b); d.firstChild; )\n\t                d.parentNode.insertBefore(d.firstChild, d);\n\t            d.parentNode.removeChild(d)\n\t        }\n\t        -1 !== c && e.splice(c, 1);\n\t        0 === e.length && n(!1)\n\t    }\n\t    var e = []\n\t      , l = k.ownerDocument\n\t      , a = odf.OdfUtils\n\t      , c = runtime.getWindow();\n\t    runtime.assert(Boolean(c), \"Expected to be run in an environment which has a global window, like a browser.\");\n\t    this.rerenderAnnotations = r;\n\t    this.rehighlightAnnotations = function() {\n\t        e.forEach(function(a) {\n\t            f(a)\n\t        })\n\t    }\n\t    ;\n\t    this.getMinimumHeightForAnnotationPane = function() {\n\t        return \"none\" !== d.style.display && 0 < e.length ? (e[e.length - 1].parentNode.getBoundingClientRect().bottom - d.getBoundingClientRect().top) / g.getZoomLevel() + \"px\" : null\n\t    }\n\t    ;\n\t    this.addAnnotations = function(c) {\n\t        0 !== c.length && (n(!0),\n\t        c.forEach(function(c) {\n\t            e.push(c);\n\t            var d = l.createElement(\"div\"), m = l.createElement(\"div\"), n = l.createElement(\"div\"), g = l.createElement(\"div\"), k;\n\t            d.className = \"annotationWrapper\";\n\t            d.setAttribute(\"creator\", a.getAnnotationCreator(c));\n\t            c.parentNode.insertBefore(d, c);\n\t            m.className = \"annotationNote\";\n\t            m.appendChild(c);\n\t            b && (k = l.createElement(\"div\"),\n\t            k.className = \"annotationRemoveButton\",\n\t            m.appendChild(k));\n\t            n.className = \"annotationConnector horizontal\";\n\t            g.className = \"annotationConnector angular\";\n\t            d.appendChild(m);\n\t            d.appendChild(n);\n\t            d.appendChild(g);\n\t            c.annotationEndElement && f(c)\n\t        }),\n\t        p(),\n\t        r())\n\t    }\n\t    ;\n\t    this.forgetAnnotation = q;\n\t    this.forgetAnnotations = function() {\n\t        for (; e.length; )\n\t            q(e[0])\n\t    }\n\t}\n\t;\n\tgui.Viewport = function() {}\n\t;\n\tgui.Viewport.prototype.scrollIntoView = function(g, k) {}\n\t;\n\tgui.SingleScrollViewport = function(g) {\n\t    this.scrollIntoView = function(k, d) {\n\t        var b, f, n, p;\n\t        p = g.offsetHeight - g.clientHeight;\n\t        n = g.offsetWidth - g.clientWidth;\n\t        var r = g.getBoundingClientRect();\n\t        if (k && r) {\n\t            b = r.left + 5;\n\t            f = r.top + 5;\n\t            n = r.right - (n + 5);\n\t            p = r.bottom - (p + 5);\n\t            if (d || k.top < f)\n\t                g.scrollTop -= f - k.top;\n\t            else if (k.top > p || k.bottom > p)\n\t                g.scrollTop = k.bottom - k.top <= p - f ? g.scrollTop + (k.bottom - p) : g.scrollTop + (k.top - f);\n\t            k.left < b ? g.scrollLeft -= b - k.left : k.right > n && (g.scrollLeft = k.right - k.left <= n - b ? g.scrollLeft + (k.right - n) : g.scrollLeft - (b - k.left))\n\t        }\n\t    }\n\t}\n\t;\n\t(function() {\n\t    function g(d, n, k, r, q) {\n\t        var e, l = 0, a;\n\t        for (a in d)\n\t            if (d.hasOwnProperty(a)) {\n\t                if (l === k) {\n\t                    e = a;\n\t                    break\n\t                }\n\t                l += 1\n\t            }\n\t        e ? n.getPartData(d[e].href, function(a, m) {\n\t            if (a)\n\t                runtime.log(a);\n\t            else if (m) {\n\t                var h = \"@font-face { font-family: \" + (d[e].family || e) + \"; src: url(data:application/x-font-ttf;charset=binary;base64,\" + b.convertUTF8ArrayToBase64(m) + ') format(\"truetype\"); }';\n\t                try {\n\t                    r.insertRule(h, r.cssRules.length)\n\t                } catch (l) {\n\t                    runtime.log(\"Problem inserting rule in CSS: \" + runtime.toJson(l) + \"\\nRule: \" + h)\n\t                }\n\t            } else\n\t                runtime.log(\"missing font data for \" + d[e].href);\n\t            g(d, n, k + 1, r, q)\n\t        }) : q && q()\n\t    }\n\t    var k = xmldom.XPath\n\t      , d = odf.OdfUtils\n\t      , b = new core.Base64;\n\t    odf.FontLoader = function() {\n\t        this.loadFonts = function(b, n) {\n\t            for (var p = b.rootElement.fontFaceDecls; n.cssRules.length; )\n\t                n.deleteRule(n.cssRules.length - 1);\n\t            if (p) {\n\t                var r = {}, q, e, l, a;\n\t                if (p)\n\t                    for (p = k.getODFElementsWithXPath(p, \"style:font-face[svg:font-face-src]\", odf.Namespaces.lookupNamespaceURI),\n\t                    q = 0; q < p.length; q += 1)\n\t                        e = p[q],\n\t                        l = e.getAttributeNS(odf.Namespaces.stylens, \"name\"),\n\t                        a = d.getNormalizedFontFamilyName(e.getAttributeNS(odf.Namespaces.svgns, \"font-family\")),\n\t                        e = k.getODFElementsWithXPath(e, \"svg:font-face-src/svg:font-face-uri\", odf.Namespaces.lookupNamespaceURI),\n\t                        0 < e.length && (e = e[0].getAttributeNS(odf.Namespaces.xlinkns, \"href\"),\n\t                        r[l] = {\n\t                            href: e,\n\t                            family: a\n\t                        });\n\t                g(r, b, 0, n)\n\t            }\n\t        }\n\t    }\n\t}\n\t)();\n\todf.Formatting = function() {\n\t    function g(a) {\n\t        return (a = A[a]) ? u.mergeObjects({}, a) : {}\n\t    }\n\t    function k() {\n\t        for (var c = a.rootElement.fontFaceDecls, b = {}, d, e, c = c && c.firstElementChild; c; ) {\n\t            if (d = c.getAttributeNS(h, \"name\"))\n\t                if ((e = c.getAttributeNS(m, \"font-family\")) || 0 < c.getElementsByTagNameNS(m, \"font-face-uri\").length)\n\t                    b[d] = e;\n\t            c = c.nextElementSibling\n\t        }\n\t        return b\n\t    }\n\t    function d(c) {\n\t        for (var b = a.rootElement.styles.firstElementChild; b; ) {\n\t            if (b.namespaceURI === h && \"default-style\" === b.localName && b.getAttributeNS(h, \"family\") === c)\n\t                return b;\n\t            b = b.nextElementSibling\n\t        }\n\t        return null\n\t    }\n\t    function b(c, b, d) {\n\t        var e, m, l;\n\t        d = d || [a.rootElement.automaticStyles, a.rootElement.styles];\n\t        for (l = 0; l < d.length; l += 1)\n\t            for (e = d[l],\n\t            e = e.firstElementChild; e; ) {\n\t                m = e.getAttributeNS(h, \"name\");\n\t                if (e.namespaceURI === h && \"style\" === e.localName && e.getAttributeNS(h, \"family\") === b && m === c || \"list-style\" === b && e.namespaceURI === y && \"list-style\" === e.localName && m === c || \"data\" === b && e.namespaceURI === x && m === c)\n\t                    return e;\n\t                e = e.nextElementSibling\n\t            }\n\t        return null\n\t    }\n\t    function f(a) {\n\t        for (var c, b, d, e, m = {}, l = a.firstElementChild; l; ) {\n\t            if (l.namespaceURI === h)\n\t                for (d = m[l.nodeName] = {},\n\t                b = l.attributes,\n\t                c = 0; c < b.length; c += 1)\n\t                    e = b.item(c),\n\t                    d[e.name] = e.value;\n\t            l = l.nextElementSibling\n\t        }\n\t        b = a.attributes;\n\t        for (c = 0; c < b.length; c += 1)\n\t            e = b.item(c),\n\t            m[e.name] = e.value;\n\t        return m\n\t    }\n\t    function n(c, e) {\n\t        for (var m = a.rootElement.styles, l, n = {}, k = c.getAttributeNS(h, \"family\"), r = c; r; )\n\t            l = f(r),\n\t            n = u.mergeObjects(l, n),\n\t            r = (l = r.getAttributeNS(h, \"parent-style-name\")) ? b(l, k, [m]) : null;\n\t        if (r = d(k))\n\t            l = f(r),\n\t            n = u.mergeObjects(l, n);\n\t        !1 !== e && (l = g(k),\n\t        n = u.mergeObjects(l, n));\n\t        return n\n\t    }\n\t    function p(b, d) {\n\t        function h(a) {\n\t            Object.keys(a).forEach(function(c) {\n\t                Object.keys(a[c]).forEach(function(a) {\n\t                    f += \"|\" + c + \":\" + a + \"|\"\n\t                })\n\t            })\n\t        }\n\t        for (var e = b.nodeType === Node.TEXT_NODE ? b.parentNode : b, m, l = [], f = \"\", n = !1; e && !w.isInlineRoot(e) && e.parentNode !== a.rootElement; )\n\t            !n && w.isGroupingElement(e) && (n = !0),\n\t            (m = c.determineStylesForNode(e)) && l.push(m),\n\t            e = e.parentNode;\n\t        n && (l.forEach(h),\n\t        d && (d[f] = l));\n\t        return n ? l : void 0\n\t    }\n\t    function r(c) {\n\t        var d = {\n\t            orderedStyles: [],\n\t            styleProperties: {}\n\t        };\n\t        c.forEach(function(c) {\n\t            Object.keys(c).forEach(function(e) {\n\t                var m = Object.keys(c[e])[0], l = {\n\t                    name: m,\n\t                    family: e,\n\t                    displayName: void 0,\n\t                    isCommonStyle: !1\n\t                }, f;\n\t                (f = b(m, e)) ? (e = n(f),\n\t                d.styleProperties = u.mergeObjects(e, d.styleProperties),\n\t                l.displayName = f.getAttributeNS(h, \"display-name\") || void 0,\n\t                l.isCommonStyle = f.parentNode === a.rootElement.styles) : runtime.log(\"No style element found for '\" + m + \"' of family '\" + e + \"'\");\n\t                d.orderedStyles.push(l)\n\t            })\n\t        });\n\t        return d\n\t    }\n\t    function q(a, c) {\n\t        var b = {}\n\t          , d = [];\n\t        c || (c = {});\n\t        a.forEach(function(a) {\n\t            p(a, b)\n\t        });\n\t        Object.keys(b).forEach(function(a) {\n\t            c[a] || (c[a] = r(b[a]));\n\t            d.push(c[a])\n\t        });\n\t        return d\n\t    }\n\t    function e(c) {\n\t        for (var b = a.rootElement.masterStyles.firstElementChild; b && (b.namespaceURI !== h || \"master-page\" !== b.localName || b.getAttributeNS(h, \"name\") !== c); )\n\t            b = b.nextElementSibling;\n\t        return b\n\t    }\n\t    function l(a, c) {\n\t        var b;\n\t        a && (b = t.convertMeasure(a, \"px\"));\n\t        void 0 === b && c && (b = t.convertMeasure(c, \"px\"));\n\t        return b\n\t    }\n\t    var a, c = new odf.StyleInfo, m = odf.Namespaces.svgns, h = odf.Namespaces.stylens, y = odf.Namespaces.textns, x = odf.Namespaces.numberns, z = odf.Namespaces.fons, w = odf.OdfUtils, v = core.DomUtils, u = new core.Utils, t = new core.CSSUnits, A = {\n\t        paragraph: {\n\t            \"style:paragraph-properties\": {\n\t                \"fo:text-align\": \"left\"\n\t            }\n\t        }\n\t    };\n\t    this.getSystemDefaultStyleAttributes = g;\n\t    this.setOdfContainer = function(c) {\n\t        a = c\n\t    }\n\t    ;\n\t    this.getFontMap = k;\n\t    this.getAvailableParagraphStyles = function() {\n\t        for (var c = a.rootElement.styles, b, d, e = [], c = c && c.firstElementChild; c; )\n\t            \"style\" === c.localName && c.namespaceURI === h && (b = c.getAttributeNS(h, \"family\"),\n\t            \"paragraph\" === b && (b = c.getAttributeNS(h, \"name\"),\n\t            d = c.getAttributeNS(h, \"display-name\") || b,\n\t            b && d && e.push({\n\t                name: b,\n\t                displayName: d\n\t            }))),\n\t            c = c.nextElementSibling;\n\t        return e\n\t    }\n\t    ;\n\t    this.isStyleUsed = function(b) {\n\t        var d, e = a.rootElement;\n\t        d = c.hasDerivedStyles(e, odf.Namespaces.lookupNamespaceURI, b);\n\t        b = (new c.UsedStyleList(e.styles)).uses(b) || (new c.UsedStyleList(e.automaticStyles)).uses(b) || (new c.UsedStyleList(e.body)).uses(b);\n\t        return d || b\n\t    }\n\t    ;\n\t    this.getDefaultStyleElement = d;\n\t    this.getStyleElement = b;\n\t    this.getStyleAttributes = f;\n\t    this.getInheritedStyleAttributes = n;\n\t    this.getFirstCommonParentStyleNameOrSelf = function(c) {\n\t        var d = a.rootElement.styles, e;\n\t        if (e = b(c, \"paragraph\", [a.rootElement.automaticStyles]))\n\t            if (c = e.getAttributeNS(h, \"parent-style-name\"),\n\t            !c)\n\t                return null;\n\t        return (e = b(c, \"paragraph\", [d])) ? c : null\n\t    }\n\t    ;\n\t    this.hasParagraphStyle = function(a) {\n\t        return Boolean(b(a, \"paragraph\"))\n\t    }\n\t    ;\n\t    this.getAppliedStyles = q;\n\t    this.getAppliedStylesForElement = function(a, c) {\n\t        return q([a], c)[0]\n\t    }\n\t    ;\n\t    this.updateStyle = function(c, b) {\n\t        var d, e;\n\t        v.mapObjOntoNode(c, b, odf.Namespaces.lookupNamespaceURI);\n\t        (d = (d = b[\"style:text-properties\"]) && d[\"style:font-name\"]) && !k().hasOwnProperty(d) && (e = c.ownerDocument.createElementNS(h, \"style:font-face\"),\n\t        e.setAttributeNS(h, \"style:name\", d),\n\t        e.setAttributeNS(m, \"svg:font-family\", d),\n\t        a.rootElement.fontFaceDecls.appendChild(e))\n\t    }\n\t    ;\n\t    this.createDerivedStyleObject = function(c, d, e) {\n\t        var h = b(c, d);\n\t        runtime.assert(Boolean(h), \"No style element found for '\" + c + \"' of family '\" + d + \"'\");\n\t        c = h.parentNode === a.rootElement.styles ? {\n\t            \"style:parent-style-name\": c\n\t        } : f(h);\n\t        c[\"style:family\"] = d;\n\t        u.mergeObjects(c, e);\n\t        return c\n\t    }\n\t    ;\n\t    this.getDefaultTabStopDistance = function() {\n\t        for (var a = d(\"paragraph\"), a = a && a.firstElementChild, c; a; )\n\t            a.namespaceURI === h && \"paragraph-properties\" === a.localName && (c = a.getAttributeNS(h, \"tab-stop-distance\")),\n\t            a = a.nextElementSibling;\n\t        c || (c = \"1.25cm\");\n\t        return w.parseNonNegativeLength(c)\n\t    }\n\t    ;\n\t    this.getMasterPageElement = e;\n\t    this.getContentSize = function(c, d) {\n\t        var m, f, n, g, k, r, p, q, y, u;\n\t        a: {\n\t            f = b(c, d);\n\t            runtime.assert(\"paragraph\" === d || \"table\" === d, \"styleFamily must be either paragraph or table\");\n\t            if (f) {\n\t                if (f = f.getAttributeNS(h, \"master-page-name\"))\n\t                    (m = e(f)) || runtime.log(\"WARN: No master page definition found for \" + f);\n\t                m || (m = e(\"Standard\"));\n\t                m || (m = a.rootElement.masterStyles.getElementsByTagNameNS(h, \"master-page\")[0]) || runtime.log(\"WARN: Document has no master pages defined\");\n\t                if (m)\n\t                    for (f = m.getAttributeNS(h, \"page-layout-name\"),\n\t                    n = a.rootElement.automaticStyles.getElementsByTagNameNS(h, \"page-layout\"),\n\t                    g = 0; g < n.length; g += 1)\n\t                        if (m = n.item(g),\n\t                        m.getAttributeNS(h, \"name\") === f)\n\t                            break a\n\t            }\n\t            m = null\n\t        }\n\t        m || (m = v.getDirectChild(a.rootElement.styles, h, \"default-page-layout\"));\n\t        (m = v.getDirectChild(m, h, \"page-layout-properties\")) ? (\"landscape\" === m.getAttributeNS(h, \"print-orientation\") ? (f = \"29.7cm\",\n\t        n = \"21.001cm\") : (f = \"21.001cm\",\n\t        n = \"29.7cm\"),\n\t        f = l(m.getAttributeNS(z, \"page-width\"), f),\n\t        n = l(m.getAttributeNS(z, \"page-height\"), n),\n\t        g = l(m.getAttributeNS(z, \"margin\")),\n\t        void 0 === g ? (g = l(m.getAttributeNS(z, \"margin-left\"), \"2cm\"),\n\t        k = l(m.getAttributeNS(z, \"margin-right\"), \"2cm\"),\n\t        r = l(m.getAttributeNS(z, \"margin-top\"), \"2cm\"),\n\t        p = l(m.getAttributeNS(z, \"margin-bottom\"), \"2cm\")) : g = k = r = p = g,\n\t        q = l(m.getAttributeNS(z, \"padding\")),\n\t        void 0 === q ? (q = l(m.getAttributeNS(z, \"padding-left\"), \"0cm\"),\n\t        y = l(m.getAttributeNS(z, \"padding-right\"), \"0cm\"),\n\t        u = l(m.getAttributeNS(z, \"padding-top\"), \"0cm\"),\n\t        m = l(m.getAttributeNS(z, \"padding-bottom\"), \"0cm\")) : q = y = u = m = q) : (f = l(\"21.001cm\"),\n\t        n = l(\"29.7cm\"),\n\t        g = k = r = p = g = l(\"2cm\"),\n\t        q = y = u = m = q = l(\"0cm\"));\n\t        return {\n\t            width: f - g - k - q - y,\n\t            height: n - r - p - u - m\n\t        }\n\t    }\n\t}\n\t;\n\t(function() {\n\t    var g = odf.Namespaces.stylens\n\t      , k = odf.Namespaces.textns\n\t      , d = {\n\t        graphic: \"draw\",\n\t        \"drawing-page\": \"draw\",\n\t        paragraph: \"text\",\n\t        presentation: \"presentation\",\n\t        ruby: \"text\",\n\t        section: \"text\",\n\t        table: \"table\",\n\t        \"table-cell\": \"table\",\n\t        \"table-column\": \"table\",\n\t        \"table-row\": \"table\",\n\t        text: \"text\",\n\t        list: \"text\",\n\t        page: \"office\"\n\t    };\n\t    odf.StyleTreeNode = function(b) {\n\t        this.derivedStyles = {};\n\t        this.element = b\n\t    }\n\t    ;\n\t    odf.StyleTree = function(b, f) {\n\t        function n(b) {\n\t            var a, c, d, e = {};\n\t            if (!b)\n\t                return e;\n\t            for (b = b.firstElementChild; b; ) {\n\t                if (c = b.namespaceURI !== g || \"style\" !== b.localName && \"default-style\" !== b.localName ? b.namespaceURI === k && \"list-style\" === b.localName ? \"list\" : b.namespaceURI !== g || \"page-layout\" !== b.localName && \"default-page-layout\" !== b.localName ? void 0 : \"page\" : b.getAttributeNS(g, \"family\"))\n\t                    (a = b.getAttributeNS(g, \"name\")) || (a = \"\"),\n\t                    e.hasOwnProperty(c) ? d = e[c] : e[c] = d = {},\n\t                    d[a] = b;\n\t                b = b.nextElementSibling\n\t            }\n\t            return e\n\t        }\n\t        function p(b, a) {\n\t            if (b.hasOwnProperty(a))\n\t                return b[a];\n\t            var c = null, d = Object.keys(b), e;\n\t            for (e = 0; e < d.length && !(c = p(b[d[e]].derivedStyles, a)); e += 1)\n\t                ;\n\t            return c\n\t        }\n\t        function r(b, a, c) {\n\t            var d, e, f;\n\t            if (!a.hasOwnProperty(b))\n\t                return null;\n\t            d = new odf.StyleTreeNode(a[b]);\n\t            e = d.element.getAttributeNS(g, \"parent-style-name\");\n\t            f = null;\n\t            e && (f = p(c, e) || r(e, a, c));\n\t            f ? f.derivedStyles[b] = d : c[b] = d;\n\t            delete a[b];\n\t            return d\n\t        }\n\t        function q(b, a) {\n\t            b && Object.keys(b).forEach(function(c) {\n\t                r(c, b, a)\n\t            })\n\t        }\n\t        var e = {};\n\t        this.getStyleTree = function() {\n\t            return e\n\t        }\n\t        ;\n\t        (function() {\n\t            var l, a, c;\n\t            a = n(b);\n\t            c = n(f);\n\t            Object.keys(d).forEach(function(b) {\n\t                l = e[b] = {};\n\t                q(a[b], l);\n\t                q(c[b], l)\n\t            })\n\t        }\n\t        )()\n\t    }\n\t}\n\t)();\n\t(function() {\n\t    function g(b, d) {\n\t        try {\n\t            b.insertRule(d, b.cssRules.length)\n\t        } catch (f) {\n\t            runtime.log(\"cannot load rule: \" + d + \" - \" + f)\n\t        }\n\t    }\n\t    function k(b, d) {\n\t        this.listCounterCount = 0;\n\t        this.contentRules = b;\n\t        this.counterIdStack = [];\n\t        this.continuedCounterIdStack = d\n\t    }\n\t    function d(b) {\n\t        function d(c, h, f, l) {\n\t            var k = h.namespaceURI === n && \"list\" === h.localName\n\t              , r = h.namespaceURI === n && \"list-item\" === h.localName;\n\t            if (k || r) {\n\t                if (k) {\n\t                    var k = f += 1, p, u, t;\n\t                    l.listCounterCount += 1;\n\t                    r = c + \"-level\" + k + \"-\" + l.listCounterCount;\n\t                    h.setAttributeNS(\"urn:webodf:names:helper\", \"counter-id\", r);\n\t                    p = l.continuedCounterIdStack.shift();\n\t                    p || (p = r,\n\t                    a += r + \" 1 \",\n\t                    u = 'text|list[webodfhelper|counter-id=\"' + r + '\"] > text|list-item:first-child > :not(text|list):first-child:before',\n\t                    u += \"{\",\n\t                    u += \"counter-increment: \" + p + \" 0;\",\n\t                    u += \"}\",\n\t                    g(b, u));\n\t                    for (; l.counterIdStack.length >= k; )\n\t                        l.counterIdStack.pop();\n\t                    l.counterIdStack.push(p);\n\t                    t = l.contentRules[k.toString()] || \"\";\n\t                    for (u = 1; u <= k; u += 1)\n\t                        t = t.replace(u + \"webodf-listLevel\", l.counterIdStack[u - 1]);\n\t                    u = 'text|list[webodfhelper|counter-id=\"' + r + '\"] > text|list-item > :not(text|list):first-child:before';\n\t                    u += \"{\";\n\t                    u += t;\n\t                    u += \"counter-increment: \" + p + \";\";\n\t                    u += \"}\";\n\t                    g(b, u)\n\t                }\n\t                for (h = h.firstElementChild; h; )\n\t                    d(c, h, f, l),\n\t                    h = h.nextElementSibling\n\t            } else\n\t                l.continuedCounterIdStack = []\n\t        }\n\t        var f = 0\n\t          , a = \"\"\n\t          , c = {};\n\t        this.createCounterRules = function(a, b, n) {\n\t            var g = b.getAttributeNS(p, \"id\")\n\t              , r = [];\n\t            n && (n = n.getAttributeNS(\"urn:webodf:names:helper\", \"counter-id\"),\n\t            r = c[n].slice(0));\n\t            a = new k(a,r);\n\t            g ? g = \"Y\" + g : (f += 1,\n\t            g = \"X\" + f);\n\t            d(g, b, 0, a);\n\t            c[g + \"-level1-1\"] = a.counterIdStack\n\t        }\n\t        ;\n\t        this.initialiseCreatedCounters = function() {\n\t            var c;\n\t            c = \"office|document{\" + (\"counter-reset: \" + a + \";\");\n\t            c += \"}\";\n\t            g(b, c)\n\t        }\n\t    }\n\t    var b = odf.Namespaces.fons\n\t      , f = odf.Namespaces.stylens\n\t      , n = odf.Namespaces.textns\n\t      , p = odf.Namespaces.xmlns\n\t      , r = {\n\t        1: \"decimal\",\n\t        a: \"lower-latin\",\n\t        A: \"upper-latin\",\n\t        i: \"lower-roman\",\n\t        I: \"upper-roman\"\n\t    };\n\t    odf.ListStyleToCss = function() {\n\t        function k(a) {\n\t            var b = m.parseLength(a);\n\t            return b ? c.convert(b.value, b.unit, \"px\") : (runtime.log(\"Could not parse value '\" + a + \"'.\"),\n\t            0)\n\t        }\n\t        function e(a) {\n\t            return a.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"')\n\t        }\n\t        function l(a, c) {\n\t            var b;\n\t            a && (b = a.getAttributeNS(n, \"style-name\"));\n\t            return b === c\n\t        }\n\t        function a(a, c, b) {\n\t            c = c.getElementsByTagNameNS(n, \"list\");\n\t            a = new d(a);\n\t            var m, g, k, q, t, A, I = {}, K;\n\t            for (K = 0; K < c.length; K += 1)\n\t                if (m = c.item(K),\n\t                A = m.getAttributeNS(n, \"style-name\")) {\n\t                    k = m.getAttributeNS(n, \"continue-numbering\");\n\t                    q = m.getAttributeNS(n, \"continue-list\");\n\t                    (t = m.getAttributeNS(p, \"id\")) && (I[t] = m);\n\t                    t = b[A].element.firstElementChild;\n\t                    for (var L = void 0, E = {}; t; ) {\n\t                        var L = (L = t.getAttributeNS(n, \"level\")) && parseInt(L, 10)\n\t                          , N = t\n\t                          , O = \"\"\n\t                          , D = void 0\n\t                          , V = void 0\n\t                          , W = D = void 0;\n\t                        if (\"list-level-style-number\" === N.localName) {\n\t                            var J = N\n\t                              , O = J.getAttributeNS(f, \"num-format\")\n\t                              , D = J.getAttributeNS(f, \"num-suffix\") || \"\"\n\t                              , V = J.getAttributeNS(f, \"num-prefix\") || \"\"\n\t                              , R = \"\"\n\t                              , P = J.getAttributeNS(n, \"level\")\n\t                              , J = J.getAttributeNS(n, \"display-levels\");\n\t                            V && (R += '\"' + e(V) + '\"\\n');\n\t                            if (r.hasOwnProperty(O))\n\t                                for (P = P ? parseInt(P, 10) : 1,\n\t                                J = J ? parseInt(J, 10) : 1; 0 < J; )\n\t                                    R += \" counter(\" + (P - J + 1) + \"webodf-listLevel,\" + r[O] + \")\",\n\t                                    1 < J && (R += '\".\"'),\n\t                                    --J;\n\t                            else\n\t                                R = O ? R + (' \"' + O + '\"') : R + ' \"\"';\n\t                            O = \"content:\" + R + ' \"' + e(D) + '\"'\n\t                        } else\n\t                            \"list-level-style-image\" === N.localName ? O = \"content: none\" : \"list-level-style-bullet\" === N.localName && (O = N.getAttributeNS(n, \"bullet-char\"),\n\t                            O = 'content: \"' + e(O) + '\"');\n\t                        if (D = N.getElementsByTagNameNS(f, \"list-level-properties\")[0])\n\t                            V = D.getAttributeNS(n, \"list-level-position-and-space-mode\"),\n\t                            \"label-alignment\" === V && ((D = D.getElementsByTagNameNS(f, \"list-level-label-alignment\")[0]) && (W = D.getAttributeNS(n, \"label-followed-by\")),\n\t                            \"space\" === W && (O += ' \"\\\\a0\"'));\n\t                        E[L] = \"\\n\" + O + \";\\n\";\n\t                        t = t.nextElementSibling\n\t                    }\n\t                    t = E;\n\t                    k && !q && l(g, A) ? a.createCounterRules(t, m, g) : q && l(I[q], A) ? a.createCounterRules(t, m, I[q]) : a.createCounterRules(t, m);\n\t                    g = m\n\t                }\n\t            a.initialiseCreatedCounters()\n\t        }\n\t        var c = new core.CSSUnits\n\t          , m = odf.OdfUtils;\n\t        this.applyListStyles = function(c, d, e) {\n\t            var m, l;\n\t            (m = d.list) && Object.keys(m).forEach(function(a) {\n\t                l = m[a];\n\t                for (var d = l.element.firstElementChild; d; ) {\n\t                    if (d.namespaceURI === n) {\n\t                        for (var e = c, r = d, p = 'text|list[text|style-name=\"' + a + '\"]', y = r.getAttributeNS(n, \"level\"), x = void 0, E = void 0, N = E = void 0, O = void 0, D = void 0, V = x = void 0, W = void 0, J = void 0, R = void 0, O = void 0, N = (E = r.getElementsByTagNameNS(f, \"list-level-properties\")[0]) && E.getAttributeNS(n, \"list-level-position-and-space-mode\"), O = E && E.getElementsByTagNameNS(f, \"list-level-label-alignment\")[0], x = y = y && parseInt(y, 10); 1 < x; )\n\t                            p += \" > text|list-item > text|list\",\n\t                            --x;\n\t                        x = E && E.getAttributeNS(b, \"text-align\") || \"left\";\n\t                        switch (x) {\n\t                        case \"end\":\n\t                            x = \"right\";\n\t                            break;\n\t                        case \"start\":\n\t                            x = \"left\"\n\t                        }\n\t                        \"label-alignment\" === N ? (D = O && O.getAttributeNS(b, \"margin-left\") || \"0px\",\n\t                        J = O && O.getAttributeNS(b, \"text-indent\") || \"0px\",\n\t                        R = O && O.getAttributeNS(n, \"label-followed-by\"),\n\t                        O = k(D)) : (D = E && E.getAttributeNS(n, \"space-before\") || \"0px\",\n\t                        V = E && E.getAttributeNS(n, \"min-label-width\") || \"0px\",\n\t                        W = E && E.getAttributeNS(n, \"min-label-distance\") || \"0px\",\n\t                        O = k(D) + k(V));\n\t                        E = p + \" > text|list-item\";\n\t                        E += \"{\";\n\t                        E += \"margin-left: \" + O + \"px;\";\n\t                        E += \"}\";\n\t                        g(e, E);\n\t                        E = p + \" > text|list-item > text|list\";\n\t                        E += \"{\";\n\t                        E += \"margin-left: \" + -O + \"px;\";\n\t                        E += \"}\";\n\t                        g(e, E);\n\t                        E = p + \" > text|list-item > :not(text|list):first-child:before\";\n\t                        E += \"{\";\n\t                        E += \"text-align: \" + x + \";\";\n\t                        E += \"display: inline-block;\";\n\t                        \"label-alignment\" === N ? (E += \"margin-left: \" + J + \";\",\n\t                        \"listtab\" === R && (E += \"padding-right: 0.2cm;\")) : (E += \"min-width: \" + V + \";\",\n\t                        E += \"margin-left: \" + (0 === parseFloat(V) ? \"\" : \"-\") + V + \";\",\n\t                        E += \"padding-right: \" + W + \";\");\n\t                        E += \"}\";\n\t                        g(e, E)\n\t                    }\n\t                    d = d.nextElementSibling\n\t                }\n\t            });\n\t            a(c, e, m)\n\t        }\n\t    }\n\t}\n\t)();\n\todf.LazyStyleProperties = function(g, k) {\n\t    var d = {};\n\t    this.value = function(b) {\n\t        var f;\n\t        d.hasOwnProperty(b) ? f = d[b] : (f = k[b](),\n\t        void 0 === f && g && (f = g.value(b)),\n\t        d[b] = f);\n\t        return f\n\t    }\n\t    ;\n\t    this.reset = function(b) {\n\t        g = b;\n\t        d = {}\n\t    }\n\t}\n\t;\n\todf.StyleParseUtils = function() {\n\t    function g(d) {\n\t        var b, f;\n\t        d = (d = /(-?[0-9]*[0-9][0-9]*(\\.[0-9]*)?|0+\\.[0-9]*[1-9][0-9]*|\\.[0-9]*[1-9][0-9]*)((cm)|(mm)|(in)|(pt)|(pc)|(px))/.exec(d)) ? {\n\t            value: parseFloat(d[1]),\n\t            unit: d[3]\n\t        } : null;\n\t        f = d && d.unit;\n\t        \"px\" === f ? b = d.value : \"cm\" === f ? b = d.value / 2.54 * 96 : \"mm\" === f ? b = d.value / 25.4 * 96 : \"in\" === f ? b = 96 * d.value : \"pt\" === f ? b = d.value / .75 : \"pc\" === f && (b = 16 * d.value);\n\t        return b\n\t    }\n\t    var k = odf.Namespaces.stylens;\n\t    this.parseLength = g;\n\t    this.parsePositiveLengthOrPercent = function(d, b, f) {\n\t        var n;\n\t        d && (n = parseFloat(d.substr(0, d.indexOf(\"%\"))),\n\t        isNaN(n) && (n = void 0));\n\t        var k;\n\t        void 0 !== n ? (f && (k = f.value(b)),\n\t        n = void 0 === k ? void 0 : k / 100 * n) : n = g(d);\n\t        return n\n\t    }\n\t    ;\n\t    this.getPropertiesElement = function(d, b, f) {\n\t        for (b = f ? f.nextElementSibling : b.firstElementChild; null !== b && (b.localName !== d || b.namespaceURI !== k); )\n\t            b = b.nextElementSibling;\n\t        return b\n\t    }\n\t    ;\n\t    this.parseAttributeList = function(d) {\n\t        d && (d = d.replace(/^\\s*(.*?)\\s*$/g, \"$1\"));\n\t        return d && 0 < d.length ? d.split(/\\s+/) : []\n\t    }\n\t}\n\t;\n\todf.Style2CSS = function() {\n\t    function g(a, c, b) {\n\t        var d = [];\n\t        b = b.derivedStyles;\n\t        var e;\n\t        var h = z[a], m;\n\t        void 0 === h ? c = null : (m = c ? \"[\" + h + '|style-name=\"' + c + '\"]' : \"\",\n\t        \"presentation\" === h && (h = \"draw\",\n\t        m = c ? '[presentation|style-name=\"' + c + '\"]' : \"\"),\n\t        c = h + \"|\" + w[a].join(m + \",\" + h + \"|\") + m);\n\t        null !== c && d.push(c);\n\t        for (e in b)\n\t            b.hasOwnProperty(e) && (c = g(a, e, b[e]),\n\t            d = d.concat(c));\n\t        return d\n\t    }\n\t    function k(a) {\n\t        var c = \"\"\n\t          , b = \"\"\n\t          , c = null;\n\t        if (\"default-style\" === a.localName)\n\t            return null;\n\t        c = a.getAttributeNS(l, \"parent-style-name\");\n\t        b = a.getAttributeNS(l, \"family\");\n\t        return c = S.getODFElementsWithXPath(P, c ? \"//style:*[@style:name='\" + c + \"'][@style:family='\" + b + \"']\" : \"//style:default-style[@style:family='\" + b + \"']\", odf.Namespaces.lookupNamespaceURI)[0]\n\t    }\n\t    function d(a, c) {\n\t        var b = \"\", d, e, h;\n\t        for (d = 0; d < c.length; d += 1)\n\t            if (e = c[d],\n\t            h = a.getAttributeNS(e[0], e[1])) {\n\t                h = h.trim();\n\t                if (D.hasOwnProperty(e[1])) {\n\t                    var m = h\n\t                      , f = m.indexOf(\" \")\n\t                      , n = void 0;\n\t                    h = void 0;\n\t                    -1 !== f ? (n = m.substring(0, f),\n\t                    h = m.substring(f)) : (n = m,\n\t                    h = \"\");\n\t                    (n = J.parseLength(n)) && \"pt\" === n.unit && .75 > n.value && (m = \"0.75pt\" + h);\n\t                    h = m\n\t                } else if (V.hasOwnProperty(e[1])) {\n\t                    var m = a\n\t                      , f = e[0]\n\t                      , n = e[1]\n\t                      , g = J.parseLength(h)\n\t                      , r = void 0\n\t                      , p = void 0\n\t                      , q = void 0\n\t                      , O = void 0\n\t                      , q = void 0;\n\t                    if (g && \"%\" === g.unit) {\n\t                        r = g.value / 100;\n\t                        p = k(m.parentNode);\n\t                        for (O = \"0\"; p; ) {\n\t                            if (q = y.getDirectChild(p, l, \"paragraph-properties\"))\n\t                                if (q = J.parseLength(q.getAttributeNS(f, n))) {\n\t                                    if (\"%\" !== q.unit) {\n\t                                        O = q.value * r + q.unit;\n\t                                        break\n\t                                    }\n\t                                    r *= q.value / 100\n\t                                }\n\t                            p = k(p)\n\t                        }\n\t                        h = O\n\t                    }\n\t                }\n\t                e[2] && (b += e[2] + \":\" + h + \";\")\n\t            }\n\t        return b\n\t    }\n\t    function b(a, c, b, d) {\n\t        return c + c + b + b + d + d\n\t    }\n\t    function f(a, c) {\n\t        var b = [a]\n\t          , d = c.derivedStyles;\n\t        Object.keys(d).forEach(function(a) {\n\t            a = f(a, d[a]);\n\t            b = b.concat(a)\n\t        });\n\t        return b\n\t    }\n\t    function n(a, c, b, d) {\n\t        function e(c, b) {\n\t            var d = [], h;\n\t            c.forEach(function(a) {\n\t                m.forEach(function(c) {\n\t                    d.push('draw|page[webodfhelper|page-style-name=\"' + c + '\"] draw|frame[presentation|class=\"' + a + '\"]')\n\t                })\n\t            });\n\t            0 < d.length && (h = d.join(\",\") + \"{visibility:\" + b + \";}\",\n\t            a.insertRule(h, a.cssRules.length))\n\t        }\n\t        var m = f(c, d)\n\t          , l = []\n\t          , n = [];\n\t        [\"page-number\", \"date-time\", \"header\", \"footer\"].forEach(function(a) {\n\t            var c;\n\t            c = b.getAttributeNS(h, \"display-\" + a);\n\t            \"true\" === c ? l.push(a) : \"false\" === c && n.push(a)\n\t        });\n\t        e(l, \"visible\");\n\t        e(n, \"hidden\")\n\t    }\n\t    function p(a, f, D, V) {\n\t        var z, w;\n\t        if (\"page\" === f) {\n\t            var B = V.element, P = \"\", M, Q;\n\t            Q = M = \"\";\n\t            D = y.getDirectChild(B, l, \"page-layout-properties\");\n\t            var F;\n\t            if (D)\n\t                if (F = B.getAttributeNS(l, \"name\"),\n\t                P += d(D, N),\n\t                (M = y.getDirectChild(D, l, \"background-image\")) && (Q = M.getAttributeNS(m, \"href\")) && (P = P + (\"background-image: url('odfkit:\" + Q + \"');\") + d(M, u)),\n\t                \"presentation\" === R)\n\t                    for (B = (B = y.getDirectChild(B.parentNode.parentNode, e, \"master-styles\")) && B.firstElementChild; B; )\n\t                        B.namespaceURI === l && \"master-page\" === B.localName && B.getAttributeNS(l, \"page-layout-name\") === F && (Q = B.getAttributeNS(l, \"name\"),\n\t                        M = 'draw|page[draw|master-page-name=\"' + Q + '\"] {' + P + \"}\",\n\t                        Q = 'office|body, draw|page[draw|master-page-name=\"' + Q + '\"] {' + d(D, O) + \" }\",\n\t                        a.insertRule(M, a.cssRules.length),\n\t                        a.insertRule(Q, a.cssRules.length)),\n\t                        B = B.nextElementSibling;\n\t                else\n\t                    \"text\" === R && (M = \"office|text {\" + P + \"}\",\n\t                    Q = \"office|body {width: \" + D.getAttributeNS(q, \"page-width\") + \";}\",\n\t                    a.insertRule(M, a.cssRules.length),\n\t                    a.insertRule(Q, a.cssRules.length))\n\t        } else {\n\t            P = g(f, D, V).join(\",\");\n\t            F = \"\";\n\t            if (B = y.getDirectChild(V.element, l, \"text-properties\")) {\n\t                var S = B\n\t                  , ca = w = \"\";\n\t                M = \"\";\n\t                Q = 1;\n\t                B = \"\" + d(S, v);\n\t                z = S.getAttributeNS(l, \"text-underline-style\");\n\t                \"solid\" === z && (w += \" underline\");\n\t                z = S.getAttributeNS(l, \"text-line-through-style\");\n\t                \"solid\" === z && (w += \" line-through\");\n\t                w.length && (B = B + (\"text-decoration:\" + w + \";\\n\") + (\"text-decoration-line:\" + w + \";\\n\"),\n\t                B += \"-moz-text-decoration-line:\" + w + \";\\n\");\n\t                z = S.getAttributeNS(l, \"text-line-through-type\");\n\t                switch (z) {\n\t                case \"double\":\n\t                    ca += \" double\";\n\t                    break;\n\t                case \"single\":\n\t                    ca += \" single\"\n\t                }\n\t                ca && (B += \"text-decoration-style:\" + ca + \";\\n\",\n\t                B += \"-moz-text-decoration-style:\" + ca + \";\\n\");\n\t                if (w = S.getAttributeNS(l, \"font-name\") || S.getAttributeNS(q, \"font-family\"))\n\t                    z = W[w],\n\t                    B += \"font-family: \" + (z || w) + \";\";\n\t                if (z = S.getAttributeNS(l, \"text-position\"))\n\t                    w = x.parseAttributeList(z),\n\t                    z = w[0],\n\t                    w = w[1],\n\t                    B += \"vertical-align: \" + z + \"\\n; \",\n\t                    w && (Q = parseFloat(w) / 100);\n\t                if (S.hasAttributeNS(q, \"font-size\") || 1 !== Q) {\n\t                    for (S = S.parentNode; S; ) {\n\t                        if (z = (z = y.getDirectChild(S, l, \"text-properties\")) ? J.parseFoFontSize(z.getAttributeNS(q, \"font-size\")) : null) {\n\t                            if (\"%\" !== z.unit) {\n\t                                M = \"font-size: \" + z.value * Q + z.unit + \";\";\n\t                                break\n\t                            }\n\t                            Q *= z.value / 100\n\t                        }\n\t                        S = k(S)\n\t                    }\n\t                    M || (M = \"font-size: \" + parseFloat(aa) * Q + fa.getUnits(aa) + \";\")\n\t                }\n\t                B += M;\n\t                F += B\n\t            }\n\t            if (B = y.getDirectChild(V.element, l, \"paragraph-properties\"))\n\t                M = B,\n\t                B = \"\" + d(M, t),\n\t                (Q = y.getDirectChild(M, l, \"background-image\")) && (S = Q.getAttributeNS(m, \"href\")) && (B = B + (\"background-image: url('odfkit:\" + S + \"');\") + d(Q, u)),\n\t                (M = M.getAttributeNS(q, \"line-height\")) && \"normal\" !== M && (M = J.parseFoLineHeight(M),\n\t                B = \"%\" !== M.unit ? B + (\"line-height: \" + M.value + M.unit + \";\") : B + (\"line-height: \" + M.value / 100 + \";\")),\n\t                F += B;\n\t            if (B = y.getDirectChild(V.element, l, \"graphic-properties\"))\n\t                S = B,\n\t                B = \"\" + d(S, A),\n\t                M = S.getAttributeNS(r, \"opacity\"),\n\t                Q = S.getAttributeNS(r, \"fill\"),\n\t                S = S.getAttributeNS(r, \"fill-color\"),\n\t                \"solid\" === Q || \"hatch\" === Q ? S && \"none\" !== S ? (M = isNaN(parseFloat(M)) ? 1 : parseFloat(M) / 100,\n\t                Q = S.replace(/^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i, b),\n\t                (S = (Q = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(Q)) ? {\n\t                    r: parseInt(Q[1], 16),\n\t                    g: parseInt(Q[2], 16),\n\t                    b: parseInt(Q[3], 16)\n\t                } : null) && (B += \"background-color: rgba(\" + S.r + \",\" + S.g + \",\" + S.b + \",\" + M + \");\")) : B += \"background: none;\" : \"none\" === Q && (B += \"background: none;\"),\n\t                F += B;\n\t            if (B = y.getDirectChild(V.element, l, \"drawing-page-properties\"))\n\t                M = B,\n\t                Q = \"\" + d(M, A),\n\t                \"true\" === M.getAttributeNS(h, \"background-visible\") && (Q += \"background: none;\"),\n\t                F += Q,\n\t                n(a, D, B, V);\n\t            if (B = y.getDirectChild(V.element, l, \"table-cell-properties\"))\n\t                D = F,\n\t                F = \"\" + d(B, I),\n\t                F = D + F;\n\t            if (B = y.getDirectChild(V.element, l, \"table-row-properties\"))\n\t                D = F,\n\t                F = \"\" + d(B, L),\n\t                F = D + F;\n\t            if (B = y.getDirectChild(V.element, l, \"table-column-properties\"))\n\t                D = F,\n\t                F = \"\" + d(B, K),\n\t                F = D + F;\n\t            if (B = y.getDirectChild(V.element, l, \"table-properties\"))\n\t                D = F,\n\t                F = \"\" + d(B, E),\n\t                B = B.getAttributeNS(c, \"border-model\"),\n\t                \"collapsing\" === B ? F += \"border-collapse:collapse;\" : \"separating\" === B && (F += \"border-collapse:separate;\"),\n\t                F = D + F;\n\t            0 !== F.length && a.insertRule(P + \"{\" + F + \"}\", a.cssRules.length)\n\t        }\n\t        for (var X in V.derivedStyles)\n\t            V.derivedStyles.hasOwnProperty(X) && p(a, f, X, V.derivedStyles[X])\n\t    }\n\t    var r = odf.Namespaces.drawns, q = odf.Namespaces.fons, e = odf.Namespaces.officens, l = odf.Namespaces.stylens, a = odf.Namespaces.svgns, c = odf.Namespaces.tablens, m = odf.Namespaces.xlinkns, h = odf.Namespaces.presentationns, y = core.DomUtils, x = new odf.StyleParseUtils, z = {\n\t        graphic: \"draw\",\n\t        \"drawing-page\": \"draw\",\n\t        paragraph: \"text\",\n\t        presentation: \"presentation\",\n\t        ruby: \"text\",\n\t        section: \"text\",\n\t        table: \"table\",\n\t        \"table-cell\": \"table\",\n\t        \"table-column\": \"table\",\n\t        \"table-row\": \"table\",\n\t        text: \"text\",\n\t        list: \"text\",\n\t        page: \"office\"\n\t    }, w = {\n\t        graphic: \"circle connected control custom-shape ellipse frame g line measure page page-thumbnail path polygon polyline rect regular-polygon\".split(\" \"),\n\t        paragraph: \"alphabetical-index-entry-template h illustration-index-entry-template index-source-style object-index-entry-template p table-index-entry-template table-of-content-entry-template user-index-entry-template\".split(\" \"),\n\t        presentation: \"caption circle connector control custom-shape ellipse frame g line measure page-thumbnail path polygon polyline rect regular-polygon\".split(\" \"),\n\t        \"drawing-page\": \"caption circle connector control page custom-shape ellipse frame g line measure page-thumbnail path polygon polyline rect regular-polygon\".split(\" \"),\n\t        ruby: [\"ruby\", \"ruby-text\"],\n\t        section: \"alphabetical-index bibliography illustration-index index-title object-index section table-of-content table-index user-index\".split(\" \"),\n\t        table: [\"background\", \"table\"],\n\t        \"table-cell\": \"body covered-table-cell even-columns even-rows first-column first-row last-column last-row odd-columns odd-rows table-cell\".split(\" \"),\n\t        \"table-column\": [\"table-column\"],\n\t        \"table-row\": [\"table-row\"],\n\t        text: \"a index-entry-chapter index-entry-link-end index-entry-link-start index-entry-page-number index-entry-span index-entry-tab-stop index-entry-text index-title-template linenumbering-configuration list-level-style-number list-level-style-bullet outline-level-style span\".split(\" \"),\n\t        list: [\"list-item\"]\n\t    }, v = [[q, \"color\", \"color\"], [q, \"background-color\", \"background-color\"], [q, \"font-weight\", \"font-weight\"], [q, \"font-style\", \"font-style\"]], u = [[l, \"repeat\", \"background-repeat\"]], t = [[q, \"background-color\", \"background-color\"], [q, \"text-align\", \"text-align\"], [q, \"text-indent\", \"text-indent\"], [q, \"padding\", \"padding\"], [q, \"padding-left\", \"padding-left\"], [q, \"padding-right\", \"padding-right\"], [q, \"padding-top\", \"padding-top\"], [q, \"padding-bottom\", \"padding-bottom\"], [q, \"border-left\", \"border-left\"], [q, \"border-right\", \"border-right\"], [q, \"border-top\", \"border-top\"], [q, \"border-bottom\", \"border-bottom\"], [q, \"margin\", \"margin\"], [q, \"margin-left\", \"margin-left\"], [q, \"margin-right\", \"margin-right\"], [q, \"margin-top\", \"margin-top\"], [q, \"margin-bottom\", \"margin-bottom\"], [q, \"border\", \"border\"]], A = [[q, \"background-color\", \"background-color\"], [q, \"min-height\", \"min-height\"], [r, \"stroke\", \"border\"], [a, \"stroke-color\", \"border-color\"], [a, \"stroke-width\", \"border-width\"], [q, \"border\", \"border\"], [q, \"border-left\", \"border-left\"], [q, \"border-right\", \"border-right\"], [q, \"border-top\", \"border-top\"], [q, \"border-bottom\", \"border-bottom\"]], I = [[q, \"background-color\", \"background-color\"], [q, \"border-left\", \"border-left\"], [q, \"border-right\", \"border-right\"], [q, \"border-top\", \"border-top\"], [q, \"border-bottom\", \"border-bottom\"], [q, \"border\", \"border\"]], K = [[l, \"column-width\", \"width\"]], L = [[l, \"row-height\", \"height\"], [q, \"keep-together\", null]], E = [[l, \"width\", \"width\"], [q, \"margin-left\", \"margin-left\"], [q, \"margin-right\", \"margin-right\"], [q, \"margin-top\", \"margin-top\"], [q, \"margin-bottom\", \"margin-bottom\"]], N = [[q, \"background-color\", \"background-color\"], [q, \"padding\", \"padding\"], [q, \"padding-left\", \"padding-left\"], [q, \"padding-right\", \"padding-right\"], [q, \"padding-top\", \"padding-top\"], [q, \"padding-bottom\", \"padding-bottom\"], [q, \"border\", \"border\"], [q, \"border-left\", \"border-left\"], [q, \"border-right\", \"border-right\"], [q, \"border-top\", \"border-top\"], [q, \"border-bottom\", \"border-bottom\"], [q, \"margin\", \"margin\"], [q, \"margin-left\", \"margin-left\"], [q, \"margin-right\", \"margin-right\"], [q, \"margin-top\", \"margin-top\"], [q, \"margin-bottom\", \"margin-bottom\"]], O = [[q, \"page-width\", \"width\"], [q, \"page-height\", \"height\"]], D = {\n\t        border: !0,\n\t        \"border-left\": !0,\n\t        \"border-right\": !0,\n\t        \"border-top\": !0,\n\t        \"border-bottom\": !0,\n\t        \"stroke-width\": !0\n\t    }, V = {\n\t        margin: !0,\n\t        \"margin-left\": !0,\n\t        \"margin-right\": !0,\n\t        \"margin-top\": !0,\n\t        \"margin-bottom\": !0\n\t    }, W = {}, J = odf.OdfUtils, R, P, aa, S = xmldom.XPath, fa = new core.CSSUnits;\n\t    this.style2css = function(a, c, b, d, e) {\n\t        function h(a, c) {\n\t            m = \"@namespace \" + a + \" url(\" + c + \");\";\n\t            try {\n\t                b.insertRule(m, b.cssRules.length)\n\t            } catch (d) {}\n\t        }\n\t        var m, f, l;\n\t        for (P = c; b.cssRules.length; )\n\t            b.deleteRule(b.cssRules.length - 1);\n\t        odf.Namespaces.forEachPrefix(h);\n\t        h(\"webodfhelper\", \"urn:webodf:names:helper\");\n\t        W = d;\n\t        R = a;\n\t        aa = runtime.getWindow().getComputedStyle(document.body, null).getPropertyValue(\"font-size\") || \"12pt\";\n\t        for (l in z)\n\t            if (z.hasOwnProperty(l))\n\t                for (f in a = e[l],\n\t                a)\n\t                    a.hasOwnProperty(f) && p(b, l, f, a[f])\n\t    }\n\t}\n\t;\n\t(function() {\n\t    function g(k, d) {\n\t        var b = this;\n\t        this.getDistance = function(d) {\n\t            var n = b.x - d.x;\n\t            d = b.y - d.y;\n\t            return Math.sqrt(n * n + d * d)\n\t        }\n\t        ;\n\t        this.getCenter = function(d) {\n\t            return new g((b.x + d.x) / 2,(b.y + d.y) / 2)\n\t        }\n\t        ;\n\t        b.x = k;\n\t        b.y = d\n\t    }\n\t    gui.ZoomHelper = function() {\n\t        function k(a, b, d, e) {\n\t            a = e ? \"translate3d(\" + a + \"px, \" + b + \"px, 0) scale3d(\" + d + \", \" + d + \", 1)\" : \"translate(\" + a + \"px, \" + b + \"px) scale(\" + d + \")\";\n\t            c.style.WebkitTransform = a;\n\t            c.style.MozTransform = a;\n\t            c.style.msTransform = a;\n\t            c.style.OTransform = a;\n\t            c.style.transform = a\n\t        }\n\t        function d(a) {\n\t            a ? k(-m.x, -m.y, x, !0) : (k(0, 0, x, !0),\n\t            k(0, 0, x, !1))\n\t        }\n\t        function b(a) {\n\t            if (w && I) {\n\t                var c = w.style.overflow\n\t                  , b = w.classList.contains(\"webodf-customScrollbars\");\n\t                a && b || !a && !b || (a ? (w.classList.add(\"webodf-customScrollbars\"),\n\t                w.style.overflow = \"hidden\",\n\t                runtime.requestAnimationFrame(function() {\n\t                    w.style.overflow = c\n\t                })) : w.classList.remove(\"webodf-customScrollbars\"))\n\t            }\n\t        }\n\t        function f() {\n\t            k(-m.x, -m.y, x, !0);\n\t            w.scrollLeft = 0;\n\t            w.scrollTop = 0;\n\t            K = v.style.overflow;\n\t            v.style.overflow = \"visible\";\n\t            b(!1)\n\t        }\n\t        function n() {\n\t            k(0, 0, x, !0);\n\t            w.scrollLeft = m.x;\n\t            w.scrollTop = m.y;\n\t            v.style.overflow = K || \"\";\n\t            b(!0)\n\t        }\n\t        function p(a) {\n\t            return new g(a.pageX - c.offsetLeft,a.pageY - c.offsetTop)\n\t        }\n\t        function r(a) {\n\t            if (h) {\n\t                m.x -= a.x - h.x;\n\t                m.y -= a.y - h.y;\n\t                var b = m;\n\t                m = new g(Math.min(Math.max(b.x, c.offsetLeft), (c.offsetLeft + c.offsetWidth) * x - w.clientWidth),Math.min(Math.max(b.y, c.offsetTop), (c.offsetTop + c.offsetHeight) * x - w.clientHeight))\n\t            }\n\t            h = a\n\t        }\n\t        function q(a) {\n\t            var c = a.touches.length\n\t              , b = 0 < c ? p(a.touches[0]) : null;\n\t            a = 1 < c ? p(a.touches[1]) : null;\n\t            b && a ? (y = b.getDistance(a),\n\t            z = x,\n\t            h = b.getCenter(a),\n\t            f(),\n\t            A = t.PINCH) : b && (h = b,\n\t            A = t.SCROLL)\n\t        }\n\t        function e(a) {\n\t            var b = a.touches.length\n\t              , e = 0 < b ? p(a.touches[0]) : null\n\t              , b = 1 < b ? p(a.touches[1]) : null;\n\t            if (e && b)\n\t                if (a.preventDefault(),\n\t                A === t.SCROLL)\n\t                    A = t.PINCH,\n\t                    f(),\n\t                    y = e.getDistance(b);\n\t                else {\n\t                    a = e.getCenter(b);\n\t                    e = e.getDistance(b) / y;\n\t                    r(a);\n\t                    var b = x\n\t                      , h = Math.min(4, c.offsetParent.clientWidth / c.offsetWidth);\n\t                    x = z * e;\n\t                    x = Math.min(Math.max(x, h), 4);\n\t                    e = x / b;\n\t                    m.x += (e - 1) * (a.x + m.x);\n\t                    m.y += (e - 1) * (a.y + m.y);\n\t                    d(!0)\n\t                }\n\t            else\n\t                e && (A === t.PINCH ? (A = t.SCROLL,\n\t                n()) : r(e))\n\t        }\n\t        function l() {\n\t            A === t.PINCH && (u.emit(gui.ZoomHelper.signalZoomChanged, x),\n\t            n(),\n\t            d(!1));\n\t            A = t.NONE\n\t        }\n\t        function a() {\n\t            w && (w.removeEventListener(\"touchstart\", q, !1),\n\t            w.removeEventListener(\"touchmove\", e, !1),\n\t            w.removeEventListener(\"touchend\", l, !1))\n\t        }\n\t        var c, m, h, y, x, z, w, v, u = new core.EventNotifier([gui.ZoomHelper.signalZoomChanged]), t = {\n\t            NONE: 0,\n\t            SCROLL: 1,\n\t            PINCH: 2\n\t        }, A = t.NONE, I = runtime.getWindow().hasOwnProperty(\"ontouchstart\"), K = \"\";\n\t        this.subscribe = function(a, c) {\n\t            u.subscribe(a, c)\n\t        }\n\t        ;\n\t        this.unsubscribe = function(a, c) {\n\t            u.unsubscribe(a, c)\n\t        }\n\t        ;\n\t        this.getZoomLevel = function() {\n\t            return x\n\t        }\n\t        ;\n\t        this.setZoomLevel = function(a) {\n\t            c && (x = a,\n\t            d(!1),\n\t            u.emit(gui.ZoomHelper.signalZoomChanged, x))\n\t        }\n\t        ;\n\t        this.destroy = function(c) {\n\t            a();\n\t            b(!1);\n\t            c()\n\t        }\n\t        ;\n\t        this.setZoomableElement = function(h) {\n\t            a();\n\t            c = h;\n\t            w = c.offsetParent;\n\t            v = c.parentNode;\n\t            d(!1);\n\t            w && (w.addEventListener(\"touchstart\", q, !1),\n\t            w.addEventListener(\"touchmove\", e, !1),\n\t            w.addEventListener(\"touchend\", l, !1));\n\t            b(!0)\n\t        }\n\t        ;\n\t        z = x = 1;\n\t        m = new g(0,0)\n\t    }\n\t    ;\n\t    gui.ZoomHelper.signalZoomChanged = \"zoomChanged\"\n\t}\n\t)();\n\tops.Canvas = function() {}\n\t;\n\tops.Canvas.prototype.getZoomLevel = function() {}\n\t;\n\tops.Canvas.prototype.getElement = function() {}\n\t;\n\tops.Canvas.prototype.getSizer = function() {}\n\t;\n\tops.Canvas.prototype.getZoomHelper = function() {}\n\t;\n\t(function() {\n\t    function g() {\n\t        function a(d) {\n\t            b = !0;\n\t            runtime.setTimeout(function() {\n\t                try {\n\t                    d()\n\t                } catch (e) {\n\t                    runtime.log(String(e) + \"\\n\" + e.stack)\n\t                }\n\t                b = !1;\n\t                0 < c.length && a(c.pop())\n\t            }, 10)\n\t        }\n\t        var c = []\n\t          , b = !1;\n\t        this.clearQueue = function() {\n\t            c.length = 0\n\t        }\n\t        ;\n\t        this.addToQueue = function(d) {\n\t            if (0 === c.length && !b)\n\t                return a(d);\n\t            c.push(d)\n\t        }\n\t    }\n\t    function k(a) {\n\t        function c() {\n\t            for (; 0 < b.cssRules.length; )\n\t                b.deleteRule(0);\n\t            b.insertRule(\"#shadowContent draw|page {display:none;}\", 0);\n\t            b.insertRule(\"office|presentation draw|page {display:none;}\", 1);\n\t            b.insertRule(\"#shadowContent draw|page:nth-of-type(\" + d + \") {display:block;}\", 2);\n\t            b.insertRule(\"office|presentation draw|page:nth-of-type(\" + d + \") {display:block;}\", 3)\n\t        }\n\t        var b = a.sheet\n\t          , d = 1;\n\t        this.showFirstPage = function() {\n\t            d = 1;\n\t            c()\n\t        }\n\t        ;\n\t        this.showNextPage = function() {\n\t            d += 1;\n\t            c()\n\t        }\n\t        ;\n\t        this.showPreviousPage = function() {\n\t            1 < d && (--d,\n\t            c())\n\t        }\n\t        ;\n\t        this.showPage = function(a) {\n\t            0 < a && (d = a,\n\t            c())\n\t        }\n\t        ;\n\t        this.css = a;\n\t        this.destroy = function(c) {\n\t            a.parentNode.removeChild(a);\n\t            c()\n\t        }\n\t    }\n\t    function d(a) {\n\t        a = a.sheet;\n\t        for (var c = a.cssRules; c.length; )\n\t            a.deleteRule(c.length - 1)\n\t    }\n\t    function b(a, c, b) {\n\t        var d = new odf.Style2CSS\n\t          , e = new odf.ListStyleToCss;\n\t        b = b.sheet;\n\t        var h = (new odf.StyleTree(a.rootElement.styles,a.rootElement.automaticStyles)).getStyleTree();\n\t        d.style2css(a.getDocumentType(), a.rootElement, b, c.getFontMap(), h);\n\t        e.applyListStyles(b, h, a.rootElement.body)\n\t    }\n\t    function f(a, c) {\n\t        (new odf.FontLoader).loadFonts(a, c.sheet)\n\t    }\n\t    function n(a, c, b) {\n\t        var d = null;\n\t        a = a.rootElement.body.getElementsByTagNameNS(L, b + \"-decl\");\n\t        b = c.getAttributeNS(L, \"use-\" + b + \"-name\");\n\t        var e;\n\t        if (b && 0 < a.length)\n\t            for (c = 0; c < a.length; c += 1)\n\t                if (e = a[c],\n\t                e.getAttributeNS(L, \"name\") === b) {\n\t                    d = e.textContent;\n\t                    break\n\t                }\n\t        return d\n\t    }\n\t    function p(a, c, b, d) {\n\t        var e = a.ownerDocument;\n\t        c = N.getElementsByTagNameNS(a, c, b);\n\t        for (a = 0; a < c.length; a += 1)\n\t            N.removeAllChildNodes(c[a]),\n\t            d && (b = c[a],\n\t            b.appendChild(e.createTextNode(d)))\n\t    }\n\t    function r(a, c, b) {\n\t        c.setAttributeNS(\"urn:webodf:names:helper\", \"styleid\", a);\n\t        var d, e = c.getAttributeNS(I, \"anchor-type\"), h = c.getAttributeNS(t, \"x\"), m = c.getAttributeNS(t, \"y\"), f = c.getAttributeNS(t, \"width\"), l = c.getAttributeNS(t, \"height\"), n = c.getAttributeNS(w, \"min-height\"), g = c.getAttributeNS(w, \"min-width\");\n\t        if (\"as-char\" === e)\n\t            d = \"display: inline-block;\";\n\t        else if (e || h || m)\n\t            d = \"position: absolute;\";\n\t        else if (f || l || n || g)\n\t            d = \"display: block;\";\n\t        h && (d += \"left: \" + h + \";\");\n\t        m && (d += \"top: \" + m + \";\");\n\t        f && (d += \"width: \" + f + \";\");\n\t        l && (d += \"height: \" + l + \";\");\n\t        n && (d += \"min-height: \" + n + \";\");\n\t        g && (d += \"min-width: \" + g + \";\");\n\t        d && (d = \"draw|\" + c.localName + '[webodfhelper|styleid=\"' + a + '\"] {' + d + \"}\",\n\t        b.insertRule(d, b.cssRules.length))\n\t    }\n\t    function q(a) {\n\t        for (a = a.firstChild; a; ) {\n\t            if (a.namespaceURI === v && \"binary-data\" === a.localName)\n\t                return \"data:image/png;base64,\" + a.textContent.replace(/[\\r\\n\\s]/g, \"\");\n\t            a = a.nextSibling\n\t        }\n\t        return \"\"\n\t    }\n\t    function e(a, c, b, d) {\n\t        function e(c) {\n\t            c && (c = 'draw|image[webodfhelper|styleid=\"' + a + '\"] {' + (\"background-image: url(\" + c + \");\") + \"}\",\n\t            d.insertRule(c, d.cssRules.length))\n\t        }\n\t        function h(a) {\n\t            e(a.url)\n\t        }\n\t        b.setAttributeNS(\"urn:webodf:names:helper\", \"styleid\", a);\n\t        var m = b.getAttributeNS(K, \"href\"), f;\n\t        if (m)\n\t            try {\n\t                f = c.getPart(m),\n\t                f.onchange = h,\n\t                f.load()\n\t            } catch (l) {\n\t                runtime.log(\"slight problem: \" + String(l))\n\t            }\n\t        else\n\t            m = q(b),\n\t            e(m)\n\t    }\n\t    function l(a) {\n\t        var c = a.ownerDocument;\n\t        N.getElementsByTagNameNS(a, I, \"line-break\").forEach(function(a) {\n\t            a.hasChildNodes() || a.appendChild(c.createElement(\"br\"))\n\t        })\n\t    }\n\t    function a(a) {\n\t        var c = a.ownerDocument;\n\t        N.getElementsByTagNameNS(a, I, \"s\").forEach(function(a) {\n\t            var b, d;\n\t            N.removeAllChildNodes(a);\n\t            a.appendChild(c.createTextNode(\" \"));\n\t            d = parseInt(a.getAttributeNS(I, \"c\"), 10);\n\t            if (1 < d)\n\t                for (a.removeAttributeNS(I, \"c\"),\n\t                b = 1; b < d; b += 1)\n\t                    a.parentNode.insertBefore(a.cloneNode(!0), a)\n\t        })\n\t    }\n\t    function c(a) {\n\t        N.getElementsByTagNameNS(a, I, \"tab\").forEach(function(a) {\n\t            a.textContent = \"\\t\"\n\t        })\n\t    }\n\t    function m(a, c) {\n\t        function b(a, d) {\n\t            var m = f.documentElement.namespaceURI;\n\t            \"video/\" === d.substr(0, 6) ? (e = f.createElementNS(m, \"video\"),\n\t            e.setAttribute(\"controls\", \"controls\"),\n\t            h = f.createElementNS(m, \"source\"),\n\t            a && h.setAttribute(\"src\", a),\n\t            h.setAttribute(\"type\", d),\n\t            e.appendChild(h),\n\t            c.parentNode.appendChild(e)) : c.innerHtml = \"Unrecognised Plugin\"\n\t        }\n\t        function d(a) {\n\t            b(a.url, a.mimetype)\n\t        }\n\t        var e, h, m, f = c.ownerDocument, l;\n\t        if (m = c.getAttributeNS(K, \"href\"))\n\t            try {\n\t                l = a.getPart(m),\n\t                l.onchange = d,\n\t                l.load()\n\t            } catch (n) {\n\t                runtime.log(\"slight problem: \" + String(n))\n\t            }\n\t        else\n\t            runtime.log(\"using MP4 data fallback\"),\n\t            m = q(c),\n\t            b(m, \"video/mp4\")\n\t    }\n\t    function h(a) {\n\t        var c = a.getElementsByTagName(\"head\")[0], b, d;\n\t        b = a.styleSheets.length;\n\t        for (d = c.firstElementChild; d && (\"style\" !== d.localName || !d.hasAttribute(\"webodfcss\")); )\n\t            d = d.nextElementSibling;\n\t        if (d)\n\t            return b = parseInt(d.getAttribute(\"webodfcss\"), 10),\n\t            d.setAttribute(\"webodfcss\", b + 1),\n\t            d;\n\t        \"string\" === String(typeof webodf_css) ? b = webodf_css : (d = \"webodf.css\",\n\t        runtime.currentDirectory && (d = runtime.currentDirectory(),\n\t        0 < d.length && \"/\" !== d.substr(-1) && (d += \"/\"),\n\t        d += \"../webodf.css\"),\n\t        b = runtime.readFileSync(d, \"utf-8\"));\n\t        d = a.createElementNS(c.namespaceURI, \"style\");\n\t        d.setAttribute(\"media\", \"screen, print, handheld, projection\");\n\t        d.setAttribute(\"type\", \"text/css\");\n\t        d.setAttribute(\"webodfcss\", \"1\");\n\t        d.appendChild(a.createTextNode(b));\n\t        c.appendChild(d);\n\t        return d\n\t    }\n\t    function y(a) {\n\t        var c = parseInt(a.getAttribute(\"webodfcss\"), 10);\n\t        1 === c ? a.parentNode.removeChild(a) : a.setAttribute(\"count\", c - 1)\n\t    }\n\t    function x(a) {\n\t        var c = a.getElementsByTagName(\"head\")[0]\n\t          , b = a.createElementNS(c.namespaceURI, \"style\")\n\t          , d = \"\";\n\t        b.setAttribute(\"type\", \"text/css\");\n\t        b.setAttribute(\"media\", \"screen, print, handheld, projection\");\n\t        odf.Namespaces.forEachPrefix(function(a, c) {\n\t            d += \"@namespace \" + a + \" url(\" + c + \");\\n\"\n\t        });\n\t        d += \"@namespace webodfhelper url(urn:webodf:names:helper);\\n\";\n\t        b.appendChild(a.createTextNode(d));\n\t        c.appendChild(b);\n\t        return b\n\t    }\n\t    var z = odf.Namespaces.drawns\n\t      , w = odf.Namespaces.fons\n\t      , v = odf.Namespaces.officens\n\t      , u = odf.Namespaces.stylens\n\t      , t = odf.Namespaces.svgns\n\t      , A = odf.Namespaces.tablens\n\t      , I = odf.Namespaces.textns\n\t      , K = odf.Namespaces.xlinkns\n\t      , L = odf.Namespaces.presentationns\n\t      , E = xmldom.XPath\n\t      , N = core.DomUtils;\n\t    odf.OdfCanvas = function(q, D) {\n\t        function t(a, c, b) {\n\t            function d(a, c, b, h) {\n\t                na.addToQueue(function() {\n\t                    e(a, c, b, h)\n\t                })\n\t            }\n\t            var h, m;\n\t            h = c.getElementsByTagNameNS(z, \"image\");\n\t            for (c = 0; c < h.length; c += 1)\n\t                m = h.item(c),\n\t                d(\"image\" + String(c), a, m, b)\n\t        }\n\t        function W(a, c) {\n\t            function b(a, c) {\n\t                na.addToQueue(function() {\n\t                    m(a, c)\n\t                })\n\t            }\n\t            var d, e, h;\n\t            e = c.getElementsByTagNameNS(z, \"plugin\");\n\t            for (d = 0; d < e.length; d += 1)\n\t                h = e.item(d),\n\t                b(a, h)\n\t        }\n\t        function w() {\n\t            var a;\n\t            a = U.firstChild;\n\t            var c = ea.getZoomLevel();\n\t            a && (U.style.WebkitTransformOrigin = \"0% 0%\",\n\t            U.style.MozTransformOrigin = \"0% 0%\",\n\t            U.style.msTransformOrigin = \"0% 0%\",\n\t            U.style.OTransformOrigin = \"0% 0%\",\n\t            U.style.transformOrigin = \"0% 0%\",\n\t            M && ((a = M.getMinimumHeightForAnnotationPane()) ? U.style.minHeight = a : U.style.removeProperty(\"min-height\")),\n\t            q.style.width = Math.round(c * U.offsetWidth) + \"px\",\n\t            q.style.height = Math.round(c * U.offsetHeight) + \"px\",\n\t            q.style.display = \"inline-block\")\n\t        }\n\t        function K(b, d) {\n\t            var e = ca.sheet;\n\t            N.removeAllChildNodes(q);\n\t            U = ha.createElementNS(q.namespaceURI, \"div\");\n\t            U.style.display = \"inline-block\";\n\t            U.style.background = \"white\";\n\t            U.style.setProperty(\"float\", \"left\", \"important\");\n\t            U.appendChild(d);\n\t            q.appendChild(U);\n\t            ga = ha.createElementNS(q.namespaceURI, \"div\");\n\t            ga.id = \"annotationsPane\";\n\t            X = ha.createElementNS(q.namespaceURI, \"div\");\n\t            X.id = \"shadowContent\";\n\t            X.style.position = \"absolute\";\n\t            X.style.top = 0;\n\t            X.style.left = 0;\n\t            b.getContentElement().appendChild(X);\n\t            var h = d.body, m, f = [], g;\n\t            for (m = h.firstElementChild; m && m !== h; )\n\t                if (m.namespaceURI === z && (f[f.length] = m),\n\t                m.firstElementChild)\n\t                    m = m.firstElementChild;\n\t                else {\n\t                    for (; m && m !== h && !m.nextElementSibling; )\n\t                        m = m.parentNode;\n\t                    m && m.nextElementSibling && (m = m.nextElementSibling)\n\t                }\n\t            for (g = 0; g < f.length; g += 1)\n\t                m = f[g],\n\t                r(\"frame\" + String(g), m, e);\n\t            f = E.getODFElementsWithXPath(h, \".//*[*[@text:anchor-type='paragraph']]\", odf.Namespaces.lookupNamespaceURI);\n\t            for (m = 0; m < f.length; m += 1)\n\t                h = f[m],\n\t                h.setAttributeNS && h.setAttributeNS(\"urn:webodf:names:helper\", \"containsparagraphanchor\", !0);\n\t            h = Z;\n\t            m = X;\n\t            var k, D, y, x, w = 0, J;\n\t            g = b.rootElement.ownerDocument;\n\t            if ((f = d.body.firstElementChild) && f.namespaceURI === v && (\"presentation\" === f.localName || \"drawing\" === f.localName))\n\t                for (f = f.firstElementChild; f; ) {\n\t                    if (k = (k = f.getAttributeNS(z, \"master-page-name\")) ? h.getMasterPageElement(k) : null) {\n\t                        D = f.getAttributeNS(\"urn:webodf:names:helper\", \"styleid\");\n\t                        y = g.createElementNS(z, \"draw:page\");\n\t                        J = k.firstElementChild;\n\t                        for (w = 0; J; )\n\t                            \"true\" !== J.getAttributeNS(L, \"placeholder\") && (x = J.cloneNode(!0),\n\t                            y.appendChild(x)),\n\t                            J = J.nextElementSibling,\n\t                            w += 1;\n\t                        J = x = w = void 0;\n\t                        for (var B = N.getElementsByTagNameNS(y, z, \"frame\"), w = 0; w < B.length; w += 1)\n\t                            x = B[w],\n\t                            (J = x.getAttributeNS(L, \"class\")) && !/^(date-time|footer|header|page-number)$/.test(J) && x.parentNode.removeChild(x);\n\t                        x = N.getElementsByTagNameNS(y, z, \"*\");\n\t                        for (w = 0; w < x.length; w += 1)\n\t                            r(D + \"_\" + w, x[w], e);\n\t                        m.appendChild(y);\n\t                        w = String(m.getElementsByTagNameNS(z, \"page\").length);\n\t                        p(y, I, \"page-number\", w);\n\t                        p(y, L, \"header\", n(b, f, \"header\"));\n\t                        p(y, L, \"footer\", n(b, f, \"footer\"));\n\t                        r(D, y, e);\n\t                        y.setAttributeNS(\"urn:webodf:names:helper\", \"page-style-name\", f.getAttributeNS(z, \"style-name\"));\n\t                        y.setAttributeNS(z, \"draw:master-page-name\", k.getAttributeNS(u, \"name\"))\n\t                    }\n\t                    f = f.nextElementSibling\n\t                }\n\t            h = q.namespaceURI;\n\t            f = N.getElementsByTagNameNS(d.body, A, \"table-cell\");\n\t            for (m = 0; m < f.length; m += 1)\n\t                g = f[m],\n\t                g.hasAttributeNS(A, \"number-columns-spanned\") && g.setAttributeNS(h, \"colspan\", g.getAttributeNS(A, \"number-columns-spanned\")),\n\t                g.hasAttributeNS(A, \"number-rows-spanned\") && g.setAttributeNS(h, \"rowspan\", g.getAttributeNS(A, \"number-rows-spanned\"));\n\t            l(d.body);\n\t            a(d.body);\n\t            c(d.body);\n\t            t(b, d.body, e);\n\t            W(b, d.body);\n\t            U.insertBefore(X, U.firstChild);\n\t            ea.setZoomableElement(U)\n\t        }\n\t        function P(a) {\n\t            B ? (ga.parentNode || U.appendChild(ga),\n\t            M && M.forgetAnnotations(),\n\t            M = new gui.AnnotationViewManager(fa,a.body,ga,Y),\n\t            a = N.getElementsByTagNameNS(a.body, v, \"annotation\"),\n\t            M.addAnnotations(a),\n\t            w()) : ga.parentNode && (U.removeChild(ga),\n\t            M.forgetAnnotations(),\n\t            w())\n\t        }\n\t        function aa(a) {\n\t            function c() {\n\t                d(F);\n\t                d(ja);\n\t                d(ca);\n\t                N.removeAllChildNodes(q);\n\t                q.style.display = \"inline-block\";\n\t                var e = C.rootElement;\n\t                q.ownerDocument.importNode(e, !0);\n\t                Z.setOdfContainer(C);\n\t                f(C, F);\n\t                b(C, Z, ja);\n\t                K(C, e);\n\t                P(e);\n\t                a || na.addToQueue(function() {\n\t                    var a = [C];\n\t                    if (da.hasOwnProperty(\"statereadychange\")) {\n\t                        var c = da.statereadychange, b;\n\t                        for (b = 0; b < c.length; b += 1)\n\t                            c[b].apply(null, a)\n\t                    }\n\t                })\n\t            }\n\t            C.state === odf.OdfContainer.DONE ? c() : (runtime.log(\"WARNING: refreshOdf called but ODF was not DONE.\"),\n\t            qa = runtime.setTimeout(function T() {\n\t                C.state === odf.OdfContainer.DONE ? c() : (runtime.log(\"will be back later...\"),\n\t                qa = runtime.setTimeout(T, 500))\n\t            }, 100))\n\t        }\n\t        function S(a) {\n\t            na.clearQueue();\n\t            N.removeAllChildNodes(q);\n\t            q.appendChild(q.ownerDocument.createTextNode(runtime.tr(\"Loading\") + a + \"...\"));\n\t            q.removeAttribute(\"style\");\n\t            C = new odf.OdfContainer(a,function(a) {\n\t                C = a;\n\t                aa(!1)\n\t            }\n\t            )\n\t        }\n\t        runtime.assert(null !== q && void 0 !== q, \"odf.OdfCanvas constructor needs DOM element\");\n\t        runtime.assert(null !== q.ownerDocument && void 0 !== q.ownerDocument, \"odf.OdfCanvas constructor needs DOM\");\n\t        var fa = this, ha = q.ownerDocument, C, Z = new odf.Formatting, ba, U = null, ga = null, B = !1, Y = !1, M = null, Q, F, ja, ca, X, da = {}, qa, la, ia = !1, ma = !1, na = new g, ea = new gui.ZoomHelper, ka = D || new gui.SingleScrollViewport(q.parentNode);\n\t        this.refreshCSS = function() {\n\t            ia = !0;\n\t            la.trigger()\n\t        }\n\t        ;\n\t        this.refreshSize = function() {\n\t            la.trigger()\n\t        }\n\t        ;\n\t        this.odfContainer = function() {\n\t            return C\n\t        }\n\t        ;\n\t        this.setOdfContainer = function(a, c) {\n\t            C = a;\n\t            aa(!0 === c)\n\t        }\n\t        ;\n\t        this.load = this.load = S;\n\t        this.save = function(a) {\n\t            C.save(a)\n\t        }\n\t        ;\n\t        this.addListener = function(a, c) {\n\t            switch (a) {\n\t            case \"click\":\n\t                var b = a;\n\t                q.addEventListener ? q.addEventListener(b, c, !1) : q.attachEvent ? q.attachEvent(\"on\" + b, c) : q[\"on\" + b] = c;\n\t                break;\n\t            default:\n\t                b = da.hasOwnProperty(a) ? da[a] : da[a] = [],\n\t                c && -1 === b.indexOf(c) && b.push(c)\n\t            }\n\t        }\n\t        ;\n\t        this.getFormatting = function() {\n\t            return Z\n\t        }\n\t        ;\n\t        this.getAnnotationViewManager = function() {\n\t            return M\n\t        }\n\t        ;\n\t        this.refreshAnnotations = function() {\n\t            P(C.rootElement)\n\t        }\n\t        ;\n\t        this.rerenderAnnotations = function() {\n\t            M && (ma = !0,\n\t            la.trigger())\n\t        }\n\t        ;\n\t        this.getSizer = function() {\n\t            return U\n\t        }\n\t        ;\n\t        this.enableAnnotations = function(a, c) {\n\t            a !== B && (B = a,\n\t            Y = c,\n\t            C && P(C.rootElement))\n\t        }\n\t        ;\n\t        this.addAnnotation = function(a) {\n\t            M && (M.addAnnotations([a]),\n\t            w())\n\t        }\n\t        ;\n\t        this.forgetAnnotation = function(a) {\n\t            M && (M.forgetAnnotation(a),\n\t            w())\n\t        }\n\t        ;\n\t        this.getZoomHelper = function() {\n\t            return ea\n\t        }\n\t        ;\n\t        this.setZoomLevel = function(a) {\n\t            ea.setZoomLevel(a)\n\t        }\n\t        ;\n\t        this.getZoomLevel = function() {\n\t            return ea.getZoomLevel()\n\t        }\n\t        ;\n\t        this.fitToContainingElement = function(a, c) {\n\t            var b = ea.getZoomLevel()\n\t              , d = q.offsetHeight / b\n\t              , b = a / (q.offsetWidth / b);\n\t            c / d < b && (b = c / d);\n\t            ea.setZoomLevel(b)\n\t        }\n\t        ;\n\t        this.fitToWidth = function(a) {\n\t            var c = q.offsetWidth / ea.getZoomLevel();\n\t            ea.setZoomLevel(a / c)\n\t        }\n\t        ;\n\t        this.fitSmart = function(a, c) {\n\t            var b, d;\n\t            d = ea.getZoomLevel();\n\t            b = q.offsetWidth / d;\n\t            d = q.offsetHeight / d;\n\t            b = a / b;\n\t            void 0 !== c && c / d < b && (b = c / d);\n\t            ea.setZoomLevel(Math.min(1, b))\n\t        }\n\t        ;\n\t        this.fitToHeight = function(a) {\n\t            var c = q.offsetHeight / ea.getZoomLevel();\n\t            ea.setZoomLevel(a / c)\n\t        }\n\t        ;\n\t        this.showFirstPage = function() {\n\t            ba.showFirstPage()\n\t        }\n\t        ;\n\t        this.showNextPage = function() {\n\t            ba.showNextPage()\n\t        }\n\t        ;\n\t        this.showPreviousPage = function() {\n\t            ba.showPreviousPage()\n\t        }\n\t        ;\n\t        this.showPage = function(a) {\n\t            ba.showPage(a);\n\t            w()\n\t        }\n\t        ;\n\t        this.getElement = function() {\n\t            return q\n\t        }\n\t        ;\n\t        this.getViewport = function() {\n\t            return ka\n\t        }\n\t        ;\n\t        this.addCssForFrameWithImage = function(a) {\n\t            var c = a.getAttributeNS(z, \"name\")\n\t              , b = a.firstElementChild;\n\t            r(c, a, ca.sheet);\n\t            b && e(c + \"img\", C, b, ca.sheet)\n\t        }\n\t        ;\n\t        this.destroy = function(a) {\n\t            var c = ha.getElementsByTagName(\"head\")[0]\n\t              , b = [ba.destroy, la.destroy];\n\t            runtime.clearTimeout(qa);\n\t            ga && ga.parentNode && ga.parentNode.removeChild(ga);\n\t            ea.destroy(function() {\n\t                U && (q.removeChild(U),\n\t                U = null)\n\t            });\n\t            y(Q);\n\t            c.removeChild(F);\n\t            c.removeChild(ja);\n\t            c.removeChild(ca);\n\t            core.Async.destroyAll(b, a)\n\t        }\n\t        ;\n\t        Q = h(ha);\n\t        ba = new k(x(ha));\n\t        F = x(ha);\n\t        ja = x(ha);\n\t        ca = x(ha);\n\t        la = core.Task.createRedrawTask(function() {\n\t            ia && (b(C, Z, ja),\n\t            ia = !1);\n\t            ma && (M && M.rerenderAnnotations(),\n\t            ma = !1);\n\t            w()\n\t        });\n\t        ea.subscribe(gui.ZoomHelper.signalZoomChanged, w)\n\t    }\n\t}\n\t)();\n\todf.StepUtils = function() {\n\t    this.getContentBounds = function(g) {\n\t        var k = g.container(), d, b;\n\t        runtime.assert(g.isStep(), \"Step iterator must be on a step\");\n\t        k.nodeType === Node.TEXT_NODE && 0 < g.offset() ? d = g.offset() : (k = g.leftNode()) && k.nodeType === Node.TEXT_NODE && (d = k.length);\n\t        k && (k.nodeType === Node.TEXT_NODE ? (runtime.assert(0 < d, \"Empty text node found\"),\n\t        b = {\n\t            container: k,\n\t            startOffset: d - 1,\n\t            endOffset: d\n\t        }) : b = {\n\t            container: k,\n\t            startOffset: 0,\n\t            endOffset: k.childNodes.length\n\t        });\n\t        return b\n\t    }\n\t}\n\t;\n\tops.MemberProperties = function() {}\n\t;\n\tops.Member = function(g, k) {\n\t    var d = new ops.MemberProperties;\n\t    this.getMemberId = function() {\n\t        return g\n\t    }\n\t    ;\n\t    this.getProperties = function() {\n\t        return d\n\t    }\n\t    ;\n\t    this.setProperties = function(b) {\n\t        Object.keys(b).forEach(function(f) {\n\t            d[f] = b[f]\n\t        })\n\t    }\n\t    ;\n\t    this.removeProperties = function(b) {\n\t        Object.keys(b).forEach(function(b) {\n\t            \"fullName\" !== b && \"color\" !== b && \"imageUrl\" !== b && d.hasOwnProperty(b) && delete d[b]\n\t        })\n\t    }\n\t    ;\n\t    runtime.assert(Boolean(g), \"No memberId was supplied!\");\n\t    k.fullName || (k.fullName = runtime.tr(\"Unknown Author\"));\n\t    k.color || (k.color = \"black\");\n\t    k.imageUrl || (k.imageUrl = \"avatar-joe.png\");\n\t    d = k\n\t}\n\t;\n\tops.Document = function() {}\n\t;\n\tops.Document.prototype.getMemberIds = function() {}\n\t;\n\tops.Document.prototype.removeCursor = function(g) {}\n\t;\n\tops.Document.prototype.getDocumentElement = function() {}\n\t;\n\tops.Document.prototype.getRootNode = function() {}\n\t;\n\tops.Document.prototype.getDOMDocument = function() {}\n\t;\n\tops.Document.prototype.cloneDocumentElement = function() {}\n\t;\n\tops.Document.prototype.setDocumentElement = function(g) {}\n\t;\n\tops.Document.prototype.subscribe = function(g, k) {}\n\t;\n\tops.Document.prototype.unsubscribe = function(g, k) {}\n\t;\n\tops.Document.prototype.getCanvas = function() {}\n\t;\n\tops.Document.prototype.createRootFilter = function(g) {}\n\t;\n\tops.Document.prototype.createPositionIterator = function(g) {}\n\t;\n\tops.Document.prototype.hasCursor = function(g) {}\n\t;\n\tops.Document.signalCursorAdded = \"cursor/added\";\n\tops.Document.signalCursorRemoved = \"cursor/removed\";\n\tops.Document.signalCursorMoved = \"cursor/moved\";\n\tops.Document.signalMemberAdded = \"member/added\";\n\tops.Document.signalMemberUpdated = \"member/updated\";\n\tops.Document.signalMemberRemoved = \"member/removed\";\n\tops.OdtCursor = function(g, k) {\n\t    var d = this, b = {}, f, n, p = new core.EventNotifier([ops.OdtCursor.signalCursorUpdated]);\n\t    this.removeFromDocument = function() {\n\t        n.remove()\n\t    }\n\t    ;\n\t    this.subscribe = function(b, d) {\n\t        p.subscribe(b, d)\n\t    }\n\t    ;\n\t    this.unsubscribe = function(b, d) {\n\t        p.unsubscribe(b, d)\n\t    }\n\t    ;\n\t    this.getMemberId = function() {\n\t        return g\n\t    }\n\t    ;\n\t    this.getNode = function() {\n\t        return n.getNode()\n\t    }\n\t    ;\n\t    this.getAnchorNode = function() {\n\t        return n.getAnchorNode()\n\t    }\n\t    ;\n\t    this.getSelectedRange = function() {\n\t        return n.getSelectedRange()\n\t    }\n\t    ;\n\t    this.setSelectedRange = function(b, f) {\n\t        n.setSelectedRange(b, f);\n\t        p.emit(ops.OdtCursor.signalCursorUpdated, d)\n\t    }\n\t    ;\n\t    this.hasForwardSelection = function() {\n\t        return n.hasForwardSelection()\n\t    }\n\t    ;\n\t    this.getDocument = function() {\n\t        return k\n\t    }\n\t    ;\n\t    this.getSelectionType = function() {\n\t        return f\n\t    }\n\t    ;\n\t    this.setSelectionType = function(d) {\n\t        b.hasOwnProperty(d) ? f = d : runtime.log(\"Invalid selection type: \" + d)\n\t    }\n\t    ;\n\t    this.resetSelectionType = function() {\n\t        d.setSelectionType(ops.OdtCursor.RangeSelection)\n\t    }\n\t    ;\n\t    n = new core.Cursor(k.getDOMDocument(),g);\n\t    b[ops.OdtCursor.RangeSelection] = !0;\n\t    b[ops.OdtCursor.RegionSelection] = !0;\n\t    d.resetSelectionType()\n\t}\n\t;\n\tops.OdtCursor.RangeSelection = \"Range\";\n\tops.OdtCursor.RegionSelection = \"Region\";\n\tops.OdtCursor.signalCursorUpdated = \"cursorUpdated\";\n\t(function() {\n\t    var g = 0;\n\t    ops.StepsCache = function(k, d, b) {\n\t        function f(a, c) {\n\t            var d = this;\n\t            this.nodeId = a;\n\t            this.steps = -1;\n\t            this.node = c;\n\t            this.previousBookmark = this.nextBookmark = null;\n\t            this.setIteratorPosition = function(a) {\n\t                a.setPositionBeforeElement(c);\n\t                b(d.steps, a)\n\t            }\n\t        }\n\t        function n(a, c, d) {\n\t            var e = this;\n\t            this.nodeId = a;\n\t            this.steps = c;\n\t            this.node = d;\n\t            this.previousBookmark = this.nextBookmark = null;\n\t            this.setIteratorPosition = function(a) {\n\t                a.setUnfilteredPosition(d, 0);\n\t                b(e.steps, a)\n\t            }\n\t        }\n\t        function p(a, c) {\n\t            var b = \"[\" + a.nodeId;\n\t            c && (b += \" => \" + c.nodeId);\n\t            return b + \"]\"\n\t        }\n\t        function r() {\n\t            if (!0 === ops.StepsCache.ENABLE_CACHE_VERIFICATION) {\n\t                for (var a = x, c, b, d, e = new core.LoopWatchDog(0,1E5), h = {}; a; ) {\n\t                    e.check();\n\t                    (c = a.previousBookmark) ? runtime.assert(c.nextBookmark === a, \"Broken bookmark link to previous @\" + p(c, a)) : (runtime.assert(a === x, \"Broken bookmark link @\" + p(a)),\n\t                    runtime.assert(void 0 === z || x === x || x.steps <= z, \"Base point is damaged @\" + p(a)));\n\t                    (b = a.nextBookmark) && runtime.assert(b.previousBookmark === a, \"Broken bookmark link to next @\" + p(a, b));\n\t                    if (void 0 === z || a === x || a.steps <= z)\n\t                        runtime.assert(y.containsNode(k, a.node), \"Disconnected node is being reported as undamaged @\" + p(a)),\n\t                        c && (d = a.node.compareDocumentPosition(c.node),\n\t                        runtime.assert(0 === d || 0 !== (d & v), \"Bookmark order with previous does not reflect DOM order @\" + p(c, a))),\n\t                        b && y.containsNode(k, b.node) && (d = a.node.compareDocumentPosition(b.node),\n\t                        runtime.assert(0 === d || 0 !== (d & w), \"Bookmark order with next does not reflect DOM order @\" + p(a, b)));\n\t                    a = a.nextBookmark\n\t                }\n\t                Object.keys(m).forEach(function(a) {\n\t                    var c = m[a];\n\t                    (void 0 === z || a <= z) && runtime.assert(c.steps <= a, \"Bookmark step of \" + c.steps + \" exceeds cached step lookup for \" + a + \" @\" + p(c));\n\t                    runtime.assert(!1 === h.hasOwnProperty(c.nodeId), \"Bookmark \" + p(c) + \" appears twice in cached step lookup at steps \" + h[c.nodeId] + \" and \" + a);\n\t                    h[c.nodeId] = a\n\t                })\n\t            }\n\t        }\n\t        function q(a) {\n\t            var c = \"\";\n\t            a.nodeType === Node.ELEMENT_NODE && (c = a.getAttributeNS(\"urn:webodf:names:steps\", \"nodeId\") || \"\");\n\t            return c\n\t        }\n\t        function e(a) {\n\t            var c = g.toString();\n\t            a.setAttributeNS(\"urn:webodf:names:steps\", \"nodeId\", c);\n\t            g += 1;\n\t            return c\n\t        }\n\t        function l(a) {\n\t            var c, b, e = new core.LoopWatchDog(0,1E4);\n\t            void 0 !== z && a > z && (a = z);\n\t            for (c = Math.floor(a / d) * d; !b && 0 <= c; )\n\t                b = m[c],\n\t                c -= d;\n\t            for (b = b || x; b.nextBookmark && b.nextBookmark.steps <= a; )\n\t                e.check(),\n\t                b = b.nextBookmark;\n\t            runtime.assert(-1 === a || b.steps <= a, \"Bookmark @\" + p(b) + \" at step \" + b.steps + \" exceeds requested step of \" + a);\n\t            return b\n\t        }\n\t        function a(a) {\n\t            a.previousBookmark && (a.previousBookmark.nextBookmark = a.nextBookmark);\n\t            a.nextBookmark && (a.nextBookmark.previousBookmark = a.previousBookmark)\n\t        }\n\t        function c(a) {\n\t            for (var c, b = null; !b && a && a !== k; )\n\t                (c = q(a)) && (b = h[c]) && b.node !== a && (runtime.log(\"Cloned node detected. Creating new bookmark\"),\n\t                b = null,\n\t                a.removeAttributeNS(\"urn:webodf:names:steps\", \"nodeId\")),\n\t                a = a.parentNode;\n\t            return b\n\t        }\n\t        var m = {}, h = {}, y = core.DomUtils, x, z, w = Node.DOCUMENT_POSITION_FOLLOWING, v = Node.DOCUMENT_POSITION_PRECEDING;\n\t        this.updateBookmark = function(c, b) {\n\t            var g, n = Math.ceil(c / d) * d, p, v, E;\n\t            if (void 0 !== z && z < c) {\n\t                p = l(z);\n\t                for (v = p.nextBookmark; v && v.steps <= c; )\n\t                    g = v.nextBookmark,\n\t                    E = Math.ceil(v.steps / d) * d,\n\t                    m[E] === v && delete m[E],\n\t                    y.containsNode(k, v.node) ? v.steps = c + 1 : (a(v),\n\t                    delete h[v.nodeId]),\n\t                    v = g;\n\t                z = c\n\t            } else\n\t                p = l(c);\n\t            v = q(b) || e(b);\n\t            g = h[v];\n\t            g ? g.node !== b && (runtime.log(\"Cloned node detected. Creating new bookmark\"),\n\t            v = e(b),\n\t            g = h[v] = new f(v,b)) : g = h[v] = new f(v,b);\n\t            v = g;\n\t            v.steps !== c && (g = Math.ceil(v.steps / d) * d,\n\t            g !== n && m[g] === v && delete m[g],\n\t            v.steps = c);\n\t            if (p !== v && p.nextBookmark !== v) {\n\t                if (p.steps === v.steps)\n\t                    for (; 0 !== (v.node.compareDocumentPosition(p.node) & w) && p !== x; )\n\t                        p = p.previousBookmark;\n\t                p !== v && p.nextBookmark !== v && (a(v),\n\t                g = p.nextBookmark,\n\t                v.nextBookmark = p.nextBookmark,\n\t                v.previousBookmark = p,\n\t                p.nextBookmark = v,\n\t                g && (g.previousBookmark = v))\n\t            }\n\t            p = m[n];\n\t            if (!p || v.steps > p.steps)\n\t                m[n] = v;\n\t            r()\n\t        }\n\t        ;\n\t        this.setToClosestStep = function(a, c) {\n\t            var b;\n\t            r();\n\t            b = l(a);\n\t            b.setIteratorPosition(c);\n\t            return b.steps\n\t        }\n\t        ;\n\t        this.setToClosestDomPoint = function(a, b, d) {\n\t            var e, h;\n\t            r();\n\t            if (a === k && 0 === b)\n\t                e = x;\n\t            else if (a === k && b === k.childNodes.length)\n\t                for (h in e = x,\n\t                m)\n\t                    m.hasOwnProperty(h) && (a = m[h],\n\t                    a.steps > e.steps && (e = a));\n\t            else if (e = c(a.childNodes.item(b) || a),\n\t            !e)\n\t                for (d.setUnfilteredPosition(a, b); !e && d.previousNode(); )\n\t                    e = c(d.getCurrentNode());\n\t            e = e || x;\n\t            void 0 !== z && e.steps > z && (e = l(z));\n\t            e.setIteratorPosition(d);\n\t            return e.steps\n\t        }\n\t        ;\n\t        this.damageCacheAfterStep = function(a) {\n\t            0 > a && (a = -1);\n\t            void 0 === z ? z = a : a < z && (z = a);\n\t            r()\n\t        }\n\t        ;\n\t        (function() {\n\t            var a = q(k) || e(k);\n\t            x = new n(a,0,k)\n\t        }\n\t        )()\n\t    }\n\t    ;\n\t    ops.StepsCache.ENABLE_CACHE_VERIFICATION = !1;\n\t    ops.StepsCache.Bookmark = function() {}\n\t    ;\n\t    ops.StepsCache.Bookmark.prototype.setIteratorPosition = function(g) {}\n\t}\n\t)();\n\t(function() {\n\t    ops.OdtStepsTranslator = function(g, k, d, b) {\n\t        function f(a, b, d) {\n\t            var e = b.getCurrentNode();\n\t            b.isBeforeNode() && r.isParagraph(e) && (d || (a += 1),\n\t            p.updateBookmark(a, e))\n\t        }\n\t        function n(c, b) {\n\t            if (!b || d.acceptPosition(c) === e)\n\t                return !0;\n\t            for (; c.previousPosition(); )\n\t                if (d.acceptPosition(c) === e) {\n\t                    if (b(l, c.container(), c.unfilteredDomOffset()))\n\t                        return !0;\n\t                    break\n\t                }\n\t            for (; c.nextPosition(); )\n\t                if (d.acceptPosition(c) === e) {\n\t                    if (b(a, c.container(), c.unfilteredDomOffset()))\n\t                        return !0;\n\t                    break\n\t                }\n\t            return !1\n\t        }\n\t        var p, r = odf.OdfUtils, q = core.DomUtils, e = core.PositionFilter.FilterResult.FILTER_ACCEPT, l = core.StepDirection.PREVIOUS, a = core.StepDirection.NEXT;\n\t        this.convertStepsToDomPoint = function(a) {\n\t            var b, h;\n\t            if (isNaN(a))\n\t                throw new TypeError(\"Requested steps is not numeric (\" + a + \")\");\n\t            if (0 > a)\n\t                throw new RangeError(\"Requested steps is negative (\" + a + \")\");\n\t            for (b = p.setToClosestStep(a, k); b < a && k.nextPosition(); )\n\t                (h = d.acceptPosition(k) === e) && (b += 1),\n\t                f(b, k, h);\n\t            if (b !== a)\n\t                throw new RangeError(\"Requested steps (\" + a + \") exceeds available steps (\" + b + \")\");\n\t            return {\n\t                node: k.container(),\n\t                offset: k.unfilteredDomOffset()\n\t            }\n\t        }\n\t        ;\n\t        this.convertDomPointToSteps = function(a, b, h) {\n\t            var l;\n\t            q.containsNode(g, a) || (b = 0 > q.comparePoints(g, 0, a, b),\n\t            a = g,\n\t            b = b ? 0 : g.childNodes.length);\n\t            k.setUnfilteredPosition(a, b);\n\t            n(k, h) || k.setUnfilteredPosition(a, b);\n\t            h = k.container();\n\t            b = k.unfilteredDomOffset();\n\t            a = p.setToClosestDomPoint(h, b, k);\n\t            if (0 > q.comparePoints(k.container(), k.unfilteredDomOffset(), h, b))\n\t                return 0 < a ? a - 1 : a;\n\t            for (; (k.container() !== h || k.unfilteredDomOffset() !== b) && k.nextPosition(); )\n\t                (l = d.acceptPosition(k) === e) && (a += 1),\n\t                f(a, k, l);\n\t            return a + 0\n\t        }\n\t        ;\n\t        this.prime = function() {\n\t            var a, b;\n\t            for (a = p.setToClosestStep(0, k); k.nextPosition(); )\n\t                (b = d.acceptPosition(k) === e) && (a += 1),\n\t                f(a, k, b)\n\t        }\n\t        ;\n\t        this.handleStepsInserted = function(a) {\n\t            p.damageCacheAfterStep(a.position)\n\t        }\n\t        ;\n\t        this.handleStepsRemoved = function(a) {\n\t            p.damageCacheAfterStep(a.position - 1)\n\t        }\n\t        ;\n\t        p = new ops.StepsCache(g,b,function(a, b) {\n\t            do {\n\t                if (d.acceptPosition(b) === e) {\n\t                    f(a, b, !0);\n\t                    break\n\t                }\n\t                f(a - 1, b, !1)\n\t            } while (b.nextPosition())\n\t        }\n\t        )\n\t    }\n\t}\n\t)();\n\tops.Operation = function() {}\n\t;\n\tops.Operation.prototype.init = function(g) {}\n\t;\n\tops.Operation.prototype.execute = function(g) {}\n\t;\n\tops.Operation.prototype.spec = function() {}\n\t;\n\tops.TextPositionFilter = function() {\n\t    function g(b, d) {\n\t        for (; b && d(b) !== n; )\n\t            b = b.previousSibling;\n\t        return b\n\t    }\n\t    function k(b, f, e, l) {\n\t        var a;\n\t        if (f) {\n\t            if (d.isInlineRoot(f) && d.isGroupingElement(e))\n\t                return p;\n\t            l = d.lookLeftForCharacter(f);\n\t            if (1 === l || 2 === l && (d.scanRightForAnyCharacter(e) || d.scanRightForAnyCharacter(d.nextNode(b))))\n\t                return n\n\t        } else if (d.isGroupingElement(b) && d.isInlineRoot(g(b.previousSibling, l)))\n\t            return n;\n\t        l = null === f && d.isParagraph(b);\n\t        a = d.lookRightForCharacter(e);\n\t        if (l)\n\t            return a ? n : d.scanRightForAnyCharacter(e) ? p : n;\n\t        if (!a)\n\t            return p;\n\t        f = f || d.previousNode(b);\n\t        return d.scanLeftForAnyCharacter(f) ? p : n\n\t    }\n\t    var d = odf.OdfUtils\n\t      , b = Node.ELEMENT_NODE\n\t      , f = Node.TEXT_NODE\n\t      , n = core.PositionFilter.FilterResult.FILTER_ACCEPT\n\t      , p = core.PositionFilter.FilterResult.FILTER_REJECT;\n\t    this.acceptPosition = function(g) {\n\t        var q = g.container(), e = q.nodeType, l, a, c;\n\t        if (e !== b && e !== f)\n\t            return p;\n\t        if (e === f) {\n\t            e = g.unfilteredDomOffset();\n\t            l = q.data;\n\t            runtime.assert(e !== l.length, \"Unexpected offset.\");\n\t            if (0 < e) {\n\t                g = l[e - 1];\n\t                if (!d.isODFWhitespace(g))\n\t                    return n;\n\t                if (1 < e)\n\t                    if (g = l[e - 2],\n\t                    !d.isODFWhitespace(g))\n\t                        c = n;\n\t                    else {\n\t                        if (!d.isODFWhitespace(l.substr(0, e)))\n\t                            return p\n\t                    }\n\t                else\n\t                    a = d.previousNode(q),\n\t                    d.scanLeftForNonSpace(a) && (c = n);\n\t                if (c === n)\n\t                    return d.isTrailingWhitespace(q, e) ? p : n;\n\t                g = l[e];\n\t                return d.isODFWhitespace(g) ? p : d.scanLeftForAnyCharacter(d.previousNode(q)) ? p : n\n\t            }\n\t            a = g.leftNode();\n\t            c = q;\n\t            q = q.parentNode;\n\t            c = k(q, a, c, g.getNodeFilter())\n\t        } else\n\t            d.isGroupingElement(q) ? (a = g.leftNode(),\n\t            c = g.rightNode(),\n\t            c = k(q, a, c, g.getNodeFilter())) : c = p;\n\t        return c\n\t    }\n\t}\n\t;\n\tfunction RootFilter(g, k, d) {\n\t    var b = core.PositionFilter.FilterResult.FILTER_ACCEPT\n\t      , f = core.PositionFilter.FilterResult.FILTER_REJECT;\n\t    this.acceptPosition = function(n) {\n\t        n = n.container();\n\t        var p;\n\t        p = \"string\" === typeof g ? k[g].getNode() : g;\n\t        return d(n) === d(p) ? b : f\n\t    }\n\t}\n\tops.OdtDocument = function(g) {\n\t    function k(a) {\n\t        return new core.PositionIterator(a,A,L,!1)\n\t    }\n\t    function d() {\n\t        var a = g.odfContainer().getContentElement()\n\t          , c = a && a.localName;\n\t        runtime.assert(\"text\" === c, \"Unsupported content element type '\" + c + \"' for OdtDocument\");\n\t        return a\n\t    }\n\t    function b() {\n\t        return a.getDocumentElement().ownerDocument\n\t    }\n\t    function f(a) {\n\t        for (; a && !(a.namespaceURI === odf.Namespaces.officens && \"text\" === a.localName || a.namespaceURI === odf.Namespaces.officens && \"annotation\" === a.localName); )\n\t            a = a.parentNode;\n\t        return a\n\t    }\n\t    function n(a, c, b, d) {\n\t        d = k(d);\n\t        var e;\n\t        1 === b.length ? e = b[0] : (e = new core.PositionFilterChain,\n\t        b.forEach(e.addFilter));\n\t        b = new core.StepIterator(e,d);\n\t        b.setPosition(a, c);\n\t        return b\n\t    }\n\t    function p(a) {\n\t        var c = k(d());\n\t        a = u.convertStepsToDomPoint(a);\n\t        c.setUnfilteredPosition(a.node, a.offset);\n\t        return c\n\t    }\n\t    function r(a) {\n\t        return a === w\n\t    }\n\t    function q(c) {\n\t        var b = c.spec()\n\t          , d = b.memberid\n\t          , e = (new Date(b.timestamp)).toISOString()\n\t          , b = g.odfContainer();\n\t        c.isEdit && (d = a.getMember(d).getProperties().fullName,\n\t        b.setMetadata({\n\t            \"dc:creator\": d,\n\t            \"dc:date\": e\n\t        }, null),\n\t        d = {\n\t            setProperties: {\n\t                \"dc:creator\": d,\n\t                \"dc:date\": e\n\t            },\n\t            removedProperties: []\n\t        },\n\t        t || (d.setProperties[\"meta:editing-cycles\"] = b.incrementEditingCycles(),\n\t        b.setMetadata(null, [\"meta:editing-duration\", \"meta:document-statistic\"])),\n\t        t = c,\n\t        a.emit(ops.OdtDocument.signalMetadataUpdated, d))\n\t    }\n\t    function e(a) {\n\t        var b, d = [], e, f = 2;\n\t        runtime.assert(a.isStep(), \"positionIterator is not at a step\");\n\t        do {\n\t            if (b = c.getContentBounds(a))\n\t                if (b = b.container,\n\t                m.isDowngradableSpaceElement(b)) {\n\t                    for (e = b.lastChild; b.firstChild; )\n\t                        d.push(b.firstChild),\n\t                        b.parentNode.insertBefore(b.firstChild, b);\n\t                    b.parentNode.removeChild(b);\n\t                    a.setPosition(e, e.nodeType === Node.TEXT_NODE ? e.length : e.childNodes.length);\n\t                    a.roundToPreviousStep()\n\t                }\n\t            --f\n\t        } while (0 < f && a.nextStep());\n\t        d.forEach(h.normalizeTextNodes)\n\t    }\n\t    function l(a, c, b) {\n\t        a = a.childNodes.item(c) || a;\n\t        return (a = m.getParagraphElement(a)) && h.containsNode(b, a) ? a : b\n\t    }\n\t    var a = this, c, m = odf.OdfUtils, h = core.DomUtils, y = {}, x = {}, z = new core.EventNotifier([ops.Document.signalMemberAdded, ops.Document.signalMemberUpdated, ops.Document.signalMemberRemoved, ops.Document.signalCursorAdded, ops.Document.signalCursorRemoved, ops.Document.signalCursorMoved, ops.OdtDocument.signalParagraphChanged, ops.OdtDocument.signalParagraphStyleModified, ops.OdtDocument.signalCommonStyleCreated, ops.OdtDocument.signalCommonStyleDeleted, ops.OdtDocument.signalTableAdded, ops.OdtDocument.signalOperationStart, ops.OdtDocument.signalOperationEnd, ops.OdtDocument.signalProcessingBatchStart, ops.OdtDocument.signalProcessingBatchEnd, ops.OdtDocument.signalUndoStackChanged, ops.OdtDocument.signalStepsInserted, ops.OdtDocument.signalStepsRemoved, ops.OdtDocument.signalMetadataUpdated, ops.OdtDocument.signalAnnotationAdded]), w = core.StepDirection.NEXT, v, u, t, A = NodeFilter.SHOW_ALL, I = new gui.BlacklistNamespaceNodeFilter([\"urn:webodf:names:cursor\", \"urn:webodf:names:editinfo\"]), K = new gui.OdfTextBodyNodeFilter, L = new core.NodeFilterChain([I, K]);\n\t    this.createPositionIterator = k;\n\t    this.getDocumentElement = function() {\n\t        return g.odfContainer().rootElement\n\t    }\n\t    ;\n\t    this.cloneDocumentElement = function() {\n\t        var c = a.getDocumentElement()\n\t          , b = g.getAnnotationViewManager();\n\t        b && b.forgetAnnotations();\n\t        c = c.cloneNode(!0);\n\t        g.refreshAnnotations();\n\t        a.fixCursorPositions();\n\t        return c\n\t    }\n\t    ;\n\t    this.setDocumentElement = function(a) {\n\t        var c = g.odfContainer();\n\t        z.unsubscribe(ops.OdtDocument.signalStepsInserted, u.handleStepsInserted);\n\t        z.unsubscribe(ops.OdtDocument.signalStepsRemoved, u.handleStepsRemoved);\n\t        c.setRootElement(a);\n\t        g.setOdfContainer(c, !0);\n\t        g.refreshCSS();\n\t        a = d();\n\t        u = new ops.OdtStepsTranslator(a,k(a),v,500);\n\t        z.subscribe(ops.OdtDocument.signalStepsInserted, u.handleStepsInserted);\n\t        z.subscribe(ops.OdtDocument.signalStepsRemoved, u.handleStepsRemoved)\n\t    }\n\t    ;\n\t    this.getDOMDocument = b;\n\t    this.getRootElement = f;\n\t    this.createStepIterator = n;\n\t    this.getIteratorAtPosition = p;\n\t    this.convertCursorStepToDomPoint = function(a) {\n\t        return u.convertStepsToDomPoint(a)\n\t    }\n\t    ;\n\t    this.convertDomPointToCursorStep = function(a, c, b) {\n\t        var d;\n\t        b === w && (d = r);\n\t        return u.convertDomPointToSteps(a, c, d)\n\t    }\n\t    ;\n\t    this.convertDomToCursorRange = function(a) {\n\t        var c;\n\t        c = u.convertDomPointToSteps(a.anchorNode, a.anchorOffset);\n\t        a = a.anchorNode === a.focusNode && a.anchorOffset === a.focusOffset ? c : u.convertDomPointToSteps(a.focusNode, a.focusOffset);\n\t        return {\n\t            position: c,\n\t            length: a - c\n\t        }\n\t    }\n\t    ;\n\t    this.convertCursorToDomRange = function(a, c) {\n\t        var d = b().createRange(), e, h;\n\t        e = u.convertStepsToDomPoint(a);\n\t        c ? (h = u.convertStepsToDomPoint(a + c),\n\t        0 < c ? (d.setStart(e.node, e.offset),\n\t        d.setEnd(h.node, h.offset)) : (d.setStart(h.node, h.offset),\n\t        d.setEnd(e.node, e.offset))) : d.setStart(e.node, e.offset);\n\t        return d\n\t    }\n\t    ;\n\t    this.upgradeWhitespacesAtPosition = function(a) {\n\t        var b = p(a), b = new core.StepIterator(v,b), d, e = 2;\n\t        runtime.assert(b.isStep(), \"positionIterator is not at a step (requested step: \" + a + \")\");\n\t        do {\n\t            if (d = c.getContentBounds(b))\n\t                if (a = d.container,\n\t                d = d.startOffset,\n\t                a.nodeType === Node.TEXT_NODE && m.isSignificantWhitespace(a, d)) {\n\t                    runtime.assert(\" \" === a.data[d], \"upgradeWhitespaceToElement: textNode.data[offset] should be a literal space\");\n\t                    var h = a.ownerDocument.createElementNS(odf.Namespaces.textns, \"text:s\")\n\t                      , f = a.parentNode\n\t                      , l = a;\n\t                    h.appendChild(a.ownerDocument.createTextNode(\" \"));\n\t                    1 === a.length ? f.replaceChild(h, a) : (a.deleteData(d, 1),\n\t                    0 < d && (d < a.length && a.splitText(d),\n\t                    l = a.nextSibling),\n\t                    f.insertBefore(h, l));\n\t                    a = h;\n\t                    b.setPosition(a, a.childNodes.length);\n\t                    b.roundToPreviousStep()\n\t                }\n\t            --e\n\t        } while (0 < e && b.nextStep())\n\t    }\n\t    ;\n\t    this.downgradeWhitespaces = e;\n\t    this.downgradeWhitespacesAtPosition = function(a) {\n\t        a = p(a);\n\t        a = new core.StepIterator(v,a);\n\t        e(a)\n\t    }\n\t    ;\n\t    this.getTextNodeAtStep = function(c, d) {\n\t        var e = p(c), h = e.container(), m, f = 0, l = null;\n\t        h.nodeType === Node.TEXT_NODE ? (m = h,\n\t        f = e.unfilteredDomOffset(),\n\t        0 < m.length && (0 < f && (m = m.splitText(f)),\n\t        m.parentNode.insertBefore(b().createTextNode(\"\"), m),\n\t        m = m.previousSibling,\n\t        f = 0)) : (m = b().createTextNode(\"\"),\n\t        f = 0,\n\t        h.insertBefore(m, e.rightNode()));\n\t        if (d) {\n\t            if (y[d] && a.getCursorPosition(d) === c) {\n\t                for (l = y[d].getNode(); l.nextSibling && \"cursor\" === l.nextSibling.localName; )\n\t                    l.parentNode.insertBefore(l.nextSibling, l);\n\t                0 < m.length && m.nextSibling !== l && (m = b().createTextNode(\"\"),\n\t                f = 0);\n\t                l.parentNode.insertBefore(m, l)\n\t            }\n\t        } else\n\t            for (; m.nextSibling && \"cursor\" === m.nextSibling.localName; )\n\t                m.parentNode.insertBefore(m.nextSibling, m);\n\t        for (; m.previousSibling && m.previousSibling.nodeType === Node.TEXT_NODE; )\n\t            e = m.previousSibling,\n\t            e.appendData(m.data),\n\t            f = e.length,\n\t            m = e,\n\t            m.parentNode.removeChild(m.nextSibling);\n\t        for (; m.nextSibling && m.nextSibling.nodeType === Node.TEXT_NODE; )\n\t            e = m.nextSibling,\n\t            m.appendData(e.data),\n\t            m.parentNode.removeChild(e);\n\t        return {\n\t            textNode: m,\n\t            offset: f\n\t        }\n\t    }\n\t    ;\n\t    this.fixCursorPositions = function() {\n\t        Object.keys(y).forEach(function(c) {\n\t            var b = y[c], d = f(b.getNode()), e = a.createRootFilter(d), h, m, g, k = !1;\n\t            g = b.getSelectedRange();\n\t            h = l(g.startContainer, g.startOffset, d);\n\t            m = n(g.startContainer, g.startOffset, [v, e], h);\n\t            g.collapsed ? d = m : (h = l(g.endContainer, g.endOffset, d),\n\t            d = n(g.endContainer, g.endOffset, [v, e], h));\n\t            m.isStep() && d.isStep() ? m.container() !== d.container() || m.offset() !== d.offset() || g.collapsed && b.getAnchorNode() === b.getNode() || (k = !0,\n\t            g.setStart(m.container(), m.offset()),\n\t            g.collapse(!0)) : (k = !0,\n\t            runtime.assert(m.roundToClosestStep(), \"No walkable step found for cursor owned by \" + c),\n\t            g.setStart(m.container(), m.offset()),\n\t            runtime.assert(d.roundToClosestStep(), \"No walkable step found for cursor owned by \" + c),\n\t            g.setEnd(d.container(), d.offset()));\n\t            k && (b.setSelectedRange(g, b.hasForwardSelection()),\n\t            a.emit(ops.Document.signalCursorMoved, b))\n\t        })\n\t    }\n\t    ;\n\t    this.getCursorPosition = function(a) {\n\t        return (a = y[a]) ? u.convertDomPointToSteps(a.getNode(), 0) : 0\n\t    }\n\t    ;\n\t    this.getCursorSelection = function(a) {\n\t        a = y[a];\n\t        var c = 0\n\t          , b = 0;\n\t        a && (c = u.convertDomPointToSteps(a.getNode(), 0),\n\t        b = u.convertDomPointToSteps(a.getAnchorNode(), 0));\n\t        return {\n\t            position: b,\n\t            length: c - b\n\t        }\n\t    }\n\t    ;\n\t    this.getPositionFilter = function() {\n\t        return v\n\t    }\n\t    ;\n\t    this.getOdfCanvas = function() {\n\t        return g\n\t    }\n\t    ;\n\t    this.getCanvas = function() {\n\t        return g\n\t    }\n\t    ;\n\t    this.getRootNode = d;\n\t    this.addMember = function(a) {\n\t        runtime.assert(void 0 === x[a.getMemberId()], \"This member already exists\");\n\t        x[a.getMemberId()] = a\n\t    }\n\t    ;\n\t    this.getMember = function(a) {\n\t        return x.hasOwnProperty(a) ? x[a] : null\n\t    }\n\t    ;\n\t    this.removeMember = function(a) {\n\t        delete x[a]\n\t    }\n\t    ;\n\t    this.getCursor = function(a) {\n\t        return y[a]\n\t    }\n\t    ;\n\t    this.hasCursor = function(a) {\n\t        return y.hasOwnProperty(a)\n\t    }\n\t    ;\n\t    this.getMemberIds = function() {\n\t        return Object.keys(x)\n\t    }\n\t    ;\n\t    this.addCursor = function(c) {\n\t        runtime.assert(Boolean(c), \"OdtDocument::addCursor without cursor\");\n\t        var b = c.getMemberId()\n\t          , d = a.convertCursorToDomRange(0, 0);\n\t        runtime.assert(\"string\" === typeof b, \"OdtDocument::addCursor has cursor without memberid\");\n\t        runtime.assert(!y[b], \"OdtDocument::addCursor is adding a duplicate cursor with memberid \" + b);\n\t        c.setSelectedRange(d, !0);\n\t        y[b] = c\n\t    }\n\t    ;\n\t    this.removeCursor = function(c) {\n\t        var b = y[c];\n\t        return b ? (b.removeFromDocument(),\n\t        delete y[c],\n\t        a.emit(ops.Document.signalCursorRemoved, c),\n\t        !0) : !1\n\t    }\n\t    ;\n\t    this.moveCursor = function(c, b, d, e) {\n\t        c = y[c];\n\t        b = a.convertCursorToDomRange(b, d);\n\t        c && (c.setSelectedRange(b, 0 <= d),\n\t        c.setSelectionType(e || ops.OdtCursor.RangeSelection))\n\t    }\n\t    ;\n\t    this.getFormatting = function() {\n\t        return g.getFormatting()\n\t    }\n\t    ;\n\t    this.emit = function(a, c) {\n\t        z.emit(a, c)\n\t    }\n\t    ;\n\t    this.subscribe = function(a, c) {\n\t        z.subscribe(a, c)\n\t    }\n\t    ;\n\t    this.unsubscribe = function(a, c) {\n\t        z.unsubscribe(a, c)\n\t    }\n\t    ;\n\t    this.createRootFilter = function(a) {\n\t        return new RootFilter(a,y,f)\n\t    }\n\t    ;\n\t    this.close = function(a) {\n\t        a()\n\t    }\n\t    ;\n\t    this.destroy = function(a) {\n\t        a()\n\t    }\n\t    ;\n\t    (function() {\n\t        var a = d();\n\t        v = new ops.TextPositionFilter;\n\t        c = new odf.StepUtils;\n\t        u = new ops.OdtStepsTranslator(a,k(a),v,500);\n\t        z.subscribe(ops.OdtDocument.signalStepsInserted, u.handleStepsInserted);\n\t        z.subscribe(ops.OdtDocument.signalStepsRemoved, u.handleStepsRemoved);\n\t        z.subscribe(ops.OdtDocument.signalOperationEnd, q);\n\t        z.subscribe(ops.OdtDocument.signalProcessingBatchEnd, core.Task.processTasks)\n\t    }\n\t    )()\n\t}\n\t;\n\tops.OdtDocument.signalParagraphChanged = \"paragraph/changed\";\n\tops.OdtDocument.signalTableAdded = \"table/added\";\n\tops.OdtDocument.signalCommonStyleCreated = \"style/created\";\n\tops.OdtDocument.signalCommonStyleDeleted = \"style/deleted\";\n\tops.OdtDocument.signalParagraphStyleModified = \"paragraphstyle/modified\";\n\tops.OdtDocument.signalOperationStart = \"operation/start\";\n\tops.OdtDocument.signalOperationEnd = \"operation/end\";\n\tops.OdtDocument.signalProcessingBatchStart = \"router/batchstart\";\n\tops.OdtDocument.signalProcessingBatchEnd = \"router/batchend\";\n\tops.OdtDocument.signalUndoStackChanged = \"undo/changed\";\n\tops.OdtDocument.signalStepsInserted = \"steps/inserted\";\n\tops.OdtDocument.signalStepsRemoved = \"steps/removed\";\n\tops.OdtDocument.signalMetadataUpdated = \"metadata/updated\";\n\tops.OdtDocument.signalAnnotationAdded = \"annotation/added\";\n\tops.OpAddAnnotation = function() {\n\t    function g(b, d, e) {\n\t        var f = b.getTextNodeAtStep(e, k);\n\t        f && (b = f.textNode,\n\t        e = b.parentNode,\n\t        f.offset !== b.length && b.splitText(f.offset),\n\t        e.insertBefore(d, b.nextSibling),\n\t        0 === b.length && e.removeChild(b))\n\t    }\n\t    var k, d, b, f, n, p;\n\t    this.init = function(g) {\n\t        k = g.memberid;\n\t        d = parseInt(g.timestamp, 10);\n\t        b = parseInt(g.position, 10);\n\t        f = void 0 !== g.length ? parseInt(g.length, 10) || 0 : void 0;\n\t        n = g.name\n\t    }\n\t    ;\n\t    this.isEdit = !0;\n\t    this.group = void 0;\n\t    this.execute = function(r) {\n\t        var q = r.getCursor(k), e, l;\n\t        p = r.getDOMDocument();\n\t        var a = new Date(d), c, m, h;\n\t        c = p.createElementNS(odf.Namespaces.officens, \"office:annotation\");\n\t        c.setAttributeNS(odf.Namespaces.officens, \"office:name\", n);\n\t        e = p.createElementNS(odf.Namespaces.dcns, \"dc:creator\");\n\t        e.setAttributeNS(\"urn:webodf:names:editinfo\", \"editinfo:memberid\", k);\n\t        e.textContent = r.getMember(k).getProperties().fullName;\n\t        l = p.createElementNS(odf.Namespaces.dcns, \"dc:date\");\n\t        l.appendChild(p.createTextNode(a.toISOString()));\n\t        a = p.createElementNS(odf.Namespaces.textns, \"text:list\");\n\t        m = p.createElementNS(odf.Namespaces.textns, \"text:list-item\");\n\t        h = p.createElementNS(odf.Namespaces.textns, \"text:p\");\n\t        m.appendChild(h);\n\t        a.appendChild(m);\n\t        c.appendChild(e);\n\t        c.appendChild(l);\n\t        c.appendChild(a);\n\t        void 0 !== f && (e = p.createElementNS(odf.Namespaces.officens, \"office:annotation-end\"),\n\t        e.setAttributeNS(odf.Namespaces.officens, \"office:name\", n),\n\t        c.annotationEndElement = e,\n\t        g(r, e, b + f));\n\t        g(r, c, b);\n\t        r.emit(ops.OdtDocument.signalStepsInserted, {\n\t            position: b\n\t        });\n\t        q && (e = p.createRange(),\n\t        l = c.getElementsByTagNameNS(odf.Namespaces.textns, \"p\")[0],\n\t        e.selectNodeContents(l),\n\t        q.setSelectedRange(e, !1),\n\t        q.setSelectionType(ops.OdtCursor.RangeSelection),\n\t        r.emit(ops.Document.signalCursorMoved, q));\n\t        r.getOdfCanvas().addAnnotation(c);\n\t        r.fixCursorPositions();\n\t        r.emit(ops.OdtDocument.signalAnnotationAdded, {\n\t            memberId: k,\n\t            annotation: c\n\t        });\n\t        return !0\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"AddAnnotation\",\n\t            memberid: k,\n\t            timestamp: d,\n\t            position: b,\n\t            length: f,\n\t            name: n\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpAddCursor = function() {\n\t    var g, k;\n\t    this.init = function(d) {\n\t        g = d.memberid;\n\t        k = d.timestamp\n\t    }\n\t    ;\n\t    this.isEdit = !1;\n\t    this.group = void 0;\n\t    this.execute = function(d) {\n\t        var b = d.getCursor(g);\n\t        if (b)\n\t            return !1;\n\t        b = new ops.OdtCursor(g,d);\n\t        d.addCursor(b);\n\t        d.emit(ops.Document.signalCursorAdded, b);\n\t        return !0\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"AddCursor\",\n\t            memberid: g,\n\t            timestamp: k\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpAddMember = function() {\n\t    var g, k, d;\n\t    this.init = function(b) {\n\t        g = b.memberid;\n\t        k = parseInt(b.timestamp, 10);\n\t        d = b.setProperties\n\t    }\n\t    ;\n\t    this.isEdit = !1;\n\t    this.group = void 0;\n\t    this.execute = function(b) {\n\t        var f;\n\t        if (b.getMember(g))\n\t            return !1;\n\t        f = new ops.Member(g,d);\n\t        b.addMember(f);\n\t        b.emit(ops.Document.signalMemberAdded, f);\n\t        return !0\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"AddMember\",\n\t            memberid: g,\n\t            timestamp: k,\n\t            setProperties: d\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpAddStyle = function() {\n\t    var g, k, d, b, f, n, p = odf.Namespaces.stylens;\n\t    this.init = function(p) {\n\t        g = p.memberid;\n\t        k = p.timestamp;\n\t        d = p.styleName;\n\t        b = p.styleFamily;\n\t        f = \"true\" === p.isAutomaticStyle || !0 === p.isAutomaticStyle;\n\t        n = p.setProperties\n\t    }\n\t    ;\n\t    this.isEdit = !0;\n\t    this.group = void 0;\n\t    this.execute = function(g) {\n\t        var k = g.getOdfCanvas().odfContainer()\n\t          , e = g.getFormatting()\n\t          , l = g.getDOMDocument().createElementNS(p, \"style:style\");\n\t        if (!l)\n\t            return !1;\n\t        n && e.updateStyle(l, n);\n\t        l.setAttributeNS(p, \"style:family\", b);\n\t        l.setAttributeNS(p, \"style:name\", d);\n\t        f ? k.rootElement.automaticStyles.appendChild(l) : k.rootElement.styles.appendChild(l);\n\t        g.getOdfCanvas().refreshCSS();\n\t        f || g.emit(ops.OdtDocument.signalCommonStyleCreated, {\n\t            name: d,\n\t            family: b\n\t        });\n\t        return !0\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"AddStyle\",\n\t            memberid: g,\n\t            timestamp: k,\n\t            styleName: d,\n\t            styleFamily: b,\n\t            isAutomaticStyle: f,\n\t            setProperties: n\n\t        }\n\t    }\n\t}\n\t;\n\todf.ObjectNameGenerator = function(g, k) {\n\t    function d(a, c) {\n\t        var b = {};\n\t        this.generateName = function() {\n\t            var d = c(), e = 0, f;\n\t            do\n\t                f = a + e,\n\t                e += 1;\n\t            while (b[f] || d[f]);\n\t            b[f] = !0;\n\t            return f\n\t        }\n\t    }\n\t    function b() {\n\t        var a = {};\n\t        [g.rootElement.automaticStyles, g.rootElement.styles].forEach(function(c) {\n\t            for (c = c.firstElementChild; c; )\n\t                c.namespaceURI === f && \"style\" === c.localName && (a[c.getAttributeNS(f, \"name\")] = !0),\n\t                c = c.nextElementSibling\n\t        });\n\t        return a\n\t    }\n\t    var f = odf.Namespaces.stylens\n\t      , n = odf.Namespaces.drawns\n\t      , p = odf.Namespaces.xlinkns\n\t      , r = (new core.Utils).hashString(k)\n\t      , q = null\n\t      , e = null\n\t      , l = null\n\t      , a = {}\n\t      , c = {};\n\t    this.generateStyleName = function() {\n\t        null === q && (q = new d(\"auto\" + r + \"_\",function() {\n\t            return b()\n\t        }\n\t        ));\n\t        return q.generateName()\n\t    }\n\t    ;\n\t    this.generateFrameName = function() {\n\t        var c, b, f;\n\t        if (null === e) {\n\t            b = g.rootElement.body.getElementsByTagNameNS(n, \"frame\");\n\t            for (c = 0; c < b.length; c += 1)\n\t                f = b.item(c),\n\t                a[f.getAttributeNS(n, \"name\")] = !0;\n\t            e = new d(\"fr\" + r + \"_\",function() {\n\t                return a\n\t            }\n\t            )\n\t        }\n\t        return e.generateName()\n\t    }\n\t    ;\n\t    this.generateImageName = function() {\n\t        var a, b, e;\n\t        if (null === l) {\n\t            e = g.rootElement.body.getElementsByTagNameNS(n, \"image\");\n\t            for (a = 0; a < e.length; a += 1)\n\t                b = e.item(a),\n\t                b = b.getAttributeNS(p, \"href\"),\n\t                b = b.substring(9, b.lastIndexOf(\".\")),\n\t                c[b] = !0;\n\t            l = new d(\"img\" + r + \"_\",function() {\n\t                return c\n\t            }\n\t            )\n\t        }\n\t        return l.generateName()\n\t    }\n\t}\n\t;\n\todf.TextStyleApplicator = function(g, k, d) {\n\t    function b(b) {\n\t        function d(a, b) {\n\t            return \"object\" === typeof a && \"object\" === typeof b ? Object.keys(a).every(function(e) {\n\t                return d(a[e], b[e])\n\t            }) : a === b\n\t        }\n\t        var a = {};\n\t        this.isStyleApplied = function(c) {\n\t            c = k.getAppliedStylesForElement(c, a).styleProperties;\n\t            return d(b, c)\n\t        }\n\t    }\n\t    function f(b) {\n\t        var f = {};\n\t        this.applyStyleToContainer = function(a) {\n\t            var c;\n\t            c = a.getAttributeNS(r, \"style-name\");\n\t            var m = a.ownerDocument;\n\t            c = c || \"\";\n\t            if (!f.hasOwnProperty(c)) {\n\t                var h = c, n;\n\t                n = c ? k.createDerivedStyleObject(c, \"text\", b) : b;\n\t                m = m.createElementNS(q, \"style:style\");\n\t                k.updateStyle(m, n);\n\t                m.setAttributeNS(q, \"style:name\", g.generateStyleName());\n\t                m.setAttributeNS(q, \"style:family\", \"text\");\n\t                m.setAttributeNS(\"urn:webodf:names:scope\", \"scope\", \"document-content\");\n\t                d.appendChild(m);\n\t                f[h] = m\n\t            }\n\t            c = f[c].getAttributeNS(q, \"name\");\n\t            a.setAttributeNS(r, \"text:style-name\", c)\n\t        }\n\t    }\n\t    function n(b, d) {\n\t        var a = b.ownerDocument, c = b.parentNode, m, h, f, g = new core.LoopWatchDog(1E4);\n\t        h = [];\n\t        h.push(b);\n\t        for (f = b.nextSibling; f && p.rangeContainsNode(d, f); )\n\t            g.check(),\n\t            h.push(f),\n\t            f = f.nextSibling;\n\t        \"span\" !== c.localName || c.namespaceURI !== r ? (m = a.createElementNS(r, \"text:span\"),\n\t        c.insertBefore(m, b),\n\t        a = !1) : (b.previousSibling && !p.rangeContainsNode(d, c.firstChild) ? (m = c.cloneNode(!1),\n\t        c.parentNode.insertBefore(m, c.nextSibling)) : m = c,\n\t        a = !0);\n\t        h.forEach(function(a) {\n\t            a.parentNode !== m && m.appendChild(a)\n\t        });\n\t        if (f && a)\n\t            for (h = m.cloneNode(!1),\n\t            m.parentNode.insertBefore(h, m.nextSibling); f; )\n\t                g.check(),\n\t                a = f.nextSibling,\n\t                h.appendChild(f),\n\t                f = a;\n\t        return m\n\t    }\n\t    var p = core.DomUtils\n\t      , r = odf.Namespaces.textns\n\t      , q = odf.Namespaces.stylens;\n\t    this.applyStyle = function(d, g, a) {\n\t        var c = {}, m, h, k, p;\n\t        runtime.assert(a && a.hasOwnProperty(\"style:text-properties\"), \"applyStyle without any text properties\");\n\t        c[\"style:text-properties\"] = a[\"style:text-properties\"];\n\t        k = new f(c);\n\t        p = new b(c);\n\t        d.forEach(function(a) {\n\t            m = p.isStyleApplied(a);\n\t            !1 === m && (h = n(a, g),\n\t            k.applyStyleToContainer(h))\n\t        })\n\t    }\n\t}\n\t;\n\tops.OpApplyDirectStyling = function() {\n\t    function g(b, d, f) {\n\t        var a = b.getOdfCanvas().odfContainer()\n\t          , c = r.splitBoundaries(d)\n\t          , m = p.getTextNodes(d, !1);\n\t        (new odf.TextStyleApplicator(new odf.ObjectNameGenerator(a,k),b.getFormatting(),a.rootElement.automaticStyles)).applyStyle(m, d, f);\n\t        c.forEach(r.normalizeTextNodes)\n\t    }\n\t    var k, d, b, f, n, p = odf.OdfUtils, r = core.DomUtils;\n\t    this.init = function(g) {\n\t        k = g.memberid;\n\t        d = g.timestamp;\n\t        b = parseInt(g.position, 10);\n\t        f = parseInt(g.length, 10);\n\t        n = g.setProperties\n\t    }\n\t    ;\n\t    this.isEdit = !0;\n\t    this.group = void 0;\n\t    this.execute = function(r) {\n\t        var e = r.convertCursorToDomRange(b, f)\n\t          , l = p.getParagraphElements(e);\n\t        g(r, e, n);\n\t        e.detach();\n\t        r.getOdfCanvas().refreshCSS();\n\t        r.fixCursorPositions();\n\t        l.forEach(function(a) {\n\t            r.emit(ops.OdtDocument.signalParagraphChanged, {\n\t                paragraphElement: a,\n\t                memberId: k,\n\t                timeStamp: d\n\t            })\n\t        });\n\t        r.getOdfCanvas().rerenderAnnotations();\n\t        return !0\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"ApplyDirectStyling\",\n\t            memberid: k,\n\t            timestamp: d,\n\t            position: b,\n\t            length: f,\n\t            setProperties: n\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpApplyHyperlink = function() {\n\t    function g(b) {\n\t        for (; b; ) {\n\t            if (r.isHyperlink(b))\n\t                return !0;\n\t            b = b.parentNode\n\t        }\n\t        return !1\n\t    }\n\t    var k, d, b, f, n, p = core.DomUtils, r = odf.OdfUtils;\n\t    this.init = function(g) {\n\t        k = g.memberid;\n\t        d = g.timestamp;\n\t        b = g.position;\n\t        f = g.length;\n\t        n = g.hyperlink\n\t    }\n\t    ;\n\t    this.isEdit = !0;\n\t    this.group = void 0;\n\t    this.execute = function(q) {\n\t        var e = q.getDOMDocument()\n\t          , l = q.convertCursorToDomRange(b, f)\n\t          , a = p.splitBoundaries(l)\n\t          , c = []\n\t          , m = r.getTextNodes(l, !1);\n\t        if (0 === m.length)\n\t            return !1;\n\t        m.forEach(function(a) {\n\t            var b = r.getParagraphElement(a);\n\t            runtime.assert(!1 === g(a), \"The given range should not contain any link.\");\n\t            var d = n\n\t              , m = e.createElementNS(odf.Namespaces.textns, \"text:a\");\n\t            m.setAttributeNS(odf.Namespaces.xlinkns, \"xlink:type\", \"simple\");\n\t            m.setAttributeNS(odf.Namespaces.xlinkns, \"xlink:href\", d);\n\t            a.parentNode.insertBefore(m, a);\n\t            m.appendChild(a);\n\t            -1 === c.indexOf(b) && c.push(b)\n\t        });\n\t        a.forEach(p.normalizeTextNodes);\n\t        l.detach();\n\t        q.fixCursorPositions();\n\t        q.getOdfCanvas().refreshSize();\n\t        q.getOdfCanvas().rerenderAnnotations();\n\t        c.forEach(function(a) {\n\t            q.emit(ops.OdtDocument.signalParagraphChanged, {\n\t                paragraphElement: a,\n\t                memberId: k,\n\t                timeStamp: d\n\t            })\n\t        });\n\t        return !0\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"ApplyHyperlink\",\n\t            memberid: k,\n\t            timestamp: d,\n\t            position: b,\n\t            length: f,\n\t            hyperlink: n\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpInsertImage = function() {\n\t    var g, k, d, b, f, n, p, r, q = odf.Namespaces.drawns, e = odf.Namespaces.svgns, l = odf.Namespaces.textns, a = odf.Namespaces.xlinkns, c = odf.OdfUtils;\n\t    this.init = function(a) {\n\t        g = a.memberid;\n\t        k = a.timestamp;\n\t        d = a.position;\n\t        b = a.filename;\n\t        f = a.frameWidth;\n\t        n = a.frameHeight;\n\t        p = a.frameStyleName;\n\t        r = a.frameName\n\t    }\n\t    ;\n\t    this.isEdit = !0;\n\t    this.group = void 0;\n\t    this.execute = function(m) {\n\t        var h = m.getOdfCanvas(), y = m.getTextNodeAtStep(d, g), x, z;\n\t        if (!y)\n\t            return !1;\n\t        x = y.textNode;\n\t        z = c.getParagraphElement(x);\n\t        var y = y.offset !== x.length ? x.splitText(y.offset) : x.nextSibling\n\t          , w = m.getDOMDocument()\n\t          , v = w.createElementNS(q, \"draw:image\")\n\t          , w = w.createElementNS(q, \"draw:frame\");\n\t        v.setAttributeNS(a, \"xlink:href\", b);\n\t        v.setAttributeNS(a, \"xlink:type\", \"simple\");\n\t        v.setAttributeNS(a, \"xlink:show\", \"embed\");\n\t        v.setAttributeNS(a, \"xlink:actuate\", \"onLoad\");\n\t        w.setAttributeNS(q, \"draw:style-name\", p);\n\t        w.setAttributeNS(q, \"draw:name\", r);\n\t        w.setAttributeNS(l, \"text:anchor-type\", \"as-char\");\n\t        w.setAttributeNS(e, \"svg:width\", f);\n\t        w.setAttributeNS(e, \"svg:height\", n);\n\t        w.appendChild(v);\n\t        x.parentNode.insertBefore(w, y);\n\t        m.emit(ops.OdtDocument.signalStepsInserted, {\n\t            position: d\n\t        });\n\t        0 === x.length && x.parentNode.removeChild(x);\n\t        h.addCssForFrameWithImage(w);\n\t        h.refreshCSS();\n\t        m.emit(ops.OdtDocument.signalParagraphChanged, {\n\t            paragraphElement: z,\n\t            memberId: g,\n\t            timeStamp: k\n\t        });\n\t        h.rerenderAnnotations();\n\t        return !0\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"InsertImage\",\n\t            memberid: g,\n\t            timestamp: k,\n\t            filename: b,\n\t            position: d,\n\t            frameWidth: f,\n\t            frameHeight: n,\n\t            frameStyleName: p,\n\t            frameName: r\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpInsertTable = function() {\n\t    function g(a, c) {\n\t        var d;\n\t        if (1 === e.length)\n\t            d = e[0];\n\t        else if (3 === e.length)\n\t            switch (a) {\n\t            case 0:\n\t                d = e[0];\n\t                break;\n\t            case b - 1:\n\t                d = e[2];\n\t                break;\n\t            default:\n\t                d = e[1]\n\t            }\n\t        else\n\t            d = e[a];\n\t        if (1 === d.length)\n\t            return d[0];\n\t        if (3 === d.length)\n\t            switch (c) {\n\t            case 0:\n\t                return d[0];\n\t            case f - 1:\n\t                return d[2];\n\t            default:\n\t                return d[1]\n\t            }\n\t        return d[c]\n\t    }\n\t    var k, d, b, f, n, p, r, q, e, l = odf.OdfUtils;\n\t    this.init = function(a) {\n\t        k = a.memberid;\n\t        d = a.timestamp;\n\t        n = a.position;\n\t        b = a.initialRows;\n\t        f = a.initialColumns;\n\t        p = a.tableName;\n\t        r = a.tableStyleName;\n\t        q = a.tableColumnStyleName;\n\t        e = a.tableCellStyleMatrix\n\t    }\n\t    ;\n\t    this.isEdit = !0;\n\t    this.group = void 0;\n\t    this.execute = function(a) {\n\t        var c = a.getTextNodeAtStep(n)\n\t          , e = a.getRootNode();\n\t        if (c) {\n\t            var h = a.getDOMDocument(), y = h.createElementNS(\"urn:oasis:names:tc:opendocument:xmlns:table:1.0\", \"table:table\"), x = h.createElementNS(\"urn:oasis:names:tc:opendocument:xmlns:table:1.0\", \"table:table-column\"), z, w, v, u;\n\t            r && y.setAttributeNS(\"urn:oasis:names:tc:opendocument:xmlns:table:1.0\", \"table:style-name\", r);\n\t            p && y.setAttributeNS(\"urn:oasis:names:tc:opendocument:xmlns:table:1.0\", \"table:name\", p);\n\t            x.setAttributeNS(\"urn:oasis:names:tc:opendocument:xmlns:table:1.0\", \"table:number-columns-repeated\", f);\n\t            q && x.setAttributeNS(\"urn:oasis:names:tc:opendocument:xmlns:table:1.0\", \"table:style-name\", q);\n\t            y.appendChild(x);\n\t            for (v = 0; v < b; v += 1) {\n\t                x = h.createElementNS(\"urn:oasis:names:tc:opendocument:xmlns:table:1.0\", \"table:table-row\");\n\t                for (u = 0; u < f; u += 1)\n\t                    z = h.createElementNS(\"urn:oasis:names:tc:opendocument:xmlns:table:1.0\", \"table:table-cell\"),\n\t                    (w = g(v, u)) && z.setAttributeNS(\"urn:oasis:names:tc:opendocument:xmlns:table:1.0\", \"table:style-name\", w),\n\t                    w = h.createElementNS(\"urn:oasis:names:tc:opendocument:xmlns:text:1.0\", \"text:p\"),\n\t                    z.appendChild(w),\n\t                    x.appendChild(z);\n\t                y.appendChild(x)\n\t            }\n\t            c = l.getParagraphElement(c.textNode);\n\t            e.insertBefore(y, c.nextSibling);\n\t            a.emit(ops.OdtDocument.signalStepsInserted, {\n\t                position: n\n\t            });\n\t            a.getOdfCanvas().refreshSize();\n\t            a.emit(ops.OdtDocument.signalTableAdded, {\n\t                tableElement: y,\n\t                memberId: k,\n\t                timeStamp: d\n\t            });\n\t            a.getOdfCanvas().rerenderAnnotations();\n\t            return !0\n\t        }\n\t        return !1\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"InsertTable\",\n\t            memberid: k,\n\t            timestamp: d,\n\t            position: n,\n\t            initialRows: b,\n\t            initialColumns: f,\n\t            tableName: p,\n\t            tableStyleName: r,\n\t            tableColumnStyleName: q,\n\t            tableCellStyleMatrix: e\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpInsertText = function() {\n\t    function g(b) {\n\t        return \"\\t\" !== b && p.isODFWhitespace(b)\n\t    }\n\t    var k, d, b, f, n, p = odf.OdfUtils;\n\t    this.init = function(g) {\n\t        k = g.memberid;\n\t        d = g.timestamp;\n\t        b = g.position;\n\t        n = g.text;\n\t        f = \"true\" === g.moveCursor || !0 === g.moveCursor\n\t    }\n\t    ;\n\t    this.isEdit = !0;\n\t    this.group = void 0;\n\t    this.execute = function(r) {\n\t        var q, e, l, a = null, c = r.getDOMDocument(), m, h = 0, y, x = r.getCursor(k), z;\n\t        r.upgradeWhitespacesAtPosition(b);\n\t        if (q = r.getTextNodeAtStep(b)) {\n\t            e = q.textNode;\n\t            a = e.nextSibling;\n\t            l = e.parentNode;\n\t            m = p.getParagraphElement(e);\n\t            for (z = 0; z < n.length; z += 1) {\n\t                if (!(y = \"\\t\" === n[z])) {\n\t                    y = n;\n\t                    var w = z;\n\t                    y = g(y[w]) && (0 === w || w === y.length - 1 || g(y[w - 1]))\n\t                }\n\t                y && (0 === h ? (q.offset !== e.length && (a = e.splitText(q.offset)),\n\t                0 < z && e.appendData(n.substring(0, z))) : h < z && (h = n.substring(h, z),\n\t                l.insertBefore(c.createTextNode(h), a)),\n\t                h = z + 1,\n\t                \"\\t\" === n[z] ? (y = c.createElementNS(\"urn:oasis:names:tc:opendocument:xmlns:text:1.0\", \"text:tab\"),\n\t                y.appendChild(c.createTextNode(\"\\t\"))) : (\" \" !== n[z] && runtime.log(\"WARN: InsertText operation contains non-tab, non-space whitespace character (character code \" + n.charCodeAt(z) + \")\"),\n\t                y = c.createElementNS(\"urn:oasis:names:tc:opendocument:xmlns:text:1.0\", \"text:s\"),\n\t                y.appendChild(c.createTextNode(\" \"))),\n\t                l.insertBefore(y, a))\n\t            }\n\t            0 === h ? e.insertData(q.offset, n) : h < n.length && (q = n.substring(h),\n\t            l.insertBefore(c.createTextNode(q), a));\n\t            l = e.parentNode;\n\t            a = e.nextSibling;\n\t            l.removeChild(e);\n\t            l.insertBefore(e, a);\n\t            0 === e.length && e.parentNode.removeChild(e);\n\t            r.emit(ops.OdtDocument.signalStepsInserted, {\n\t                position: b\n\t            });\n\t            x && f && (r.moveCursor(k, b + n.length, 0),\n\t            r.emit(ops.Document.signalCursorMoved, x));\n\t            r.downgradeWhitespacesAtPosition(b);\n\t            r.downgradeWhitespacesAtPosition(b + n.length);\n\t            r.getOdfCanvas().refreshSize();\n\t            r.emit(ops.OdtDocument.signalParagraphChanged, {\n\t                paragraphElement: m,\n\t                memberId: k,\n\t                timeStamp: d\n\t            });\n\t            r.getOdfCanvas().rerenderAnnotations();\n\t            return !0\n\t        }\n\t        return !1\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"InsertText\",\n\t            memberid: k,\n\t            timestamp: d,\n\t            position: b,\n\t            text: n,\n\t            moveCursor: f\n\t        }\n\t    }\n\t}\n\t;\n\todf.CollapsingRules = function(g) {\n\t    function k(d) {\n\t        return b.isODFNode(d) || \"br\" === d.localName && b.isLineBreak(d.parentNode) || d.nodeType === Node.TEXT_NODE && b.isODFNode(d.parentNode) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT\n\t    }\n\t    function d(n) {\n\t        var p;\n\t        n.nodeType === Node.TEXT_NODE ? (p = n.parentNode,\n\t        p.removeChild(n)) : p = f.removeUnwantedNodes(n, k);\n\t        if (n = p)\n\t            n = p,\n\t            n = !b.isParagraph(n) && n !== g && b.hasNoODFContent(n);\n\t        return n ? d(p) : p\n\t    }\n\t    var b = odf.OdfUtils\n\t      , f = core.DomUtils;\n\t    this.mergeChildrenIntoParent = d\n\t}\n\t;\n\tops.OpMergeParagraph = function() {\n\t    function g(a) {\n\t        return odf.OdfUtils.isInlineRoot(a) ? NodeFilter.FILTER_SKIP : l.isGroupingElement(a) && l.hasNoODFContent(a) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT\n\t    }\n\t    function k(a) {\n\t        if (a.nodeType === Node.TEXT_NODE) {\n\t            if (0 === a.length)\n\t                return runtime.log(\"WARN: Empty text node found during merge operation\"),\n\t                !0;\n\t            if (l.isODFWhitespace(a.data) && !1 === l.isSignificantWhitespace(a, 0))\n\t                return !0;\n\t            a = \"#text\"\n\t        } else\n\t            a = (a.prefix ? a.prefix + \":\" : \"\") + a.localName;\n\t        runtime.log(\"WARN: Unexpected text element found near paragraph boundary [\" + a + \"]\");\n\t        return !1\n\t    }\n\t    function d(c) {\n\t        c.collapsed || (a.splitBoundaries(c),\n\t        c = l.getTextElements(c, !1, !0).filter(k),\n\t        c.forEach(function(a) {\n\t            a.parentNode.removeChild(a)\n\t        }))\n\t    }\n\t    function b(a, c, b) {\n\t        a = a.convertCursorStepToDomPoint(c);\n\t        var d = l.getParagraphElement(a.node, a.offset);\n\t        runtime.assert(Boolean(d), \"Paragraph not found at step \" + c);\n\t        b && b.setPosition(a.node, a.offset);\n\t        return d\n\t    }\n\t    var f, n, p, r, q, e, l = odf.OdfUtils, a = core.DomUtils, c = odf.Namespaces.textns;\n\t    this.init = function(a) {\n\t        f = a.memberid;\n\t        n = a.timestamp;\n\t        p = a.moveCursor;\n\t        r = a.paragraphStyleName;\n\t        q = parseInt(a.sourceStartPosition, 10);\n\t        e = parseInt(a.destinationStartPosition, 10)\n\t    }\n\t    ;\n\t    this.isEdit = !0;\n\t    this.group = void 0;\n\t    this.execute = function(m) {\n\t        var h, l, k = m.getCursor(f);\n\t        h = m.getRootNode();\n\t        var z = new odf.CollapsingRules(h), w = m.createStepIterator(h, 0, [m.getPositionFilter()], h), v;\n\t        runtime.assert(e < q, \"Destination paragraph (\" + e + \") must be before source paragraph (\" + q + \")\");\n\t        l = b(m, e);\n\t        h = b(m, q, w);\n\t        w.previousStep();\n\t        runtime.assert(a.containsNode(l, w.container()), \"Destination paragraph must be adjacent to the source paragraph\");\n\t        v = l.ownerDocument.createRange();\n\t        w.setPosition(l, l.childNodes.length);\n\t        w.roundToPreviousStep();\n\t        v.setStart(w.container(), w.offset());\n\t        v.setEnd(l, l.childNodes.length);\n\t        d(v);\n\t        v = l.childNodes.length;\n\t        var u = h.ownerDocument.createRange();\n\t        w.setPosition(h, 0);\n\t        w.roundToNextStep();\n\t        u.setStart(h, 0);\n\t        u.setEnd(w.container(), w.offset());\n\t        d(u);\n\t        for (u = h.firstChild; u; )\n\t            \"editinfo\" === u.localName ? h.removeChild(u) : (l.appendChild(u),\n\t            a.removeUnwantedNodes(u, g)),\n\t            u = h.firstChild;\n\t        runtime.assert(0 === h.childNodes.length, \"Source paragraph should be empty before it is removed\");\n\t        z.mergeChildrenIntoParent(h);\n\t        m.emit(ops.OdtDocument.signalStepsRemoved, {\n\t            position: q - 1\n\t        });\n\t        w.setPosition(l, v);\n\t        w.roundToClosestStep();\n\t        w.previousStep() || w.roundToNextStep();\n\t        m.downgradeWhitespaces(w);\n\t        r ? l.setAttributeNS(c, \"text:style-name\", r) : l.removeAttributeNS(c, \"style-name\");\n\t        k && p && (m.moveCursor(f, q - 1, 0),\n\t        m.emit(ops.Document.signalCursorMoved, k));\n\t        m.fixCursorPositions();\n\t        m.getOdfCanvas().refreshSize();\n\t        m.emit(ops.OdtDocument.signalParagraphChanged, {\n\t            paragraphElement: l,\n\t            memberId: f,\n\t            timeStamp: n\n\t        });\n\t        m.getOdfCanvas().rerenderAnnotations();\n\t        return !0\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"MergeParagraph\",\n\t            memberid: f,\n\t            timestamp: n,\n\t            moveCursor: p,\n\t            paragraphStyleName: r,\n\t            sourceStartPosition: q,\n\t            destinationStartPosition: e\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpMoveCursor = function() {\n\t    var g, k, d, b, f;\n\t    this.init = function(n) {\n\t        g = n.memberid;\n\t        k = n.timestamp;\n\t        d = n.position;\n\t        b = n.length || 0;\n\t        f = n.selectionType || ops.OdtCursor.RangeSelection\n\t    }\n\t    ;\n\t    this.isEdit = !1;\n\t    this.group = void 0;\n\t    this.execute = function(n) {\n\t        var k = n.getCursor(g), r;\n\t        if (!k)\n\t            return !1;\n\t        r = n.convertCursorToDomRange(d, b);\n\t        k.setSelectedRange(r, 0 <= b);\n\t        k.setSelectionType(f);\n\t        n.emit(ops.Document.signalCursorMoved, k);\n\t        return !0\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"MoveCursor\",\n\t            memberid: g,\n\t            timestamp: k,\n\t            position: d,\n\t            length: b,\n\t            selectionType: f\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpRemoveAnnotation = function() {\n\t    var g, k, d, b, f = core.DomUtils;\n\t    this.init = function(f) {\n\t        g = f.memberid;\n\t        k = f.timestamp;\n\t        d = parseInt(f.position, 10);\n\t        b = parseInt(f.length, 10)\n\t    }\n\t    ;\n\t    this.isEdit = !0;\n\t    this.group = void 0;\n\t    this.execute = function(b) {\n\t        function g(b) {\n\t            q.parentNode.insertBefore(b, q)\n\t        }\n\t        for (var k = b.getIteratorAtPosition(d).container(), q; k.namespaceURI !== odf.Namespaces.officens || \"annotation\" !== k.localName; )\n\t            k = k.parentNode;\n\t        if (null === k)\n\t            return !1;\n\t        q = k;\n\t        k = q.annotationEndElement;\n\t        b.getOdfCanvas().forgetAnnotation(q);\n\t        f.getElementsByTagNameNS(q, \"urn:webodf:names:cursor\", \"cursor\").forEach(g);\n\t        f.getElementsByTagNameNS(q, \"urn:webodf:names:cursor\", \"anchor\").forEach(g);\n\t        q.parentNode.removeChild(q);\n\t        k && k.parentNode.removeChild(k);\n\t        b.emit(ops.OdtDocument.signalStepsRemoved, {\n\t            position: 0 < d ? d - 1 : d\n\t        });\n\t        b.getOdfCanvas().rerenderAnnotations();\n\t        b.fixCursorPositions();\n\t        return !0\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"RemoveAnnotation\",\n\t            memberid: g,\n\t            timestamp: k,\n\t            position: d,\n\t            length: b\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpRemoveBlob = function() {\n\t    var g, k, d;\n\t    this.init = function(b) {\n\t        g = b.memberid;\n\t        k = b.timestamp;\n\t        d = b.filename\n\t    }\n\t    ;\n\t    this.isEdit = !0;\n\t    this.group = void 0;\n\t    this.execute = function(b) {\n\t        b.getOdfCanvas().odfContainer().removeBlob(d);\n\t        return !0\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"RemoveBlob\",\n\t            memberid: g,\n\t            timestamp: k,\n\t            filename: d\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpRemoveCursor = function() {\n\t    var g, k;\n\t    this.init = function(d) {\n\t        g = d.memberid;\n\t        k = d.timestamp\n\t    }\n\t    ;\n\t    this.isEdit = !1;\n\t    this.group = void 0;\n\t    this.execute = function(d) {\n\t        return d.removeCursor(g) ? !0 : !1\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"RemoveCursor\",\n\t            memberid: g,\n\t            timestamp: k\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpRemoveHyperlink = function() {\n\t    var g, k, d, b, f = core.DomUtils, n = odf.OdfUtils;\n\t    this.init = function(f) {\n\t        g = f.memberid;\n\t        k = f.timestamp;\n\t        d = f.position;\n\t        b = f.length\n\t    }\n\t    ;\n\t    this.isEdit = !0;\n\t    this.group = void 0;\n\t    this.execute = function(p) {\n\t        var r = p.convertCursorToDomRange(d, b)\n\t          , q = n.getHyperlinkElements(r);\n\t        runtime.assert(1 === q.length, \"The given range should only contain a single link.\");\n\t        q = f.mergeIntoParent(q[0]);\n\t        r.detach();\n\t        p.fixCursorPositions();\n\t        p.getOdfCanvas().refreshSize();\n\t        p.getOdfCanvas().rerenderAnnotations();\n\t        p.emit(ops.OdtDocument.signalParagraphChanged, {\n\t            paragraphElement: n.getParagraphElement(q),\n\t            memberId: g,\n\t            timeStamp: k\n\t        });\n\t        return !0\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"RemoveHyperlink\",\n\t            memberid: g,\n\t            timestamp: k,\n\t            position: d,\n\t            length: b\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpRemoveMember = function() {\n\t    var g, k;\n\t    this.init = function(d) {\n\t        g = d.memberid;\n\t        k = parseInt(d.timestamp, 10)\n\t    }\n\t    ;\n\t    this.isEdit = !1;\n\t    this.group = void 0;\n\t    this.execute = function(d) {\n\t        if (!d.getMember(g))\n\t            return !1;\n\t        d.removeMember(g);\n\t        d.emit(ops.Document.signalMemberRemoved, g);\n\t        return !0\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"RemoveMember\",\n\t            memberid: g,\n\t            timestamp: k\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpRemoveStyle = function() {\n\t    var g, k, d, b;\n\t    this.init = function(f) {\n\t        g = f.memberid;\n\t        k = f.timestamp;\n\t        d = f.styleName;\n\t        b = f.styleFamily\n\t    }\n\t    ;\n\t    this.isEdit = !0;\n\t    this.group = void 0;\n\t    this.execute = function(f) {\n\t        var g = f.getFormatting().getStyleElement(d, b);\n\t        if (!g)\n\t            return !1;\n\t        g.parentNode.removeChild(g);\n\t        f.getOdfCanvas().refreshCSS();\n\t        f.emit(ops.OdtDocument.signalCommonStyleDeleted, {\n\t            name: d,\n\t            family: b\n\t        });\n\t        return !0\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"RemoveStyle\",\n\t            memberid: g,\n\t            timestamp: k,\n\t            styleName: d,\n\t            styleFamily: b\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpRemoveText = function() {\n\t    var g, k, d, b, f = odf.OdfUtils, n = core.DomUtils;\n\t    this.init = function(f) {\n\t        runtime.assert(0 <= f.length, \"OpRemoveText only supports positive lengths\");\n\t        g = f.memberid;\n\t        k = f.timestamp;\n\t        d = parseInt(f.position, 10);\n\t        b = parseInt(f.length, 10)\n\t    }\n\t    ;\n\t    this.isEdit = !0;\n\t    this.group = void 0;\n\t    this.execute = function(p) {\n\t        var r, q, e, l = p.getCursor(g), a = new odf.CollapsingRules(p.getRootNode());\n\t        p.upgradeWhitespacesAtPosition(d);\n\t        p.upgradeWhitespacesAtPosition(d + b);\n\t        r = p.convertCursorToDomRange(d, b);\n\t        n.splitBoundaries(r);\n\t        q = f.getTextElements(r, !1, !0);\n\t        e = f.getParagraphElement(r.startContainer, r.startOffset);\n\t        runtime.assert(void 0 !== e, \"Attempting to remove text outside a paragraph element\");\n\t        r.detach();\n\t        q.forEach(function(c) {\n\t            c.parentNode ? (runtime.assert(n.containsNode(e, c), \"RemoveText only supports removing elements within the same paragraph\"),\n\t            a.mergeChildrenIntoParent(c)) : runtime.log(\"WARN: text element has already been removed from it's container\")\n\t        });\n\t        p.emit(ops.OdtDocument.signalStepsRemoved, {\n\t            position: d\n\t        });\n\t        p.downgradeWhitespacesAtPosition(d);\n\t        p.fixCursorPositions();\n\t        p.getOdfCanvas().refreshSize();\n\t        p.emit(ops.OdtDocument.signalParagraphChanged, {\n\t            paragraphElement: e,\n\t            memberId: g,\n\t            timeStamp: k\n\t        });\n\t        l && (l.resetSelectionType(),\n\t        p.emit(ops.Document.signalCursorMoved, l));\n\t        p.getOdfCanvas().rerenderAnnotations();\n\t        return !0\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"RemoveText\",\n\t            memberid: g,\n\t            timestamp: k,\n\t            position: d,\n\t            length: b\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpSetBlob = function() {\n\t    var g, k, d, b, f;\n\t    this.init = function(n) {\n\t        g = n.memberid;\n\t        k = n.timestamp;\n\t        d = n.filename;\n\t        b = n.mimetype;\n\t        f = n.content\n\t    }\n\t    ;\n\t    this.isEdit = !0;\n\t    this.group = void 0;\n\t    this.execute = function(g) {\n\t        g.getOdfCanvas().odfContainer().setBlob(d, b, f);\n\t        return !0\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"SetBlob\",\n\t            memberid: g,\n\t            timestamp: k,\n\t            filename: d,\n\t            mimetype: b,\n\t            content: f\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpSetParagraphStyle = function() {\n\t    function g(b, d, f) {\n\t        var e = [b.getPositionFilter()]\n\t          , g = f.container();\n\t        f = f.unfilteredDomOffset();\n\t        return !1 === b.createStepIterator(g, f, e, d).previousStep()\n\t    }\n\t    var k, d, b, f, n = odf.OdfUtils;\n\t    this.init = function(g) {\n\t        k = g.memberid;\n\t        d = g.timestamp;\n\t        b = g.position;\n\t        f = g.styleName\n\t    }\n\t    ;\n\t    this.isEdit = !0;\n\t    this.group = void 0;\n\t    this.execute = function(p) {\n\t        var r, q;\n\t        r = p.getIteratorAtPosition(b);\n\t        return (q = n.getParagraphElement(r.container())) ? (runtime.assert(g(p, q, r), \"SetParagraphStyle position should be the first position in the paragraph\"),\n\t        f ? q.setAttributeNS(\"urn:oasis:names:tc:opendocument:xmlns:text:1.0\", \"text:style-name\", f) : q.removeAttributeNS(\"urn:oasis:names:tc:opendocument:xmlns:text:1.0\", \"style-name\"),\n\t        p.getOdfCanvas().refreshSize(),\n\t        p.emit(ops.OdtDocument.signalParagraphChanged, {\n\t            paragraphElement: q,\n\t            timeStamp: d,\n\t            memberId: k\n\t        }),\n\t        p.getOdfCanvas().rerenderAnnotations(),\n\t        !0) : !1\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"SetParagraphStyle\",\n\t            memberid: k,\n\t            timestamp: d,\n\t            position: b,\n\t            styleName: f\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpSplitParagraph = function() {\n\t    var g, k, d, b, f, n, p = odf.OdfUtils, r = odf.Namespaces.textns;\n\t    this.init = function(p) {\n\t        g = p.memberid;\n\t        k = p.timestamp;\n\t        b = p.position;\n\t        d = p.sourceParagraphPosition;\n\t        n = p.paragraphStyleName;\n\t        f = \"true\" === p.moveCursor || !0 === p.moveCursor\n\t    }\n\t    ;\n\t    this.isEdit = !0;\n\t    this.group = void 0;\n\t    this.execute = function(d) {\n\t        var e, l, a, c, m, h, y, x = d.getCursor(g);\n\t        d.upgradeWhitespacesAtPosition(b);\n\t        e = d.getTextNodeAtStep(b);\n\t        if (!e)\n\t            return !1;\n\t        l = p.getParagraphElement(e.textNode);\n\t        if (!l)\n\t            return !1;\n\t        a = p.isListItem(l.parentNode) ? l.parentNode : l;\n\t        0 === e.offset ? (y = e.textNode.previousSibling,\n\t        h = null) : (y = e.textNode,\n\t        h = e.offset >= e.textNode.length ? null : e.textNode.splitText(e.offset));\n\t        for (c = e.textNode; c !== a; ) {\n\t            c = c.parentNode;\n\t            m = c.cloneNode(!1);\n\t            h && m.appendChild(h);\n\t            if (y)\n\t                for (; y && y.nextSibling; )\n\t                    m.appendChild(y.nextSibling);\n\t            else\n\t                for (; c.firstChild; )\n\t                    m.appendChild(c.firstChild);\n\t            c.parentNode.insertBefore(m, c.nextSibling);\n\t            y = c;\n\t            h = m\n\t        }\n\t        p.isListItem(h) && (h = h.childNodes.item(0));\n\t        n ? h.setAttributeNS(r, \"text:style-name\", n) : h.removeAttributeNS(r, \"style-name\");\n\t        0 === e.textNode.length && e.textNode.parentNode.removeChild(e.textNode);\n\t        d.emit(ops.OdtDocument.signalStepsInserted, {\n\t            position: b\n\t        });\n\t        x && f && (d.moveCursor(g, b + 1, 0),\n\t        d.emit(ops.Document.signalCursorMoved, x));\n\t        d.fixCursorPositions();\n\t        d.getOdfCanvas().refreshSize();\n\t        d.emit(ops.OdtDocument.signalParagraphChanged, {\n\t            paragraphElement: l,\n\t            memberId: g,\n\t            timeStamp: k\n\t        });\n\t        d.emit(ops.OdtDocument.signalParagraphChanged, {\n\t            paragraphElement: h,\n\t            memberId: g,\n\t            timeStamp: k\n\t        });\n\t        d.getOdfCanvas().rerenderAnnotations();\n\t        return !0\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"SplitParagraph\",\n\t            memberid: g,\n\t            timestamp: k,\n\t            position: b,\n\t            sourceParagraphPosition: d,\n\t            paragraphStyleName: n,\n\t            moveCursor: f\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpUpdateMember = function() {\n\t    function g(d) {\n\t        var f = \"//dc:creator[@editinfo:memberid='\" + k + \"']\";\n\t        d = xmldom.XPath.getODFElementsWithXPath(d.getRootNode(), f, function(b) {\n\t            return \"editinfo\" === b ? \"urn:webodf:names:editinfo\" : odf.Namespaces.lookupNamespaceURI(b)\n\t        });\n\t        for (f = 0; f < d.length; f += 1)\n\t            d[f].textContent = b.fullName\n\t    }\n\t    var k, d, b, f;\n\t    this.init = function(g) {\n\t        k = g.memberid;\n\t        d = parseInt(g.timestamp, 10);\n\t        b = g.setProperties;\n\t        f = g.removedProperties\n\t    }\n\t    ;\n\t    this.isEdit = !1;\n\t    this.group = void 0;\n\t    this.execute = function(d) {\n\t        var p = d.getMember(k);\n\t        if (!p)\n\t            return !1;\n\t        f && p.removeProperties(f);\n\t        b && (p.setProperties(b),\n\t        b.fullName && g(d));\n\t        d.emit(ops.Document.signalMemberUpdated, p);\n\t        return !0\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"UpdateMember\",\n\t            memberid: k,\n\t            timestamp: d,\n\t            setProperties: b,\n\t            removedProperties: f\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpUpdateMetadata = function() {\n\t    var g, k, d, b;\n\t    this.init = function(f) {\n\t        g = f.memberid;\n\t        k = parseInt(f.timestamp, 10);\n\t        d = f.setProperties;\n\t        b = f.removedProperties\n\t    }\n\t    ;\n\t    this.isEdit = !0;\n\t    this.group = void 0;\n\t    this.execute = function(f) {\n\t        var g = f.getOdfCanvas().odfContainer()\n\t          , k = null;\n\t        b && (k = b.attributes.split(\",\"));\n\t        g.setMetadata(d, k);\n\t        f.emit(ops.OdtDocument.signalMetadataUpdated, {\n\t            setProperties: null !== d ? d : {},\n\t            removedProperties: null !== k ? k : []\n\t        });\n\t        return !0\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"UpdateMetadata\",\n\t            memberid: g,\n\t            timestamp: k,\n\t            setProperties: d,\n\t            removedProperties: b\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpUpdateParagraphStyle = function() {\n\t    function g(b, d) {\n\t        var e, f, a = d ? d.split(\",\") : [];\n\t        for (e = 0; e < a.length; e += 1)\n\t            f = a[e].split(\":\"),\n\t            b.removeAttributeNS(odf.Namespaces.lookupNamespaceURI(f[0]), f[1])\n\t    }\n\t    var k, d, b, f, n, p = odf.Namespaces.stylens;\n\t    this.init = function(g) {\n\t        k = g.memberid;\n\t        d = g.timestamp;\n\t        b = g.styleName;\n\t        f = g.setProperties;\n\t        n = g.removedProperties\n\t    }\n\t    ;\n\t    this.isEdit = !0;\n\t    this.group = void 0;\n\t    this.execute = function(d) {\n\t        var k = d.getFormatting(), e, l, a;\n\t        return (e = \"\" !== b ? k.getStyleElement(b, \"paragraph\") : k.getDefaultStyleElement(\"paragraph\")) ? (l = e.getElementsByTagNameNS(p, \"paragraph-properties\").item(0),\n\t        a = e.getElementsByTagNameNS(p, \"text-properties\").item(0),\n\t        f && k.updateStyle(e, f),\n\t        n && (k = n[\"style:paragraph-properties\"],\n\t        l && k && (g(l, k.attributes),\n\t        0 === l.attributes.length && e.removeChild(l)),\n\t        k = n[\"style:text-properties\"],\n\t        a && k && (g(a, k.attributes),\n\t        0 === a.attributes.length && e.removeChild(a)),\n\t        g(e, n.attributes)),\n\t        d.getOdfCanvas().refreshCSS(),\n\t        d.emit(ops.OdtDocument.signalParagraphStyleModified, b),\n\t        d.getOdfCanvas().rerenderAnnotations(),\n\t        !0) : !1\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"UpdateParagraphStyle\",\n\t            memberid: k,\n\t            timestamp: d,\n\t            styleName: b,\n\t            setProperties: f,\n\t            removedProperties: n\n\t        }\n\t    }\n\t}\n\t;\n\tops.OperationFactory = function() {\n\t    function g(d) {\n\t        return function(b) {\n\t            return new d\n\t        }\n\t    }\n\t    var k;\n\t    this.register = function(d, b) {\n\t        k[d] = b\n\t    }\n\t    ;\n\t    this.create = function(d) {\n\t        var b = null\n\t          , f = k[d.optype];\n\t        f && (b = f(d),\n\t        b.init(d));\n\t        return b\n\t    }\n\t    ;\n\t    k = {\n\t        AddMember: g(ops.OpAddMember),\n\t        UpdateMember: g(ops.OpUpdateMember),\n\t        RemoveMember: g(ops.OpRemoveMember),\n\t        AddCursor: g(ops.OpAddCursor),\n\t        ApplyDirectStyling: g(ops.OpApplyDirectStyling),\n\t        SetBlob: g(ops.OpSetBlob),\n\t        RemoveBlob: g(ops.OpRemoveBlob),\n\t        InsertImage: g(ops.OpInsertImage),\n\t        InsertTable: g(ops.OpInsertTable),\n\t        InsertText: g(ops.OpInsertText),\n\t        RemoveText: g(ops.OpRemoveText),\n\t        MergeParagraph: g(ops.OpMergeParagraph),\n\t        SplitParagraph: g(ops.OpSplitParagraph),\n\t        SetParagraphStyle: g(ops.OpSetParagraphStyle),\n\t        UpdateParagraphStyle: g(ops.OpUpdateParagraphStyle),\n\t        AddStyle: g(ops.OpAddStyle),\n\t        RemoveStyle: g(ops.OpRemoveStyle),\n\t        MoveCursor: g(ops.OpMoveCursor),\n\t        RemoveCursor: g(ops.OpRemoveCursor),\n\t        AddAnnotation: g(ops.OpAddAnnotation),\n\t        RemoveAnnotation: g(ops.OpRemoveAnnotation),\n\t        UpdateMetadata: g(ops.OpUpdateMetadata),\n\t        ApplyHyperlink: g(ops.OpApplyHyperlink),\n\t        RemoveHyperlink: g(ops.OpRemoveHyperlink)\n\t    }\n\t}\n\t;\n\tops.OperationRouter = function() {}\n\t;\n\tops.OperationRouter.prototype.setOperationFactory = function(g) {}\n\t;\n\tops.OperationRouter.prototype.setPlaybackFunction = function(g) {}\n\t;\n\tops.OperationRouter.prototype.push = function(g) {}\n\t;\n\tops.OperationRouter.prototype.close = function(g) {}\n\t;\n\tops.OperationRouter.prototype.subscribe = function(g, k) {}\n\t;\n\tops.OperationRouter.prototype.unsubscribe = function(g, k) {}\n\t;\n\tops.OperationRouter.prototype.hasLocalUnsyncedOps = function() {}\n\t;\n\tops.OperationRouter.prototype.hasSessionHostConnection = function() {}\n\t;\n\tops.OperationRouter.signalProcessingBatchStart = \"router/batchstart\";\n\tops.OperationRouter.signalProcessingBatchEnd = \"router/batchend\";\n\tops.TrivialOperationRouter = function() {\n\t    var g = new core.EventNotifier([ops.OperationRouter.signalProcessingBatchStart, ops.OperationRouter.signalProcessingBatchEnd]), k, d, b = 0;\n\t    this.setOperationFactory = function(b) {\n\t        k = b\n\t    }\n\t    ;\n\t    this.setPlaybackFunction = function(b) {\n\t        d = b\n\t    }\n\t    ;\n\t    this.push = function(f) {\n\t        b += 1;\n\t        g.emit(ops.OperationRouter.signalProcessingBatchStart, {});\n\t        f.forEach(function(f) {\n\t            f = f.spec();\n\t            f.timestamp = Date.now();\n\t            f = k.create(f);\n\t            f.group = \"g\" + b;\n\t            d(f)\n\t        });\n\t        g.emit(ops.OperationRouter.signalProcessingBatchEnd, {})\n\t    }\n\t    ;\n\t    this.close = function(b) {\n\t        b()\n\t    }\n\t    ;\n\t    this.subscribe = function(b, d) {\n\t        g.subscribe(b, d)\n\t    }\n\t    ;\n\t    this.unsubscribe = function(b, d) {\n\t        g.unsubscribe(b, d)\n\t    }\n\t    ;\n\t    this.hasLocalUnsyncedOps = function() {\n\t        return !1\n\t    }\n\t    ;\n\t    this.hasSessionHostConnection = function() {\n\t        return !0\n\t    }\n\t}\n\t;\n\tops.Session = function(g) {\n\t    function k(b) {\n\t        f.emit(ops.OdtDocument.signalProcessingBatchStart, b)\n\t    }\n\t    function d(b) {\n\t        f.emit(ops.OdtDocument.signalProcessingBatchEnd, b)\n\t    }\n\t    var b = new ops.OperationFactory\n\t      , f = new ops.OdtDocument(g)\n\t      , n = null;\n\t    this.setOperationFactory = function(d) {\n\t        b = d;\n\t        n && n.setOperationFactory(b)\n\t    }\n\t    ;\n\t    this.setOperationRouter = function(g) {\n\t        n && (n.unsubscribe(ops.OperationRouter.signalProcessingBatchStart, k),\n\t        n.unsubscribe(ops.OperationRouter.signalProcessingBatchEnd, d));\n\t        n = g;\n\t        n.subscribe(ops.OperationRouter.signalProcessingBatchStart, k);\n\t        n.subscribe(ops.OperationRouter.signalProcessingBatchEnd, d);\n\t        g.setPlaybackFunction(function(b) {\n\t            f.emit(ops.OdtDocument.signalOperationStart, b);\n\t            return b.execute(f) ? (f.emit(ops.OdtDocument.signalOperationEnd, b),\n\t            !0) : !1\n\t        });\n\t        g.setOperationFactory(b)\n\t    }\n\t    ;\n\t    this.getOperationFactory = function() {\n\t        return b\n\t    }\n\t    ;\n\t    this.getOdtDocument = function() {\n\t        return f\n\t    }\n\t    ;\n\t    this.enqueue = function(b) {\n\t        n.push(b)\n\t    }\n\t    ;\n\t    this.close = function(b) {\n\t        n.close(function(d) {\n\t            d ? b(d) : f.close(b)\n\t        })\n\t    }\n\t    ;\n\t    this.destroy = function(b) {\n\t        f.destroy(b)\n\t    }\n\t    ;\n\t    this.setOperationRouter(new ops.TrivialOperationRouter)\n\t}\n\t;\n\tgui.AnnotationController = function(g, k, d) {\n\t    function b() {\n\t        var a = r.getCursor(d)\n\t          , a = a && a.getNode()\n\t          , b = !1;\n\t        a && (b = !l.isWithinAnnotation(a, r.getRootNode()));\n\t        b !== q && (q = b,\n\t        e.emit(gui.AnnotationController.annotatableChanged, q))\n\t    }\n\t    function f(a) {\n\t        a.getMemberId() === d && b()\n\t    }\n\t    function n(a) {\n\t        a === d && b()\n\t    }\n\t    function p(a) {\n\t        a.getMemberId() === d && b()\n\t    }\n\t    var r = g.getOdtDocument()\n\t      , q = !1\n\t      , e = new core.EventNotifier([gui.AnnotationController.annotatableChanged])\n\t      , l = odf.OdfUtils\n\t      , a = core.StepDirection.NEXT;\n\t    this.isAnnotatable = function() {\n\t        return q\n\t    }\n\t    ;\n\t    this.addAnnotation = function() {\n\t        var a = new ops.OpAddAnnotation\n\t          , b = r.getCursorSelection(d)\n\t          , e = b.length\n\t          , b = b.position;\n\t        q && (0 === e ? e = void 0 : (b = 0 <= e ? b : b + e,\n\t        e = Math.abs(e)),\n\t        a.init({\n\t            memberid: d,\n\t            position: b,\n\t            length: e,\n\t            name: d + Date.now()\n\t        }),\n\t        g.enqueue([a]))\n\t    }\n\t    ;\n\t    this.removeAnnotation = function(c) {\n\t        var b, e;\n\t        b = r.getMember(d).getProperties().fullName;\n\t        if (!0 !== k.getState(gui.CommonConstraints.EDIT.ANNOTATIONS.ONLY_DELETE_OWN) || b === l.getAnnotationCreator(c))\n\t            b = r.convertDomPointToCursorStep(c, 0, a),\n\t            e = r.convertDomPointToCursorStep(c, c.childNodes.length),\n\t            c = new ops.OpRemoveAnnotation,\n\t            c.init({\n\t                memberid: d,\n\t                position: b,\n\t                length: e - b\n\t            }),\n\t            e = new ops.OpMoveCursor,\n\t            e.init({\n\t                memberid: d,\n\t                position: 0 < b ? b - 1 : b,\n\t                length: 0\n\t            }),\n\t            g.enqueue([c, e])\n\t    }\n\t    ;\n\t    this.subscribe = function(a, b) {\n\t        e.subscribe(a, b)\n\t    }\n\t    ;\n\t    this.unsubscribe = function(a, b) {\n\t        e.unsubscribe(a, b)\n\t    }\n\t    ;\n\t    this.destroy = function(a) {\n\t        r.unsubscribe(ops.Document.signalCursorAdded, f);\n\t        r.unsubscribe(ops.Document.signalCursorRemoved, n);\n\t        r.unsubscribe(ops.Document.signalCursorMoved, p);\n\t        a()\n\t    }\n\t    ;\n\t    k.registerConstraint(gui.CommonConstraints.EDIT.ANNOTATIONS.ONLY_DELETE_OWN);\n\t    r.subscribe(ops.Document.signalCursorAdded, f);\n\t    r.subscribe(ops.Document.signalCursorRemoved, n);\n\t    r.subscribe(ops.Document.signalCursorMoved, p);\n\t    b()\n\t}\n\t;\n\tgui.AnnotationController.annotatableChanged = \"annotatable/changed\";\n\tgui.Avatar = function(g, k) {\n\t    var d = this, b, f, n;\n\t    this.setColor = function(b) {\n\t        f.style.borderColor = b\n\t    }\n\t    ;\n\t    this.setImageUrl = function(b) {\n\t        d.isVisible() ? f.src = b : n = b\n\t    }\n\t    ;\n\t    this.isVisible = function() {\n\t        return \"block\" === b.style.display\n\t    }\n\t    ;\n\t    this.show = function() {\n\t        n && (f.src = n,\n\t        n = void 0);\n\t        b.style.display = \"block\"\n\t    }\n\t    ;\n\t    this.hide = function() {\n\t        b.style.display = \"none\"\n\t    }\n\t    ;\n\t    this.markAsFocussed = function(d) {\n\t        d ? b.classList.add(\"active\") : b.classList.remove(\"active\")\n\t    }\n\t    ;\n\t    this.destroy = function(d) {\n\t        g.removeChild(b);\n\t        d()\n\t    }\n\t    ;\n\t    (function() {\n\t        var d = g.ownerDocument;\n\t        b = d.createElement(\"div\");\n\t        f = d.createElement(\"img\");\n\t        b.appendChild(f);\n\t        b.style.display = k ? \"block\" : \"none\";\n\t        b.className = \"handle\";\n\t        g.appendChild(b)\n\t    }\n\t    )()\n\t}\n\t;\n\tgui.StepInfo = function() {}\n\t;\n\tgui.StepInfo.VisualDirection = {\n\t    LEFT_TO_RIGHT: 0,\n\t    RIGHT_TO_LEFT: 1\n\t};\n\tgui.StepInfo.prototype.container = function() {}\n\t;\n\tgui.StepInfo.prototype.offset = function() {}\n\t;\n\tgui.VisualStepScanner = function() {}\n\t;\n\tgui.VisualStepScanner.prototype.process = function(g, k, d) {}\n\t;\n\tgui.GuiStepUtils = function() {\n\t    function g(f) {\n\t        f = d.getContentBounds(f);\n\t        var g, e = null;\n\t        if (f)\n\t            if (f.container.nodeType === Node.TEXT_NODE)\n\t                g = f.container.ownerDocument.createRange(),\n\t                g.setStart(f.container, f.startOffset),\n\t                g.setEnd(f.container, f.endOffset),\n\t                (e = 0 < g.getClientRects().length ? g.getBoundingClientRect() : null) && \" \" === f.container.data.substring(f.startOffset, f.endOffset) && 1 >= e.width && (e = null),\n\t                g.detach();\n\t            else if (k.isCharacterElement(f.container) || k.isCharacterFrame(f.container))\n\t                e = b.getBoundingClientRect(f.container);\n\t        return e\n\t    }\n\t    var k = odf.OdfUtils\n\t      , d = new odf.StepUtils\n\t      , b = core.DomUtils\n\t      , f = core.StepDirection.NEXT\n\t      , n = gui.StepInfo.VisualDirection.LEFT_TO_RIGHT\n\t      , p = gui.StepInfo.VisualDirection.RIGHT_TO_LEFT;\n\t    this.getContentRect = g;\n\t    this.moveToFilteredStep = function(b, d, e) {\n\t        function l(a, b) {\n\t            b.process(w, h, k) && (a = !0,\n\t            !x && b.token && (x = b.token));\n\t            return a\n\t        }\n\t        var a = d === f, c, m, h, k, x, z = b.snapshot();\n\t        c = !1;\n\t        var w;\n\t        do\n\t            c = g(b),\n\t            w = {\n\t                token: b.snapshot(),\n\t                container: b.container,\n\t                offset: b.offset,\n\t                direction: d,\n\t                visualDirection: d === f ? n : p\n\t            },\n\t            m = b.nextStep() ? g(b) : null,\n\t            b.restore(w.token),\n\t            a ? (h = c,\n\t            k = m) : (h = m,\n\t            k = c),\n\t            c = e.reduce(l, !1);\n\t        while (!c && b.advanceStep(d));\n\t        c || e.forEach(function(a) {\n\t            !x && a.token && (x = a.token)\n\t        });\n\t        b.restore(x || z);\n\t        return Boolean(x)\n\t    }\n\t}\n\t;\n\tgui.Caret = function(g, k, d, b) {\n\t    function f() {\n\t        a.style.opacity = \"0\" === a.style.opacity ? \"1\" : \"0\";\n\t        t.trigger()\n\t    }\n\t    function n() {\n\t        y.selectNodeContents(h);\n\t        return y.getBoundingClientRect()\n\t    }\n\t    function p(a) {\n\t        return E[a] !== L[a]\n\t    }\n\t    function r() {\n\t        Object.keys(L).forEach(function(a) {\n\t            E[a] = L[a]\n\t        })\n\t    }\n\t    function q() {\n\t        if (!1 === L.isShown || g.getSelectionType() !== ops.OdtCursor.RangeSelection || !b && !g.getSelectedRange().collapsed)\n\t            L.visibility = \"hidden\",\n\t            a.style.visibility = \"hidden\",\n\t            t.cancel();\n\t        else if (L.visibility = \"visible\",\n\t        a.style.visibility = \"visible\",\n\t        !1 === L.isFocused)\n\t            a.style.opacity = \"1\",\n\t            t.cancel();\n\t        else {\n\t            if (A || p(\"visibility\"))\n\t                a.style.opacity = \"1\",\n\t                t.cancel();\n\t            t.trigger()\n\t        }\n\t        if (K || I) {\n\t            var d;\n\t            d = g.getNode();\n\t            var e, h, f = z.getBoundingClientRect(x.getSizer()), q = !1, y = 0;\n\t            d.removeAttributeNS(\"urn:webodf:names:cursor\", \"caret-sizer-active\");\n\t            if (0 < d.getClientRects().length)\n\t                h = n(),\n\t                y = h.left - z.getBoundingClientRect(d).left,\n\t                q = !0;\n\t            else if (v.setPosition(d, 0),\n\t            h = w.getContentRect(v),\n\t            !h && v.nextStep() && (e = w.getContentRect(v)) && (h = e,\n\t            q = !0),\n\t            h || (d.setAttributeNS(\"urn:webodf:names:cursor\", \"caret-sizer-active\", \"true\"),\n\t            h = n(),\n\t            q = !0),\n\t            !h)\n\t                for (runtime.log(\"WARN: No suitable client rectangle found for visual caret for \" + g.getMemberId()); d; ) {\n\t                    if (0 < d.getClientRects().length) {\n\t                        h = z.getBoundingClientRect(d);\n\t                        q = !0;\n\t                        break\n\t                    }\n\t                    d = d.parentNode\n\t                }\n\t            h = z.translateRect(h, f, x.getZoomLevel());\n\t            d = {\n\t                top: h.top,\n\t                height: h.height,\n\t                right: q ? h.left : h.right,\n\t                width: z.adaptRangeDifferenceToZoomLevel(y, x.getZoomLevel())\n\t            };\n\t            8 > d.height && (d = {\n\t                top: d.top - (8 - d.height) / 2,\n\t                height: 8,\n\t                right: d.right\n\t            });\n\t            l.style.height = d.height + \"px\";\n\t            l.style.top = d.top + \"px\";\n\t            l.style.left = d.right - d.width + \"px\";\n\t            l.style.width = d.width ? d.width + \"px\" : \"\";\n\t            m && (d = runtime.getWindow().getComputedStyle(g.getNode(), null),\n\t            d.font ? m.style.font = d.font : (m.style.fontStyle = d.fontStyle,\n\t            m.style.fontVariant = d.fontVariant,\n\t            m.style.fontWeight = d.fontWeight,\n\t            m.style.fontSize = d.fontSize,\n\t            m.style.lineHeight = d.lineHeight,\n\t            m.style.fontFamily = d.fontFamily))\n\t        }\n\t        L.isShown && I && k.scrollIntoView(a.getBoundingClientRect());\n\t        p(\"isFocused\") && c.markAsFocussed(L.isFocused);\n\t        r();\n\t        K = I = A = !1\n\t    }\n\t    function e(a) {\n\t        l.parentNode.removeChild(l);\n\t        h.parentNode.removeChild(h);\n\t        a()\n\t    }\n\t    var l, a, c, m, h, y, x = g.getDocument().getCanvas(), z = core.DomUtils, w = new gui.GuiStepUtils, v, u, t, A = !1, I = !1, K = !1, L = {\n\t        isFocused: !1,\n\t        isShown: !0,\n\t        visibility: \"hidden\"\n\t    }, E = {\n\t        isFocused: !L.isFocused,\n\t        isShown: !L.isShown,\n\t        visibility: \"hidden\"\n\t    };\n\t    this.handleUpdate = function() {\n\t        K = !0;\n\t        u.trigger()\n\t    }\n\t    ;\n\t    this.refreshCursorBlinking = function() {\n\t        A = !0;\n\t        u.trigger()\n\t    }\n\t    ;\n\t    this.setFocus = function() {\n\t        L.isFocused = !0;\n\t        u.trigger()\n\t    }\n\t    ;\n\t    this.removeFocus = function() {\n\t        L.isFocused = !1;\n\t        u.trigger()\n\t    }\n\t    ;\n\t    this.show = function() {\n\t        L.isShown = !0;\n\t        u.trigger()\n\t    }\n\t    ;\n\t    this.hide = function() {\n\t        L.isShown = !1;\n\t        u.trigger()\n\t    }\n\t    ;\n\t    this.setAvatarImageUrl = function(a) {\n\t        c.setImageUrl(a)\n\t    }\n\t    ;\n\t    this.setColor = function(b) {\n\t        a.style.borderColor = b;\n\t        c.setColor(b)\n\t    }\n\t    ;\n\t    this.getCursor = function() {\n\t        return g\n\t    }\n\t    ;\n\t    this.getFocusElement = function() {\n\t        return a\n\t    }\n\t    ;\n\t    this.toggleHandleVisibility = function() {\n\t        c.isVisible() ? c.hide() : c.show()\n\t    }\n\t    ;\n\t    this.showHandle = function() {\n\t        c.show()\n\t    }\n\t    ;\n\t    this.hideHandle = function() {\n\t        c.hide()\n\t    }\n\t    ;\n\t    this.setOverlayElement = function(a) {\n\t        m = a;\n\t        l.appendChild(a);\n\t        K = !0;\n\t        u.trigger()\n\t    }\n\t    ;\n\t    this.ensureVisible = function() {\n\t        I = !0;\n\t        u.trigger()\n\t    }\n\t    ;\n\t    this.getBoundingClientRect = function() {\n\t        return z.getBoundingClientRect(l)\n\t    }\n\t    ;\n\t    this.destroy = function(a) {\n\t        core.Async.destroyAll([u.destroy, t.destroy, c.destroy, e], a)\n\t    }\n\t    ;\n\t    (function() {\n\t        var b = g.getDocument()\n\t          , e = [b.createRootFilter(g.getMemberId()), b.getPositionFilter()]\n\t          , m = b.getDOMDocument();\n\t        y = m.createRange();\n\t        h = m.createElement(\"span\");\n\t        h.className = \"webodf-caretSizer\";\n\t        h.textContent = \"|\";\n\t        g.getNode().appendChild(h);\n\t        l = m.createElement(\"div\");\n\t        l.setAttributeNS(\"urn:webodf:names:editinfo\", \"editinfo:memberid\", g.getMemberId());\n\t        l.className = \"webodf-caretOverlay\";\n\t        a = m.createElement(\"div\");\n\t        a.className = \"caret\";\n\t        l.appendChild(a);\n\t        c = new gui.Avatar(l,d);\n\t        x.getSizer().appendChild(l);\n\t        v = b.createStepIterator(g.getNode(), 0, e, b.getRootNode());\n\t        u = core.Task.createRedrawTask(q);\n\t        t = core.Task.createTimeoutTask(f, 500);\n\t        u.triggerImmediate()\n\t    }\n\t    )()\n\t}\n\t;\n\todf.TextSerializer = function() {\n\t    function g(b) {\n\t        var f = \"\", n = k.filter ? k.filter.acceptNode(b) : NodeFilter.FILTER_ACCEPT, p = b.nodeType, r;\n\t        if ((n === NodeFilter.FILTER_ACCEPT || n === NodeFilter.FILTER_SKIP) && d.isTextContentContainingNode(b))\n\t            for (r = b.firstChild; r; )\n\t                f += g(r),\n\t                r = r.nextSibling;\n\t        n === NodeFilter.FILTER_ACCEPT && (p === Node.ELEMENT_NODE && d.isParagraph(b) ? f += \"\\n\" : p === Node.TEXT_NODE && b.textContent && (f += b.textContent));\n\t        return f\n\t    }\n\t    var k = this\n\t      , d = odf.OdfUtils;\n\t    this.filter = null;\n\t    this.writeToString = function(b) {\n\t        if (!b)\n\t            return \"\";\n\t        b = g(b);\n\t        \"\\n\" === b[b.length - 1] && (b = b.substr(0, b.length - 1));\n\t        return b\n\t    }\n\t}\n\t;\n\tgui.MimeDataExporter = function() {\n\t    var g;\n\t    this.exportRangeToDataTransfer = function(k, d) {\n\t        var b;\n\t        b = d.startContainer.ownerDocument.createElement(\"span\");\n\t        b.appendChild(d.cloneContents());\n\t        b = g.writeToString(b);\n\t        try {\n\t            k.setData(\"text/plain\", b)\n\t        } catch (f) {\n\t            k.setData(\"Text\", b)\n\t        }\n\t    }\n\t    ;\n\t    g = new odf.TextSerializer;\n\t    g.filter = new odf.OdfNodeFilter\n\t}\n\t;\n\tgui.Clipboard = function(g) {\n\t    this.setDataFromRange = function(k, d) {\n\t        var b, f = k.clipboardData;\n\t        b = runtime.getWindow();\n\t        !f && b && (f = b.clipboardData);\n\t        f ? (b = !0,\n\t        g.exportRangeToDataTransfer(f, d),\n\t        k.preventDefault()) : b = !1;\n\t        return b\n\t    }\n\t}\n\t;\n\tgui.SessionContext = function(g, k) {\n\t    var d = g.getOdtDocument()\n\t      , b = odf.OdfUtils;\n\t    this.isLocalCursorWithinOwnAnnotation = function() {\n\t        var f = d.getCursor(k), g;\n\t        if (!f)\n\t            return !1;\n\t        g = f && f.getNode();\n\t        f = d.getMember(k).getProperties().fullName;\n\t        return (g = b.getParentAnnotation(g, d.getRootNode())) && b.getAnnotationCreator(g) === f ? !0 : !1\n\t    }\n\t}\n\t;\n\tgui.StyleSummary = function(g) {\n\t    function k(b, d) {\n\t        var k = b + \"|\" + d, q;\n\t        f.hasOwnProperty(k) || (q = [],\n\t        g.forEach(function(e) {\n\t            e = (e = e.styleProperties[b]) && e[d];\n\t            -1 === q.indexOf(e) && q.push(e)\n\t        }),\n\t        f[k] = q);\n\t        return f[k]\n\t    }\n\t    function d(b, d, f) {\n\t        return function() {\n\t            var g = k(b, d);\n\t            return f.length >= g.length && g.every(function(b) {\n\t                return -1 !== f.indexOf(b)\n\t            })\n\t        }\n\t    }\n\t    function b(b, d) {\n\t        var f = k(b, d);\n\t        return 1 === f.length ? f[0] : void 0\n\t    }\n\t    var f = {};\n\t    this.getPropertyValues = k;\n\t    this.getCommonValue = b;\n\t    this.isBold = d(\"style:text-properties\", \"fo:font-weight\", [\"bold\"]);\n\t    this.isItalic = d(\"style:text-properties\", \"fo:font-style\", [\"italic\"]);\n\t    this.hasUnderline = d(\"style:text-properties\", \"style:text-underline-style\", [\"solid\"]);\n\t    this.hasStrikeThrough = d(\"style:text-properties\", \"style:text-line-through-style\", [\"solid\"]);\n\t    this.fontSize = function() {\n\t        var d = b(\"style:text-properties\", \"fo:font-size\");\n\t        return d && parseFloat(d)\n\t    }\n\t    ;\n\t    this.fontName = function() {\n\t        return b(\"style:text-properties\", \"style:font-name\")\n\t    }\n\t    ;\n\t    this.isAlignedLeft = d(\"style:paragraph-properties\", \"fo:text-align\", [\"left\", \"start\"]);\n\t    this.isAlignedCenter = d(\"style:paragraph-properties\", \"fo:text-align\", [\"center\"]);\n\t    this.isAlignedRight = d(\"style:paragraph-properties\", \"fo:text-align\", [\"right\", \"end\"]);\n\t    this.isAlignedJustified = d(\"style:paragraph-properties\", \"fo:text-align\", [\"justify\"]);\n\t    this.text = {\n\t        isBold: this.isBold,\n\t        isItalic: this.isItalic,\n\t        hasUnderline: this.hasUnderline,\n\t        hasStrikeThrough: this.hasStrikeThrough,\n\t        fontSize: this.fontSize,\n\t        fontName: this.fontName\n\t    };\n\t    this.paragraph = {\n\t        isAlignedLeft: this.isAlignedLeft,\n\t        isAlignedCenter: this.isAlignedCenter,\n\t        isAlignedRight: this.isAlignedRight,\n\t        isAlignedJustified: this.isAlignedJustified\n\t    }\n\t}\n\t;\n\tgui.DirectFormattingController = function(g, k, d, b, f, n, p) {\n\t    function r() {\n\t        return U.value().styleSummary\n\t    }\n\t    function q() {\n\t        return U.value().enabledFeatures\n\t    }\n\t    function e(a) {\n\t        var b;\n\t        a.collapsed ? (b = a.startContainer,\n\t        b.hasChildNodes() && a.startOffset < b.childNodes.length && (b = b.childNodes.item(a.startOffset)),\n\t        a = [b]) : a = S.getTextElements(a, !0, !1);\n\t        return a\n\t    }\n\t    function l() {\n\t        var a = P.getCursor(b)\n\t          , c = a && a.getSelectedRange()\n\t          , h = []\n\t          , h = []\n\t          , f = !0\n\t          , g = {\n\t            directTextStyling: !0,\n\t            directParagraphStyling: !0\n\t        };\n\t        c && (h = e(c),\n\t        0 === h.length && (h = [c.startContainer, c.endContainer],\n\t        f = !1),\n\t        h = P.getFormatting().getAppliedStyles(h));\n\t        void 0 !== h[0] && Z && (h[0].styleProperties = aa.mergeObjects(h[0].styleProperties, Z));\n\t        !0 === k.getState(gui.CommonConstraints.EDIT.REVIEW_MODE) && (g.directTextStyling = g.directParagraphStyling = d.isLocalCursorWithinOwnAnnotation());\n\t        g.directTextStyling && (g.directTextStyling = f && void 0 !== a && a.getSelectionType() === ops.OdtCursor.RangeSelection);\n\t        return {\n\t            enabledFeatures: g,\n\t            appliedStyles: h,\n\t            styleSummary: new gui.StyleSummary(h)\n\t        }\n\t    }\n\t    function a(a, b) {\n\t        var c = {};\n\t        Object.keys(a).forEach(function(d) {\n\t            var e = a[d]()\n\t              , h = b[d]();\n\t            e !== h && (c[d] = h)\n\t        });\n\t        return c\n\t    }\n\t    function c() {\n\t        var b, c;\n\t        c = ba.styleSummary;\n\t        var d = U.value()\n\t          , e = d.styleSummary\n\t          , h = ba.enabledFeatures\n\t          , f = d.enabledFeatures;\n\t        b = a(c.text, e.text);\n\t        c = a(c.paragraph, e.paragraph);\n\t        h = !(f.directTextStyling === h.directTextStyling && f.directParagraphStyling === h.directParagraphStyling);\n\t        ba = d;\n\t        h && fa.emit(gui.DirectFormattingController.enabledChanged, f);\n\t        0 < Object.keys(b).length && fa.emit(gui.DirectFormattingController.textStylingChanged, b);\n\t        0 < Object.keys(c).length && fa.emit(gui.DirectFormattingController.paragraphStylingChanged, c)\n\t    }\n\t    function m() {\n\t        U.reset();\n\t        c()\n\t    }\n\t    function h(a) {\n\t        (\"string\" === typeof a ? a : a.getMemberId()) === b && U.reset()\n\t    }\n\t    function y() {\n\t        U.reset()\n\t    }\n\t    function x(a) {\n\t        var c = P.getCursor(b);\n\t        a = a.paragraphElement;\n\t        c && S.getParagraphElement(c.getNode()) === a && U.reset()\n\t    }\n\t    function z(a, b) {\n\t        b(!a());\n\t        return !0\n\t    }\n\t    function w(a) {\n\t        if (q().directTextStyling) {\n\t            var c = P.getCursorSelection(b)\n\t              , d = {\n\t                \"style:text-properties\": a\n\t            };\n\t            0 !== c.length ? (a = new ops.OpApplyDirectStyling,\n\t            a.init({\n\t                memberid: b,\n\t                position: c.position,\n\t                length: c.length,\n\t                setProperties: d\n\t            }),\n\t            g.enqueue([a])) : (Z = aa.mergeObjects(Z || {}, d),\n\t            U.reset())\n\t        }\n\t    }\n\t    function v(a, b) {\n\t        var c = {};\n\t        c[a] = b;\n\t        w(c)\n\t    }\n\t    function u(a) {\n\t        a = a.spec();\n\t        Z && a.memberid === b && \"SplitParagraph\" !== a.optype && (Z = null,\n\t        U.reset())\n\t    }\n\t    function t(a) {\n\t        v(\"fo:font-weight\", a ? \"bold\" : \"normal\")\n\t    }\n\t    function A(a) {\n\t        v(\"fo:font-style\", a ? \"italic\" : \"normal\")\n\t    }\n\t    function I(a) {\n\t        v(\"style:text-underline-style\", a ? \"solid\" : \"none\")\n\t    }\n\t    function K(a) {\n\t        v(\"style:text-line-through-style\", a ? \"solid\" : \"none\")\n\t    }\n\t    function L(a) {\n\t        if (q().directParagraphStyling) {\n\t            var c = P.getCursor(b).getSelectedRange(), c = S.getParagraphElements(c), d = P.getFormatting(), e = [], h = {}, m;\n\t            c.forEach(function(c) {\n\t                var g = P.convertDomPointToCursorStep(c, 0, C), l = c.getAttributeNS(odf.Namespaces.textns, \"style-name\"), k;\n\t                c = l ? h.hasOwnProperty(l) ? h[l] : void 0 : m;\n\t                c || (c = f.generateStyleName(),\n\t                l ? (h[l] = c,\n\t                k = d.createDerivedStyleObject(l, \"paragraph\", {})) : (m = c,\n\t                k = {}),\n\t                k = a(k),\n\t                l = new ops.OpAddStyle,\n\t                l.init({\n\t                    memberid: b,\n\t                    styleName: c.toString(),\n\t                    styleFamily: \"paragraph\",\n\t                    isAutomaticStyle: !0,\n\t                    setProperties: k\n\t                }),\n\t                e.push(l));\n\t                l = new ops.OpSetParagraphStyle;\n\t                l.init({\n\t                    memberid: b,\n\t                    styleName: c.toString(),\n\t                    position: g\n\t                });\n\t                e.push(l)\n\t            });\n\t            g.enqueue(e)\n\t        }\n\t    }\n\t    function E(a) {\n\t        L(function(b) {\n\t            return aa.mergeObjects(b, a)\n\t        })\n\t    }\n\t    function N(a) {\n\t        E({\n\t            \"style:paragraph-properties\": {\n\t                \"fo:text-align\": a\n\t            }\n\t        })\n\t    }\n\t    function O(a, b) {\n\t        var c = P.getFormatting().getDefaultTabStopDistance(), d = b[\"style:paragraph-properties\"], e;\n\t        d && (d = d[\"fo:margin-left\"],\n\t        e = S.parseLength(d));\n\t        return aa.mergeObjects(b, {\n\t            \"style:paragraph-properties\": {\n\t                \"fo:margin-left\": e && e.unit === c.unit ? e.value + a * c.value + e.unit : a * c.value + c.unit\n\t            }\n\t        })\n\t    }\n\t    function D(a, b) {\n\t        var c = e(a)\n\t          , c = 0 === c.length ? [a.startContainer] : c\n\t          , c = P.getFormatting().getAppliedStyles(c)\n\t          , d = 0 < c.length ? c[0].styleProperties : void 0\n\t          , h = P.getFormatting().getAppliedStylesForElement(b).styleProperties;\n\t        if (!d || \"text\" !== d[\"style:family\"] || !d[\"style:text-properties\"])\n\t            return !1;\n\t        if (!h || !h[\"style:text-properties\"])\n\t            return !0;\n\t        d = d[\"style:text-properties\"];\n\t        h = h[\"style:text-properties\"];\n\t        return !Object.keys(d).every(function(a) {\n\t            return d[a] === h[a]\n\t        })\n\t    }\n\t    function V() {}\n\t    function W() {\n\t        return !1\n\t    }\n\t    function J() {\n\t        return !1\n\t    }\n\t    var R = this, P = g.getOdtDocument(), aa = new core.Utils, S = odf.OdfUtils, fa = new core.EventNotifier([gui.DirectFormattingController.enabledChanged, gui.DirectFormattingController.textStylingChanged, gui.DirectFormattingController.paragraphStylingChanged]), ha = odf.Namespaces.textns, C = core.StepDirection.NEXT, Z = null, ba, U;\n\t    this.enabledFeatures = q;\n\t    this.formatTextSelection = w;\n\t    this.createCursorStyleOp = function(a, c, d) {\n\t        var e = null\n\t          , h = Z;\n\t        d && (h = (d = U.value().appliedStyles[0]) && d.styleProperties);\n\t        h && h[\"style:text-properties\"] && (e = new ops.OpApplyDirectStyling,\n\t        e.init({\n\t            memberid: b,\n\t            position: a,\n\t            length: c,\n\t            setProperties: {\n\t                \"style:text-properties\": h[\"style:text-properties\"]\n\t            }\n\t        }),\n\t        Z = null,\n\t        U.reset());\n\t        return e\n\t    }\n\t    ;\n\t    this.setBold = t;\n\t    this.setItalic = A;\n\t    this.setHasUnderline = I;\n\t    this.setHasStrikethrough = K;\n\t    this.setFontSize = function(a) {\n\t        v(\"fo:font-size\", a + \"pt\")\n\t    }\n\t    ;\n\t    this.setFontName = function(a) {\n\t        v(\"style:font-name\", a)\n\t    }\n\t    ;\n\t    this.getAppliedStyles = function() {\n\t        return U.value().appliedStyles\n\t    }\n\t    ;\n\t    this.toggleBold = z.bind(R, function() {\n\t        return r().isBold()\n\t    }, t);\n\t    this.toggleItalic = z.bind(R, function() {\n\t        return r().isItalic()\n\t    }, A);\n\t    this.toggleUnderline = z.bind(R, function() {\n\t        return r().hasUnderline()\n\t    }, I);\n\t    this.toggleStrikethrough = z.bind(R, function() {\n\t        return r().hasStrikeThrough()\n\t    }, K);\n\t    this.isBold = function() {\n\t        return r().isBold()\n\t    }\n\t    ;\n\t    this.isItalic = function() {\n\t        return r().isItalic()\n\t    }\n\t    ;\n\t    this.hasUnderline = function() {\n\t        return r().hasUnderline()\n\t    }\n\t    ;\n\t    this.hasStrikeThrough = function() {\n\t        return r().hasStrikeThrough()\n\t    }\n\t    ;\n\t    this.fontSize = function() {\n\t        return r().fontSize()\n\t    }\n\t    ;\n\t    this.fontName = function() {\n\t        return r().fontName()\n\t    }\n\t    ;\n\t    this.isAlignedLeft = function() {\n\t        return r().isAlignedLeft()\n\t    }\n\t    ;\n\t    this.isAlignedCenter = function() {\n\t        return r().isAlignedCenter()\n\t    }\n\t    ;\n\t    this.isAlignedRight = function() {\n\t        return r().isAlignedRight()\n\t    }\n\t    ;\n\t    this.isAlignedJustified = function() {\n\t        return r().isAlignedJustified()\n\t    }\n\t    ;\n\t    this.alignParagraphLeft = function() {\n\t        N(\"left\");\n\t        return !0\n\t    }\n\t    ;\n\t    this.alignParagraphCenter = function() {\n\t        N(\"center\");\n\t        return !0\n\t    }\n\t    ;\n\t    this.alignParagraphRight = function() {\n\t        N(\"right\");\n\t        return !0\n\t    }\n\t    ;\n\t    this.alignParagraphJustified = function() {\n\t        N(\"justify\");\n\t        return !0\n\t    }\n\t    ;\n\t    this.indent = function() {\n\t        L(O.bind(null, 1));\n\t        return !0\n\t    }\n\t    ;\n\t    this.outdent = function() {\n\t        L(O.bind(null, -1));\n\t        return !0\n\t    }\n\t    ;\n\t    this.createParagraphStyleOps = function(a) {\n\t        if (!q().directParagraphStyling)\n\t            return [];\n\t        var c = P.getCursor(b), d = c.getSelectedRange(), e = [], h, g;\n\t        c.hasForwardSelection() ? (h = c.getAnchorNode(),\n\t        g = c.getNode()) : (h = c.getNode(),\n\t        g = c.getAnchorNode());\n\t        c = S.getParagraphElement(g);\n\t        runtime.assert(Boolean(c), \"DirectFormattingController: Cursor outside paragraph\");\n\t        var m = c\n\t          , l = [P.getPositionFilter(), P.createRootFilter(b)];\n\t        if (!1 !== P.createStepIterator(d.endContainer, d.endOffset, l, m).nextStep())\n\t            return e;\n\t        g !== h && (c = S.getParagraphElement(h));\n\t        if (!Z && !D(d, c))\n\t            return e;\n\t        d = (d = U.value().appliedStyles[0]) && d.styleProperties;\n\t        if (!d)\n\t            return e;\n\t        if (c = c.getAttributeNS(ha, \"style-name\"))\n\t            d = {\n\t                \"style:text-properties\": d[\"style:text-properties\"]\n\t            },\n\t            d = P.getFormatting().createDerivedStyleObject(c, \"paragraph\", d);\n\t        h = f.generateStyleName();\n\t        c = new ops.OpAddStyle;\n\t        c.init({\n\t            memberid: b,\n\t            styleName: h,\n\t            styleFamily: \"paragraph\",\n\t            isAutomaticStyle: !0,\n\t            setProperties: d\n\t        });\n\t        e.push(c);\n\t        c = new ops.OpSetParagraphStyle;\n\t        c.init({\n\t            memberid: b,\n\t            styleName: h,\n\t            position: a\n\t        });\n\t        e.push(c);\n\t        return e\n\t    }\n\t    ;\n\t    this.subscribe = function(a, c) {\n\t        fa.subscribe(a, c)\n\t    }\n\t    ;\n\t    this.unsubscribe = function(a, c) {\n\t        fa.unsubscribe(a, c)\n\t    }\n\t    ;\n\t    this.destroy = function(a) {\n\t        P.unsubscribe(ops.Document.signalCursorAdded, h);\n\t        P.unsubscribe(ops.Document.signalCursorRemoved, h);\n\t        P.unsubscribe(ops.Document.signalCursorMoved, h);\n\t        P.unsubscribe(ops.OdtDocument.signalParagraphStyleModified, y);\n\t        P.unsubscribe(ops.OdtDocument.signalParagraphChanged, x);\n\t        P.unsubscribe(ops.OdtDocument.signalOperationEnd, u);\n\t        P.unsubscribe(ops.OdtDocument.signalProcessingBatchEnd, c);\n\t        k.unsubscribe(gui.CommonConstraints.EDIT.REVIEW_MODE, m);\n\t        a()\n\t    }\n\t    ;\n\t    (function() {\n\t        P.subscribe(ops.Document.signalCursorAdded, h);\n\t        P.subscribe(ops.Document.signalCursorRemoved, h);\n\t        P.subscribe(ops.Document.signalCursorMoved, h);\n\t        P.subscribe(ops.OdtDocument.signalParagraphStyleModified, y);\n\t        P.subscribe(ops.OdtDocument.signalParagraphChanged, x);\n\t        P.subscribe(ops.OdtDocument.signalOperationEnd, u);\n\t        P.subscribe(ops.OdtDocument.signalProcessingBatchEnd, c);\n\t        k.subscribe(gui.CommonConstraints.EDIT.REVIEW_MODE, m);\n\t        U = new core.LazyProperty(l);\n\t        ba = U.value();\n\t        n || (R.formatTextSelection = V,\n\t        R.setBold = V,\n\t        R.setItalic = V,\n\t        R.setHasUnderline = V,\n\t        R.setHasStrikethrough = V,\n\t        R.setFontSize = V,\n\t        R.setFontName = V,\n\t        R.toggleBold = J,\n\t        R.toggleItalic = J,\n\t        R.toggleUnderline = J,\n\t        R.toggleStrikethrough = J);\n\t        p || (R.alignParagraphCenter = W,\n\t        R.alignParagraphJustified = W,\n\t        R.alignParagraphLeft = W,\n\t        R.alignParagraphRight = W,\n\t        R.createParagraphStyleOps = function() {\n\t            return []\n\t        }\n\t        ,\n\t        R.indent = W,\n\t        R.outdent = W)\n\t    }\n\t    )()\n\t}\n\t;\n\tgui.DirectFormattingController.enabledChanged = \"enabled/changed\";\n\tgui.DirectFormattingController.textStylingChanged = \"textStyling/changed\";\n\tgui.DirectFormattingController.paragraphStylingChanged = \"paragraphStyling/changed\";\n\tgui.DirectFormattingController.SelectionInfo = function() {}\n\t;\n\tgui.KeyboardHandler = function() {\n\t    function g(b, d) {\n\t        d || (d = k.None);\n\t        switch (b) {\n\t        case gui.KeyboardHandler.KeyCode.LeftMeta:\n\t        case gui.KeyboardHandler.KeyCode.RightMeta:\n\t        case gui.KeyboardHandler.KeyCode.MetaInMozilla:\n\t            d |= k.Meta;\n\t            break;\n\t        case gui.KeyboardHandler.KeyCode.Ctrl:\n\t            d |= k.Ctrl;\n\t            break;\n\t        case gui.KeyboardHandler.KeyCode.Alt:\n\t            d |= k.Alt;\n\t            break;\n\t        case gui.KeyboardHandler.KeyCode.Shift:\n\t            d |= k.Shift\n\t        }\n\t        return b + \":\" + d\n\t    }\n\t    var k = gui.KeyboardHandler.Modifier\n\t      , d = null\n\t      , b = {};\n\t    this.setDefault = function(b) {\n\t        d = b\n\t    }\n\t    ;\n\t    this.bind = function(d, k, p, r) {\n\t        d = g(d, k);\n\t        runtime.assert(r || !1 === b.hasOwnProperty(d), \"tried to overwrite the callback handler of key combo: \" + d);\n\t        b[d] = p\n\t    }\n\t    ;\n\t    this.unbind = function(d, k) {\n\t        var p = g(d, k);\n\t        delete b[p]\n\t    }\n\t    ;\n\t    this.reset = function() {\n\t        d = null;\n\t        b = {}\n\t    }\n\t    ;\n\t    this.handleEvent = function(f) {\n\t        var n = f.keyCode\n\t          , p = k.None;\n\t        f.metaKey && (p |= k.Meta);\n\t        f.ctrlKey && (p |= k.Ctrl);\n\t        f.altKey && (p |= k.Alt);\n\t        f.shiftKey && (p |= k.Shift);\n\t        n = g(n, p);\n\t        n = b[n];\n\t        p = !1;\n\t        n ? p = n() : null !== d && (p = d(f));\n\t        p && (f.preventDefault ? f.preventDefault() : f.returnValue = !1)\n\t    }\n\t}\n\t;\n\tgui.KeyboardHandler.Modifier = {\n\t    None: 0,\n\t    Meta: 1,\n\t    Ctrl: 2,\n\t    Alt: 4,\n\t    CtrlAlt: 6,\n\t    Shift: 8,\n\t    MetaShift: 9,\n\t    CtrlShift: 10,\n\t    AltShift: 12\n\t};\n\tgui.KeyboardHandler.KeyCode = {\n\t    Backspace: 8,\n\t    Tab: 9,\n\t    Clear: 12,\n\t    Enter: 13,\n\t    Shift: 16,\n\t    Ctrl: 17,\n\t    Alt: 18,\n\t    End: 35,\n\t    Home: 36,\n\t    Left: 37,\n\t    Up: 38,\n\t    Right: 39,\n\t    Down: 40,\n\t    Delete: 46,\n\t    A: 65,\n\t    B: 66,\n\t    C: 67,\n\t    D: 68,\n\t    E: 69,\n\t    F: 70,\n\t    G: 71,\n\t    H: 72,\n\t    I: 73,\n\t    J: 74,\n\t    K: 75,\n\t    L: 76,\n\t    M: 77,\n\t    N: 78,\n\t    O: 79,\n\t    P: 80,\n\t    Q: 81,\n\t    R: 82,\n\t    S: 83,\n\t    T: 84,\n\t    U: 85,\n\t    V: 86,\n\t    W: 87,\n\t    X: 88,\n\t    Y: 89,\n\t    Z: 90,\n\t    LeftMeta: 91,\n\t    RightMeta: 93,\n\t    MetaInMozilla: 224\n\t};\n\tgui.HyperlinkClickHandler = function(g, k, d) {\n\t    function b() {\n\t        var a = g();\n\t        runtime.assert(Boolean(a.classList), \"Document container has no classList element\");\n\t        a.classList.remove(\"webodf-inactiveLinks\")\n\t    }\n\t    function f() {\n\t        var a = g();\n\t        runtime.assert(Boolean(a.classList), \"Document container has no classList element\");\n\t        a.classList.add(\"webodf-inactiveLinks\")\n\t    }\n\t    function n() {\n\t        a.removeEventListener(\"focus\", f, !1);\n\t        m.forEach(function(a) {\n\t            k.unbind(a.keyCode, a.modifier);\n\t            d.unbind(a.keyCode, a.modifier)\n\t        });\n\t        m.length = 0\n\t    }\n\t    function p(c) {\n\t        n();\n\t        if (c !== r.None) {\n\t            a.addEventListener(\"focus\", f, !1);\n\t            switch (c) {\n\t            case r.Ctrl:\n\t                m.push({\n\t                    keyCode: q.Ctrl,\n\t                    modifier: r.None\n\t                });\n\t                break;\n\t            case r.Meta:\n\t                m.push({\n\t                    keyCode: q.LeftMeta,\n\t                    modifier: r.None\n\t                }),\n\t                m.push({\n\t                    keyCode: q.RightMeta,\n\t                    modifier: r.None\n\t                }),\n\t                m.push({\n\t                    keyCode: q.MetaInMozilla,\n\t                    modifier: r.None\n\t                })\n\t            }\n\t            m.forEach(function(a) {\n\t                k.bind(a.keyCode, a.modifier, b);\n\t                d.bind(a.keyCode, a.modifier, f)\n\t            })\n\t        }\n\t    }\n\t    var r = gui.KeyboardHandler.Modifier\n\t      , q = gui.KeyboardHandler.KeyCode\n\t      , e = xmldom.XPath\n\t      , l = odf.OdfUtils\n\t      , a = runtime.getWindow()\n\t      , c = r.None\n\t      , m = [];\n\t    runtime.assert(null !== a, \"Expected to be run in an environment which has a global window, like a browser.\");\n\t    this.handleClick = function(b) {\n\t        var d = b.target || b.srcElement, f, m;\n\t        b.ctrlKey ? f = r.Ctrl : b.metaKey && (f = r.Meta);\n\t        if (c === r.None || c === f) {\n\t            a: {\n\t                for (; null !== d; ) {\n\t                    if (l.isHyperlink(d))\n\t                        break a;\n\t                    if (l.isParagraph(d))\n\t                        break;\n\t                    d = d.parentNode\n\t                }\n\t                d = null\n\t            }\n\t            d && (d = l.getHyperlinkTarget(d),\n\t            \"\" !== d && (\"#\" === d[0] ? (d = d.substring(1),\n\t            f = g(),\n\t            m = e.getODFElementsWithXPath(f, \"//text:bookmark-start[@text:name='\" + d + \"']\", odf.Namespaces.lookupNamespaceURI),\n\t            0 === m.length && (m = e.getODFElementsWithXPath(f, \"//text:bookmark[@text:name='\" + d + \"']\", odf.Namespaces.lookupNamespaceURI)),\n\t            0 < m.length && m[0].scrollIntoView(!0)) : /^\\s*(javascript|data):/.test(d) ? runtime.log(\"WARN:\", \"potentially malicious URL ignored\") : a.open(d),\n\t            b.preventDefault ? b.preventDefault() : b.returnValue = !1))\n\t        }\n\t    }\n\t    ;\n\t    this.setModifier = function(a) {\n\t        c !== a && (runtime.assert(a === r.None || a === r.Ctrl || a === r.Meta, \"Unsupported KeyboardHandler.Modifier value: \" + a),\n\t        c = a,\n\t        c !== r.None ? f() : b(),\n\t        p(c))\n\t    }\n\t    ;\n\t    this.getModifier = function() {\n\t        return c\n\t    }\n\t    ;\n\t    this.destroy = function(a) {\n\t        f();\n\t        n();\n\t        a()\n\t    }\n\t}\n\t;\n\tgui.EventManager = function(g) {\n\t    function k(a) {\n\t        function b(a, c, d) {\n\t            var e, h = !1;\n\t            e = \"on\" + c;\n\t            a.attachEvent && (a.attachEvent(e, d),\n\t            h = !0);\n\t            !h && a.addEventListener && (a.addEventListener(c, d, !1),\n\t            h = !0);\n\t            h && !u[c] || !a.hasOwnProperty(e) || (a[e] = d)\n\t        }\n\t        function c(a, b, d) {\n\t            var e = \"on\" + b;\n\t            a.detachEvent && a.detachEvent(e, d);\n\t            a.removeEventListener && a.removeEventListener(b, d, !1);\n\t            a[e] === d && (a[e] = null)\n\t        }\n\t        function d(c) {\n\t            if (-1 === h.indexOf(c)) {\n\t                h.push(c);\n\t                if (e.filters.every(function(a) {\n\t                    return a(c)\n\t                }))\n\t                    try {\n\t                        f.emit(a, c)\n\t                    } catch (b) {\n\t                        runtime.log(\"Error occurred while processing \" + a + \":\\n\" + b.message + \"\\n\" + b.stack)\n\t                    }\n\t                runtime.setTimeout(function() {\n\t                    h.splice(h.indexOf(c), 1)\n\t                }, 0)\n\t            }\n\t        }\n\t        var e = this\n\t          , h = []\n\t          , f = new core.EventNotifier([a]);\n\t        this.filters = [];\n\t        this.subscribe = function(c) {\n\t            f.subscribe(a, c)\n\t        }\n\t        ;\n\t        this.unsubscribe = function(c) {\n\t            f.unsubscribe(a, c)\n\t        }\n\t        ;\n\t        this.destroy = function() {\n\t            c(v, a, d);\n\t            c(K, a, d);\n\t            c(L, a, d)\n\t        }\n\t        ;\n\t        t[a] && b(v, a, d);\n\t        b(K, a, d);\n\t        b(L, a, d)\n\t    }\n\t    function d(a, c, b) {\n\t        function d(c) {\n\t            b(c, e, function(c) {\n\t                c.type = a;\n\t                h.emit(a, c)\n\t            })\n\t        }\n\t        var e = {}\n\t          , h = new core.EventNotifier([a]);\n\t        this.subscribe = function(c) {\n\t            h.subscribe(a, c)\n\t        }\n\t        ;\n\t        this.unsubscribe = function(c) {\n\t            h.unsubscribe(a, c)\n\t        }\n\t        ;\n\t        this.destroy = function() {\n\t            c.forEach(function(a) {\n\t                E.unsubscribe(a, d)\n\t            })\n\t        }\n\t        ;\n\t        (function() {\n\t            c.forEach(function(a) {\n\t                E.subscribe(a, d)\n\t            })\n\t        }\n\t        )()\n\t    }\n\t    function b(a) {\n\t        runtime.clearTimeout(a);\n\t        delete N[a]\n\t    }\n\t    function f(a, c) {\n\t        var d = runtime.setTimeout(function() {\n\t            a();\n\t            b(d)\n\t        }, c);\n\t        N[d] = !0;\n\t        return d\n\t    }\n\t    function n(a, c, d) {\n\t        var e = a.touches.length\n\t          , h = a.touches[0]\n\t          , g = c.timer;\n\t        \"touchmove\" === a.type || \"touchend\" === a.type ? g && b(g) : \"touchstart\" === a.type && (1 !== e ? runtime.clearTimeout(g) : g = f(function() {\n\t            d({\n\t                clientX: h.clientX,\n\t                clientY: h.clientY,\n\t                pageX: h.pageX,\n\t                pageY: h.pageY,\n\t                target: a.target || a.srcElement || null,\n\t                detail: 1\n\t            })\n\t        }, 400));\n\t        c.timer = g\n\t    }\n\t    function p(a, c, b) {\n\t        var d = a.touches[0]\n\t          , e = a.target || a.srcElement || null\n\t          , h = c.target;\n\t        1 !== a.touches.length || \"touchend\" === a.type ? h = null : \"touchstart\" === a.type && \"webodf-draggable\" === e.getAttribute(\"class\") ? h = e : \"touchmove\" === a.type && h && (a.preventDefault(),\n\t        a.stopPropagation(),\n\t        b({\n\t            clientX: d.clientX,\n\t            clientY: d.clientY,\n\t            pageX: d.pageX,\n\t            pageY: d.pageY,\n\t            target: h,\n\t            detail: 1\n\t        }));\n\t        c.target = h\n\t    }\n\t    function r(a, c, b) {\n\t        var d = a.target || a.srcElement || null\n\t          , e = c.dragging;\n\t        \"drag\" === a.type ? e = !0 : \"touchend\" === a.type && e && (e = !1,\n\t        a = a.changedTouches[0],\n\t        b({\n\t            clientX: a.clientX,\n\t            clientY: a.clientY,\n\t            pageX: a.pageX,\n\t            pageY: a.pageY,\n\t            target: d,\n\t            detail: 1\n\t        }));\n\t        c.dragging = e\n\t    }\n\t    function q() {\n\t        L.classList.add(\"webodf-touchEnabled\");\n\t        E.unsubscribe(\"touchstart\", q)\n\t    }\n\t    function e(a) {\n\t        var c = a.scrollX\n\t          , b = a.scrollY;\n\t        this.restore = function() {\n\t            a.scrollX === c && a.scrollY === b || a.scrollTo(c, b)\n\t        }\n\t    }\n\t    function l(a) {\n\t        var c = a.scrollTop\n\t          , b = a.scrollLeft;\n\t        this.restore = function() {\n\t            if (a.scrollTop !== c || a.scrollLeft !== b)\n\t                a.scrollTop = c,\n\t                a.scrollLeft = b\n\t        }\n\t    }\n\t    function a(a, c) {\n\t        var b = I[a] || A[a] || null;\n\t        !b && c && (b = I[a] = new k(a));\n\t        return b\n\t    }\n\t    function c(c, b) {\n\t        a(c, !0).subscribe(b)\n\t    }\n\t    function m(c, b) {\n\t        var d = a(c, !1);\n\t        d && d.unsubscribe(b)\n\t    }\n\t    function h() {\n\t        return g.getDOMDocument().activeElement === K\n\t    }\n\t    function y() {\n\t        h() && K.blur();\n\t        K.setAttribute(\"disabled\", \"true\")\n\t    }\n\t    function x() {\n\t        K.removeAttribute(\"disabled\")\n\t    }\n\t    function z(a) {\n\t        for (var c = []; a; )\n\t            (a.scrollWidth > a.clientWidth || a.scrollHeight > a.clientHeight) && c.push(new l(a)),\n\t            a = a.parentNode;\n\t        c.push(new e(v));\n\t        return c\n\t    }\n\t    function w() {\n\t        var a;\n\t        h() || (a = z(K),\n\t        x(),\n\t        K.focus(),\n\t        a.forEach(function(a) {\n\t            a.restore()\n\t        }))\n\t    }\n\t    var v = runtime.getWindow(), u = {\n\t        beforecut: !0,\n\t        beforepaste: !0,\n\t        longpress: !0,\n\t        drag: !0,\n\t        dragstop: !0\n\t    }, t = {\n\t        mousedown: !0,\n\t        mouseup: !0,\n\t        focus: !0\n\t    }, A = {}, I = {}, K, L = g.getCanvas().getElement(), E = this, N = {};\n\t    this.addFilter = function(c, b) {\n\t        a(c, !0).filters.push(b)\n\t    }\n\t    ;\n\t    this.removeFilter = function(c, b) {\n\t        var d = a(c, !0)\n\t          , e = d.filters.indexOf(b);\n\t        -1 !== e && d.filters.splice(e, 1)\n\t    }\n\t    ;\n\t    this.subscribe = c;\n\t    this.unsubscribe = m;\n\t    this.hasFocus = h;\n\t    this.focus = w;\n\t    this.getEventTrap = function() {\n\t        return K\n\t    }\n\t    ;\n\t    this.setEditing = function(a) {\n\t        var c = h();\n\t        c && K.blur();\n\t        a ? K.removeAttribute(\"readOnly\") : K.setAttribute(\"readOnly\", \"true\");\n\t        c && w()\n\t    }\n\t    ;\n\t    this.destroy = function(a) {\n\t        m(\"touchstart\", q);\n\t        Object.keys(N).forEach(function(a) {\n\t            b(parseInt(a, 10))\n\t        });\n\t        N.length = 0;\n\t        Object.keys(A).forEach(function(a) {\n\t            A[a].destroy()\n\t        });\n\t        A = {};\n\t        m(\"mousedown\", y);\n\t        m(\"mouseup\", x);\n\t        m(\"contextmenu\", x);\n\t        Object.keys(I).forEach(function(a) {\n\t            I[a].destroy()\n\t        });\n\t        I = {};\n\t        K.parentNode.removeChild(K);\n\t        a()\n\t    }\n\t    ;\n\t    (function() {\n\t        var a = g.getOdfCanvas().getSizer()\n\t          , b = a.ownerDocument;\n\t        runtime.assert(Boolean(v), \"EventManager requires a window object to operate correctly\");\n\t        K = b.createElement(\"textarea\");\n\t        K.id = \"eventTrap\";\n\t        K.setAttribute(\"tabindex\", \"-1\");\n\t        K.setAttribute(\"readOnly\", \"true\");\n\t        K.setAttribute(\"rows\", \"1\");\n\t        a.appendChild(K);\n\t        c(\"mousedown\", y);\n\t        c(\"mouseup\", x);\n\t        c(\"contextmenu\", x);\n\t        A.longpress = new d(\"longpress\",[\"touchstart\", \"touchmove\", \"touchend\"],n);\n\t        A.drag = new d(\"drag\",[\"touchstart\", \"touchmove\", \"touchend\"],p);\n\t        A.dragstop = new d(\"dragstop\",[\"drag\", \"touchend\"],r);\n\t        c(\"touchstart\", q)\n\t    }\n\t    )()\n\t}\n\t;\n\tgui.IOSSafariSupport = function(g) {\n\t    function k() {\n\t        d.innerHeight !== d.outerHeight && (b.style.display = \"none\",\n\t        runtime.requestAnimationFrame(function() {\n\t            b.style.display = \"block\"\n\t        }))\n\t    }\n\t    var d = runtime.getWindow()\n\t      , b = g.getEventTrap();\n\t    this.destroy = function(d) {\n\t        g.unsubscribe(\"focus\", k);\n\t        b.removeAttribute(\"autocapitalize\");\n\t        b.style.WebkitTransform = \"\";\n\t        d()\n\t    }\n\t    ;\n\t    g.subscribe(\"focus\", k);\n\t    b.setAttribute(\"autocapitalize\", \"off\");\n\t    b.style.WebkitTransform = \"translateX(-10000px)\"\n\t}\n\t;\n\tgui.HyperlinkController = function(g, k, d, b) {\n\t    function f() {\n\t        var b = !0;\n\t        !0 === k.getState(gui.CommonConstraints.EDIT.REVIEW_MODE) && (b = d.isLocalCursorWithinOwnAnnotation());\n\t        b !== e && (e = b,\n\t        q.emit(gui.HyperlinkController.enabledChanged, e))\n\t    }\n\t    function n(d) {\n\t        d.getMemberId() === b && f()\n\t    }\n\t    var p = odf.OdfUtils\n\t      , r = g.getOdtDocument()\n\t      , q = new core.EventNotifier([gui.HyperlinkController.enabledChanged])\n\t      , e = !1;\n\t    this.isEnabled = function() {\n\t        return e\n\t    }\n\t    ;\n\t    this.subscribe = function(b, a) {\n\t        q.subscribe(b, a)\n\t    }\n\t    ;\n\t    this.unsubscribe = function(b, a) {\n\t        q.unsubscribe(b, a)\n\t    }\n\t    ;\n\t    this.addHyperlink = function(d, a) {\n\t        if (e) {\n\t            var c = r.getCursorSelection(b)\n\t              , f = new ops.OpApplyHyperlink\n\t              , h = [];\n\t            if (0 === c.length || a)\n\t                a = a || d,\n\t                f = new ops.OpInsertText,\n\t                f.init({\n\t                    memberid: b,\n\t                    position: c.position,\n\t                    text: a\n\t                }),\n\t                c.length = a.length,\n\t                h.push(f);\n\t            f = new ops.OpApplyHyperlink;\n\t            f.init({\n\t                memberid: b,\n\t                position: c.position,\n\t                length: c.length,\n\t                hyperlink: d\n\t            });\n\t            h.push(f);\n\t            g.enqueue(h)\n\t        }\n\t    }\n\t    ;\n\t    this.removeHyperlinks = function() {\n\t        if (e) {\n\t            var d = r.createPositionIterator(r.getRootNode()), a = r.getCursor(b).getSelectedRange(), c = p.getHyperlinkElements(a), f = a.collapsed && 1 === c.length, h = r.getDOMDocument().createRange(), k = [], n, q;\n\t            0 !== c.length && (c.forEach(function(a) {\n\t                h.selectNodeContents(a);\n\t                n = r.convertDomToCursorRange({\n\t                    anchorNode: h.startContainer,\n\t                    anchorOffset: h.startOffset,\n\t                    focusNode: h.endContainer,\n\t                    focusOffset: h.endOffset\n\t                });\n\t                q = new ops.OpRemoveHyperlink;\n\t                q.init({\n\t                    memberid: b,\n\t                    position: n.position,\n\t                    length: n.length\n\t                });\n\t                k.push(q)\n\t            }),\n\t            f || (f = c[0],\n\t            -1 === a.comparePoint(f, 0) && (h.setStart(f, 0),\n\t            h.setEnd(a.startContainer, a.startOffset),\n\t            n = r.convertDomToCursorRange({\n\t                anchorNode: h.startContainer,\n\t                anchorOffset: h.startOffset,\n\t                focusNode: h.endContainer,\n\t                focusOffset: h.endOffset\n\t            }),\n\t            0 < n.length && (q = new ops.OpApplyHyperlink,\n\t            q.init({\n\t                memberid: b,\n\t                position: n.position,\n\t                length: n.length,\n\t                hyperlink: p.getHyperlinkTarget(f)\n\t            }),\n\t            k.push(q))),\n\t            c = c[c.length - 1],\n\t            d.moveToEndOfNode(c),\n\t            d = d.unfilteredDomOffset(),\n\t            1 === a.comparePoint(c, d) && (h.setStart(a.endContainer, a.endOffset),\n\t            h.setEnd(c, d),\n\t            n = r.convertDomToCursorRange({\n\t                anchorNode: h.startContainer,\n\t                anchorOffset: h.startOffset,\n\t                focusNode: h.endContainer,\n\t                focusOffset: h.endOffset\n\t            }),\n\t            0 < n.length && (q = new ops.OpApplyHyperlink,\n\t            q.init({\n\t                memberid: b,\n\t                position: n.position,\n\t                length: n.length,\n\t                hyperlink: p.getHyperlinkTarget(c)\n\t            }),\n\t            k.push(q)))),\n\t            g.enqueue(k),\n\t            h.detach())\n\t        }\n\t    }\n\t    ;\n\t    this.destroy = function(b) {\n\t        r.unsubscribe(ops.Document.signalCursorMoved, n);\n\t        k.unsubscribe(gui.CommonConstraints.EDIT.REVIEW_MODE, f);\n\t        b()\n\t    }\n\t    ;\n\t    r.subscribe(ops.Document.signalCursorMoved, n);\n\t    k.subscribe(gui.CommonConstraints.EDIT.REVIEW_MODE, f);\n\t    f()\n\t}\n\t;\n\tgui.HyperlinkController.enabledChanged = \"enabled/changed\";\n\tgui.ImageController = function(g, k, d, b, f) {\n\t    function n() {\n\t        var a = !0;\n\t        !0 === k.getState(gui.CommonConstraints.EDIT.REVIEW_MODE) && (a = d.isLocalCursorWithinOwnAnnotation());\n\t        a !== m && (m = a,\n\t        c.emit(gui.ImageController.enabledChanged, m))\n\t    }\n\t    function p(a) {\n\t        a.getMemberId() === b && n()\n\t    }\n\t    var r = {\n\t        \"image/gif\": \".gif\",\n\t        \"image/jpeg\": \".jpg\",\n\t        \"image/png\": \".png\"\n\t    }\n\t      , q = odf.Namespaces.textns\n\t      , e = g.getOdtDocument()\n\t      , l = odf.OdfUtils\n\t      , a = e.getFormatting()\n\t      , c = new core.EventNotifier([gui.HyperlinkController.enabledChanged])\n\t      , m = !1;\n\t    this.isEnabled = function() {\n\t        return m\n\t    }\n\t    ;\n\t    this.subscribe = function(a, b) {\n\t        c.subscribe(a, b)\n\t    }\n\t    ;\n\t    this.unsubscribe = function(a, b) {\n\t        c.unsubscribe(a, b)\n\t    }\n\t    ;\n\t    this.insertImage = function(c, d, k, n) {\n\t        if (m) {\n\t            var p = new core.CSSUnits;\n\t            runtime.assert(0 < k && 0 < n, \"Both width and height of the image should be greater than 0px.\");\n\t            n = {\n\t                width: k,\n\t                height: n\n\t            };\n\t            if (k = l.getParagraphElement(e.getCursor(b).getNode()).getAttributeNS(q, \"style-name\")) {\n\t                k = a.getContentSize(k, \"paragraph\");\n\t                var v = 1\n\t                  , u = 1;\n\t                n.width > k.width && (v = k.width / n.width);\n\t                n.height > k.height && (u = k.height / n.height);\n\t                k = Math.min(v, u);\n\t                n = {\n\t                    width: n.width * k,\n\t                    height: n.height * k\n\t                }\n\t            }\n\t            k = p.convert(n.width, \"px\", \"cm\") + \"cm\";\n\t            p = p.convert(n.height, \"px\", \"cm\") + \"cm\";\n\t            u = e.getOdfCanvas().odfContainer().rootElement.styles;\n\t            n = c.toLowerCase();\n\t            var v = r.hasOwnProperty(n) ? r[n] : null, t;\n\t            n = [];\n\t            runtime.assert(null !== v, \"Image type is not supported: \" + c);\n\t            v = \"Pictures/\" + f.generateImageName() + v;\n\t            t = new ops.OpSetBlob;\n\t            t.init({\n\t                memberid: b,\n\t                filename: v,\n\t                mimetype: c,\n\t                content: d\n\t            });\n\t            n.push(t);\n\t            a.getStyleElement(\"Graphics\", \"graphic\", [u]) || (c = new ops.OpAddStyle,\n\t            c.init({\n\t                memberid: b,\n\t                styleName: \"Graphics\",\n\t                styleFamily: \"graphic\",\n\t                isAutomaticStyle: !1,\n\t                setProperties: {\n\t                    \"style:graphic-properties\": {\n\t                        \"text:anchor-type\": \"paragraph\",\n\t                        \"svg:x\": \"0cm\",\n\t                        \"svg:y\": \"0cm\",\n\t                        \"style:wrap\": \"dynamic\",\n\t                        \"style:number-wrapped-paragraphs\": \"no-limit\",\n\t                        \"style:wrap-contour\": \"false\",\n\t                        \"style:vertical-pos\": \"top\",\n\t                        \"style:vertical-rel\": \"paragraph\",\n\t                        \"style:horizontal-pos\": \"center\",\n\t                        \"style:horizontal-rel\": \"paragraph\"\n\t                    }\n\t                }\n\t            }),\n\t            n.push(c));\n\t            c = f.generateStyleName();\n\t            d = new ops.OpAddStyle;\n\t            d.init({\n\t                memberid: b,\n\t                styleName: c,\n\t                styleFamily: \"graphic\",\n\t                isAutomaticStyle: !0,\n\t                setProperties: {\n\t                    \"style:parent-style-name\": \"Graphics\",\n\t                    \"style:graphic-properties\": {\n\t                        \"style:vertical-pos\": \"top\",\n\t                        \"style:vertical-rel\": \"baseline\",\n\t                        \"style:horizontal-pos\": \"center\",\n\t                        \"style:horizontal-rel\": \"paragraph\",\n\t                        \"fo:background-color\": \"transparent\",\n\t                        \"style:background-transparency\": \"100%\",\n\t                        \"style:shadow\": \"none\",\n\t                        \"style:mirror\": \"none\",\n\t                        \"fo:clip\": \"rect(0cm, 0cm, 0cm, 0cm)\",\n\t                        \"draw:luminance\": \"0%\",\n\t                        \"draw:contrast\": \"0%\",\n\t                        \"draw:red\": \"0%\",\n\t                        \"draw:green\": \"0%\",\n\t                        \"draw:blue\": \"0%\",\n\t                        \"draw:gamma\": \"100%\",\n\t                        \"draw:color-inversion\": \"false\",\n\t                        \"draw:image-opacity\": \"100%\",\n\t                        \"draw:color-mode\": \"standard\"\n\t                    }\n\t                }\n\t            });\n\t            n.push(d);\n\t            t = new ops.OpInsertImage;\n\t            t.init({\n\t                memberid: b,\n\t                position: e.getCursorPosition(b),\n\t                filename: v,\n\t                frameWidth: k,\n\t                frameHeight: p,\n\t                frameStyleName: c,\n\t                frameName: f.generateFrameName()\n\t            });\n\t            n.push(t);\n\t            g.enqueue(n)\n\t        }\n\t    }\n\t    ;\n\t    this.destroy = function(a) {\n\t        e.unsubscribe(ops.Document.signalCursorMoved, p);\n\t        k.unsubscribe(gui.CommonConstraints.EDIT.REVIEW_MODE, n);\n\t        a()\n\t    }\n\t    ;\n\t    e.subscribe(ops.Document.signalCursorMoved, p);\n\t    k.subscribe(gui.CommonConstraints.EDIT.REVIEW_MODE, n);\n\t    n()\n\t}\n\t;\n\tgui.ImageController.enabledChanged = \"enabled/changed\";\n\tgui.ImageSelector = function(g) {\n\t    function k() {\n\t        var d = g.getSizer()\n\t          , k = f.createElement(\"div\");\n\t        k.id = \"imageSelector\";\n\t        k.style.borderWidth = \"1px\";\n\t        d.appendChild(k);\n\t        b.forEach(function(b) {\n\t            var d = f.createElement(\"div\");\n\t            d.className = b;\n\t            k.appendChild(d)\n\t        });\n\t        return k\n\t    }\n\t    var d = odf.Namespaces.svgns\n\t      , b = \"topLeft topRight bottomRight bottomLeft topMiddle rightMiddle bottomMiddle leftMiddle\".split(\" \")\n\t      , f = g.getElement().ownerDocument\n\t      , n = !1;\n\t    this.select = function(b) {\n\t        var r, q, e = f.getElementById(\"imageSelector\");\n\t        e || (e = k());\n\t        n = !0;\n\t        r = e.parentNode;\n\t        q = b.getBoundingClientRect();\n\t        var l = r.getBoundingClientRect()\n\t          , a = g.getZoomLevel();\n\t        r = (q.left - l.left) / a - 1;\n\t        q = (q.top - l.top) / a - 1;\n\t        e.style.display = \"block\";\n\t        e.style.left = r + \"px\";\n\t        e.style.top = q + \"px\";\n\t        e.style.width = b.getAttributeNS(d, \"width\");\n\t        e.style.height = b.getAttributeNS(d, \"height\")\n\t    }\n\t    ;\n\t    this.clearSelection = function() {\n\t        var b;\n\t        n && (b = f.getElementById(\"imageSelector\")) && (b.style.display = \"none\");\n\t        n = !1\n\t    }\n\t    ;\n\t    this.isSelectorElement = function(b) {\n\t        var d = f.getElementById(\"imageSelector\");\n\t        return d ? b === d || b.parentNode === d : !1\n\t    }\n\t}\n\t;\n\t(function() {\n\t    function g(g) {\n\t        function d(b) {\n\t            p = b.which && String.fromCharCode(b.which) === n;\n\t            n = void 0;\n\t            return !1 === p\n\t        }\n\t        function b() {\n\t            p = !1\n\t        }\n\t        function f(b) {\n\t            n = b.data;\n\t            p = !1\n\t        }\n\t        var n, p = !1;\n\t        this.destroy = function(n) {\n\t            g.unsubscribe(\"textInput\", b);\n\t            g.unsubscribe(\"compositionend\", f);\n\t            g.removeFilter(\"keypress\", d);\n\t            n()\n\t        }\n\t        ;\n\t        g.subscribe(\"textInput\", b);\n\t        g.subscribe(\"compositionend\", f);\n\t        g.addFilter(\"keypress\", d)\n\t    }\n\t    gui.InputMethodEditor = function(k, d) {\n\t        function b(c) {\n\t            a && (c ? a.getNode().setAttributeNS(\"urn:webodf:names:cursor\", \"composing\", \"true\") : (a.getNode().removeAttributeNS(\"urn:webodf:names:cursor\", \"composing\"),\n\t            h.textContent = \"\"))\n\t        }\n\t        function f() {\n\t            x && (x = !1,\n\t            b(!1),\n\t            w.emit(gui.InputMethodEditor.signalCompositionEnd, {\n\t                data: z\n\t            }),\n\t            z = \"\")\n\t        }\n\t        function n() {\n\t            I || (I = !0,\n\t            f(),\n\t            a && a.getSelectedRange().collapsed ? c.value = \"\" : c.value = u.writeToString(a.getSelectedRange().cloneContents()),\n\t            c.setSelectionRange(0, c.value.length),\n\t            I = !1)\n\t        }\n\t        function p() {\n\t            d.hasFocus() && y.trigger()\n\t        }\n\t        function r() {\n\t            v = void 0;\n\t            y.cancel();\n\t            b(!0);\n\t            x || w.emit(gui.InputMethodEditor.signalCompositionStart, {\n\t                data: \"\"\n\t            })\n\t        }\n\t        function q(a) {\n\t            a = v = a.data;\n\t            x = !0;\n\t            z += a;\n\t            y.trigger()\n\t        }\n\t        function e(a) {\n\t            a.data !== v && (a = a.data,\n\t            x = !0,\n\t            z += a,\n\t            y.trigger());\n\t            v = void 0\n\t        }\n\t        function l() {\n\t            h.textContent = c.value\n\t        }\n\t        var a = null, c = d.getEventTrap(), m = c.ownerDocument, h, y, x = !1, z = \"\", w = new core.EventNotifier([gui.InputMethodEditor.signalCompositionStart, gui.InputMethodEditor.signalCompositionEnd]), v, u, t = [], A, I = !1;\n\t        this.subscribe = w.subscribe;\n\t        this.unsubscribe = w.unsubscribe;\n\t        this.registerCursor = function(c) {\n\t            c.getMemberId() === k && (a = c,\n\t            a.getNode().appendChild(h),\n\t            c.subscribe(ops.OdtCursor.signalCursorUpdated, p),\n\t            d.subscribe(\"input\", l),\n\t            d.subscribe(\"compositionupdate\", l))\n\t        }\n\t        ;\n\t        this.removeCursor = function(c) {\n\t            a && c === k && (a.getNode().removeChild(h),\n\t            a.unsubscribe(ops.OdtCursor.signalCursorUpdated, p),\n\t            d.unsubscribe(\"input\", l),\n\t            d.unsubscribe(\"compositionupdate\", l),\n\t            a = null)\n\t        }\n\t        ;\n\t        this.destroy = function(a) {\n\t            d.unsubscribe(\"compositionstart\", r);\n\t            d.unsubscribe(\"compositionend\", q);\n\t            d.unsubscribe(\"textInput\", e);\n\t            d.unsubscribe(\"keypress\", f);\n\t            d.unsubscribe(\"focus\", n);\n\t            core.Async.destroyAll(A, a)\n\t        }\n\t        ;\n\t        (function() {\n\t            u = new odf.TextSerializer;\n\t            u.filter = new odf.OdfNodeFilter;\n\t            d.subscribe(\"compositionstart\", r);\n\t            d.subscribe(\"compositionend\", q);\n\t            d.subscribe(\"textInput\", e);\n\t            d.subscribe(\"keypress\", f);\n\t            d.subscribe(\"focus\", n);\n\t            t.push(new g(d));\n\t            A = t.map(function(a) {\n\t                return a.destroy\n\t            });\n\t            h = m.createElement(\"span\");\n\t            h.setAttribute(\"id\", \"composer\");\n\t            y = core.Task.createTimeoutTask(n, 1);\n\t            A.push(y.destroy)\n\t        }\n\t        )()\n\t    }\n\t    ;\n\t    gui.InputMethodEditor.signalCompositionStart = \"input/compositionstart\";\n\t    gui.InputMethodEditor.signalCompositionEnd = \"input/compositionend\"\n\t}\n\t)();\n\tgui.MetadataController = function(g, k) {\n\t    function d(b) {\n\t        n.emit(gui.MetadataController.signalMetadataChanged, b)\n\t    }\n\t    function b(b) {\n\t        var d = -1 === p.indexOf(b);\n\t        d || runtime.log(\"Setting \" + b + \" is restricted.\");\n\t        return d\n\t    }\n\t    var f = g.getOdtDocument()\n\t      , n = new core.EventNotifier([gui.MetadataController.signalMetadataChanged])\n\t      , p = [\"dc:creator\", \"dc:date\", \"meta:editing-cycles\", \"meta:editing-duration\", \"meta:document-statistic\"];\n\t    this.setMetadata = function(d, f) {\n\t        var e = {}, l = \"\", a;\n\t        d && Object.keys(d).filter(b).forEach(function(a) {\n\t            e[a] = d[a]\n\t        });\n\t        f && (l = f.filter(b).join(\",\"));\n\t        if (0 < l.length || 0 < Object.keys(e).length)\n\t            a = new ops.OpUpdateMetadata,\n\t            a.init({\n\t                memberid: k,\n\t                setProperties: e,\n\t                removedProperties: 0 < l.length ? {\n\t                    attributes: l\n\t                } : null\n\t            }),\n\t            g.enqueue([a])\n\t    }\n\t    ;\n\t    this.getMetadata = function(b) {\n\t        var d;\n\t        runtime.assert(\"string\" === typeof b, \"Property must be a string\");\n\t        d = b.split(\":\");\n\t        runtime.assert(2 === d.length, \"Property must be a namespace-prefixed string\");\n\t        b = odf.Namespaces.lookupNamespaceURI(d[0]);\n\t        runtime.assert(Boolean(b), \"Prefix must be for an ODF namespace.\");\n\t        return f.getOdfCanvas().odfContainer().getMetadata(b, d[1])\n\t    }\n\t    ;\n\t    this.subscribe = function(b, d) {\n\t        n.subscribe(b, d)\n\t    }\n\t    ;\n\t    this.unsubscribe = function(b, d) {\n\t        n.unsubscribe(b, d)\n\t    }\n\t    ;\n\t    this.destroy = function(b) {\n\t        f.unsubscribe(ops.OdtDocument.signalMetadataUpdated, d);\n\t        b()\n\t    }\n\t    ;\n\t    f.subscribe(ops.OdtDocument.signalMetadataUpdated, d)\n\t}\n\t;\n\tgui.MetadataController.signalMetadataChanged = \"metadata/changed\";\n\tgui.PasteController = function(g, k, d, b) {\n\t    function f() {\n\t        r = !0 === k.getState(gui.CommonConstraints.EDIT.REVIEW_MODE) ? d.isLocalCursorWithinOwnAnnotation() : !0\n\t    }\n\t    function n(a) {\n\t        a.getMemberId() === b && f()\n\t    }\n\t    var p = g.getOdtDocument()\n\t      , r = !1\n\t      , q = odf.Namespaces.textns\n\t      , e = core.StepDirection.NEXT\n\t      , l = odf.OdfUtils;\n\t    this.isEnabled = function() {\n\t        return r\n\t    }\n\t    ;\n\t    this.paste = function(a) {\n\t        if (r) {\n\t            var c = p.getCursorPosition(b)\n\t              , d = p.getCursor(b).getNode()\n\t              , d = l.getParagraphElement(d)\n\t              , h = d.getAttributeNS(q, \"style-name\") || \"\"\n\t              , f = c\n\t              , k = []\n\t              , n = p.convertDomPointToCursorStep(d, 0, e);\n\t            a.replace(/\\r/g, \"\").split(\"\\n\").forEach(function(a) {\n\t                var c = new ops.OpInsertText\n\t                  , d = new ops.OpSplitParagraph;\n\t                c.init({\n\t                    memberid: b,\n\t                    position: f,\n\t                    text: a,\n\t                    moveCursor: !0\n\t                });\n\t                k.push(c);\n\t                f += a.length;\n\t                d.init({\n\t                    memberid: b,\n\t                    position: f,\n\t                    paragraphStyleName: h,\n\t                    sourceParagraphPosition: n,\n\t                    moveCursor: !0\n\t                });\n\t                k.push(d);\n\t                n = f += 1\n\t            });\n\t            k.pop();\n\t            g.enqueue(k)\n\t        }\n\t    }\n\t    ;\n\t    this.destroy = function(a) {\n\t        p.unsubscribe(ops.Document.signalCursorMoved, n);\n\t        k.unsubscribe(gui.CommonConstraints.EDIT.REVIEW_MODE, f);\n\t        a()\n\t    }\n\t    ;\n\t    p.subscribe(ops.Document.signalCursorMoved, n);\n\t    k.subscribe(gui.CommonConstraints.EDIT.REVIEW_MODE, f);\n\t    f()\n\t}\n\t;\n\tgui.ClosestXOffsetScanner = function(g) {\n\t    function k(b) {\n\t        return null !== b && void 0 !== f ? Math.abs(b - g) > f : !1\n\t    }\n\t    function d(b) {\n\t        null !== b && !1 === k(b) && (f = Math.abs(b - g))\n\t    }\n\t    var b = this, f, n = gui.StepInfo.VisualDirection.LEFT_TO_RIGHT;\n\t    this.token = void 0;\n\t    this.process = function(f, g, q) {\n\t        var e, l;\n\t        f.visualDirection === n ? (e = g && g.right,\n\t        l = q && q.left) : (e = g && g.left,\n\t        l = q && q.right);\n\t        if (k(e) || k(l))\n\t            return !0;\n\t        if (g || q)\n\t            d(e),\n\t            d(l),\n\t            b.token = f.token;\n\t        return !1\n\t    }\n\t}\n\t;\n\tgui.LineBoundaryScanner = function() {\n\t    var g = this\n\t      , k = null;\n\t    this.token = void 0;\n\t    this.process = function(d, b, f) {\n\t        var n;\n\t        if (n = f)\n\t            if (k) {\n\t                var p = k;\n\t                n = Math.min(p.bottom - p.top, f.bottom - f.top);\n\t                var r = Math.max(p.top, f.top)\n\t                  , p = Math.min(p.bottom, f.bottom) - r;\n\t                n = .4 >= (0 < n ? p / n : 0)\n\t            } else\n\t                n = !1;\n\t        !b || f && !n || (g.token = d.token);\n\t        if (n)\n\t            return !0;\n\t        k = (d = k) && b ? {\n\t            left: Math.min(d.left, b.left),\n\t            right: Math.max(d.right, b.right),\n\t            top: Math.min(d.top, b.top),\n\t            bottom: Math.min(d.bottom, b.bottom)\n\t        } : d || b;\n\t        return !1\n\t    }\n\t}\n\t;\n\tgui.ParagraphBoundaryScanner = function() {\n\t    var g = this, k = !1, d, b = odf.OdfUtils;\n\t    this.token = void 0;\n\t    this.process = function(f) {\n\t        var n = b.getParagraphElement(f.container());\n\t        k || (d = n,\n\t        k = !0);\n\t        if (d !== n)\n\t            return !0;\n\t        g.token = f.token;\n\t        return !1\n\t    }\n\t}\n\t;\n\todf.WordBoundaryFilter = function(g, k) {\n\t    function d(a, b, c) {\n\t        for (var d = null, e = g.getRootNode(), f; a !== e && null !== a && null === d; )\n\t            f = 0 > b ? a.previousSibling : a.nextSibling,\n\t            c(f) === NodeFilter.FILTER_ACCEPT && (d = f),\n\t            a = a.parentNode;\n\t        return d\n\t    }\n\t    function b(a, b) {\n\t        var c;\n\t        return null === a ? m.NO_NEIGHBOUR : p.isCharacterElement(a) ? m.SPACE_CHAR : a.nodeType === f || p.isTextSpan(a) || p.isHyperlink(a) ? (c = a.textContent.charAt(b()),\n\t        q.test(c) ? m.SPACE_CHAR : r.test(c) ? m.PUNCTUATION_CHAR : m.WORD_CHAR) : m.OTHER\n\t    }\n\t    var f = Node.TEXT_NODE\n\t      , n = Node.ELEMENT_NODE\n\t      , p = odf.OdfUtils\n\t      , r = /[!-#%-*,-\\/:-;?-@\\[-\\]_{}\\u00a1\\u00ab\\u00b7\\u00bb\\u00bf;\\u00b7\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0964-\\u0965\\u0970\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u104a-\\u104f\\u10fb\\u1361-\\u1368\\u166d-\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u19de-\\u19df\\u1a1e-\\u1a1f\\u1b5a-\\u1b60\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u2000-\\u206e\\u207d-\\u207e\\u208d-\\u208e\\u3008-\\u3009\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2e00-\\u2e7e\\u3000-\\u303f\\u30a0\\u30fb\\ua60d-\\ua60f\\ua673\\ua67e\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua92e-\\ua92f\\ua95f\\uaa5c-\\uaa5f\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd01\\udf9f\\udfd0]|\\ud802[\\udd1f\\udd3f\\ude50-\\ude58]|\\ud809[\\udc00-\\udc7e]/\n\t      , q = /\\s/\n\t      , e = core.PositionFilter.FilterResult.FILTER_ACCEPT\n\t      , l = core.PositionFilter.FilterResult.FILTER_REJECT\n\t      , a = odf.WordBoundaryFilter.IncludeWhitespace.TRAILING\n\t      , c = odf.WordBoundaryFilter.IncludeWhitespace.LEADING\n\t      , m = {\n\t        NO_NEIGHBOUR: 0,\n\t        SPACE_CHAR: 1,\n\t        PUNCTUATION_CHAR: 2,\n\t        WORD_CHAR: 3,\n\t        OTHER: 4\n\t    };\n\t    this.acceptPosition = function(f) {\n\t        var g = f.container()\n\t          , p = f.leftNode()\n\t          , r = f.rightNode()\n\t          , q = f.unfilteredDomOffset\n\t          , v = function() {\n\t            return f.unfilteredDomOffset() - 1\n\t        };\n\t        g.nodeType === n && (null === r && (r = d(g, 1, f.getNodeFilter())),\n\t        null === p && (p = d(g, -1, f.getNodeFilter())));\n\t        g !== r && (q = function() {\n\t            return 0\n\t        }\n\t        );\n\t        g !== p && null !== p && (v = function() {\n\t            return p.textContent.length - 1\n\t        }\n\t        );\n\t        g = b(p, v);\n\t        r = b(r, q);\n\t        return g === m.WORD_CHAR && r === m.WORD_CHAR || g === m.PUNCTUATION_CHAR && r === m.PUNCTUATION_CHAR || k === a && g !== m.NO_NEIGHBOUR && r === m.SPACE_CHAR || k === c && g === m.SPACE_CHAR && r !== m.NO_NEIGHBOUR ? l : e\n\t    }\n\t}\n\t;\n\todf.WordBoundaryFilter.IncludeWhitespace = {\n\t    None: 0,\n\t    TRAILING: 1,\n\t    LEADING: 2\n\t};\n\tgui.SelectionController = function(g, k) {\n\t    function d(a) {\n\t        var b = a.spec();\n\t        if (a.isEdit || b.memberid === k)\n\t            I = void 0,\n\t            K.cancel()\n\t    }\n\t    function b() {\n\t        var a = x.getCursor(k).getNode();\n\t        return x.createStepIterator(a, 0, [v, t], x.getRootElement(a))\n\t    }\n\t    function f(a, b, c) {\n\t        c = new odf.WordBoundaryFilter(x,c);\n\t        var d = x.getRootElement(a) || x.getRootNode()\n\t          , e = x.createRootFilter(d);\n\t        return x.createStepIterator(a, b, [v, e, c], d)\n\t    }\n\t    function n(a, b) {\n\t        return b ? {\n\t            anchorNode: a.startContainer,\n\t            anchorOffset: a.startOffset,\n\t            focusNode: a.endContainer,\n\t            focusOffset: a.endOffset\n\t        } : {\n\t            anchorNode: a.endContainer,\n\t            anchorOffset: a.endOffset,\n\t            focusNode: a.startContainer,\n\t            focusOffset: a.startOffset\n\t        }\n\t    }\n\t    function p(a, b, c) {\n\t        var d = new ops.OpMoveCursor;\n\t        d.init({\n\t            memberid: k,\n\t            position: a,\n\t            length: b || 0,\n\t            selectionType: c\n\t        });\n\t        return d\n\t    }\n\t    function r(a, b, c) {\n\t        var d;\n\t        d = x.getCursor(k);\n\t        d = n(d.getSelectedRange(), d.hasForwardSelection());\n\t        d.focusNode = a;\n\t        d.focusOffset = b;\n\t        c || (d.anchorNode = d.focusNode,\n\t        d.anchorOffset = d.focusOffset);\n\t        a = x.convertDomToCursorRange(d);\n\t        g.enqueue([p(a.position, a.length)])\n\t    }\n\t    function q(a) {\n\t        var b;\n\t        b = f(a.startContainer, a.startOffset, L);\n\t        b.roundToPreviousStep() && a.setStart(b.container(), b.offset());\n\t        b = f(a.endContainer, a.endOffset, E);\n\t        b.roundToNextStep() && a.setEnd(b.container(), b.offset())\n\t    }\n\t    function e(a) {\n\t        var b = w.getParagraphElements(a)\n\t          , c = b[0]\n\t          , b = b[b.length - 1];\n\t        c && a.setStart(c, 0);\n\t        b && (w.isParagraph(a.endContainer) && 0 === a.endOffset ? a.setEndBefore(b) : a.setEnd(b, b.childNodes.length))\n\t    }\n\t    function l(a, b, c, d) {\n\t        var e, f;\n\t        d ? (e = c.startContainer,\n\t        f = c.startOffset) : (e = c.endContainer,\n\t        f = c.endOffset);\n\t        z.containsNode(a, e) || (f = 0 > z.comparePoints(a, 0, e, f) ? 0 : a.childNodes.length,\n\t        e = a);\n\t        a = x.createStepIterator(e, f, b, w.getParagraphElement(e) || a);\n\t        a.roundToClosestStep() || runtime.assert(!1, \"No step found in requested range\");\n\t        d ? c.setStart(a.container(), a.offset()) : c.setEnd(a.container(), a.offset())\n\t    }\n\t    function a(a, c) {\n\t        var d = b();\n\t        d.advanceStep(a) && r(d.container(), d.offset(), c)\n\t    }\n\t    function c(a, c) {\n\t        var d, e = I, f = [new gui.LineBoundaryScanner, new gui.ParagraphBoundaryScanner];\n\t        void 0 === e && A && (e = A());\n\t        isNaN(e) || (d = b(),\n\t        u.moveToFilteredStep(d, a, f) && d.advanceStep(a) && (f = [new gui.ClosestXOffsetScanner(e), new gui.LineBoundaryScanner, new gui.ParagraphBoundaryScanner],\n\t        u.moveToFilteredStep(d, a, f) && (r(d.container(), d.offset(), c),\n\t        I = e,\n\t        K.restart())))\n\t    }\n\t    function m(a, c) {\n\t        var d = b()\n\t          , e = [new gui.LineBoundaryScanner, new gui.ParagraphBoundaryScanner];\n\t        u.moveToFilteredStep(d, a, e) && r(d.container(), d.offset(), c)\n\t    }\n\t    function h(a, b) {\n\t        var c = x.getCursor(k)\n\t          , c = n(c.getSelectedRange(), c.hasForwardSelection())\n\t          , c = f(c.focusNode, c.focusOffset, L);\n\t        c.advanceStep(a) && r(c.container(), c.offset(), b)\n\t    }\n\t    function y(a, b, c) {\n\t        var d = !1\n\t          , e = x.getCursor(k)\n\t          , e = n(e.getSelectedRange(), e.hasForwardSelection())\n\t          , d = x.getRootElement(e.focusNode);\n\t        runtime.assert(Boolean(d), \"SelectionController: Cursor outside root\");\n\t        e = x.createStepIterator(e.focusNode, e.focusOffset, [v, t], d);\n\t        e.roundToClosestStep();\n\t        e.advanceStep(a) && (c = c(e.container())) && (a === N ? (e.setPosition(c, 0),\n\t        d = e.roundToNextStep()) : (e.setPosition(c, c.childNodes.length),\n\t        d = e.roundToPreviousStep()),\n\t        d && r(e.container(), e.offset(), b))\n\t    }\n\t    var x = g.getOdtDocument(), z = core.DomUtils, w = odf.OdfUtils, v = x.getPositionFilter(), u = new gui.GuiStepUtils, t = x.createRootFilter(k), A = null, I, K, L = odf.WordBoundaryFilter.IncludeWhitespace.TRAILING, E = odf.WordBoundaryFilter.IncludeWhitespace.LEADING, N = core.StepDirection.PREVIOUS, O = core.StepDirection.NEXT;\n\t    this.selectionToRange = function(a) {\n\t        var b = 0 <= z.comparePoints(a.anchorNode, a.anchorOffset, a.focusNode, a.focusOffset)\n\t          , c = a.focusNode.ownerDocument.createRange();\n\t        b ? (c.setStart(a.anchorNode, a.anchorOffset),\n\t        c.setEnd(a.focusNode, a.focusOffset)) : (c.setStart(a.focusNode, a.focusOffset),\n\t        c.setEnd(a.anchorNode, a.anchorOffset));\n\t        return {\n\t            range: c,\n\t            hasForwardSelection: b\n\t        }\n\t    }\n\t    ;\n\t    this.rangeToSelection = n;\n\t    this.selectImage = function(a) {\n\t        var c = x.getRootElement(a), b = x.createRootFilter(c), c = x.createStepIterator(a, 0, [b, x.getPositionFilter()], c), d;\n\t        c.roundToPreviousStep() || runtime.assert(!1, \"No walkable position before frame\");\n\t        b = c.container();\n\t        d = c.offset();\n\t        c.setPosition(a, a.childNodes.length);\n\t        c.roundToNextStep() || runtime.assert(!1, \"No walkable position after frame\");\n\t        a = x.convertDomToCursorRange({\n\t            anchorNode: b,\n\t            anchorOffset: d,\n\t            focusNode: c.container(),\n\t            focusOffset: c.offset()\n\t        });\n\t        a = p(a.position, a.length, ops.OdtCursor.RegionSelection);\n\t        g.enqueue([a])\n\t    }\n\t    ;\n\t    this.expandToWordBoundaries = q;\n\t    this.expandToParagraphBoundaries = e;\n\t    this.selectRange = function(a, c, b) {\n\t        var d = x.getOdfCanvas().getElement(), f, h = [v];\n\t        f = z.containsNode(d, a.startContainer);\n\t        d = z.containsNode(d, a.endContainer);\n\t        if (f || d)\n\t            if (f && d && (2 === b ? q(a) : 3 <= b && e(a)),\n\t            (b = c ? x.getRootElement(a.startContainer) : x.getRootElement(a.endContainer)) || (b = x.getRootNode()),\n\t            h.push(x.createRootFilter(b)),\n\t            l(b, h, a, !0),\n\t            l(b, h, a, !1),\n\t            a = n(a, c),\n\t            c = x.convertDomToCursorRange(a),\n\t            a = x.getCursorSelection(k),\n\t            c.position !== a.position || c.length !== a.length)\n\t                a = p(c.position, c.length, ops.OdtCursor.RangeSelection),\n\t                g.enqueue([a])\n\t    }\n\t    ;\n\t    this.moveCursorToLeft = function() {\n\t        a(N, !1);\n\t        return !0\n\t    }\n\t    ;\n\t    this.moveCursorToRight = function() {\n\t        a(O, !1);\n\t        return !0\n\t    }\n\t    ;\n\t    this.extendSelectionToLeft = function() {\n\t        a(N, !0);\n\t        return !0\n\t    }\n\t    ;\n\t    this.extendSelectionToRight = function() {\n\t        a(O, !0);\n\t        return !0\n\t    }\n\t    ;\n\t    this.setCaretXPositionLocator = function(a) {\n\t        A = a\n\t    }\n\t    ;\n\t    this.moveCursorUp = function() {\n\t        c(N, !1);\n\t        return !0\n\t    }\n\t    ;\n\t    this.moveCursorDown = function() {\n\t        c(O, !1);\n\t        return !0\n\t    }\n\t    ;\n\t    this.extendSelectionUp = function() {\n\t        c(N, !0);\n\t        return !0\n\t    }\n\t    ;\n\t    this.extendSelectionDown = function() {\n\t        c(O, !0);\n\t        return !0\n\t    }\n\t    ;\n\t    this.moveCursorBeforeWord = function() {\n\t        h(N, !1);\n\t        return !0\n\t    }\n\t    ;\n\t    this.moveCursorPastWord = function() {\n\t        h(O, !1);\n\t        return !0\n\t    }\n\t    ;\n\t    this.extendSelectionBeforeWord = function() {\n\t        h(N, !0);\n\t        return !0\n\t    }\n\t    ;\n\t    this.extendSelectionPastWord = function() {\n\t        h(O, !0);\n\t        return !0\n\t    }\n\t    ;\n\t    this.moveCursorToLineStart = function() {\n\t        m(N, !1);\n\t        return !0\n\t    }\n\t    ;\n\t    this.moveCursorToLineEnd = function() {\n\t        m(O, !1);\n\t        return !0\n\t    }\n\t    ;\n\t    this.extendSelectionToLineStart = function() {\n\t        m(N, !0);\n\t        return !0\n\t    }\n\t    ;\n\t    this.extendSelectionToLineEnd = function() {\n\t        m(O, !0);\n\t        return !0\n\t    }\n\t    ;\n\t    this.extendSelectionToParagraphStart = function() {\n\t        y(N, !0, w.getParagraphElement);\n\t        return !0\n\t    }\n\t    ;\n\t    this.extendSelectionToParagraphEnd = function() {\n\t        y(O, !0, w.getParagraphElement);\n\t        return !0\n\t    }\n\t    ;\n\t    this.moveCursorToParagraphStart = function() {\n\t        y(N, !1, w.getParagraphElement);\n\t        return !0\n\t    }\n\t    ;\n\t    this.moveCursorToParagraphEnd = function() {\n\t        y(O, !1, w.getParagraphElement);\n\t        return !0\n\t    }\n\t    ;\n\t    this.moveCursorToDocumentStart = function() {\n\t        y(N, !1, x.getRootElement);\n\t        return !0\n\t    }\n\t    ;\n\t    this.moveCursorToDocumentEnd = function() {\n\t        y(O, !1, x.getRootElement);\n\t        return !0\n\t    }\n\t    ;\n\t    this.extendSelectionToDocumentStart = function() {\n\t        y(N, !0, x.getRootElement);\n\t        return !0\n\t    }\n\t    ;\n\t    this.extendSelectionToDocumentEnd = function() {\n\t        y(O, !0, x.getRootElement);\n\t        return !0\n\t    }\n\t    ;\n\t    this.extendSelectionToEntireDocument = function() {\n\t        var a = x.getCursor(k), a = x.getRootElement(a.getNode()), c, b, d;\n\t        runtime.assert(Boolean(a), \"SelectionController: Cursor outside root\");\n\t        d = x.createStepIterator(a, 0, [v, t], a);\n\t        d.roundToClosestStep();\n\t        c = d.container();\n\t        b = d.offset();\n\t        d.setPosition(a, a.childNodes.length);\n\t        d.roundToClosestStep();\n\t        a = x.convertDomToCursorRange({\n\t            anchorNode: c,\n\t            anchorOffset: b,\n\t            focusNode: d.container(),\n\t            focusOffset: d.offset()\n\t        });\n\t        g.enqueue([p(a.position, a.length)]);\n\t        return !0\n\t    }\n\t    ;\n\t    this.destroy = function(a) {\n\t        x.unsubscribe(ops.OdtDocument.signalOperationStart, d);\n\t        core.Async.destroyAll([K.destroy], a)\n\t    }\n\t    ;\n\t    (function() {\n\t        K = core.Task.createTimeoutTask(function() {\n\t            I = void 0\n\t        }, 2E3);\n\t        x.subscribe(ops.OdtDocument.signalOperationStart, d)\n\t    }\n\t    )()\n\t}\n\t;\n\tgui.TextController = function(g, k, d, b, f, n) {\n\t    function p() {\n\t        y = !0 === k.getState(gui.CommonConstraints.EDIT.REVIEW_MODE) ? d.isLocalCursorWithinOwnAnnotation() : !0\n\t    }\n\t    function r(a) {\n\t        a.getMemberId() === b && p()\n\t    }\n\t    function q(a, b, d) {\n\t        var e = [c.getPositionFilter()];\n\t        d && e.push(c.createRootFilter(a.startContainer));\n\t        d = c.createStepIterator(a.startContainer, a.startOffset, e, b);\n\t        d.roundToClosestStep() || runtime.assert(!1, \"No walkable step found in paragraph element at range start\");\n\t        b = c.convertDomPointToCursorStep(d.container(), d.offset());\n\t        a.collapsed ? a = b : (d.setPosition(a.endContainer, a.endOffset),\n\t        d.roundToClosestStep() || runtime.assert(!1, \"No walkable step found in paragraph element at range end\"),\n\t        a = c.convertDomPointToCursorStep(d.container(), d.offset()));\n\t        return {\n\t            position: b,\n\t            length: a - b\n\t        }\n\t    }\n\t    function e(a) {\n\t        var c, d, e, f = m.getParagraphElements(a), g = a.cloneRange(), l = [];\n\t        c = f[0];\n\t        1 < f.length && (m.hasNoODFContent(c) && (c = f[f.length - 1]),\n\t        d = c.getAttributeNS(odf.Namespaces.textns, \"style-name\") || \"\");\n\t        f.forEach(function(c, f) {\n\t            var m, k;\n\t            g.setStart(c, 0);\n\t            g.collapse(!0);\n\t            m = q(g, c, !1).position;\n\t            0 < f && (k = new ops.OpMergeParagraph,\n\t            k.init({\n\t                memberid: b,\n\t                paragraphStyleName: d,\n\t                destinationStartPosition: e,\n\t                sourceStartPosition: m,\n\t                moveCursor: 1 === f\n\t            }),\n\t            l.unshift(k));\n\t            e = m;\n\t            g.selectNodeContents(c);\n\t            if (m = h.rangeIntersection(g, a))\n\t                m = q(m, c, !0),\n\t                0 < m.length && (k = new ops.OpRemoveText,\n\t                k.init({\n\t                    memberid: b,\n\t                    position: m.position,\n\t                    length: m.length\n\t                }),\n\t                l.unshift(k))\n\t        });\n\t        return l\n\t    }\n\t    function l(a) {\n\t        0 > a.length && (a.position += a.length,\n\t        a.length = -a.length);\n\t        return a\n\t    }\n\t    function a(a) {\n\t        if (!y)\n\t            return !1;\n\t        var d, f = c.getCursor(b).getSelectedRange().cloneRange(), h = l(c.getCursorSelection(b)), m;\n\t        if (0 === h.length) {\n\t            h = void 0;\n\t            d = c.getCursor(b).getNode();\n\t            m = c.getRootElement(d);\n\t            var k = [c.getPositionFilter(), c.createRootFilter(m)];\n\t            m = c.createStepIterator(d, 0, k, m);\n\t            m.roundToClosestStep() && (a ? m.nextStep() : m.previousStep()) && (h = l(c.convertDomToCursorRange({\n\t                anchorNode: d,\n\t                anchorOffset: 0,\n\t                focusNode: m.container(),\n\t                focusOffset: m.offset()\n\t            })),\n\t            a ? (f.setStart(d, 0),\n\t            f.setEnd(m.container(), m.offset())) : (f.setStart(m.container(), m.offset()),\n\t            f.setEnd(d, 0)))\n\t        }\n\t        h && g.enqueue(e(f));\n\t        return void 0 !== h\n\t    }\n\t    var c = g.getOdtDocument()\n\t      , m = odf.OdfUtils\n\t      , h = core.DomUtils\n\t      , y = !1\n\t      , x = odf.Namespaces.textns\n\t      , z = core.StepDirection.NEXT;\n\t    this.isEnabled = function() {\n\t        return y\n\t    }\n\t    ;\n\t    this.enqueueParagraphSplittingOps = function() {\n\t        if (!y)\n\t            return !1;\n\t        var a = c.getCursor(b)\n\t          , d = a.getSelectedRange()\n\t          , f = l(c.getCursorSelection(b))\n\t          , h = []\n\t          , a = m.getParagraphElement(a.getNode())\n\t          , k = a.getAttributeNS(x, \"style-name\") || \"\";\n\t        0 < f.length && (h = h.concat(e(d)));\n\t        d = new ops.OpSplitParagraph;\n\t        d.init({\n\t            memberid: b,\n\t            position: f.position,\n\t            paragraphStyleName: k,\n\t            sourceParagraphPosition: c.convertDomPointToCursorStep(a, 0, z),\n\t            moveCursor: !0\n\t        });\n\t        h.push(d);\n\t        n && (f = n(f.position + 1),\n\t        h = h.concat(f));\n\t        g.enqueue(h);\n\t        return !0\n\t    }\n\t    ;\n\t    this.removeTextByBackspaceKey = function() {\n\t        return a(!1)\n\t    }\n\t    ;\n\t    this.removeTextByDeleteKey = function() {\n\t        return a(!0)\n\t    }\n\t    ;\n\t    this.removeCurrentSelection = function() {\n\t        if (!y)\n\t            return !1;\n\t        var a = c.getCursor(b).getSelectedRange();\n\t        g.enqueue(e(a));\n\t        return !0\n\t    }\n\t    ;\n\t    this.insertText = function(a) {\n\t        if (y) {\n\t            var d = c.getCursor(b).getSelectedRange()\n\t              , h = l(c.getCursorSelection(b))\n\t              , m = []\n\t              , k = !1;\n\t            0 < h.length && (m = m.concat(e(d)),\n\t            k = !0);\n\t            d = new ops.OpInsertText;\n\t            d.init({\n\t                memberid: b,\n\t                position: h.position,\n\t                text: a,\n\t                moveCursor: !0\n\t            });\n\t            m.push(d);\n\t            f && (a = f(h.position, a.length, k)) && m.push(a);\n\t            g.enqueue(m)\n\t        }\n\t    }\n\t    ;\n\t    this.destroy = function(a) {\n\t        c.unsubscribe(ops.Document.signalCursorMoved, r);\n\t        k.unsubscribe(gui.CommonConstraints.EDIT.REVIEW_MODE, p);\n\t        a()\n\t    }\n\t    ;\n\t    c.subscribe(ops.Document.signalCursorMoved, r);\n\t    k.subscribe(gui.CommonConstraints.EDIT.REVIEW_MODE, p);\n\t    p()\n\t}\n\t;\n\tgui.UndoManager = function() {}\n\t;\n\tgui.UndoManager.prototype.subscribe = function(g, k) {}\n\t;\n\tgui.UndoManager.prototype.unsubscribe = function(g, k) {}\n\t;\n\tgui.UndoManager.prototype.setDocument = function(g) {}\n\t;\n\tgui.UndoManager.prototype.setInitialState = function() {}\n\t;\n\tgui.UndoManager.prototype.initialize = function() {}\n\t;\n\tgui.UndoManager.prototype.purgeInitialState = function() {}\n\t;\n\tgui.UndoManager.prototype.setPlaybackFunction = function(g) {}\n\t;\n\tgui.UndoManager.prototype.hasUndoStates = function() {}\n\t;\n\tgui.UndoManager.prototype.hasRedoStates = function() {}\n\t;\n\tgui.UndoManager.prototype.moveForward = function(g) {}\n\t;\n\tgui.UndoManager.prototype.moveBackward = function(g) {}\n\t;\n\tgui.UndoManager.prototype.onOperationExecuted = function(g) {}\n\t;\n\tgui.UndoManager.prototype.isDocumentModified = function() {}\n\t;\n\tgui.UndoManager.prototype.setDocumentModified = function(g) {}\n\t;\n\tgui.UndoManager.signalUndoStackChanged = \"undoStackChanged\";\n\tgui.UndoManager.signalUndoStateCreated = \"undoStateCreated\";\n\tgui.UndoManager.signalUndoStateModified = \"undoStateModified\";\n\tgui.UndoManager.signalDocumentModifiedChanged = \"documentModifiedChanged\";\n\tgui.SessionControllerOptions = function() {\n\t    this.annotationsEnabled = this.directParagraphStylingEnabled = this.directTextStylingEnabled = !1\n\t}\n\t;\n\t(function() {\n\t    var g = core.PositionFilter.FilterResult.FILTER_ACCEPT;\n\t    gui.SessionController = function(k, d, b, f) {\n\t        function n(a, c) {\n\t            var b = J.getDOMDocument()\n\t              , d = null;\n\t            b.caretRangeFromPoint ? (b = b.caretRangeFromPoint(a, c),\n\t            d = {\n\t                container: b.startContainer,\n\t                offset: b.startOffset\n\t            }) : b.caretPositionFromPoint && (b = b.caretPositionFromPoint(a, c)) && b.offsetNode && (d = {\n\t                container: b.offsetNode,\n\t                offset: b.offset\n\t            });\n\t            return d\n\t        }\n\t        function p(a) {\n\t            var c = J.getCursor(d).getSelectedRange();\n\t            c.collapsed ? a.preventDefault() : ha.setDataFromRange(a, c) ? da.removeCurrentSelection() : runtime.log(\"Cut operation failed\")\n\t        }\n\t        function r() {\n\t            return !1 !== J.getCursor(d).getSelectedRange().collapsed\n\t        }\n\t        function q(a) {\n\t            var c = J.getCursor(d).getSelectedRange();\n\t            c.collapsed ? a.preventDefault() : ha.setDataFromRange(a, c) || runtime.log(\"Copy operation failed\")\n\t        }\n\t        function e(a) {\n\t            var c;\n\t            W.clipboardData && W.clipboardData.getData ? c = W.clipboardData.getData(\"Text\") : a.clipboardData && a.clipboardData.getData && (c = a.clipboardData.getData(\"text/plain\"));\n\t            c && (da.removeCurrentSelection(),\n\t            ea.paste(c));\n\t            a.preventDefault ? a.preventDefault() : a.returnValue = !1\n\t        }\n\t        function l() {\n\t            return !1\n\t        }\n\t        function a(a) {\n\t            if (Q)\n\t                Q.onOperationExecuted(a)\n\t        }\n\t        function c(a) {\n\t            J.emit(ops.OdtDocument.signalUndoStackChanged, a)\n\t        }\n\t        function m() {\n\t            var a;\n\t            return Q ? (a = F.hasFocus(),\n\t            Q.moveBackward(1),\n\t            a && F.focus(),\n\t            !0) : !1\n\t        }\n\t        function h() {\n\t            var a;\n\t            return Q ? (a = F.hasFocus(),\n\t            Q.moveForward(1),\n\t            a && F.focus(),\n\t            !0) : !1\n\t        }\n\t        function y(a) {\n\t            var c = J.getCursor(d).getSelectedRange()\n\t              , e = (a.target || a.srcElement || null).getAttribute(\"end\");\n\t            c && e && (a = n(a.clientX, a.clientY)) && (ia.setUnfilteredPosition(a.container, a.offset),\n\t            Y.acceptPosition(ia) === g && (c = c.cloneRange(),\n\t            \"left\" === e ? c.setStart(ia.container(), ia.unfilteredDomOffset()) : c.setEnd(ia.container(), ia.unfilteredDomOffset()),\n\t            b.setSelectedRange(c, \"right\" === e),\n\t            J.emit(ops.Document.signalCursorMoved, b)))\n\t        }\n\t        function x() {\n\t            T.selectRange(b.getSelectedRange(), b.hasForwardSelection(), 1)\n\t        }\n\t        function z() {\n\t            var a = W.getSelection()\n\t              , c = 0 < a.rangeCount && T.selectionToRange(a);\n\t            U && c && (B = !0,\n\t            la.clearSelection(),\n\t            ia.setUnfilteredPosition(a.focusNode, a.focusOffset),\n\t            Y.acceptPosition(ia) === g && (2 === oa ? T.expandToWordBoundaries(c.range) : 3 <= oa && T.expandToParagraphBoundaries(c.range),\n\t            b.setSelectedRange(c.range, c.hasForwardSelection),\n\t            J.emit(ops.Document.signalCursorMoved, b)))\n\t        }\n\t        function w(a) {\n\t            var c = a.target || a.srcElement || null\n\t              , b = J.getCursor(d);\n\t            if (U = null !== c && aa.containsNode(J.getOdfCanvas().getElement(), c))\n\t                B = !1,\n\t                c = J.getRootElement(c) || J.getRootNode(),\n\t                Y = J.createRootFilter(c),\n\t                oa = 0 === a.button ? a.detail : 0,\n\t                b && a.shiftKey ? W.getSelection().collapse(b.getAnchorNode(), 0) : (a = W.getSelection(),\n\t                c = b.getSelectedRange(),\n\t                a.extend ? b.hasForwardSelection() ? (a.collapse(c.startContainer, c.startOffset),\n\t                a.extend(c.endContainer, c.endOffset)) : (a.collapse(c.endContainer, c.endOffset),\n\t                a.extend(c.startContainer, c.startOffset)) : (a.removeAllRanges(),\n\t                a.addRange(c.cloneRange()))),\n\t                1 < oa && z()\n\t        }\n\t        function v(a) {\n\t            var c = J.getRootElement(a)\n\t              , b = J.createRootFilter(c)\n\t              , c = J.createStepIterator(a, 0, [b, J.getPositionFilter()], c);\n\t            c.setPosition(a, a.childNodes.length);\n\t            return c.roundToNextStep() ? {\n\t                container: c.container(),\n\t                offset: c.offset()\n\t            } : null\n\t        }\n\t        function u(a) {\n\t            var c;\n\t            c = (c = W.getSelection()) ? {\n\t                anchorNode: c.anchorNode,\n\t                anchorOffset: c.anchorOffset,\n\t                focusNode: c.focusNode,\n\t                focusOffset: c.focusOffset\n\t            } : null;\n\t            var b = W.getSelection().isCollapsed, d, e;\n\t            c.anchorNode || c.focusNode || !(d = n(a.clientX, a.clientY)) || (c.anchorNode = d.container,\n\t            c.anchorOffset = d.offset,\n\t            c.focusNode = c.anchorNode,\n\t            c.focusOffset = c.anchorOffset);\n\t            if (S.isImage(c.focusNode) && 0 === c.focusOffset && S.isCharacterFrame(c.focusNode.parentNode)) {\n\t                if (e = c.focusNode.parentNode,\n\t                d = e.getBoundingClientRect(),\n\t                a.clientX > d.left && (d = v(e)))\n\t                    c.focusNode = d.container,\n\t                    c.focusOffset = d.offset,\n\t                    b && (c.anchorNode = c.focusNode,\n\t                    c.anchorOffset = c.focusOffset)\n\t            } else\n\t                S.isImage(c.focusNode.firstChild) && 1 === c.focusOffset && S.isCharacterFrame(c.focusNode) && (d = v(c.focusNode)) && (c.anchorNode = c.focusNode = d.container,\n\t                c.anchorOffset = c.focusOffset = d.offset);\n\t            c.anchorNode && c.focusNode && (c = T.selectionToRange(c),\n\t            T.selectRange(c.range, c.hasForwardSelection, 0 === a.button ? a.detail : 0));\n\t            F.focus()\n\t        }\n\t        function t(a) {\n\t            var c;\n\t            if (c = n(a.clientX, a.clientY))\n\t                a = c.container,\n\t                c = c.offset,\n\t                a = {\n\t                    anchorNode: a,\n\t                    anchorOffset: c,\n\t                    focusNode: a,\n\t                    focusOffset: c\n\t                },\n\t                a = T.selectionToRange(a),\n\t                T.selectRange(a.range, a.hasForwardSelection, 2),\n\t                F.focus()\n\t        }\n\t        function A(a) {\n\t            var c = a.target || a.srcElement || null, d, e, f;\n\t            ma.processRequests();\n\t            U && (S.isImage(c) && S.isCharacterFrame(c.parentNode) && W.getSelection().isCollapsed ? (T.selectImage(c.parentNode),\n\t            F.focus()) : la.isSelectorElement(c) ? F.focus() : B ? (c = b.getSelectedRange(),\n\t            e = c.collapsed,\n\t            S.isImage(c.endContainer) && 0 === c.endOffset && S.isCharacterFrame(c.endContainer.parentNode) && (f = c.endContainer.parentNode,\n\t            f = v(f)) && (c.setEnd(f.container, f.offset),\n\t            e && c.collapse(!1)),\n\t            T.selectRange(c, b.hasForwardSelection(), 0 === a.button ? a.detail : 0),\n\t            F.focus()) : ua ? u(a) : (d = aa.cloneEvent(a),\n\t            M = runtime.setTimeout(function() {\n\t                u(d)\n\t            }, 0)),\n\t            oa = 0,\n\t            B = U = !1)\n\t        }\n\t        function I(a) {\n\t            var c = J.getCursor(d).getSelectedRange();\n\t            c.collapsed || fa.exportRangeToDataTransfer(a.dataTransfer, c)\n\t        }\n\t        function K() {\n\t            U && F.focus();\n\t            oa = 0;\n\t            B = U = !1\n\t        }\n\t        function L(a) {\n\t            A(a)\n\t        }\n\t        function E(a) {\n\t            var c = a.target || a.srcElement || null\n\t              , b = null;\n\t            \"annotationRemoveButton\" === c.className ? (runtime.assert(ja, \"Remove buttons are displayed on annotations while annotation editing is disabled in the controller.\"),\n\t            b = c.parentNode.getElementsByTagNameNS(odf.Namespaces.officens, \"annotation\").item(0),\n\t            ca.removeAnnotation(b),\n\t            F.focus()) : \"webodf-draggable\" !== c.getAttribute(\"class\") && A(a)\n\t        }\n\t        function N(a) {\n\t            (a = a.data) && (-1 === a.indexOf(\"\\n\") ? da.insertText(a) : ea.paste(a))\n\t        }\n\t        function O(a) {\n\t            return function() {\n\t                a();\n\t                return !0\n\t            }\n\t        }\n\t        function D(a) {\n\t            return function(c) {\n\t                return J.getCursor(d).getSelectionType() === ops.OdtCursor.RangeSelection ? a(c) : !0\n\t            }\n\t        }\n\t        function V(c) {\n\t            F.unsubscribe(\"keydown\", C.handleEvent);\n\t            F.unsubscribe(\"keypress\", Z.handleEvent);\n\t            F.unsubscribe(\"keyup\", ba.handleEvent);\n\t            F.unsubscribe(\"copy\", q);\n\t            F.unsubscribe(\"mousedown\", w);\n\t            F.unsubscribe(\"mousemove\", ma.trigger);\n\t            F.unsubscribe(\"mouseup\", E);\n\t            F.unsubscribe(\"contextmenu\", L);\n\t            F.unsubscribe(\"dragstart\", I);\n\t            F.unsubscribe(\"dragend\", K);\n\t            F.unsubscribe(\"click\", pa.handleClick);\n\t            F.unsubscribe(\"longpress\", t);\n\t            F.unsubscribe(\"drag\", y);\n\t            F.unsubscribe(\"dragstop\", x);\n\t            J.unsubscribe(ops.OdtDocument.signalOperationEnd, na.trigger);\n\t            J.unsubscribe(ops.Document.signalCursorAdded, ka.registerCursor);\n\t            J.unsubscribe(ops.Document.signalCursorRemoved, ka.removeCursor);\n\t            J.unsubscribe(ops.OdtDocument.signalOperationEnd, a);\n\t            c()\n\t        }\n\t        var W = runtime.getWindow(), J = k.getOdtDocument(), R = new gui.SessionConstraints, P = new gui.SessionContext(k,d), aa = core.DomUtils, S = odf.OdfUtils, fa = new gui.MimeDataExporter, ha = new gui.Clipboard(fa), C = new gui.KeyboardHandler, Z = new gui.KeyboardHandler, ba = new gui.KeyboardHandler, U = !1, ga = new odf.ObjectNameGenerator(J.getOdfCanvas().odfContainer(),d), B = !1, Y = null, M, Q = null, F = new gui.EventManager(J), ja = f.annotationsEnabled, ca = new gui.AnnotationController(k,R,d), X = new gui.DirectFormattingController(k,R,P,d,ga,f.directTextStylingEnabled,f.directParagraphStylingEnabled), da = new gui.TextController(k,R,P,d,X.createCursorStyleOp,X.createParagraphStyleOps), qa = new gui.ImageController(k,R,P,d,ga), la = new gui.ImageSelector(J.getOdfCanvas()), ia = J.createPositionIterator(J.getRootNode()), ma, na, ea = new gui.PasteController(k,R,P,d), ka = new gui.InputMethodEditor(d,F), oa = 0, pa = new gui.HyperlinkClickHandler(J.getOdfCanvas().getElement,C,ba), ta = new gui.HyperlinkController(k,R,P,d), T = new gui.SelectionController(k,d), va = new gui.MetadataController(k,d), G = gui.KeyboardHandler.Modifier, H = gui.KeyboardHandler.KeyCode, ra = -1 !== W.navigator.appVersion.toLowerCase().indexOf(\"mac\"), ua = -1 !== [\"iPad\", \"iPod\", \"iPhone\"].indexOf(W.navigator.platform), sa;\n\t        runtime.assert(null !== W, \"Expected to be run in an environment which has a global window, like a browser.\");\n\t        this.undo = m;\n\t        this.redo = h;\n\t        this.insertLocalCursor = function() {\n\t            runtime.assert(void 0 === k.getOdtDocument().getCursor(d), \"Inserting local cursor a second time.\");\n\t            var a = new ops.OpAddCursor;\n\t            a.init({\n\t                memberid: d\n\t            });\n\t            k.enqueue([a]);\n\t            F.focus()\n\t        }\n\t        ;\n\t        this.removeLocalCursor = function() {\n\t            runtime.assert(void 0 !== k.getOdtDocument().getCursor(d), \"Removing local cursor without inserting before.\");\n\t            var a = new ops.OpRemoveCursor;\n\t            a.init({\n\t                memberid: d\n\t            });\n\t            k.enqueue([a])\n\t        }\n\t        ;\n\t        this.startEditing = function() {\n\t            ka.subscribe(gui.InputMethodEditor.signalCompositionStart, da.removeCurrentSelection);\n\t            ka.subscribe(gui.InputMethodEditor.signalCompositionEnd, N);\n\t            F.subscribe(\"beforecut\", r);\n\t            F.subscribe(\"cut\", p);\n\t            F.subscribe(\"beforepaste\", l);\n\t            F.subscribe(\"paste\", e);\n\t            Q && Q.initialize();\n\t            F.setEditing(!0);\n\t            pa.setModifier(ra ? G.Meta : G.Ctrl);\n\t            C.bind(H.Backspace, G.None, O(da.removeTextByBackspaceKey), !0);\n\t            C.bind(H.Delete, G.None, da.removeTextByDeleteKey);\n\t            C.bind(H.Tab, G.None, D(function() {\n\t                da.insertText(\"\\t\");\n\t                return !0\n\t            }));\n\t            ra ? (C.bind(H.Clear, G.None, da.removeCurrentSelection),\n\t            C.bind(H.B, G.Meta, D(X.toggleBold)),\n\t            C.bind(H.I, G.Meta, D(X.toggleItalic)),\n\t            C.bind(H.U, G.Meta, D(X.toggleUnderline)),\n\t            C.bind(H.L, G.MetaShift, D(X.alignParagraphLeft)),\n\t            C.bind(H.E, G.MetaShift, D(X.alignParagraphCenter)),\n\t            C.bind(H.R, G.MetaShift, D(X.alignParagraphRight)),\n\t            C.bind(H.J, G.MetaShift, D(X.alignParagraphJustified)),\n\t            ja && C.bind(H.C, G.MetaShift, ca.addAnnotation),\n\t            C.bind(H.Z, G.Meta, m),\n\t            C.bind(H.Z, G.MetaShift, h)) : (C.bind(H.B, G.Ctrl, D(X.toggleBold)),\n\t            C.bind(H.I, G.Ctrl, D(X.toggleItalic)),\n\t            C.bind(H.U, G.Ctrl, D(X.toggleUnderline)),\n\t            C.bind(H.L, G.CtrlShift, D(X.alignParagraphLeft)),\n\t            C.bind(H.E, G.CtrlShift, D(X.alignParagraphCenter)),\n\t            C.bind(H.R, G.CtrlShift, D(X.alignParagraphRight)),\n\t            C.bind(H.J, G.CtrlShift, D(X.alignParagraphJustified)),\n\t            ja && C.bind(H.C, G.CtrlAlt, ca.addAnnotation),\n\t            C.bind(H.Z, G.Ctrl, m),\n\t            C.bind(H.Z, G.CtrlShift, h));\n\t            Z.setDefault(D(function(a) {\n\t                var c;\n\t                c = null === a.which || void 0 === a.which ? String.fromCharCode(a.keyCode) : 0 !== a.which && 0 !== a.charCode ? String.fromCharCode(a.which) : null;\n\t                return !c || a.altKey || a.ctrlKey || a.metaKey ? !1 : (da.insertText(c),\n\t                !0)\n\t            }));\n\t            Z.bind(H.Enter, G.None, D(da.enqueueParagraphSplittingOps))\n\t        }\n\t        ;\n\t        this.endEditing = function() {\n\t            ka.unsubscribe(gui.InputMethodEditor.signalCompositionStart, da.removeCurrentSelection);\n\t            ka.unsubscribe(gui.InputMethodEditor.signalCompositionEnd, N);\n\t            F.unsubscribe(\"cut\", p);\n\t            F.unsubscribe(\"beforecut\", r);\n\t            F.unsubscribe(\"paste\", e);\n\t            F.unsubscribe(\"beforepaste\", l);\n\t            F.setEditing(!1);\n\t            pa.setModifier(G.None);\n\t            C.bind(H.Backspace, G.None, function() {\n\t                return !0\n\t            }, !0);\n\t            C.unbind(H.Delete, G.None);\n\t            C.unbind(H.Tab, G.None);\n\t            ra ? (C.unbind(H.Clear, G.None),\n\t            C.unbind(H.B, G.Meta),\n\t            C.unbind(H.I, G.Meta),\n\t            C.unbind(H.U, G.Meta),\n\t            C.unbind(H.L, G.MetaShift),\n\t            C.unbind(H.E, G.MetaShift),\n\t            C.unbind(H.R, G.MetaShift),\n\t            C.unbind(H.J, G.MetaShift),\n\t            ja && C.unbind(H.C, G.MetaShift),\n\t            C.unbind(H.Z, G.Meta),\n\t            C.unbind(H.Z, G.MetaShift)) : (C.unbind(H.B, G.Ctrl),\n\t            C.unbind(H.I, G.Ctrl),\n\t            C.unbind(H.U, G.Ctrl),\n\t            C.unbind(H.L, G.CtrlShift),\n\t            C.unbind(H.E, G.CtrlShift),\n\t            C.unbind(H.R, G.CtrlShift),\n\t            C.unbind(H.J, G.CtrlShift),\n\t            ja && C.unbind(H.C, G.CtrlAlt),\n\t            C.unbind(H.Z, G.Ctrl),\n\t            C.unbind(H.Z, G.CtrlShift));\n\t            Z.setDefault(null);\n\t            Z.unbind(H.Enter, G.None)\n\t        }\n\t        ;\n\t        this.getInputMemberId = function() {\n\t            return d\n\t        }\n\t        ;\n\t        this.getSession = function() {\n\t            return k\n\t        }\n\t        ;\n\t        this.getSessionConstraints = function() {\n\t            return R\n\t        }\n\t        ;\n\t        this.setUndoManager = function(a) {\n\t            Q && Q.unsubscribe(gui.UndoManager.signalUndoStackChanged, c);\n\t            if (Q = a)\n\t                Q.setDocument(J),\n\t                Q.setPlaybackFunction(k.enqueue),\n\t                Q.subscribe(gui.UndoManager.signalUndoStackChanged, c)\n\t        }\n\t        ;\n\t        this.getUndoManager = function() {\n\t            return Q\n\t        }\n\t        ;\n\t        this.getMetadataController = function() {\n\t            return va\n\t        }\n\t        ;\n\t        this.getAnnotationController = function() {\n\t            return ca\n\t        }\n\t        ;\n\t        this.getDirectFormattingController = function() {\n\t            return X\n\t        }\n\t        ;\n\t        this.getHyperlinkClickHandler = function() {\n\t            return pa\n\t        }\n\t        ;\n\t        this.getHyperlinkController = function() {\n\t            return ta\n\t        }\n\t        ;\n\t        this.getImageController = function() {\n\t            return qa\n\t        }\n\t        ;\n\t        this.getSelectionController = function() {\n\t            return T\n\t        }\n\t        ;\n\t        this.getTextController = function() {\n\t            return da\n\t        }\n\t        ;\n\t        this.getEventManager = function() {\n\t            return F\n\t        }\n\t        ;\n\t        this.getKeyboardHandlers = function() {\n\t            return {\n\t                keydown: C,\n\t                keypress: Z\n\t            }\n\t        }\n\t        ;\n\t        this.destroy = function(a) {\n\t            var c = [ma.destroy, na.destroy, X.destroy, ka.destroy, F.destroy, pa.destroy, ta.destroy, va.destroy, T.destroy, da.destroy, V];\n\t            sa && c.unshift(sa.destroy);\n\t            runtime.clearTimeout(M);\n\t            core.Async.destroyAll(c, a)\n\t        }\n\t        ;\n\t        ma = core.Task.createRedrawTask(z);\n\t        na = core.Task.createRedrawTask(function() {\n\t            var a = J.getCursor(d);\n\t            if (a && a.getSelectionType() === ops.OdtCursor.RegionSelection && (a = S.getImageElements(a.getSelectedRange())[0])) {\n\t                la.select(a.parentNode);\n\t                return\n\t            }\n\t            la.clearSelection()\n\t        });\n\t        C.bind(H.Left, G.None, D(T.moveCursorToLeft));\n\t        C.bind(H.Right, G.None, D(T.moveCursorToRight));\n\t        C.bind(H.Up, G.None, D(T.moveCursorUp));\n\t        C.bind(H.Down, G.None, D(T.moveCursorDown));\n\t        C.bind(H.Left, G.Shift, D(T.extendSelectionToLeft));\n\t        C.bind(H.Right, G.Shift, D(T.extendSelectionToRight));\n\t        C.bind(H.Up, G.Shift, D(T.extendSelectionUp));\n\t        C.bind(H.Down, G.Shift, D(T.extendSelectionDown));\n\t        C.bind(H.Home, G.None, D(T.moveCursorToLineStart));\n\t        C.bind(H.End, G.None, D(T.moveCursorToLineEnd));\n\t        C.bind(H.Home, G.Ctrl, D(T.moveCursorToDocumentStart));\n\t        C.bind(H.End, G.Ctrl, D(T.moveCursorToDocumentEnd));\n\t        C.bind(H.Home, G.Shift, D(T.extendSelectionToLineStart));\n\t        C.bind(H.End, G.Shift, D(T.extendSelectionToLineEnd));\n\t        C.bind(H.Up, G.CtrlShift, D(T.extendSelectionToParagraphStart));\n\t        C.bind(H.Down, G.CtrlShift, D(T.extendSelectionToParagraphEnd));\n\t        C.bind(H.Home, G.CtrlShift, D(T.extendSelectionToDocumentStart));\n\t        C.bind(H.End, G.CtrlShift, D(T.extendSelectionToDocumentEnd));\n\t        ra ? (C.bind(H.Left, G.Alt, D(T.moveCursorBeforeWord)),\n\t        C.bind(H.Right, G.Alt, D(T.moveCursorPastWord)),\n\t        C.bind(H.Left, G.Meta, D(T.moveCursorToLineStart)),\n\t        C.bind(H.Right, G.Meta, D(T.moveCursorToLineEnd)),\n\t        C.bind(H.Home, G.Meta, D(T.moveCursorToDocumentStart)),\n\t        C.bind(H.End, G.Meta, D(T.moveCursorToDocumentEnd)),\n\t        C.bind(H.Left, G.AltShift, D(T.extendSelectionBeforeWord)),\n\t        C.bind(H.Right, G.AltShift, D(T.extendSelectionPastWord)),\n\t        C.bind(H.Left, G.MetaShift, D(T.extendSelectionToLineStart)),\n\t        C.bind(H.Right, G.MetaShift, D(T.extendSelectionToLineEnd)),\n\t        C.bind(H.Up, G.AltShift, D(T.extendSelectionToParagraphStart)),\n\t        C.bind(H.Down, G.AltShift, D(T.extendSelectionToParagraphEnd)),\n\t        C.bind(H.Up, G.MetaShift, D(T.extendSelectionToDocumentStart)),\n\t        C.bind(H.Down, G.MetaShift, D(T.extendSelectionToDocumentEnd)),\n\t        C.bind(H.A, G.Meta, D(T.extendSelectionToEntireDocument))) : (C.bind(H.Left, G.Ctrl, D(T.moveCursorBeforeWord)),\n\t        C.bind(H.Right, G.Ctrl, D(T.moveCursorPastWord)),\n\t        C.bind(H.Left, G.CtrlShift, D(T.extendSelectionBeforeWord)),\n\t        C.bind(H.Right, G.CtrlShift, D(T.extendSelectionPastWord)),\n\t        C.bind(H.A, G.Ctrl, D(T.extendSelectionToEntireDocument)));\n\t        ua && (sa = new gui.IOSSafariSupport(F));\n\t        F.subscribe(\"keydown\", C.handleEvent);\n\t        F.subscribe(\"keypress\", Z.handleEvent);\n\t        F.subscribe(\"keyup\", ba.handleEvent);\n\t        F.subscribe(\"copy\", q);\n\t        F.subscribe(\"mousedown\", w);\n\t        F.subscribe(\"mousemove\", ma.trigger);\n\t        F.subscribe(\"mouseup\", E);\n\t        F.subscribe(\"contextmenu\", L);\n\t        F.subscribe(\"dragstart\", I);\n\t        F.subscribe(\"dragend\", K);\n\t        F.subscribe(\"click\", pa.handleClick);\n\t        F.subscribe(\"longpress\", t);\n\t        F.subscribe(\"drag\", y);\n\t        F.subscribe(\"dragstop\", x);\n\t        J.subscribe(ops.OdtDocument.signalOperationEnd, na.trigger);\n\t        J.subscribe(ops.Document.signalCursorAdded, ka.registerCursor);\n\t        J.subscribe(ops.Document.signalCursorRemoved, ka.removeCursor);\n\t        J.subscribe(ops.OdtDocument.signalOperationEnd, a)\n\t    }\n\t}\n\t)();\n\tgui.CaretManager = function(g, k) {\n\t    function d(b) {\n\t        return n.hasOwnProperty(b) ? n[b] : null\n\t    }\n\t    function b() {\n\t        return Object.keys(n).map(function(b) {\n\t            return n[b]\n\t        })\n\t    }\n\t    function f(b) {\n\t        var d = n[b];\n\t        d && (delete n[b],\n\t        b === g.getInputMemberId() ? (r.unsubscribe(ops.OdtDocument.signalProcessingBatchEnd, d.ensureVisible),\n\t        r.unsubscribe(ops.Document.signalCursorMoved, d.refreshCursorBlinking),\n\t        q.unsubscribe(\"compositionupdate\", d.handleUpdate),\n\t        q.unsubscribe(\"compositionend\", d.handleUpdate),\n\t        q.unsubscribe(\"focus\", d.setFocus),\n\t        q.unsubscribe(\"blur\", d.removeFocus),\n\t        p.removeEventListener(\"focus\", d.show, !1),\n\t        p.removeEventListener(\"blur\", d.hide, !1)) : r.unsubscribe(ops.OdtDocument.signalProcessingBatchEnd, d.handleUpdate),\n\t        d.destroy(function() {}))\n\t    }\n\t    var n = {}\n\t      , p = runtime.getWindow()\n\t      , r = g.getSession().getOdtDocument()\n\t      , q = g.getEventManager();\n\t    this.registerCursor = function(b, d, a) {\n\t        var c = b.getMemberId();\n\t        b = new gui.Caret(b,k,d,a);\n\t        n[c] = b;\n\t        c === g.getInputMemberId() ? (runtime.log(\"Starting to track input on new cursor of \" + c),\n\t        r.subscribe(ops.OdtDocument.signalProcessingBatchEnd, b.ensureVisible),\n\t        r.subscribe(ops.Document.signalCursorMoved, b.refreshCursorBlinking),\n\t        q.subscribe(\"compositionupdate\", b.handleUpdate),\n\t        q.subscribe(\"compositionend\", b.handleUpdate),\n\t        q.subscribe(\"focus\", b.setFocus),\n\t        q.subscribe(\"blur\", b.removeFocus),\n\t        p.addEventListener(\"focus\", b.show, !1),\n\t        p.addEventListener(\"blur\", b.hide, !1),\n\t        b.setOverlayElement(q.getEventTrap())) : r.subscribe(ops.OdtDocument.signalProcessingBatchEnd, b.handleUpdate);\n\t        return b\n\t    }\n\t    ;\n\t    this.getCaret = d;\n\t    this.getCarets = b;\n\t    this.destroy = function(d) {\n\t        var l = b().map(function(a) {\n\t            return a.destroy\n\t        });\n\t        g.getSelectionController().setCaretXPositionLocator(null);\n\t        r.unsubscribe(ops.Document.signalCursorRemoved, f);\n\t        n = {};\n\t        core.Async.destroyAll(l, d)\n\t    }\n\t    ;\n\t    g.getSelectionController().setCaretXPositionLocator(function() {\n\t        var b = d(g.getInputMemberId()), f;\n\t        b && (f = b.getBoundingClientRect());\n\t        return f ? f.right : void 0\n\t    });\n\t    r.subscribe(ops.Document.signalCursorRemoved, f)\n\t}\n\t;\n\tgui.EditInfoHandle = function(g) {\n\t    var k = [], d, b = g.ownerDocument, f = b.documentElement.namespaceURI;\n\t    this.setEdits = function(g) {\n\t        k = g;\n\t        var p, r, q, e;\n\t        core.DomUtils.removeAllChildNodes(d);\n\t        for (g = 0; g < k.length; g += 1)\n\t            p = b.createElementNS(f, \"div\"),\n\t            p.className = \"editInfo\",\n\t            r = b.createElementNS(f, \"span\"),\n\t            r.className = \"editInfoColor\",\n\t            r.setAttributeNS(\"urn:webodf:names:editinfo\", \"editinfo:memberid\", k[g].memberid),\n\t            q = b.createElementNS(f, \"span\"),\n\t            q.className = \"editInfoAuthor\",\n\t            q.setAttributeNS(\"urn:webodf:names:editinfo\", \"editinfo:memberid\", k[g].memberid),\n\t            e = b.createElementNS(f, \"span\"),\n\t            e.className = \"editInfoTime\",\n\t            e.setAttributeNS(\"urn:webodf:names:editinfo\", \"editinfo:memberid\", k[g].memberid),\n\t            e.appendChild(b.createTextNode(k[g].time.toString())),\n\t            p.appendChild(r),\n\t            p.appendChild(q),\n\t            p.appendChild(e),\n\t            d.appendChild(p)\n\t    }\n\t    ;\n\t    this.show = function() {\n\t        d.style.display = \"block\"\n\t    }\n\t    ;\n\t    this.hide = function() {\n\t        d.style.display = \"none\"\n\t    }\n\t    ;\n\t    this.destroy = function(b) {\n\t        g.removeChild(d);\n\t        b()\n\t    }\n\t    ;\n\t    d = b.createElementNS(f, \"div\");\n\t    d.setAttribute(\"class\", \"editInfoHandle\");\n\t    d.style.display = \"none\";\n\t    g.appendChild(d)\n\t}\n\t;\n\tops.EditInfo = function(g, k) {\n\t    function d() {\n\t        var b = [], d;\n\t        for (d in f)\n\t            f.hasOwnProperty(d) && b.push({\n\t                memberid: d,\n\t                time: f[d].time\n\t            });\n\t        b.sort(function(b, d) {\n\t            return b.time - d.time\n\t        });\n\t        return b\n\t    }\n\t    var b, f = {};\n\t    this.getNode = function() {\n\t        return b\n\t    }\n\t    ;\n\t    this.getOdtDocument = function() {\n\t        return k\n\t    }\n\t    ;\n\t    this.getEdits = function() {\n\t        return f\n\t    }\n\t    ;\n\t    this.getSortedEdits = function() {\n\t        return d()\n\t    }\n\t    ;\n\t    this.addEdit = function(b, d) {\n\t        f[b] = {\n\t            time: d\n\t        }\n\t    }\n\t    ;\n\t    this.clearEdits = function() {\n\t        f = {}\n\t    }\n\t    ;\n\t    this.destroy = function(d) {\n\t        g.parentNode && g.removeChild(b);\n\t        d()\n\t    }\n\t    ;\n\t    b = k.getDOMDocument().createElementNS(\"urn:webodf:names:editinfo\", \"editinfo\");\n\t    g.insertBefore(b, g.firstChild)\n\t}\n\t;\n\tgui.EditInfoMarker = function(g, k) {\n\t    function d(b, a) {\n\t        return runtime.setTimeout(function() {\n\t            p.style.opacity = b\n\t        }, a)\n\t    }\n\t    var b = this, f, n, p, r, q, e;\n\t    this.addEdit = function(b, a) {\n\t        var c = Date.now() - a;\n\t        g.addEdit(b, a);\n\t        n.setEdits(g.getSortedEdits());\n\t        p.setAttributeNS(\"urn:webodf:names:editinfo\", \"editinfo:memberid\", b);\n\t        runtime.clearTimeout(q);\n\t        runtime.clearTimeout(e);\n\t        1E4 > c ? (r = d(1, 0),\n\t        q = d(.5, 1E4 - c),\n\t        e = d(.2, 2E4 - c)) : 1E4 <= c && 2E4 > c ? (r = d(.5, 0),\n\t        e = d(.2, 2E4 - c)) : r = d(.2, 0)\n\t    }\n\t    ;\n\t    this.getEdits = function() {\n\t        return g.getEdits()\n\t    }\n\t    ;\n\t    this.clearEdits = function() {\n\t        g.clearEdits();\n\t        n.setEdits([]);\n\t        p.hasAttributeNS(\"urn:webodf:names:editinfo\", \"editinfo:memberid\") && p.removeAttributeNS(\"urn:webodf:names:editinfo\", \"editinfo:memberid\")\n\t    }\n\t    ;\n\t    this.getEditInfo = function() {\n\t        return g\n\t    }\n\t    ;\n\t    this.show = function() {\n\t        p.style.display = \"block\"\n\t    }\n\t    ;\n\t    this.hide = function() {\n\t        b.hideHandle();\n\t        p.style.display = \"none\"\n\t    }\n\t    ;\n\t    this.showHandle = function() {\n\t        n.show()\n\t    }\n\t    ;\n\t    this.hideHandle = function() {\n\t        n.hide()\n\t    }\n\t    ;\n\t    this.destroy = function(b) {\n\t        runtime.clearTimeout(r);\n\t        runtime.clearTimeout(q);\n\t        runtime.clearTimeout(e);\n\t        f.removeChild(p);\n\t        n.destroy(function(a) {\n\t            a ? b(a) : g.destroy(b)\n\t        })\n\t    }\n\t    ;\n\t    (function() {\n\t        var d = g.getOdtDocument().getDOMDocument();\n\t        p = d.createElementNS(d.documentElement.namespaceURI, \"div\");\n\t        p.setAttribute(\"class\", \"editInfoMarker\");\n\t        p.onmouseover = function() {\n\t            b.showHandle()\n\t        }\n\t        ;\n\t        p.onmouseout = function() {\n\t            b.hideHandle()\n\t        }\n\t        ;\n\t        f = g.getNode();\n\t        f.appendChild(p);\n\t        n = new gui.EditInfoHandle(f);\n\t        k || b.hide()\n\t    }\n\t    )()\n\t}\n\t;\n\tgui.HyperlinkTooltipView = function(g, k) {\n\t    var d = core.DomUtils, b = odf.OdfUtils, f = runtime.getWindow(), n, p, r;\n\t    runtime.assert(null !== f, \"Expected to be run in an environment which has a global window, like a browser.\");\n\t    this.showTooltip = function(q) {\n\t        var e = q.target || q.srcElement, l = g.getSizer(), a = g.getZoomLevel(), c;\n\t        a: {\n\t            for (; e; ) {\n\t                if (b.isHyperlink(e))\n\t                    break a;\n\t                if (b.isParagraph(e) || b.isInlineRoot(e))\n\t                    break;\n\t                e = e.parentNode\n\t            }\n\t            e = null\n\t        }\n\t        if (e) {\n\t            d.containsNode(l, r) || l.appendChild(r);\n\t            c = p;\n\t            var m;\n\t            switch (k()) {\n\t            case gui.KeyboardHandler.Modifier.Ctrl:\n\t                m = runtime.tr(\"Ctrl-click to follow link\");\n\t                break;\n\t            case gui.KeyboardHandler.Modifier.Meta:\n\t                m = runtime.tr(\"\\u2318-click to follow link\");\n\t                break;\n\t            default:\n\t                m = \"\"\n\t            }\n\t            c.textContent = m;\n\t            n.textContent = b.getHyperlinkTarget(e);\n\t            r.style.display = \"block\";\n\t            c = f.innerWidth - r.offsetWidth - 15;\n\t            e = q.clientX > c ? c : q.clientX + 15;\n\t            c = f.innerHeight - r.offsetHeight - 10;\n\t            q = q.clientY > c ? c : q.clientY + 10;\n\t            l = l.getBoundingClientRect();\n\t            e = (e - l.left) / a;\n\t            q = (q - l.top) / a;\n\t            r.style.left = e + \"px\";\n\t            r.style.top = q + \"px\"\n\t        }\n\t    }\n\t    ;\n\t    this.hideTooltip = function() {\n\t        r.style.display = \"none\"\n\t    }\n\t    ;\n\t    this.destroy = function(b) {\n\t        r.parentNode && r.parentNode.removeChild(r);\n\t        b()\n\t    }\n\t    ;\n\t    (function() {\n\t        var b = g.getElement().ownerDocument;\n\t        n = b.createElement(\"span\");\n\t        p = b.createElement(\"span\");\n\t        n.className = \"webodf-hyperlinkTooltipLink\";\n\t        p.className = \"webodf-hyperlinkTooltipText\";\n\t        r = b.createElement(\"div\");\n\t        r.className = \"webodf-hyperlinkTooltip\";\n\t        r.appendChild(n);\n\t        r.appendChild(p);\n\t        g.getElement().appendChild(r)\n\t    }\n\t    )()\n\t}\n\t;\n\tgui.OdfFieldView = function(g) {\n\t    function k() {\n\t        var b = odf.OdfSchema.getFields().map(function(b) {\n\t            return b.replace(\":\", \"|\")\n\t        })\n\t          , d = b.join(\",\\n\") + \"\\n{ background-color: #D0D0D0; }\\n\"\n\t          , b = b.map(function(b) {\n\t            return b + \":empty::after\"\n\t        }).join(\",\\n\") + \"\\n{ content:' '; white-space: pre; }\\n\";\n\t        return d + \"\\n\" + b\n\t    }\n\t    var d, b = g.getElement().ownerDocument;\n\t    this.showFieldHighlight = function() {\n\t        d.appendChild(b.createTextNode(k()))\n\t    }\n\t    ;\n\t    this.hideFieldHighlight = function() {\n\t        for (var b = d.sheet, g = b.cssRules; g.length; )\n\t            b.deleteRule(g.length - 1)\n\t    }\n\t    ;\n\t    this.destroy = function(b) {\n\t        d.parentNode && d.parentNode.removeChild(d);\n\t        b()\n\t    }\n\t    ;\n\t    d = function() {\n\t        var d = b.getElementsByTagName(\"head\").item(0)\n\t          , g = b.createElement(\"style\")\n\t          , k = \"\";\n\t        g.type = \"text/css\";\n\t        g.media = \"screen, print, handheld, projection\";\n\t        odf.Namespaces.forEachPrefix(function(b, d) {\n\t            k += \"@namespace \" + b + \" url(\" + d + \");\\n\"\n\t        });\n\t        g.appendChild(b.createTextNode(k));\n\t        d.appendChild(g);\n\t        return g\n\t    }()\n\t}\n\t;\n\tgui.ShadowCursor = function(g) {\n\t    var k = g.getDOMDocument().createRange()\n\t      , d = !0;\n\t    this.removeFromDocument = function() {}\n\t    ;\n\t    this.getMemberId = function() {\n\t        return gui.ShadowCursor.ShadowCursorMemberId\n\t    }\n\t    ;\n\t    this.getSelectedRange = function() {\n\t        return k\n\t    }\n\t    ;\n\t    this.setSelectedRange = function(b, f) {\n\t        k = b;\n\t        d = !1 !== f\n\t    }\n\t    ;\n\t    this.hasForwardSelection = function() {\n\t        return d\n\t    }\n\t    ;\n\t    this.getDocument = function() {\n\t        return g\n\t    }\n\t    ;\n\t    this.getSelectionType = function() {\n\t        return ops.OdtCursor.RangeSelection\n\t    }\n\t    ;\n\t    k.setStart(g.getRootNode(), 0)\n\t}\n\t;\n\tgui.ShadowCursor.ShadowCursorMemberId = \"\";\n\tgui.SelectionView = function(g) {}\n\t;\n\tgui.SelectionView.prototype.rerender = function() {}\n\t;\n\tgui.SelectionView.prototype.show = function() {}\n\t;\n\tgui.SelectionView.prototype.hide = function() {}\n\t;\n\tgui.SelectionView.prototype.destroy = function(g) {}\n\t;\n\tgui.SelectionViewManager = function(g) {\n\t    function k() {\n\t        return Object.keys(d).map(function(b) {\n\t            return d[b]\n\t        })\n\t    }\n\t    var d = {};\n\t    this.getSelectionView = function(b) {\n\t        return d.hasOwnProperty(b) ? d[b] : null\n\t    }\n\t    ;\n\t    this.getSelectionViews = k;\n\t    this.removeSelectionView = function(b) {\n\t        d.hasOwnProperty(b) && (d[b].destroy(function() {}),\n\t        delete d[b])\n\t    }\n\t    ;\n\t    this.hideSelectionView = function(b) {\n\t        d.hasOwnProperty(b) && d[b].hide()\n\t    }\n\t    ;\n\t    this.showSelectionView = function(b) {\n\t        d.hasOwnProperty(b) && d[b].show()\n\t    }\n\t    ;\n\t    this.rerenderSelectionViews = function() {\n\t        Object.keys(d).forEach(function(b) {\n\t            d[b].rerender()\n\t        })\n\t    }\n\t    ;\n\t    this.registerCursor = function(b, f) {\n\t        var k = b.getMemberId()\n\t          , p = new g(b);\n\t        f ? p.show() : p.hide();\n\t        return d[k] = p\n\t    }\n\t    ;\n\t    this.destroy = function(b) {\n\t        function d(k, r) {\n\t            r ? b(r) : k < g.length ? g[k].destroy(function(b) {\n\t                d(k + 1, b)\n\t            }) : b()\n\t        }\n\t        var g = k();\n\t        d(0, void 0)\n\t    }\n\t}\n\t;\n\tgui.SessionViewOptions = function() {\n\t    this.caretBlinksOnRangeSelect = this.caretAvatarsInitiallyVisible = this.editInfoMarkersInitiallyVisible = !0\n\t}\n\t;\n\t(function() {\n\t    function g(g, d) {\n\t        return void 0 !== g ? Boolean(g) : d\n\t    }\n\t    gui.SessionView = function(k, d, b, f, n, p) {\n\t        function r(a) {\n\t            a.memberId === d && I.getViewport().scrollIntoView(a.annotation.getBoundingClientRect())\n\t        }\n\t        function q() {\n\t            var a = document.getElementsByTagName(\"head\").item(0)\n\t              , c = document.createElement(\"style\");\n\t            c.type = \"text/css\";\n\t            c.media = \"screen, print, handheld, projection\";\n\t            a.appendChild(c);\n\t            return c\n\t        }\n\t        function e(a, c, b) {\n\t            function e(c, b, d) {\n\t                b = c + '[editinfo|memberid=\"' + a + '\"]' + d + b;\n\t                a: {\n\t                    var f = v.firstChild;\n\t                    for (c = c + '[editinfo|memberid=\"' + a + '\"]' + d + \"{\"; f; ) {\n\t                        if (f.nodeType === Node.TEXT_NODE && 0 === f.data.indexOf(c)) {\n\t                            c = f;\n\t                            break a\n\t                        }\n\t                        f = f.nextSibling\n\t                    }\n\t                    c = null\n\t                }\n\t                c ? c.data = b : v.appendChild(document.createTextNode(b))\n\t            }\n\t            e(\"div.editInfoMarker\", \"{ background-color: \" + b + \"; }\", \"\");\n\t            e(\"span.editInfoColor\", \"{ background-color: \" + b + \"; }\", \"\");\n\t            e(\"span.editInfoAuthor\", '{ content: \"' + c + '\"; }', \":before\");\n\t            e(\"dc|creator\", \"{ background-color: \" + b + \"; }\", \"\");\n\t            e(\".webodf-selectionOverlay\", \"{ fill: \" + b + \"; stroke: \" + b + \";}\", \"\");\n\t            a === d && (e(\".webodf-touchEnabled .webodf-selectionOverlay\", \"{ display: block; }\", \" > .webodf-draggable\"),\n\t            a = gui.ShadowCursor.ShadowCursorMemberId,\n\t            e(\".webodf-selectionOverlay\", \"{ fill: \" + b + \"; stroke: \" + b + \";}\", \"\"),\n\t            e(\".webodf-touchEnabled .webodf-selectionOverlay\", \"{ display: block; }\", \" > .webodf-draggable\"))\n\t        }\n\t        function l(a) {\n\t            var c, b;\n\t            for (b in t)\n\t                t.hasOwnProperty(b) && (c = t[b],\n\t                a ? c.show() : c.hide())\n\t        }\n\t        function a(a) {\n\t            n.getCarets().forEach(function(c) {\n\t                a ? c.showHandle() : c.hideHandle()\n\t            })\n\t        }\n\t        function c(a) {\n\t            var c = a.getMemberId();\n\t            a = a.getProperties();\n\t            e(c, a.fullName, a.color)\n\t        }\n\t        function m(a) {\n\t            var c = a.getMemberId()\n\t              , d = b.getOdtDocument().getMember(c).getProperties();\n\t            n.registerCursor(a, E, N);\n\t            p.registerCursor(a, !0);\n\t            if (a = n.getCaret(c))\n\t                a.setAvatarImageUrl(d.imageUrl),\n\t                a.setColor(d.color);\n\t            runtime.log(\"+++ View here +++ eagerly created an Caret for '\" + c + \"'! +++\")\n\t        }\n\t        function h(a) {\n\t            a = a.getMemberId();\n\t            var c = p.getSelectionView(d)\n\t              , b = p.getSelectionView(gui.ShadowCursor.ShadowCursorMemberId)\n\t              , e = n.getCaret(d);\n\t            a === d ? (b.hide(),\n\t            c && c.show(),\n\t            e && e.show()) : a === gui.ShadowCursor.ShadowCursorMemberId && (b.show(),\n\t            c && c.hide(),\n\t            e && e.hide())\n\t        }\n\t        function y(a) {\n\t            p.removeSelectionView(a)\n\t        }\n\t        function x(a) {\n\t            var c = a.paragraphElement\n\t              , d = a.memberId;\n\t            a = a.timeStamp;\n\t            var e, f = \"\", h = c.getElementsByTagNameNS(\"urn:webodf:names:editinfo\", \"editinfo\").item(0);\n\t            h ? (f = h.getAttributeNS(\"urn:webodf:names:editinfo\", \"id\"),\n\t            e = t[f]) : (f = Math.random().toString(),\n\t            e = new ops.EditInfo(c,b.getOdtDocument()),\n\t            e = new gui.EditInfoMarker(e,L),\n\t            h = c.getElementsByTagNameNS(\"urn:webodf:names:editinfo\", \"editinfo\").item(0),\n\t            h.setAttributeNS(\"urn:webodf:names:editinfo\", \"id\", f),\n\t            t[f] = e);\n\t            e.addEdit(d, new Date(a));\n\t            K.trigger()\n\t        }\n\t        function z() {\n\t            var a;\n\t            u.hasChildNodes() && core.DomUtils.removeAllChildNodes(u);\n\t            !0 === f.getState(gui.CommonConstraints.EDIT.ANNOTATIONS.ONLY_DELETE_OWN) && (a = b.getOdtDocument().getMember(d)) && (a = a.getProperties().fullName,\n\t            u.appendChild(document.createTextNode(\".annotationWrapper:not([creator = '\" + a + \"']) .annotationRemoveButton { display: none; }\")))\n\t        }\n\t        function w(a) {\n\t            var b = Object.keys(t).map(function(a) {\n\t                return t[a]\n\t            });\n\t            A.unsubscribe(ops.Document.signalMemberAdded, c);\n\t            A.unsubscribe(ops.Document.signalMemberUpdated, c);\n\t            A.unsubscribe(ops.Document.signalCursorAdded, m);\n\t            A.unsubscribe(ops.Document.signalCursorRemoved, y);\n\t            A.unsubscribe(ops.OdtDocument.signalParagraphChanged, x);\n\t            A.unsubscribe(ops.Document.signalCursorMoved, h);\n\t            A.unsubscribe(ops.OdtDocument.signalParagraphChanged, p.rerenderSelectionViews);\n\t            A.unsubscribe(ops.OdtDocument.signalTableAdded, p.rerenderSelectionViews);\n\t            A.unsubscribe(ops.OdtDocument.signalParagraphStyleModified, p.rerenderSelectionViews);\n\t            f.unsubscribe(gui.CommonConstraints.EDIT.ANNOTATIONS.ONLY_DELETE_OWN, z);\n\t            A.unsubscribe(ops.Document.signalMemberAdded, z);\n\t            A.unsubscribe(ops.Document.signalMemberUpdated, z);\n\t            v.parentNode.removeChild(v);\n\t            u.parentNode.removeChild(u);\n\t            (function W(c, d) {\n\t                d ? a(d) : c < b.length ? b[c].destroy(function(a) {\n\t                    W(c + 1, a)\n\t                }) : a()\n\t            }\n\t            )(0, void 0)\n\t        }\n\t        var v, u, t = {}, A, I, K, L = g(k.editInfoMarkersInitiallyVisible, !0), E = g(k.caretAvatarsInitiallyVisible, !0), N = g(k.caretBlinksOnRangeSelect, !0);\n\t        this.showEditInfoMarkers = function() {\n\t            L || (L = !0,\n\t            l(L))\n\t        }\n\t        ;\n\t        this.hideEditInfoMarkers = function() {\n\t            L && (L = !1,\n\t            l(L))\n\t        }\n\t        ;\n\t        this.showCaretAvatars = function() {\n\t            E || (E = !0,\n\t            a(E))\n\t        }\n\t        ;\n\t        this.hideCaretAvatars = function() {\n\t            E && (E = !1,\n\t            a(E))\n\t        }\n\t        ;\n\t        this.getSession = function() {\n\t            return b\n\t        }\n\t        ;\n\t        this.getCaret = function(a) {\n\t            return n.getCaret(a)\n\t        }\n\t        ;\n\t        this.destroy = function(a) {\n\t            var c = [K.destroy, w];\n\t            A.unsubscribe(ops.OdtDocument.signalAnnotationAdded, r);\n\t            core.Async.destroyAll(c, a)\n\t        }\n\t        ;\n\t        A = b.getOdtDocument();\n\t        I = A.getOdfCanvas();\n\t        A.subscribe(ops.OdtDocument.signalAnnotationAdded, r);\n\t        A.subscribe(ops.Document.signalMemberAdded, c);\n\t        A.subscribe(ops.Document.signalMemberUpdated, c);\n\t        A.subscribe(ops.Document.signalCursorAdded, m);\n\t        A.subscribe(ops.Document.signalCursorRemoved, y);\n\t        A.subscribe(ops.OdtDocument.signalParagraphChanged, x);\n\t        A.subscribe(ops.Document.signalCursorMoved, h);\n\t        A.subscribe(ops.OdtDocument.signalParagraphChanged, p.rerenderSelectionViews);\n\t        A.subscribe(ops.OdtDocument.signalTableAdded, p.rerenderSelectionViews);\n\t        A.subscribe(ops.OdtDocument.signalParagraphStyleModified, p.rerenderSelectionViews);\n\t        f.subscribe(gui.CommonConstraints.EDIT.ANNOTATIONS.ONLY_DELETE_OWN, z);\n\t        A.subscribe(ops.Document.signalMemberAdded, z);\n\t        A.subscribe(ops.Document.signalMemberUpdated, z);\n\t        v = q();\n\t        v.appendChild(document.createTextNode(\"@namespace editinfo url(urn:webodf:names:editinfo);\"));\n\t        v.appendChild(document.createTextNode(\"@namespace dc url(http://purl.org/dc/elements/1.1/);\"));\n\t        u = q();\n\t        z();\n\t        K = core.Task.createRedrawTask(function() {\n\t            var a = I.getAnnotationViewManager();\n\t            a && (a.rehighlightAnnotations(),\n\t            A.fixCursorPositions())\n\t        })\n\t    }\n\t}\n\t)();\n\tgui.SvgSelectionView = function(g) {\n\t    function k() {\n\t        var a = c.getRootNode();\n\t        m !== a && (m = a,\n\t        h = c.getCanvas().getSizer(),\n\t        h.appendChild(x),\n\t        x.setAttribute(\"class\", \"webodf-selectionOverlay\"),\n\t        w.setAttribute(\"class\", \"webodf-draggable\"),\n\t        v.setAttribute(\"class\", \"webodf-draggable\"),\n\t        w.setAttribute(\"end\", \"left\"),\n\t        v.setAttribute(\"end\", \"right\"),\n\t        w.setAttribute(\"r\", 8),\n\t        v.setAttribute(\"r\", 8),\n\t        x.appendChild(z),\n\t        x.appendChild(w),\n\t        x.appendChild(v))\n\t    }\n\t    function d(a) {\n\t        a = a.getBoundingClientRect();\n\t        return Boolean(a && 0 !== a.height)\n\t    }\n\t    function b(a) {\n\t        var c = u.getTextElements(a, !0, !1)\n\t          , b = a.cloneRange()\n\t          , e = a.cloneRange();\n\t        a = a.cloneRange();\n\t        if (!c.length)\n\t            return null;\n\t        var f;\n\t        a: {\n\t            f = 0;\n\t            var h = c[f]\n\t              , g = b.startContainer === h ? b.startOffset : 0\n\t              , m = g;\n\t            b.setStart(h, g);\n\t            for (b.setEnd(h, m); !d(b); ) {\n\t                if (h.nodeType === Node.ELEMENT_NODE && m < h.childNodes.length)\n\t                    m = h.childNodes.length;\n\t                else if (h.nodeType === Node.TEXT_NODE && m < h.length)\n\t                    m += 1;\n\t                else if (c[f])\n\t                    h = c[f],\n\t                    f += 1,\n\t                    g = m = 0;\n\t                else {\n\t                    f = !1;\n\t                    break a\n\t                }\n\t                b.setStart(h, g);\n\t                b.setEnd(h, m)\n\t            }\n\t            f = !0\n\t        }\n\t        if (!f)\n\t            return null;\n\t        a: {\n\t            f = c.length - 1;\n\t            h = c[f];\n\t            m = g = e.endContainer === h ? e.endOffset : h.nodeType === Node.TEXT_NODE ? h.length : h.childNodes.length;\n\t            e.setStart(h, g);\n\t            for (e.setEnd(h, m); !d(e); ) {\n\t                if (h.nodeType === Node.ELEMENT_NODE && 0 < g)\n\t                    g = 0;\n\t                else if (h.nodeType === Node.TEXT_NODE && 0 < g)\n\t                    --g;\n\t                else if (c[f])\n\t                    h = c[f],\n\t                    --f,\n\t                    g = m = h.length || h.childNodes.length;\n\t                else {\n\t                    c = !1;\n\t                    break a\n\t                }\n\t                e.setStart(h, g);\n\t                e.setEnd(h, m)\n\t            }\n\t            c = !0\n\t        }\n\t        if (!c)\n\t            return null;\n\t        a.setStart(b.startContainer, b.startOffset);\n\t        a.setEnd(e.endContainer, e.endOffset);\n\t        return {\n\t            firstRange: b,\n\t            lastRange: e,\n\t            fillerRange: a\n\t        }\n\t    }\n\t    function f(a, c) {\n\t        var b = {};\n\t        b.top = Math.min(a.top, c.top);\n\t        b.left = Math.min(a.left, c.left);\n\t        b.right = Math.max(a.right, c.right);\n\t        b.bottom = Math.max(a.bottom, c.bottom);\n\t        b.width = b.right - b.left;\n\t        b.height = b.bottom - b.top;\n\t        return b\n\t    }\n\t    function n(a, c) {\n\t        c && 0 < c.width && 0 < c.height && (a = a ? f(a, c) : c);\n\t        return a\n\t    }\n\t    function p(a) {\n\t        function b(a) {\n\t            K.setUnfilteredPosition(a, 0);\n\t            return v.acceptNode(a) === L && x.acceptPosition(K) === L ? L : E\n\t        }\n\t        function d(a) {\n\t            var c = null;\n\t            b(a) === L && (c = t.getBoundingClientRect(a));\n\t            return c\n\t        }\n\t        var e = a.commonAncestorContainer, f = a.startContainer, h = a.endContainer, g = a.startOffset, m = a.endOffset, k, l, p = null, r, q = y.createRange(), x, v = new odf.OdfNodeFilter, w;\n\t        if (f === e || h === e)\n\t            return q = a.cloneRange(),\n\t            p = q.getBoundingClientRect(),\n\t            q.detach(),\n\t            p;\n\t        for (a = f; a.parentNode !== e; )\n\t            a = a.parentNode;\n\t        for (l = h; l.parentNode !== e; )\n\t            l = l.parentNode;\n\t        x = c.createRootFilter(f);\n\t        for (e = a.nextSibling; e && e !== l; )\n\t            r = d(e),\n\t            p = n(p, r),\n\t            e = e.nextSibling;\n\t        if (u.isParagraph(a))\n\t            p = n(p, t.getBoundingClientRect(a));\n\t        else if (a.nodeType === Node.TEXT_NODE)\n\t            e = a,\n\t            q.setStart(e, g),\n\t            q.setEnd(e, e === l ? m : e.length),\n\t            r = q.getBoundingClientRect(),\n\t            p = n(p, r);\n\t        else\n\t            for (w = y.createTreeWalker(a, NodeFilter.SHOW_TEXT, b, !1),\n\t            e = w.currentNode = f; e && e !== h; )\n\t                q.setStart(e, g),\n\t                q.setEnd(e, e.length),\n\t                r = q.getBoundingClientRect(),\n\t                p = n(p, r),\n\t                k = e,\n\t                g = 0,\n\t                e = w.nextNode();\n\t        k || (k = f);\n\t        if (u.isParagraph(l))\n\t            p = n(p, t.getBoundingClientRect(l));\n\t        else if (l.nodeType === Node.TEXT_NODE)\n\t            e = l,\n\t            q.setStart(e, e === a ? g : 0),\n\t            q.setEnd(e, m),\n\t            r = q.getBoundingClientRect(),\n\t            p = n(p, r);\n\t        else\n\t            for (w = y.createTreeWalker(l, NodeFilter.SHOW_TEXT, b, !1),\n\t            e = w.currentNode = h; e && e !== k; )\n\t                if (q.setStart(e, 0),\n\t                q.setEnd(e, m),\n\t                r = q.getBoundingClientRect(),\n\t                p = n(p, r),\n\t                e = w.previousNode())\n\t                    m = e.length;\n\t        return p\n\t    }\n\t    function r(a, c) {\n\t        var b = a.getBoundingClientRect()\n\t          , d = {\n\t            width: 0\n\t        };\n\t        d.top = b.top;\n\t        d.bottom = b.bottom;\n\t        d.height = b.height;\n\t        d.left = d.right = c ? b.right : b.left;\n\t        return d\n\t    }\n\t    function q() {\n\t        var a = g.getSelectedRange(), c;\n\t        if (c = I && g.getSelectionType() === ops.OdtCursor.RangeSelection && !a.collapsed) {\n\t            k();\n\t            var d = t.getBoundingClientRect(h), e = A.getZoomLevel(), a = b(a), m, l, n, q, y, u;\n\t            if (a) {\n\t                c = a.firstRange;\n\t                m = a.lastRange;\n\t                l = a.fillerRange;\n\t                n = t.translateRect(r(c, !1), d, e);\n\t                y = t.translateRect(r(m, !0), d, e);\n\t                q = (q = p(l)) ? t.translateRect(q, d, e) : f(n, y);\n\t                u = q.left;\n\t                q = n.left + Math.max(0, q.width - (n.left - q.left));\n\t                d = Math.min(n.top, y.top);\n\t                e = y.top + y.height;\n\t                u = [{\n\t                    x: n.left,\n\t                    y: d + n.height\n\t                }, {\n\t                    x: n.left,\n\t                    y: d\n\t                }, {\n\t                    x: q,\n\t                    y: d\n\t                }, {\n\t                    x: q,\n\t                    y: e - y.height\n\t                }, {\n\t                    x: y.right,\n\t                    y: e - y.height\n\t                }, {\n\t                    x: y.right,\n\t                    y: e\n\t                }, {\n\t                    x: u,\n\t                    y: e\n\t                }, {\n\t                    x: u,\n\t                    y: d + n.height\n\t                }, {\n\t                    x: n.left,\n\t                    y: d + n.height\n\t                }];\n\t                q = \"\";\n\t                var E;\n\t                for (E = 0; E < u.length; E += 1)\n\t                    q += u[E].x + \",\" + u[E].y + \" \";\n\t                z.setAttribute(\"points\", q);\n\t                w.setAttribute(\"cx\", n.left);\n\t                w.setAttribute(\"cy\", d + n.height / 2);\n\t                v.setAttribute(\"cx\", y.right);\n\t                v.setAttribute(\"cy\", e - y.height / 2);\n\t                c.detach();\n\t                m.detach();\n\t                l.detach()\n\t            }\n\t            c = Boolean(a)\n\t        }\n\t        x.style.display = c ? \"block\" : \"none\"\n\t    }\n\t    function e(a) {\n\t        I && a === g && N.trigger()\n\t    }\n\t    function l(a) {\n\t        a = 8 / a;\n\t        w.setAttribute(\"r\", a);\n\t        v.setAttribute(\"r\", a)\n\t    }\n\t    function a(a) {\n\t        h.removeChild(x);\n\t        h.classList.remove(\"webodf-virtualSelections\");\n\t        g.getDocument().unsubscribe(ops.Document.signalCursorMoved, e);\n\t        A.unsubscribe(gui.ZoomHelper.signalZoomChanged, l);\n\t        a()\n\t    }\n\t    var c = g.getDocument(), m, h, y = c.getDOMDocument(), x = y.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\"), z = y.createElementNS(\"http://www.w3.org/2000/svg\", \"polygon\"), w = y.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\"), v = y.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\"), u = odf.OdfUtils, t = core.DomUtils, A = c.getCanvas().getZoomHelper(), I = !0, K = g.getDocument().createPositionIterator(c.getRootNode()), L = NodeFilter.FILTER_ACCEPT, E = NodeFilter.FILTER_REJECT, N;\n\t    this.rerender = function() {\n\t        I && N.trigger()\n\t    }\n\t    ;\n\t    this.show = function() {\n\t        I = !0;\n\t        N.trigger()\n\t    }\n\t    ;\n\t    this.hide = function() {\n\t        I = !1;\n\t        N.trigger()\n\t    }\n\t    ;\n\t    this.destroy = function(c) {\n\t        core.Async.destroyAll([N.destroy, a], c)\n\t    }\n\t    ;\n\t    (function() {\n\t        var a = g.getMemberId();\n\t        N = core.Task.createRedrawTask(q);\n\t        k();\n\t        x.setAttributeNS(\"urn:webodf:names:editinfo\", \"editinfo:memberid\", a);\n\t        h.classList.add(\"webodf-virtualSelections\");\n\t        g.getDocument().subscribe(ops.Document.signalCursorMoved, e);\n\t        A.subscribe(gui.ZoomHelper.signalZoomChanged, l);\n\t        l(A.getZoomLevel())\n\t    }\n\t    )()\n\t}\n\t;\n\tgui.UndoStateRules = function() {\n\t    function g(b, d) {\n\t        var g = b.length;\n\t        this.previous = function() {\n\t            for (--g; 0 <= g; --g)\n\t                if (d(b[g]))\n\t                    return b[g];\n\t            return null\n\t        }\n\t    }\n\t    function k(b) {\n\t        b = b.spec();\n\t        var d;\n\t        b.hasOwnProperty(\"position\") && (d = b.position);\n\t        return d\n\t    }\n\t    function d(b) {\n\t        return b.isEdit\n\t    }\n\t    function b(b, d, g) {\n\t        if (!g)\n\t            return g = k(b) - k(d),\n\t            0 === g || 1 === Math.abs(g);\n\t        b = k(b);\n\t        d = k(d);\n\t        g = k(g);\n\t        return b - d === d - g\n\t    }\n\t    this.isEditOperation = d;\n\t    this.isPartOfOperationSet = function(f, k) {\n\t        var p = void 0 !== f.group, r;\n\t        if (!f.isEdit || 0 === k.length)\n\t            return !0;\n\t        r = k[k.length - 1];\n\t        if (p && f.group === r.group)\n\t            return !0;\n\t        a: switch (f.spec().optype) {\n\t        case \"RemoveText\":\n\t        case \"InsertText\":\n\t            r = !0;\n\t            break a;\n\t        default:\n\t            r = !1\n\t        }\n\t        if (r && k.some(d)) {\n\t            if (p) {\n\t                var q;\n\t                p = f.spec().optype;\n\t                r = new g(k,d);\n\t                var e = r.previous(), l = null, a, c;\n\t                runtime.assert(Boolean(e), \"No edit operations found in state\");\n\t                c = e.group;\n\t                runtime.assert(void 0 !== c, \"Operation has no group\");\n\t                for (a = 1; e && e.group === c; ) {\n\t                    if (p === e.spec().optype) {\n\t                        q = e;\n\t                        break\n\t                    }\n\t                    e = r.previous()\n\t                }\n\t                if (q) {\n\t                    for (e = r.previous(); e; ) {\n\t                        if (e.group !== c) {\n\t                            if (2 === a)\n\t                                break;\n\t                            c = e.group;\n\t                            a += 1\n\t                        }\n\t                        if (p === e.spec().optype) {\n\t                            l = e;\n\t                            break\n\t                        }\n\t                        e = r.previous()\n\t                    }\n\t                    q = b(f, q, l)\n\t                } else\n\t                    q = !1;\n\t                return q\n\t            }\n\t            q = f.spec().optype;\n\t            p = new g(k,d);\n\t            r = p.previous();\n\t            runtime.assert(Boolean(r), \"No edit operations found in state\");\n\t            q = q === r.spec().optype ? b(f, r, p.previous()) : !1;\n\t            return q\n\t        }\n\t        return !1\n\t    }\n\t}\n\t;\n\t(function() {\n\t    function g(b, d) {\n\t        this.mainId = void 0 !== b ? b : -1;\n\t        this.subId = void 0 !== d ? d : -1\n\t    }\n\t    function k(b, f, k) {\n\t        function p(d, a) {\n\t            return d + (b.isEditOperation(a) ? 1 : 0)\n\t        }\n\t        var r, q, e;\n\t        this.addOperation = function(d) {\n\t            b.isEditOperation(d) && (e += 1);\n\t            q.push(d)\n\t        }\n\t        ;\n\t        this.isNextStateId = function(b) {\n\t            return b.mainId === r && b.subId === e\n\t        }\n\t        ;\n\t        this.getNextStateId = function() {\n\t            return new g(r,e)\n\t        }\n\t        ;\n\t        this.getOperations = function() {\n\t            return q\n\t        }\n\t        ;\n\t        r = d += 1;\n\t        q = f || [];\n\t        e = f && k ? f.reduce(p, 0) : 0\n\t    }\n\t    var d = 0;\n\t    gui.TrivialUndoManager = function(b) {\n\t        function d() {\n\t            return !0 !== u.isNextStateId(v)\n\t        }\n\t        function n(a) {\n\t            a = a.getOperations();\n\t            0 < a.length && (L = !0,\n\t            z(a),\n\t            L = !1)\n\t        }\n\t        function p() {\n\t            I.emit(gui.UndoManager.signalUndoStackChanged, {\n\t                undoAvailable: m.hasUndoStates(),\n\t                redoAvailable: m.hasRedoStates()\n\t            })\n\t        }\n\t        function r(a) {\n\t            var c = d();\n\t            a !== c && I.emit(gui.UndoManager.signalDocumentModifiedChanged, c)\n\t        }\n\t        function q() {\n\t            u !== x && u !== t[t.length - 1] && t.push(u)\n\t        }\n\t        function e(a) {\n\t            var c = a.previousSibling || a.nextSibling;\n\t            a.parentNode.removeChild(a);\n\t            h.normalizeTextNodes(c)\n\t        }\n\t        function l(a) {\n\t            return Object.keys(a).map(function(c) {\n\t                return a[c]\n\t            })\n\t        }\n\t        function a(a) {\n\t            function c(a) {\n\t                var h = a.spec();\n\t                if (e[h.memberid])\n\t                    switch (h.optype) {\n\t                    case \"AddCursor\":\n\t                        b[h.memberid] || (b[h.memberid] = a,\n\t                        delete e[h.memberid],\n\t                        --f);\n\t                        break;\n\t                    case \"MoveCursor\":\n\t                        d[h.memberid] || (d[h.memberid] = a)\n\t                    }\n\t            }\n\t            var b = {}, d = {}, e = {}, f, h;\n\t            h = a.pop();\n\t            w.getMemberIds().forEach(function(a) {\n\t                e[a] = !0\n\t            });\n\t            for (f = Object.keys(e).length; h && 0 < f; )\n\t                h = h.getOperations(),\n\t                h.reverse(),\n\t                h.forEach(c),\n\t                h = a.pop();\n\t            return new k(K,l(b).concat(l(d)))\n\t        }\n\t        function c() {\n\t            var c = d()\n\t              , b = y = w.cloneDocumentElement();\n\t            h.getElementsByTagNameNS(b, \"urn:webodf:names:cursor\", \"cursor\").forEach(e);\n\t            h.getElementsByTagNameNS(b, \"urn:webodf:names:cursor\", \"anchor\").forEach(e);\n\t            q();\n\t            u = x = a([x].concat(t));\n\t            t.length = 0;\n\t            A.length = 0;\n\t            c || (v = u.getNextStateId());\n\t            p();\n\t            r(c)\n\t        }\n\t        var m = this, h = core.DomUtils, y, x, z, w, v, u, t = [], A = [], I = new core.EventNotifier([gui.UndoManager.signalUndoStackChanged, gui.UndoManager.signalUndoStateCreated, gui.UndoManager.signalUndoStateModified, gui.UndoManager.signalDocumentModifiedChanged, gui.TrivialUndoManager.signalDocumentRootReplaced]), K = b || new gui.UndoStateRules, L = !1;\n\t        this.subscribe = function(a, c) {\n\t            I.subscribe(a, c)\n\t        }\n\t        ;\n\t        this.unsubscribe = function(a, c) {\n\t            I.unsubscribe(a, c)\n\t        }\n\t        ;\n\t        this.isDocumentModified = d;\n\t        this.setDocumentModified = function(a) {\n\t            d() !== a && (v = a ? new g : u.getNextStateId(),\n\t            I.emit(gui.UndoManager.signalDocumentModifiedChanged, a))\n\t        }\n\t        ;\n\t        this.hasUndoStates = function() {\n\t            return 0 < t.length\n\t        }\n\t        ;\n\t        this.hasRedoStates = function() {\n\t            return 0 < A.length\n\t        }\n\t        ;\n\t        this.setDocument = function(a) {\n\t            w = a\n\t        }\n\t        ;\n\t        this.purgeInitialState = function() {\n\t            var a = d();\n\t            t.length = 0;\n\t            A.length = 0;\n\t            u = x = new k(K);\n\t            v = u.getNextStateId();\n\t            y = null;\n\t            p();\n\t            r(a)\n\t        }\n\t        ;\n\t        this.setInitialState = c;\n\t        this.initialize = function() {\n\t            y || c()\n\t        }\n\t        ;\n\t        this.setPlaybackFunction = function(a) {\n\t            z = a\n\t        }\n\t        ;\n\t        this.onOperationExecuted = function(a) {\n\t            if (!L) {\n\t                var c = d();\n\t                K.isEditOperation(a) && (u === x || 0 < A.length) || !K.isPartOfOperationSet(a, u.getOperations()) ? (A.length = 0,\n\t                q(),\n\t                u = new k(K,[a],!0),\n\t                t.push(u),\n\t                I.emit(gui.UndoManager.signalUndoStateCreated, {\n\t                    operations: u.getOperations()\n\t                }),\n\t                p()) : (u.addOperation(a),\n\t                I.emit(gui.UndoManager.signalUndoStateModified, {\n\t                    operations: u.getOperations()\n\t                }));\n\t                r(c)\n\t            }\n\t        }\n\t        ;\n\t        this.moveForward = function(a) {\n\t            for (var c = 0, b = d(), e; a && A.length; )\n\t                e = A.pop(),\n\t                t.push(e),\n\t                n(e),\n\t                --a,\n\t                c += 1;\n\t            c && (u = t[t.length - 1],\n\t            p(),\n\t            r(b));\n\t            return c\n\t        }\n\t        ;\n\t        this.moveBackward = function(a) {\n\t            for (var c = 0, b = d(); a && t.length; )\n\t                A.push(t.pop()),\n\t                --a,\n\t                c += 1;\n\t            c && (w.getMemberIds().forEach(function(a) {\n\t                w.hasCursor(a) && w.removeCursor(a)\n\t            }),\n\t            w.setDocumentElement(y.cloneNode(!0)),\n\t            I.emit(gui.TrivialUndoManager.signalDocumentRootReplaced, {}),\n\t            n(x),\n\t            t.forEach(n),\n\t            u = t[t.length - 1] || x,\n\t            p(),\n\t            r(b));\n\t            return c\n\t        }\n\t        ;\n\t        u = x = new k(K);\n\t        v = u.getNextStateId()\n\t    }\n\t    ;\n\t    gui.TrivialUndoManager.signalDocumentRootReplaced = \"documentRootReplaced\"\n\t}\n\t)();\n\todf.GraphicProperties = function(g, k, d) {\n\t    var b = this\n\t      , f = odf.Namespaces.stylens\n\t      , n = odf.Namespaces.svgns;\n\t    this.verticalPos = function() {\n\t        return b.data.value(\"verticalPos\")\n\t    }\n\t    ;\n\t    this.verticalRel = function() {\n\t        return b.data.value(\"verticalRel\")\n\t    }\n\t    ;\n\t    this.horizontalPos = function() {\n\t        return b.data.value(\"horizontalPos\")\n\t    }\n\t    ;\n\t    this.horizontalRel = function() {\n\t        return b.data.value(\"horizontalRel\")\n\t    }\n\t    ;\n\t    this.strokeWidth = function() {\n\t        return b.data.value(\"strokeWidth\")\n\t    }\n\t    ;\n\t    b.data = new odf.LazyStyleProperties(void 0 === d ? void 0 : d.data,{\n\t        verticalPos: function() {\n\t            var b = g.getAttributeNS(f, \"vertical-pos\");\n\t            return \"\" === b ? void 0 : b\n\t        },\n\t        verticalRel: function() {\n\t            var b = g.getAttributeNS(f, \"vertical-rel\");\n\t            return \"\" === b ? void 0 : b\n\t        },\n\t        horizontalPos: function() {\n\t            var b = g.getAttributeNS(f, \"horizontal-pos\");\n\t            return \"\" === b ? void 0 : b\n\t        },\n\t        horizontalRel: function() {\n\t            var b = g.getAttributeNS(f, \"horizontal-rel\");\n\t            return \"\" === b ? void 0 : b\n\t        },\n\t        strokeWidth: function() {\n\t            var b = g.getAttributeNS(n, \"stroke-width\");\n\t            return k.parseLength(b)\n\t        }\n\t    })\n\t}\n\t;\n\todf.ComputedGraphicProperties = function() {\n\t    var g;\n\t    this.setGraphicProperties = function(k) {\n\t        g = k\n\t    }\n\t    ;\n\t    this.verticalPos = function() {\n\t        return g && g.verticalPos() || \"from-top\"\n\t    }\n\t    ;\n\t    this.verticalRel = function() {\n\t        return g && g.verticalRel() || \"page\"\n\t    }\n\t    ;\n\t    this.horizontalPos = function() {\n\t        return g && g.horizontalPos() || \"from-left\"\n\t    }\n\t    ;\n\t    this.horizontalRel = function() {\n\t        return g && g.horizontalRel() || \"page\"\n\t    }\n\t}\n\t;\n\todf.PageLayoutProperties = function(g, k, d) {\n\t    var b = this\n\t      , f = odf.Namespaces.fons;\n\t    this.pageHeight = function() {\n\t        return b.data.value(\"pageHeight\") || 1123\n\t    }\n\t    ;\n\t    this.pageWidth = function() {\n\t        return b.data.value(\"pageWidth\") || 794\n\t    }\n\t    ;\n\t    b.data = new odf.LazyStyleProperties(void 0 === d ? void 0 : d.data,{\n\t        pageHeight: function() {\n\t            var b;\n\t            g && (b = g.getAttributeNS(f, \"page-height\"),\n\t            b = k.parseLength(b));\n\t            return b\n\t        },\n\t        pageWidth: function() {\n\t            var b;\n\t            g && (b = g.getAttributeNS(f, \"page-width\"),\n\t            b = k.parseLength(b));\n\t            return b\n\t        }\n\t    })\n\t}\n\t;\n\todf.PageLayout = function(g, k, d) {\n\t    var b = null;\n\t    g && (b = k.getPropertiesElement(\"page-layout-properties\", g));\n\t    this.pageLayout = new odf.PageLayoutProperties(b,k,d && d.pageLayout)\n\t}\n\t;\n\todf.PageLayoutCache = function() {}\n\t;\n\todf.PageLayoutCache.prototype.getPageLayout = function(g) {}\n\t;\n\todf.PageLayoutCache.prototype.getDefaultPageLayout = function() {}\n\t;\n\todf.ParagraphProperties = function(g, k, d) {\n\t    var b = this\n\t      , f = odf.Namespaces.fons;\n\t    this.marginTop = function() {\n\t        return b.data.value(\"marginTop\")\n\t    }\n\t    ;\n\t    b.data = new odf.LazyStyleProperties(void 0 === d ? void 0 : d.data,{\n\t        marginTop: function() {\n\t            var b = g.getAttributeNS(f, \"margin-top\");\n\t            return k.parsePositiveLengthOrPercent(b, \"marginTop\", d && d.data)\n\t        }\n\t    })\n\t}\n\t;\n\todf.ComputedParagraphProperties = function() {\n\t    var g = {}\n\t      , k = [];\n\t    this.setStyleChain = function(d) {\n\t        k = d;\n\t        g = {}\n\t    }\n\t    ;\n\t    this.marginTop = function() {\n\t        var d, b;\n\t        if (g.hasOwnProperty(\"marginTop\"))\n\t            d = g.marginTop;\n\t        else {\n\t            for (b = 0; void 0 === d && b < k.length; b += 1)\n\t                d = k[b].marginTop();\n\t            g.marginTop = d\n\t        }\n\t        return d || 0\n\t    }\n\t}\n\t;\n\todf.TextProperties = function(g, k, d) {\n\t    var b = this\n\t      , f = odf.Namespaces.fons;\n\t    this.fontSize = function() {\n\t        return b.data.value(\"fontSize\")\n\t    }\n\t    ;\n\t    b.data = new odf.LazyStyleProperties(void 0 === d ? void 0 : d.data,{\n\t        fontSize: function() {\n\t            var b = g.getAttributeNS(f, \"font-size\");\n\t            return k.parsePositiveLengthOrPercent(b, \"fontSize\", d && d.data)\n\t        }\n\t    })\n\t}\n\t;\n\todf.ComputedTextProperties = function() {\n\t    var g = {}\n\t      , k = [];\n\t    this.setStyleChain = function(d) {\n\t        k = d;\n\t        g = {}\n\t    }\n\t    ;\n\t    this.fontSize = function() {\n\t        var d, b;\n\t        if (g.hasOwnProperty(\"fontSize\"))\n\t            d = g.fontSize;\n\t        else {\n\t            for (b = 0; void 0 === d && b < k.length; b += 1)\n\t                d = k[b].fontSize();\n\t            g.fontSize = d\n\t        }\n\t        return d || 12\n\t    }\n\t}\n\t;\n\todf.MasterPage = function(g, k) {\n\t    var d;\n\t    g ? (d = g.getAttributeNS(odf.Namespaces.stylens, \"page-layout-name\"),\n\t    this.pageLayout = k.getPageLayout(d)) : this.pageLayout = k.getDefaultPageLayout()\n\t}\n\t;\n\todf.MasterPageCache = function() {}\n\t;\n\todf.MasterPageCache.prototype.getMasterPage = function(g) {}\n\t;\n\todf.StylePileEntry = function(g, k, d, b) {\n\t    this.masterPage = function() {\n\t        var b = g.getAttributeNS(odf.Namespaces.stylens, \"master-page-name\")\n\t          , k = null;\n\t        b && (k = d.getMasterPage(b));\n\t        return k\n\t    }\n\t    ;\n\t    (function(d) {\n\t        var n = g.getAttributeNS(odf.Namespaces.stylens, \"family\")\n\t          , p = null;\n\t        if (\"graphic\" === n || \"chart\" === n)\n\t            d.graphic = void 0 === b ? void 0 : b.graphic,\n\t            p = k.getPropertiesElement(\"graphic-properties\", g, p),\n\t            null !== p && (d.graphic = new odf.GraphicProperties(p,k,d.graphic));\n\t        if (\"paragraph\" === n || \"table-cell\" === n || \"graphic\" === n || \"presentation\" === n || \"chart\" === n)\n\t            d.paragraph = void 0 === b ? void 0 : b.paragraph,\n\t            p = k.getPropertiesElement(\"paragraph-properties\", g, p),\n\t            null !== p && (d.paragraph = new odf.ParagraphProperties(p,k,d.paragraph));\n\t        if (\"text\" === n || \"paragraph\" === n || \"table-cell\" === n || \"graphic\" === n || \"presentation\" === n || \"chart\" === n)\n\t            d.text = void 0 === b ? void 0 : b.text,\n\t            p = k.getPropertiesElement(\"text-properties\", g, p),\n\t            null !== p && (d.text = new odf.TextProperties(p,k,d.text))\n\t    }\n\t    )(this)\n\t}\n\t;\n\todf.StylePile = function(g, k) {\n\t    function d(d, a) {\n\t        var c, f;\n\t        d.hasAttributeNS(b, \"parent-style-name\") && (f = d.getAttributeNS(b, \"parent-style-name\"),\n\t        -1 === a.indexOf(f) && (c = e(f, a)));\n\t        return new odf.StylePileEntry(d,g,k,c)\n\t    }\n\t    var b = odf.Namespaces.stylens, f = {}, n = {}, p, r = {}, q = {}, e;\n\t    e = function(b, a) {\n\t        var c = r[b], e;\n\t        !c && (e = f[b]) && (a.push(b),\n\t        c = d(e, a),\n\t        r[b] = c);\n\t        return c\n\t    }\n\t    ;\n\t    this.getStyle = function(b) {\n\t        var a = q[b] || r[b], c, e = [];\n\t        a || (c = n[b],\n\t        c || (c = f[b]) && e.push(b),\n\t        c && (a = d(c, e)));\n\t        return a\n\t    }\n\t    ;\n\t    this.addCommonStyle = function(d) {\n\t        var a;\n\t        d.hasAttributeNS(b, \"name\") && (a = d.getAttributeNS(b, \"name\"),\n\t        f.hasOwnProperty(a) || (f[a] = d))\n\t    }\n\t    ;\n\t    this.addAutomaticStyle = function(d) {\n\t        var a;\n\t        d.hasAttributeNS(b, \"name\") && (a = d.getAttributeNS(b, \"name\"),\n\t        n.hasOwnProperty(a) || (n[a] = d))\n\t    }\n\t    ;\n\t    this.setDefaultStyle = function(b) {\n\t        void 0 === p && (p = d(b, []))\n\t    }\n\t    ;\n\t    this.getDefaultStyle = function() {\n\t        return p\n\t    }\n\t}\n\t;\n\todf.ComputedGraphicStyle = function() {\n\t    this.text = new odf.ComputedTextProperties;\n\t    this.paragraph = new odf.ComputedParagraphProperties;\n\t    this.graphic = new odf.ComputedGraphicProperties\n\t}\n\t;\n\todf.ComputedParagraphStyle = function() {\n\t    this.text = new odf.ComputedTextProperties;\n\t    this.paragraph = new odf.ComputedParagraphProperties\n\t}\n\t;\n\todf.ComputedTextStyle = function() {\n\t    this.text = new odf.ComputedTextProperties\n\t}\n\t;\n\todf.StyleCache = function(g) {\n\t    function k(a, c, b, d) {\n\t        c = b.getAttributeNS(c, \"class-names\");\n\t        var e;\n\t        if (c)\n\t            for (c = c.split(\" \"),\n\t            e = 0; e < c.length; e += 1)\n\t                if (b = c[e])\n\t                    d.push(a),\n\t                    d.push(b)\n\t    }\n\t    function d(a, c) {\n\t        var b = x.getStyleName(\"paragraph\", a);\n\t        void 0 !== b && (c.push(\"paragraph\"),\n\t        c.push(b));\n\t        a.namespaceURI !== h || \"h\" !== a.localName && \"p\" !== a.localName || k(\"paragraph\", h, a, c);\n\t        return c\n\t    }\n\t    function b(a, c, b) {\n\t        var d = [], e, h, f, g;\n\t        for (e = 0; e < a.length; e += 2)\n\t            f = a[e],\n\t            g = a[e + 1],\n\t            f = r[f],\n\t            g = f.getStyle(g),\n\t            void 0 !== g && (g = g[c],\n\t            void 0 !== g && g !== h && (d.push(g),\n\t            h = g));\n\t        f = r[b];\n\t        if (g = f.getDefaultStyle())\n\t            g = g[c],\n\t            void 0 !== g && g !== h && d.push(g);\n\t        return d\n\t    }\n\t    function f(a, c) {\n\t        var b = x.getStyleName(\"text\", a)\n\t          , e = a.parentNode;\n\t        void 0 !== b && (c.push(\"text\"),\n\t        c.push(b));\n\t        \"span\" === a.localName && a.namespaceURI === h && k(\"text\", h, a, c);\n\t        if (!e || e === g)\n\t            return c;\n\t        e.namespaceURI !== h || \"p\" !== e.localName && \"h\" !== e.localName ? f(e, c) : d(e, c);\n\t        return c\n\t    }\n\t    function n(a) {\n\t        a = a.getAttributeNS(y, \"family\");\n\t        return r[a]\n\t    }\n\t    var p = this, r, q, e, l, a, c, m, h = odf.Namespaces.textns, y = odf.Namespaces.stylens, x = new odf.StyleInfo, z = new odf.StyleParseUtils, w, v, u, t, A, I;\n\t    this.getComputedGraphicStyle = function(a) {\n\t        var c = [];\n\t        a = x.getStyleName(\"graphic\", a);\n\t        void 0 !== a && (c.push(\"graphic\"),\n\t        c.push(a));\n\t        a = c.join(\"/\");\n\t        var d = l[a];\n\t        runtime.assert(0 === c.length % 2, \"Invalid style chain.\");\n\t        void 0 === d && (d = new odf.ComputedGraphicStyle,\n\t        d.graphic.setGraphicProperties(b(c, \"graphic\", \"graphic\")[0]),\n\t        d.text.setStyleChain(b(c, \"text\", \"graphic\")),\n\t        d.paragraph.setStyleChain(b(c, \"paragraph\", \"graphic\")),\n\t        l[a] = d);\n\t        return d\n\t    }\n\t    ;\n\t    this.getComputedParagraphStyle = function(a) {\n\t        a = d(a, []);\n\t        var c = a.join(\"/\")\n\t          , f = e[c];\n\t        runtime.assert(0 === a.length % 2, \"Invalid style chain.\");\n\t        void 0 === f && (f = new odf.ComputedParagraphStyle,\n\t        f.text.setStyleChain(b(a, \"text\", \"paragraph\")),\n\t        f.paragraph.setStyleChain(b(a, \"paragraph\", \"paragraph\")),\n\t        e[c] = f);\n\t        return f\n\t    }\n\t    ;\n\t    this.getComputedTextStyle = function(a) {\n\t        a = f(a, []);\n\t        var c = a.join(\"/\")\n\t          , d = q[c];\n\t        runtime.assert(0 === a.length % 2, \"Invalid style chain.\");\n\t        void 0 === d && (d = new odf.ComputedTextStyle,\n\t        d.text.setStyleChain(b(a, \"text\", \"text\")),\n\t        q[c] = d);\n\t        return d\n\t    }\n\t    ;\n\t    this.getPageLayout = function(a) {\n\t        var c = I[a];\n\t        c || ((c = A[a]) ? (c = new odf.PageLayout(c,z,t),\n\t        I[a] = c) : c = t);\n\t        return c\n\t    }\n\t    ;\n\t    this.getDefaultPageLayout = function() {\n\t        return t\n\t    }\n\t    ;\n\t    this.getMasterPage = function(a) {\n\t        var c = v[a];\n\t        void 0 === c && ((c = w[a]) ? (c = new odf.MasterPage(c,p),\n\t        v[a] = c) : c = null);\n\t        return c\n\t    }\n\t    ;\n\t    this.getDefaultMasterPage = function() {\n\t        return u\n\t    }\n\t    ;\n\t    this.update = function() {\n\t        var b, d, f = null, h = null;\n\t        q = {};\n\t        e = {};\n\t        l = {};\n\t        w = {};\n\t        v = {};\n\t        I = {};\n\t        A = {};\n\t        a = new odf.StylePile(z,p);\n\t        c = new odf.StylePile(z,p);\n\t        m = new odf.StylePile(z,p);\n\t        r = {\n\t            text: a,\n\t            paragraph: c,\n\t            graphic: m\n\t        };\n\t        for (b = g.styles.firstElementChild; b; )\n\t            b.namespaceURI === y && ((d = n(b)) ? \"style\" === b.localName ? d.addCommonStyle(b) : \"default-style\" === b.localName && d.setDefaultStyle(b) : \"default-page-layout\" === b.localName && (f = b)),\n\t            b = b.nextElementSibling;\n\t        t = new odf.PageLayout(f,z);\n\t        for (b = g.automaticStyles.firstElementChild; b; )\n\t            b.namespaceURI === y && ((d = n(b)) && \"style\" === b.localName ? d.addAutomaticStyle(b) : \"page-layout\" === b.localName && (A[b.getAttributeNS(y, \"name\")] = b)),\n\t            b = b.nextElementSibling;\n\t        for (b = g.masterStyles.firstElementChild; b; )\n\t            b.namespaceURI === y && \"master-page\" === b.localName && (h = h || b,\n\t            d = b,\n\t            f = d.getAttributeNS(y, \"name\"),\n\t            0 < f.length && !w.hasOwnProperty(f) && (w[f] = d)),\n\t            b = b.nextElementSibling;\n\t        u = new odf.MasterPage(h,p)\n\t    }\n\t}\n\t;\n\tops.OperationTransformMatrix = function() {\n\t    function g(a) {\n\t        a.position += a.length;\n\t        a.length *= -1\n\t    }\n\t    function k(a) {\n\t        var c = 0 > a.length;\n\t        c && g(a);\n\t        return c\n\t    }\n\t    function d(a, c) {\n\t        function b(e) {\n\t            a[e] === c && d.push(e)\n\t        }\n\t        var d = [];\n\t        a && [\"style:parent-style-name\", \"style:next-style-name\"].forEach(b);\n\t        return d\n\t    }\n\t    function b(a, c) {\n\t        function b(d) {\n\t            a[d] === c && delete a[d]\n\t        }\n\t        a && [\"style:parent-style-name\", \"style:next-style-name\"].forEach(b)\n\t    }\n\t    function f(a) {\n\t        var c = {};\n\t        Object.keys(a).forEach(function(b) {\n\t            c[b] = \"object\" === typeof a[b] ? f(a[b]) : a[b]\n\t        });\n\t        return c\n\t    }\n\t    function n(a, c, b, d) {\n\t        var e, f = !1, g = !1, k, l = [];\n\t        d && d.attributes && (l = d.attributes.split(\",\"));\n\t        a && (b || 0 < l.length) && Object.keys(a).forEach(function(c) {\n\t            var d = a[c], e;\n\t            \"object\" !== typeof d && (b && (e = b[c]),\n\t            void 0 !== e ? (delete a[c],\n\t            g = !0,\n\t            e === d && (delete b[c],\n\t            f = !0)) : -1 !== l.indexOf(c) && (delete a[c],\n\t            g = !0))\n\t        });\n\t        if (c && c.attributes && (b || 0 < l.length)) {\n\t            k = c.attributes.split(\",\");\n\t            for (d = 0; d < k.length; d += 1)\n\t                if (e = k[d],\n\t                b && void 0 !== b[e] || l && -1 !== l.indexOf(e))\n\t                    k.splice(d, 1),\n\t                    --d,\n\t                    g = !0;\n\t            0 < k.length ? c.attributes = k.join(\",\") : delete c.attributes\n\t        }\n\t        return {\n\t            majorChanged: f,\n\t            minorChanged: g\n\t        }\n\t    }\n\t    function p(a) {\n\t        for (var c in a)\n\t            if (a.hasOwnProperty(c))\n\t                return !0;\n\t        return !1\n\t    }\n\t    function r(a) {\n\t        for (var c in a)\n\t            if (a.hasOwnProperty(c) && (\"attributes\" !== c || 0 < a.attributes.length))\n\t                return !0;\n\t        return !1\n\t    }\n\t    function q(a, c, b, d, e) {\n\t        var f = a ? a[e] : null, g = c ? c[e] : null, k = b ? b[e] : null, l = d ? d[e] : null, q;\n\t        q = n(f, g, k, l);\n\t        f && !p(f) && delete a[e];\n\t        g && !r(g) && delete c[e];\n\t        k && !p(k) && delete b[e];\n\t        l && !r(l) && delete d[e];\n\t        return q\n\t    }\n\t    function e(a, c) {\n\t        return {\n\t            opSpecsA: [a],\n\t            opSpecsB: [c]\n\t        }\n\t    }\n\t    var l;\n\t    l = {\n\t        AddAnnotation: {\n\t            AddAnnotation: function(a, c, b) {\n\t                var d;\n\t                a.position < c.position ? (d = a,\n\t                b = c) : c.position < a.position ? (d = c,\n\t                b = a) : (d = b ? a : c,\n\t                b = b ? c : a);\n\t                b.position < d.position + d.length && (d.length += 2);\n\t                b.position += 2;\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [c]\n\t                }\n\t            },\n\t            AddCursor: e,\n\t            AddMember: e,\n\t            AddStyle: e,\n\t            ApplyDirectStyling: function(a, c) {\n\t                a.position <= c.position ? c.position += 2 : a.position <= c.position + c.length && (c.length += 2);\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [c]\n\t                }\n\t            },\n\t            InsertText: function(a, c) {\n\t                c.position <= a.position ? a.position += c.text.length : (void 0 !== a.length && c.position <= a.position + a.length && (a.length += c.text.length),\n\t                c.position += 2);\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [c]\n\t                }\n\t            },\n\t            MergeParagraph: function(a, c) {\n\t                c.sourceStartPosition <= a.position ? --a.position : (void 0 !== a.length && c.sourceStartPosition <= a.position + a.length && --a.length,\n\t                c.sourceStartPosition += 2,\n\t                a.position < c.destinationStartPosition && (c.destinationStartPosition += 2));\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [c]\n\t                }\n\t            },\n\t            MoveCursor: function(a, c) {\n\t                var b = k(c);\n\t                a.position < c.position ? c.position += 2 : a.position < c.position + c.length && (c.length += 2);\n\t                b && g(c);\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [c]\n\t                }\n\t            },\n\t            RemoveAnnotation: function(a, c) {\n\t                a.position < c.position ? (c.position < a.position + a.length && (a.length -= c.length + 2),\n\t                c.position += 2) : a.position -= c.length + 2;\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [c]\n\t                }\n\t            },\n\t            RemoveCursor: e,\n\t            RemoveMember: e,\n\t            RemoveStyle: e,\n\t            RemoveText: function(a, c) {\n\t                var b = c.position, d = c.position + c.length, e, f = [a], g = [c];\n\t                a.position <= c.position ? c.position += 2 : a.position < d && (c.length = a.position - c.position,\n\t                e = {\n\t                    optype: \"RemoveText\",\n\t                    memberid: c.memberid,\n\t                    timestamp: c.timestamp,\n\t                    position: a.position + 2,\n\t                    length: d - a.position\n\t                },\n\t                g.unshift(e));\n\t                c.position + c.length <= a.position ? (a.position -= c.length,\n\t                void 0 !== a.length && e && (a.length = e.length >= a.length ? 0 : a.length - e.length)) : void 0 !== a.length && (e = a.position + a.length,\n\t                d <= e ? a.length -= c.length : b < e && (a.length = b - a.position));\n\t                return {\n\t                    opSpecsA: f,\n\t                    opSpecsB: g\n\t                }\n\t            },\n\t            SetParagraphStyle: function(a, c) {\n\t                a.position < c.position && (c.position += 2);\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [c]\n\t                }\n\t            },\n\t            SplitParagraph: function(a, c) {\n\t                a.position < c.sourceParagraphPosition && (c.sourceParagraphPosition += 2);\n\t                c.position <= a.position ? a.position += 1 : (void 0 !== a.length && c.position <= a.position + a.length && (a.length += 1),\n\t                c.position += 2);\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [c]\n\t                }\n\t            },\n\t            UpdateMember: e,\n\t            UpdateMetadata: e,\n\t            UpdateParagraphStyle: e\n\t        },\n\t        AddCursor: {\n\t            AddCursor: e,\n\t            AddMember: e,\n\t            AddStyle: e,\n\t            ApplyDirectStyling: e,\n\t            InsertText: e,\n\t            MergeParagraph: e,\n\t            MoveCursor: e,\n\t            RemoveAnnotation: e,\n\t            RemoveCursor: e,\n\t            RemoveMember: e,\n\t            RemoveStyle: e,\n\t            RemoveText: e,\n\t            SetParagraphStyle: e,\n\t            SplitParagraph: e,\n\t            UpdateMember: e,\n\t            UpdateMetadata: e,\n\t            UpdateParagraphStyle: e\n\t        },\n\t        AddMember: {\n\t            AddStyle: e,\n\t            ApplyDirectStyling: e,\n\t            InsertText: e,\n\t            MergeParagraph: e,\n\t            MoveCursor: e,\n\t            RemoveAnnotation: e,\n\t            RemoveCursor: e,\n\t            RemoveStyle: e,\n\t            RemoveText: e,\n\t            SetParagraphStyle: e,\n\t            SplitParagraph: e,\n\t            UpdateMetadata: e,\n\t            UpdateParagraphStyle: e\n\t        },\n\t        AddStyle: {\n\t            AddStyle: e,\n\t            ApplyDirectStyling: e,\n\t            InsertText: e,\n\t            MergeParagraph: e,\n\t            MoveCursor: e,\n\t            RemoveAnnotation: e,\n\t            RemoveCursor: e,\n\t            RemoveMember: e,\n\t            RemoveStyle: function(a, c) {\n\t                var e, f = [a], g = [c];\n\t                a.styleFamily === c.styleFamily && (e = d(a.setProperties, c.styleName),\n\t                0 < e.length && (e = {\n\t                    optype: \"UpdateParagraphStyle\",\n\t                    memberid: c.memberid,\n\t                    timestamp: c.timestamp,\n\t                    styleName: a.styleName,\n\t                    removedProperties: {\n\t                        attributes: e.join(\",\")\n\t                    }\n\t                },\n\t                g.unshift(e)),\n\t                b(a.setProperties, c.styleName));\n\t                return {\n\t                    opSpecsA: f,\n\t                    opSpecsB: g\n\t                }\n\t            },\n\t            RemoveText: e,\n\t            SetParagraphStyle: e,\n\t            SplitParagraph: e,\n\t            UpdateMember: e,\n\t            UpdateMetadata: e,\n\t            UpdateParagraphStyle: e\n\t        },\n\t        ApplyDirectStyling: {\n\t            ApplyDirectStyling: function(a, c, b) {\n\t                var d, e, g, k, l, n, r, t;\n\t                k = [a];\n\t                g = [c];\n\t                if (!(a.position + a.length <= c.position || a.position >= c.position + c.length)) {\n\t                    d = b ? a : c;\n\t                    e = b ? c : a;\n\t                    if (a.position !== c.position || a.length !== c.length)\n\t                        n = f(d),\n\t                        r = f(e);\n\t                    c = q(e.setProperties, null, d.setProperties, null, \"style:text-properties\");\n\t                    if (c.majorChanged || c.minorChanged)\n\t                        g = [],\n\t                        a = [],\n\t                        k = d.position + d.length,\n\t                        l = e.position + e.length,\n\t                        e.position < d.position ? c.minorChanged && (t = f(r),\n\t                        t.length = d.position - e.position,\n\t                        a.push(t),\n\t                        e.position = d.position,\n\t                        e.length = l - e.position) : d.position < e.position && c.majorChanged && (t = f(n),\n\t                        t.length = e.position - d.position,\n\t                        g.push(t),\n\t                        d.position = e.position,\n\t                        d.length = k - d.position),\n\t                        l > k ? c.minorChanged && (n = r,\n\t                        n.position = k,\n\t                        n.length = l - k,\n\t                        a.push(n),\n\t                        e.length = k - e.position) : k > l && c.majorChanged && (n.position = l,\n\t                        n.length = k - l,\n\t                        g.push(n),\n\t                        d.length = l - d.position),\n\t                        d.setProperties && p(d.setProperties) && g.push(d),\n\t                        e.setProperties && p(e.setProperties) && a.push(e),\n\t                        b ? (k = g,\n\t                        g = a) : k = a\n\t                }\n\t                return {\n\t                    opSpecsA: k,\n\t                    opSpecsB: g\n\t                }\n\t            },\n\t            InsertText: function(a, c) {\n\t                c.position <= a.position ? a.position += c.text.length : c.position <= a.position + a.length && (a.length += c.text.length);\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [c]\n\t                }\n\t            },\n\t            MergeParagraph: function(a, c) {\n\t                var b = a.position\n\t                  , d = a.position + a.length;\n\t                b >= c.sourceStartPosition && --b;\n\t                d >= c.sourceStartPosition && --d;\n\t                a.position = b;\n\t                a.length = d - b;\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [c]\n\t                }\n\t            },\n\t            MoveCursor: e,\n\t            RemoveAnnotation: function(a, b) {\n\t                var d = a.position\n\t                  , e = a.position + a.length\n\t                  , f = b.position + b.length\n\t                  , g = [a]\n\t                  , k = [b];\n\t                b.position <= d && e <= f ? g = [] : (f < d && (d -= b.length + 2),\n\t                f < e && (e -= b.length + 2),\n\t                a.position = d,\n\t                a.length = e - d);\n\t                return {\n\t                    opSpecsA: g,\n\t                    opSpecsB: k\n\t                }\n\t            },\n\t            RemoveCursor: e,\n\t            RemoveMember: e,\n\t            RemoveStyle: e,\n\t            RemoveText: function(a, b) {\n\t                var d = a.position + a.length\n\t                  , e = b.position + b.length\n\t                  , f = [a]\n\t                  , g = [b];\n\t                e <= a.position ? a.position -= b.length : b.position < d && (a.position < b.position ? a.length = e < d ? a.length - b.length : b.position - a.position : (a.position = b.position,\n\t                e < d ? a.length = d - e : f = []));\n\t                return {\n\t                    opSpecsA: f,\n\t                    opSpecsB: g\n\t                }\n\t            },\n\t            SetParagraphStyle: e,\n\t            SplitParagraph: function(a, b) {\n\t                b.position < a.position ? a.position += 1 : b.position < a.position + a.length && (a.length += 1);\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [b]\n\t                }\n\t            },\n\t            UpdateMember: e,\n\t            UpdateMetadata: e,\n\t            UpdateParagraphStyle: e\n\t        },\n\t        InsertText: {\n\t            InsertText: function(a, b, d) {\n\t                a.position < b.position ? b.position += a.text.length : a.position > b.position ? a.position += b.text.length : d ? b.position += a.text.length : a.position += b.text.length;\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [b]\n\t                }\n\t            },\n\t            MergeParagraph: function(a, b) {\n\t                a.position >= b.sourceStartPosition ? --a.position : (a.position < b.sourceStartPosition && (b.sourceStartPosition += a.text.length),\n\t                a.position < b.destinationStartPosition && (b.destinationStartPosition += a.text.length));\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [b]\n\t                }\n\t            },\n\t            MoveCursor: function(a, b) {\n\t                var d = k(b);\n\t                a.position < b.position ? b.position += a.text.length : a.position < b.position + b.length && (b.length += a.text.length);\n\t                d && g(b);\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [b]\n\t                }\n\t            },\n\t            RemoveAnnotation: function(a, b) {\n\t                var d = a.position\n\t                  , e = b.position + b.length\n\t                  , f = [a]\n\t                  , g = [b];\n\t                b.position <= d && d <= e ? (f = [],\n\t                b.length += a.text.length) : e < a.position ? a.position -= b.length + 2 : b.position += a.text.length;\n\t                return {\n\t                    opSpecsA: f,\n\t                    opSpecsB: g\n\t                }\n\t            },\n\t            RemoveCursor: e,\n\t            RemoveMember: e,\n\t            RemoveStyle: e,\n\t            RemoveText: function(a, b) {\n\t                var d;\n\t                d = b.position + b.length;\n\t                var e = [a]\n\t                  , f = [b];\n\t                d <= a.position ? a.position -= b.length : a.position <= b.position ? b.position += a.text.length : (b.length = a.position - b.position,\n\t                d = {\n\t                    optype: \"RemoveText\",\n\t                    memberid: b.memberid,\n\t                    timestamp: b.timestamp,\n\t                    position: a.position + a.text.length,\n\t                    length: d - a.position\n\t                },\n\t                f.unshift(d),\n\t                a.position = b.position);\n\t                return {\n\t                    opSpecsA: e,\n\t                    opSpecsB: f\n\t                }\n\t            },\n\t            SetParagraphStyle: function(a, b) {\n\t                b.position > a.position && (b.position += a.text.length);\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [b]\n\t                }\n\t            },\n\t            SplitParagraph: function(a, b) {\n\t                a.position < b.sourceParagraphPosition && (b.sourceParagraphPosition += a.text.length);\n\t                a.position <= b.position ? b.position += a.text.length : a.position += 1;\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [b]\n\t                }\n\t            },\n\t            UpdateMember: e,\n\t            UpdateMetadata: e,\n\t            UpdateParagraphStyle: e\n\t        },\n\t        MergeParagraph: {\n\t            MergeParagraph: function(a, b, d) {\n\t                var e = [a], f = [b], g;\n\t                a.destinationStartPosition === b.destinationStartPosition ? (e = [],\n\t                f = [],\n\t                a.moveCursor && (g = {\n\t                    optype: \"MoveCursor\",\n\t                    memberid: a.memberid,\n\t                    timestamp: a.timestamp,\n\t                    position: a.sourceStartPosition - 1\n\t                },\n\t                e.push(g)),\n\t                b.moveCursor && (g = {\n\t                    optype: \"MoveCursor\",\n\t                    memberid: b.memberid,\n\t                    timestamp: b.timestamp,\n\t                    position: b.sourceStartPosition - 1\n\t                },\n\t                f.push(g)),\n\t                a = d ? a : b,\n\t                a = {\n\t                    optype: \"SetParagraphStyle\",\n\t                    memberid: a.memberid,\n\t                    timestamp: a.timestamp,\n\t                    position: a.destinationStartPosition,\n\t                    styleName: a.paragraphStyleName\n\t                },\n\t                d ? e.push(a) : f.push(a)) : b.sourceStartPosition === a.destinationStartPosition ? (a.destinationStartPosition = b.destinationStartPosition,\n\t                --a.sourceStartPosition,\n\t                a.paragraphStyleName = b.paragraphStyleName) : a.sourceStartPosition === b.destinationStartPosition ? (b.destinationStartPosition = a.destinationStartPosition,\n\t                --b.sourceStartPosition,\n\t                b.paragraphStyleName = a.paragraphStyleName) : a.destinationStartPosition < b.destinationStartPosition ? (--b.destinationStartPosition,\n\t                --b.sourceStartPosition) : (--a.destinationStartPosition,\n\t                --a.sourceStartPosition);\n\t                return {\n\t                    opSpecsA: e,\n\t                    opSpecsB: f\n\t                }\n\t            },\n\t            MoveCursor: function(a, b) {\n\t                var d = b.position\n\t                  , e = b.position + b.length\n\t                  , f = Math.min(d, e)\n\t                  , d = Math.max(d, e);\n\t                f >= a.sourceStartPosition && --f;\n\t                d >= a.sourceStartPosition && --d;\n\t                0 <= b.length ? (b.position = f,\n\t                b.length = d - f) : (b.position = d,\n\t                b.length = f - d);\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [b]\n\t                }\n\t            },\n\t            RemoveAnnotation: function(a, b) {\n\t                var d = b.position + b.length\n\t                  , e = [a]\n\t                  , f = [b];\n\t                b.position <= a.destinationStartPosition && a.sourceStartPosition <= d ? (e = [],\n\t                --b.length) : a.sourceStartPosition < b.position ? --b.position : (d < a.destinationStartPosition && (a.destinationStartPosition -= b.length + 2),\n\t                d < a.sourceStartPosition && (a.sourceStartPosition -= b.length + 2));\n\t                return {\n\t                    opSpecsA: e,\n\t                    opSpecsB: f\n\t                }\n\t            },\n\t            RemoveCursor: e,\n\t            RemoveMember: e,\n\t            RemoveStyle: e,\n\t            RemoveText: function(a, b) {\n\t                b.position >= a.sourceStartPosition ? --b.position : (b.position < a.destinationStartPosition && (a.destinationStartPosition -= b.length),\n\t                b.position < a.sourceStartPosition && (a.sourceStartPosition -= b.length));\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [b]\n\t                }\n\t            },\n\t            SetParagraphStyle: function(a, b) {\n\t                var d = [a]\n\t                  , e = [b];\n\t                if (b.position > a.sourceStartPosition)\n\t                    --b.position;\n\t                else if (b.position === a.destinationStartPosition || b.position === a.sourceStartPosition)\n\t                    b.position = a.destinationStartPosition,\n\t                    a.paragraphStyleName = b.styleName;\n\t                return {\n\t                    opSpecsA: d,\n\t                    opSpecsB: e\n\t                }\n\t            },\n\t            SplitParagraph: function(a, b) {\n\t                var d, e = [a], f = [b];\n\t                b.position < a.destinationStartPosition ? (a.destinationStartPosition += 1,\n\t                a.sourceStartPosition += 1) : b.position >= a.destinationStartPosition && b.position < a.sourceStartPosition ? (b.paragraphStyleName = a.paragraphStyleName,\n\t                d = {\n\t                    optype: \"SetParagraphStyle\",\n\t                    memberid: a.memberid,\n\t                    timestamp: a.timestamp,\n\t                    position: a.destinationStartPosition,\n\t                    styleName: a.paragraphStyleName\n\t                },\n\t                e.push(d),\n\t                b.position === a.sourceStartPosition - 1 && a.moveCursor && (d = {\n\t                    optype: \"MoveCursor\",\n\t                    memberid: a.memberid,\n\t                    timestamp: a.timestamp,\n\t                    position: b.position,\n\t                    length: 0\n\t                },\n\t                e.push(d)),\n\t                a.destinationStartPosition = b.position + 1,\n\t                a.sourceStartPosition += 1) : b.position >= a.sourceStartPosition && (--b.position,\n\t                --b.sourceParagraphPosition);\n\t                return {\n\t                    opSpecsA: e,\n\t                    opSpecsB: f\n\t                }\n\t            },\n\t            UpdateMember: e,\n\t            UpdateMetadata: e,\n\t            UpdateParagraphStyle: e\n\t        },\n\t        MoveCursor: {\n\t            MoveCursor: e,\n\t            RemoveAnnotation: function(a, b) {\n\t                var d = k(a)\n\t                  , e = a.position + a.length\n\t                  , f = b.position + b.length;\n\t                b.position <= a.position && e <= f ? (a.position = b.position - 1,\n\t                a.length = 0) : (f < a.position ? a.position -= b.length + 2 : f < e && (a.length -= b.length + 2),\n\t                d && g(a));\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [b]\n\t                }\n\t            },\n\t            RemoveCursor: function(a, b) {\n\t                return {\n\t                    opSpecsA: a.memberid === b.memberid ? [] : [a],\n\t                    opSpecsB: [b]\n\t                }\n\t            },\n\t            RemoveMember: e,\n\t            RemoveStyle: e,\n\t            RemoveText: function(a, b) {\n\t                var d = k(a)\n\t                  , e = a.position + a.length\n\t                  , f = b.position + b.length;\n\t                f <= a.position ? a.position -= b.length : b.position < e && (a.position < b.position ? a.length = f < e ? a.length - b.length : b.position - a.position : (a.position = b.position,\n\t                a.length = f < e ? e - f : 0));\n\t                d && g(a);\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [b]\n\t                }\n\t            },\n\t            SetParagraphStyle: e,\n\t            SplitParagraph: function(a, b) {\n\t                var d = k(a);\n\t                b.position < a.position ? a.position += 1 : b.position < a.position + a.length && (a.length += 1);\n\t                d && g(a);\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [b]\n\t                }\n\t            },\n\t            UpdateMember: e,\n\t            UpdateMetadata: e,\n\t            UpdateParagraphStyle: e\n\t        },\n\t        RemoveAnnotation: {\n\t            RemoveAnnotation: function(a, b) {\n\t                var d = [a]\n\t                  , e = [b];\n\t                a.position === b.position && a.length === b.length ? (d = [],\n\t                e = []) : a.position < b.position ? b.position -= a.length + 2 : a.position -= b.length + 2;\n\t                return {\n\t                    opSpecsA: d,\n\t                    opSpecsB: e\n\t                }\n\t            },\n\t            RemoveCursor: e,\n\t            RemoveMember: e,\n\t            RemoveStyle: e,\n\t            RemoveText: function(a, b) {\n\t                var d = a.position + a.length\n\t                  , e = b.position + b.length\n\t                  , f = [a]\n\t                  , g = [b];\n\t                a.position <= b.position && e <= d ? (g = [],\n\t                a.length -= b.length) : e < a.position ? a.position -= b.length : b.position < a.position ? (a.position = b.position + 1,\n\t                b.length -= a.length + 2) : b.position -= a.length + 2;\n\t                return {\n\t                    opSpecsA: f,\n\t                    opSpecsB: g\n\t                }\n\t            },\n\t            SetParagraphStyle: function(a, b) {\n\t                var d = b.position\n\t                  , e = a.position + a.length\n\t                  , f = [a]\n\t                  , g = [b];\n\t                a.position <= d && d <= e ? g = [] : e < d && (b.position -= a.length + 2);\n\t                return {\n\t                    opSpecsA: f,\n\t                    opSpecsB: g\n\t                }\n\t            },\n\t            SplitParagraph: function(a, b) {\n\t                var d = b.position\n\t                  , e = a.position + a.length\n\t                  , f = [a]\n\t                  , g = [b];\n\t                a.position <= d && d <= e ? (g = [],\n\t                a.length += 1) : (e < b.sourceParagraphPosition && (b.sourceParagraphPosition -= a.length + 2),\n\t                e < d ? b.position -= a.length + 2 : a.position += 1);\n\t                return {\n\t                    opSpecsA: f,\n\t                    opSpecsB: g\n\t                }\n\t            },\n\t            UpdateMember: e,\n\t            UpdateMetadata: e,\n\t            UpdateParagraphStyle: e\n\t        },\n\t        RemoveCursor: {\n\t            RemoveCursor: function(a, b) {\n\t                var d = a.memberid === b.memberid;\n\t                return {\n\t                    opSpecsA: d ? [] : [a],\n\t                    opSpecsB: d ? [] : [b]\n\t                }\n\t            },\n\t            RemoveMember: e,\n\t            RemoveStyle: e,\n\t            RemoveText: e,\n\t            SetParagraphStyle: e,\n\t            SplitParagraph: e,\n\t            UpdateMember: e,\n\t            UpdateMetadata: e,\n\t            UpdateParagraphStyle: e\n\t        },\n\t        RemoveMember: {\n\t            RemoveStyle: e,\n\t            RemoveText: e,\n\t            SetParagraphStyle: e,\n\t            SplitParagraph: e,\n\t            UpdateMetadata: e,\n\t            UpdateParagraphStyle: e\n\t        },\n\t        RemoveStyle: {\n\t            RemoveStyle: function(a, b) {\n\t                var d = a.styleName === b.styleName && a.styleFamily === b.styleFamily;\n\t                return {\n\t                    opSpecsA: d ? [] : [a],\n\t                    opSpecsB: d ? [] : [b]\n\t                }\n\t            },\n\t            RemoveText: e,\n\t            SetParagraphStyle: function(a, b) {\n\t                var d, e = [a], f = [b];\n\t                \"paragraph\" === a.styleFamily && a.styleName === b.styleName && (d = {\n\t                    optype: \"SetParagraphStyle\",\n\t                    memberid: a.memberid,\n\t                    timestamp: a.timestamp,\n\t                    position: b.position,\n\t                    styleName: \"\"\n\t                },\n\t                e.unshift(d),\n\t                b.styleName = \"\");\n\t                return {\n\t                    opSpecsA: e,\n\t                    opSpecsB: f\n\t                }\n\t            },\n\t            SplitParagraph: e,\n\t            UpdateMember: e,\n\t            UpdateMetadata: e,\n\t            UpdateParagraphStyle: function(a, c) {\n\t                var e, f = [a], g = [c];\n\t                \"paragraph\" === a.styleFamily && (e = d(c.setProperties, a.styleName),\n\t                0 < e.length && (e = {\n\t                    optype: \"UpdateParagraphStyle\",\n\t                    memberid: a.memberid,\n\t                    timestamp: a.timestamp,\n\t                    styleName: c.styleName,\n\t                    removedProperties: {\n\t                        attributes: e.join(\",\")\n\t                    }\n\t                },\n\t                f.unshift(e)),\n\t                a.styleName === c.styleName ? g = [] : b(c.setProperties, a.styleName));\n\t                return {\n\t                    opSpecsA: f,\n\t                    opSpecsB: g\n\t                }\n\t            }\n\t        },\n\t        RemoveText: {\n\t            RemoveText: function(a, b) {\n\t                var d = a.position + a.length\n\t                  , e = b.position + b.length\n\t                  , f = [a]\n\t                  , g = [b];\n\t                e <= a.position ? a.position -= b.length : d <= b.position ? b.position -= a.length : b.position < d && (a.position < b.position ? (a.length = e < d ? a.length - b.length : b.position - a.position,\n\t                d < e ? (b.position = a.position,\n\t                b.length = e - d) : g = []) : (d < e ? b.length -= a.length : b.position < a.position ? b.length = a.position - b.position : g = [],\n\t                e < d ? (a.position = b.position,\n\t                a.length = d - e) : f = []));\n\t                return {\n\t                    opSpecsA: f,\n\t                    opSpecsB: g\n\t                }\n\t            },\n\t            SetParagraphStyle: function(a, b) {\n\t                a.position < b.position && (b.position -= a.length);\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [b]\n\t                }\n\t            },\n\t            SplitParagraph: function(a, b) {\n\t                var d = a.position + a.length\n\t                  , e = [a]\n\t                  , f = [b];\n\t                b.position <= a.position ? a.position += 1 : b.position < d && (a.length = b.position - a.position,\n\t                d = {\n\t                    optype: \"RemoveText\",\n\t                    memberid: a.memberid,\n\t                    timestamp: a.timestamp,\n\t                    position: b.position + 1,\n\t                    length: d - b.position\n\t                },\n\t                e.unshift(d));\n\t                a.position + a.length <= b.position ? b.position -= a.length : a.position < b.position && (b.position = a.position);\n\t                a.position + a.length < b.sourceParagraphPosition && (b.sourceParagraphPosition -= a.length);\n\t                return {\n\t                    opSpecsA: e,\n\t                    opSpecsB: f\n\t                }\n\t            },\n\t            UpdateMember: e,\n\t            UpdateMetadata: e,\n\t            UpdateParagraphStyle: e\n\t        },\n\t        SetParagraphStyle: {\n\t            SetParagraphStyle: function(a, b, d) {\n\t                a.position === b.position && (d ? b.styleName = a.styleName : a.styleName = b.styleName);\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [b]\n\t                }\n\t            },\n\t            SplitParagraph: function(a, b) {\n\t                var d = [a], e = [b], g;\n\t                a.position > b.position ? a.position += 1 : a.position === b.sourceParagraphPosition && (b.paragraphStyleName = a.styleName,\n\t                g = f(a),\n\t                g.position = b.position + 1,\n\t                d.push(g));\n\t                return {\n\t                    opSpecsA: d,\n\t                    opSpecsB: e\n\t                }\n\t            },\n\t            UpdateMember: e,\n\t            UpdateMetadata: e,\n\t            UpdateParagraphStyle: e\n\t        },\n\t        SplitParagraph: {\n\t            SplitParagraph: function(a, b, d) {\n\t                var e, f;\n\t                a.position < b.position ? e = !0 : b.position < a.position ? f = !0 : a.position === b.position && (d ? e = !0 : f = !0);\n\t                e ? (b.position += 1,\n\t                b.sourceParagraphPosition = a.position < b.sourceParagraphPosition ? b.sourceParagraphPosition + 1 : a.position + 1) : f && (a.position += 1,\n\t                a.sourceParagraphPosition = b.position < b.sourceParagraphPosition ? a.sourceParagraphPosition + 1 : b.position + 1);\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [b]\n\t                }\n\t            },\n\t            UpdateMember: e,\n\t            UpdateMetadata: e,\n\t            UpdateParagraphStyle: e\n\t        },\n\t        UpdateMember: {\n\t            UpdateMetadata: e,\n\t            UpdateParagraphStyle: e\n\t        },\n\t        UpdateMetadata: {\n\t            UpdateMetadata: function(a, b, d) {\n\t                var e, f = [a], g = [b];\n\t                e = d ? a : b;\n\t                a = d ? b : a;\n\t                n(a.setProperties || null, a.removedProperties || null, e.setProperties || null, e.removedProperties || null);\n\t                e.setProperties && p(e.setProperties) || e.removedProperties && r(e.removedProperties) || (d ? f = [] : g = []);\n\t                a.setProperties && p(a.setProperties) || a.removedProperties && r(a.removedProperties) || (d ? g = [] : f = []);\n\t                return {\n\t                    opSpecsA: f,\n\t                    opSpecsB: g\n\t                }\n\t            },\n\t            UpdateParagraphStyle: e\n\t        },\n\t        UpdateParagraphStyle: {\n\t            UpdateParagraphStyle: function(a, b, d) {\n\t                var e, f = [a], g = [b];\n\t                a.styleName === b.styleName && (e = d ? a : b,\n\t                a = d ? b : a,\n\t                q(a.setProperties, a.removedProperties, e.setProperties, e.removedProperties, \"style:paragraph-properties\"),\n\t                q(a.setProperties, a.removedProperties, e.setProperties, e.removedProperties, \"style:text-properties\"),\n\t                n(a.setProperties || null, a.removedProperties || null, e.setProperties || null, e.removedProperties || null),\n\t                e.setProperties && p(e.setProperties) || e.removedProperties && r(e.removedProperties) || (d ? f = [] : g = []),\n\t                a.setProperties && p(a.setProperties) || a.removedProperties && r(a.removedProperties) || (d ? g = [] : f = []));\n\t                return {\n\t                    opSpecsA: f,\n\t                    opSpecsB: g\n\t                }\n\t            }\n\t        }\n\t    };\n\t    this.passUnchanged = e;\n\t    this.extendTransformations = function(a) {\n\t        Object.keys(a).forEach(function(b) {\n\t            var d = a[b], e, f = l.hasOwnProperty(b);\n\t            runtime.log((f ? \"Extending\" : \"Adding\") + \" map for optypeA: \" + b);\n\t            f || (l[b] = {});\n\t            e = l[b];\n\t            Object.keys(d).forEach(function(a) {\n\t                var f = e.hasOwnProperty(a);\n\t                runtime.assert(b <= a, \"Wrong order:\" + b + \", \" + a);\n\t                runtime.log(\"  \" + (f ? \"Overwriting\" : \"Adding\") + \" entry for optypeB: \" + a);\n\t                e[a] = d[a]\n\t            })\n\t        })\n\t    }\n\t    ;\n\t    this.transformOpspecVsOpspec = function(a, b) {\n\t        var d = a.optype <= b.optype, e;\n\t        runtime.log(\"Crosstransforming:\");\n\t        runtime.log(runtime.toJson(a));\n\t        runtime.log(runtime.toJson(b));\n\t        d || (e = a,\n\t        a = b,\n\t        b = e);\n\t        (e = (e = l[a.optype]) && e[b.optype]) ? (e = e(a, b, !d),\n\t        d || null === e || (e = {\n\t            opSpecsA: e.opSpecsB,\n\t            opSpecsB: e.opSpecsA\n\t        })) : e = null;\n\t        runtime.log(\"result:\");\n\t        e ? (runtime.log(runtime.toJson(e.opSpecsA)),\n\t        runtime.log(runtime.toJson(e.opSpecsB))) : runtime.log(\"null\");\n\t        return e\n\t    }\n\t}\n\t;\n\tops.OperationTransformer = function() {\n\t    function g(d, b) {\n\t        for (var f, n, p = [], r = []; 0 < d.length && b; ) {\n\t            f = d.shift();\n\t            f = k.transformOpspecVsOpspec(f, b);\n\t            if (!f)\n\t                return null;\n\t            p = p.concat(f.opSpecsA);\n\t            if (0 === f.opSpecsB.length) {\n\t                p = p.concat(d);\n\t                b = null;\n\t                break\n\t            }\n\t            for (; 1 < f.opSpecsB.length; ) {\n\t                n = g(d, f.opSpecsB.shift());\n\t                if (!n)\n\t                    return null;\n\t                r = r.concat(n.opSpecsB);\n\t                d = n.opSpecsA\n\t            }\n\t            b = f.opSpecsB.pop()\n\t        }\n\t        b && r.push(b);\n\t        return {\n\t            opSpecsA: p,\n\t            opSpecsB: r\n\t        }\n\t    }\n\t    var k = new ops.OperationTransformMatrix;\n\t    this.getOperationTransformMatrix = function() {\n\t        return k\n\t    }\n\t    ;\n\t    this.transform = function(d, b) {\n\t        for (var f, k = []; 0 < b.length; ) {\n\t            f = g(d, b.shift());\n\t            if (!f)\n\t                return null;\n\t            d = f.opSpecsA;\n\t            k = k.concat(f.opSpecsB)\n\t        }\n\t        return {\n\t            opSpecsA: d,\n\t            opSpecsB: k\n\t        }\n\t    }\n\t}\n\t;\n\tvar webodf_css = '@namespace draw url(urn:oasis:names:tc:opendocument:xmlns:drawing:1.0);@namespace fo url(urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0);@namespace office url(urn:oasis:names:tc:opendocument:xmlns:office:1.0);@namespace presentation url(urn:oasis:names:tc:opendocument:xmlns:presentation:1.0);@namespace style url(urn:oasis:names:tc:opendocument:xmlns:style:1.0);@namespace svg url(urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0);@namespace table url(urn:oasis:names:tc:opendocument:xmlns:table:1.0);@namespace text url(urn:oasis:names:tc:opendocument:xmlns:text:1.0);@namespace webodfhelper url(urn:webodf:names:helper);@namespace cursor url(urn:webodf:names:cursor);@namespace editinfo url(urn:webodf:names:editinfo);@namespace annotation url(urn:webodf:names:annotation);@namespace dc url(http://purl.org/dc/elements/1.1/);@namespace svgns url(http://www.w3.org/2000/svg);office|document > *, office|document-content > * {display: none;}office|body, office|document {display: inline-block;position: relative;}text|p, text|h {display: block;padding: 0;margin: 0;line-height: normal;position: relative;}text|p::after, text|h::after {content: \"\\\\200B\";white-space: pre;}*[webodfhelper|containsparagraphanchor] {position: relative;}text|s {white-space: pre;}text|tab {display: inline;white-space: pre;}text|tracked-changes {display: none;}office|binary-data {display: none;}office|text {display: block;text-align: left;overflow: visible;word-wrap: break-word;}office|text::selection {background: transparent;}.webodf-virtualSelections *::selection {background: transparent;}.webodf-virtualSelections *::-moz-selection {background: transparent;}office|text * draw|text-box {display: block;border: 1px solid #d3d3d3;}office|text draw|frame {z-index: 1;}office|spreadsheet {display: block;border-collapse: collapse;empty-cells: show;font-family: sans-serif;font-size: 10pt;text-align: left;page-break-inside: avoid;overflow: hidden;}office|presentation {display: inline-block;text-align: left;}#shadowContent {display: inline-block;text-align: left;}draw|page {display: block;position: relative;overflow: hidden;}presentation|notes, presentation|footer-decl, presentation|date-time-decl {display: none;}@media print {draw|page {border: 1pt solid black;page-break-inside: avoid;}presentation|notes {}}office|spreadsheet text|p {border: 0px;padding: 1px;margin: 0px;}office|spreadsheet table|table {margin: 3px;}office|spreadsheet table|table:after {}office|spreadsheet table|table-row {counter-increment: row;}office|spreadsheet table|table-row:before {width: 3em;background: #cccccc;border: 1px solid black;text-align: center;content: counter(row);display: table-cell;}office|spreadsheet table|table-cell {border: 1px solid #cccccc;}table|table {display: table;}draw|frame table|table {width: 100%;height: 100%;background: white;}table|table-header-rows {display: table-header-group;}table|table-row {display: table-row;}table|table-column {display: table-column;}table|table-cell {width: 0.889in;display: table-cell;word-break: break-all;}draw|frame {display: block;}draw|image {display: block;width: 100%;height: 100%;top: 0px;left: 0px;background-repeat: no-repeat;background-size: 100% 100%;-moz-background-size: 100% 100%;}draw|frame > draw|image:nth-of-type(n+2) {display: none;}text|list:before {display: none;content:\"\";}text|list {display: block;}text|list-item {display: block;}text|number {display:none;}text|a {color: blue;text-decoration: underline;cursor: pointer;}.webodf-inactiveLinks text|a {cursor: text;}text|note-citation {vertical-align: super;font-size: smaller;}text|note-body {display: none;}text|note:hover text|note-citation {background: #dddddd;}text|note:hover text|note-body {display: block;left:1em;max-width: 80%;position: absolute;background: #ffffaa;}text|bibliography-source {display: none;}svg|title, svg|desc {display: none;}video {width: 100%;height: 100%}cursor|anchor {display: none;}cursor|cursor {display: none;}.webodf-caretOverlay {position: absolute;top: 5%;height: 1em;z-index: 10;padding-left: 1px;pointer-events: none;}.webodf-caretOverlay .caret {position: absolute;border-left: 2px solid black;top: 0;bottom: 0;right: 0;}.webodf-caretOverlay .handle {position: absolute;margin-top: 5px;padding-top: 3px;margin-left: auto;margin-right: auto;width: 64px;height: 68px;border-radius: 5px;opacity: 0.3;text-align: center;background-color: black;box-shadow: 0px 0px 5px rgb(90, 90, 90);border: 1px solid black;top: -85px;right: -32px;}.webodf-caretOverlay .handle > img {box-shadow: 0px 0px 5px rgb(90, 90, 90) inset;background-color: rgb(200, 200, 200);border-radius: 5px;border: 2px solid;height: 60px;width: 60px;display: block;margin: auto;}.webodf-caretOverlay .handle.active {opacity: 0.8;}.webodf-caretOverlay .handle:after {content: \" \";position: absolute;width: 0px;height: 0px;border-style: solid;border-width: 8.7px 5px 0 5px;border-color: black transparent transparent transparent;top: 100%;left: 43%;}.webodf-caretSizer {display: inline-block;width: 0;visibility: hidden;}#eventTrap {display: block;position: absolute;bottom: 0;left: 0;outline: none;opacity: 0;color: rgba(255, 255, 255, 0);pointer-events: none;white-space: pre;overflow: hidden;}cursor|cursor > #composer {text-decoration: underline;}cursor|cursor[cursor|caret-sizer-active=\"true\"],cursor|cursor[cursor|composing=\"true\"] {display: inline;}editinfo|editinfo {display: inline-block;}.editInfoMarker {position: absolute;width: 10px;height: 100%;left: -20px;opacity: 0.8;top: 0;border-radius: 5px;background-color: transparent;box-shadow: 0px 0px 5px rgba(50, 50, 50, 0.75);}.editInfoMarker:hover {box-shadow: 0px 0px 8px rgba(0, 0, 0, 1);}.editInfoHandle {position: absolute;background-color: black;padding: 5px;border-radius: 5px;opacity: 0.8;box-shadow: 0px 0px 5px rgba(50, 50, 50, 0.75);bottom: 100%;margin-bottom: 10px;z-index: 3;left: -25px;}.editInfoHandle:after {content: \" \";position: absolute;width: 0px;height: 0px;border-style: solid;border-width: 8.7px 5px 0 5px;border-color: black transparent transparent transparent;top: 100%;left: 5px;}.editInfo {font-family: sans-serif;font-weight: normal;font-style: normal;text-decoration: none;color: white;width: 100%;height: 12pt;}.editInfoColor {float: left;width: 10pt;height: 10pt;border: 1px solid white;}.editInfoAuthor {float: left;margin-left: 5pt;font-size: 10pt;text-align: left;height: 12pt;line-height: 12pt;}.editInfoTime {float: right;margin-left: 30pt;font-size: 8pt;font-style: italic;color: yellow;height: 12pt;line-height: 12pt;}.annotationWrapper {display: inline;position: relative;}.annotationRemoveButton:before {content: \"\\u00d7\";color: white;padding: 5px;line-height: 1em;}.annotationRemoveButton {width: 20px;height: 20px;border-radius: 10px;background-color: black;box-shadow: 0px 0px 5px rgba(50, 50, 50, 0.75);position: absolute;top: -10px;left: -10px;z-index: 3;text-align: center;font-family: sans-serif;font-style: normal;font-weight: normal;text-decoration: none;font-size: 15px;}.annotationRemoveButton:hover {cursor: pointer;box-shadow: 0px 0px 5px rgba(0, 0, 0, 1);}.annotationNote {width: 4cm;position: absolute;display: inline;z-index: 10;top: 0;}.annotationNote > office|annotation {display: block;text-align: left;}.annotationConnector {position: absolute;display: inline;top: 0;z-index: 2;border-top: 1px dashed brown;}.annotationConnector.angular {-moz-transform-origin: left top;-webkit-transform-origin: left top;-ms-transform-origin: left top;transform-origin: left top;}.annotationConnector.horizontal {left: 0;}.annotationConnector.horizontal:before {content: \"\";display: inline;position: absolute;width: 0px;height: 0px;border-style: solid;border-width: 8.7px 5px 0 5px;border-color: brown transparent transparent transparent;top: -1px;left: -5px;}office|annotation {width: 100%;height: 100%;display: none;background: rgb(198, 238, 184);background: -moz-linear-gradient(90deg, rgb(198, 238, 184) 30%, rgb(180, 196, 159) 100%);background: -webkit-linear-gradient(90deg, rgb(198, 238, 184) 30%, rgb(180, 196, 159) 100%);background: -o-linear-gradient(90deg, rgb(198, 238, 184) 30%, rgb(180, 196, 159) 100%);background: -ms-linear-gradient(90deg, rgb(198, 238, 184) 30%, rgb(180, 196, 159) 100%);background: linear-gradient(180deg, rgb(198, 238, 184) 30%, rgb(180, 196, 159) 100%);box-shadow: 0 3px 4px -3px #ccc;}office|annotation > dc|creator {display: block;font-size: 10pt;font-weight: normal;font-style: normal;font-family: sans-serif;color: white;background-color: brown;padding: 4px;}office|annotation > dc|date {display: block;font-size: 10pt;font-weight: normal;font-style: normal;font-family: sans-serif;border: 4px solid transparent;color: black;}office|annotation > text|list {display: block;padding: 5px;}office|annotation text|p {font-size: 10pt;color: black;font-weight: normal;font-style: normal;text-decoration: none;font-family: sans-serif;}#annotationsPane {background-color: #EAEAEA;width: 4cm;height: 100%;display: none;position: absolute;outline: 1px solid #ccc;}.webodf-annotationHighlight {background-color: yellow;position: relative;}.webodf-selectionOverlay {position: absolute;pointer-events: none;top: 0;left: 0;top: 0;left: 0;width: 100%;height: 100%;z-index: 15;}.webodf-selectionOverlay > polygon {fill-opacity: 0.3;stroke-opacity: 0.8;stroke-width: 1;fill-rule: evenodd;}.webodf-selectionOverlay > .webodf-draggable {fill-opacity: 0.8;stroke-opacity: 0;stroke-width: 8;pointer-events: all;display: none;-moz-transform-origin: center center;-webkit-transform-origin: center center;-ms-transform-origin: center center;transform-origin: center center;}#imageSelector {display: none;position: absolute;border-style: solid;border-color: black;}#imageSelector > div {width: 5px;height: 5px;display: block;position: absolute;border: 1px solid black;background-color: #ffffff;}#imageSelector > .topLeft {top: -4px;left: -4px;}#imageSelector > .topRight {top: -4px;right: -4px;}#imageSelector > .bottomRight {right: -4px;bottom: -4px;}#imageSelector > .bottomLeft {bottom: -4px;left: -4px;}#imageSelector > .topMiddle {top: -4px;left: 50%;margin-left: -2.5px;}#imageSelector > .rightMiddle {top: 50%;right: -4px;margin-top: -2.5px;}#imageSelector > .bottomMiddle {bottom: -4px;left: 50%;margin-left: -2.5px;}#imageSelector > .leftMiddle {top: 50%;left: -4px;margin-top: -2.5px;}div.webodf-customScrollbars::-webkit-scrollbar{width: 8px;height: 8px;background-color: transparent;}div.webodf-customScrollbars::-webkit-scrollbar-track{background-color: transparent;}div.webodf-customScrollbars::-webkit-scrollbar-thumb{background-color: #444;border-radius: 4px;}.webodf-hyperlinkTooltip {display: none;color: white;background-color: black;border-radius: 5px;box-shadow: 2px 2px 5px gray;padding: 3px;position: absolute;max-width: 210px;text-align: left;word-break: break-all;z-index: 16;}.webodf-hyperlinkTooltipText {display: block;font-weight: bold;}';\n\t/*\n\n\t @licstart\n\tJSZip - A Javascript class for generating and reading zip files\n\t<http://stuartk.com/jszip>\n\n\t(c) 2009-2014 Stuart Knightley <stuart [at] stuartk.com>\n\tDual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.\n\n\tJSZip uses the library pako released under the MIT license :\n\thttps://github.com/nodeca/pako/blob/master/LICENSE\n\t @licend\n\t*/\n\t!function(e) {\n\t    var globalScope = typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {}\n\t      , externs = globalScope.externs || (globalScope.externs = {});\n\t    externs.JSZip = e()\n\t}(function() {\n\t    var define, module, exports;\n\t    return function e(t, n, r) {\n\t        function s(o, u) {\n\t            if (!n[o]) {\n\t                if (!t[o]) {\n\t                    var a = typeof require == \"function\" && require;\n\t                    if (!u && a)\n\t                        return a(o, !0);\n\t                    if (i)\n\t                        return i(o, !0);\n\t                    throw new Error(\"Cannot find module '\" + o + \"'\");\n\t                }\n\t                var f = n[o] = {\n\t                    exports: {}\n\t                };\n\t                t[o][0].call(f.exports, function(e) {\n\t                    var n = t[o][1][e];\n\t                    return s(n ? n : e)\n\t                }, f, f.exports, e, t, n, r)\n\t            }\n\t            return n[o].exports\n\t        }\n\t        var i = typeof require == \"function\" && require;\n\t        for (var o = 0; o < r.length; o++)\n\t            s(r[o]);\n\t        return s\n\t    }({\n\t        1: [function(_dereq_, module, exports) {\n\t            var _keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\t            exports.encode = function(input, utf8) {\n\t                var output = \"\";\n\t                var chr1, chr2, chr3, enc1, enc2, enc3, enc4;\n\t                var i = 0;\n\t                while (i < input.length) {\n\t                    chr1 = input.charCodeAt(i++);\n\t                    chr2 = input.charCodeAt(i++);\n\t                    chr3 = input.charCodeAt(i++);\n\t                    enc1 = chr1 >> 2;\n\t                    enc2 = (chr1 & 3) << 4 | chr2 >> 4;\n\t                    enc3 = (chr2 & 15) << 2 | chr3 >> 6;\n\t                    enc4 = chr3 & 63;\n\t                    if (isNaN(chr2))\n\t                        enc3 = enc4 = 64;\n\t                    else if (isNaN(chr3))\n\t                        enc4 = 64;\n\t                    output = output + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4)\n\t                }\n\t                return output\n\t            }\n\t            ;\n\t            exports.decode = function(input, utf8) {\n\t                var output = \"\";\n\t                var chr1, chr2, chr3;\n\t                var enc1, enc2, enc3, enc4;\n\t                var i = 0;\n\t                input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n\t                while (i < input.length) {\n\t                    enc1 = _keyStr.indexOf(input.charAt(i++));\n\t                    enc2 = _keyStr.indexOf(input.charAt(i++));\n\t                    enc3 = _keyStr.indexOf(input.charAt(i++));\n\t                    enc4 = _keyStr.indexOf(input.charAt(i++));\n\t                    chr1 = enc1 << 2 | enc2 >> 4;\n\t                    chr2 = (enc2 & 15) << 4 | enc3 >> 2;\n\t                    chr3 = (enc3 & 3) << 6 | enc4;\n\t                    output = output + String.fromCharCode(chr1);\n\t                    if (enc3 != 64)\n\t                        output = output + String.fromCharCode(chr2);\n\t                    if (enc4 != 64)\n\t                        output = output + String.fromCharCode(chr3)\n\t                }\n\t                return output\n\t            }\n\t        }\n\t        , {}],\n\t        2: [function(_dereq_, module, exports) {\n\t            function CompressedObject() {\n\t                this.compressedSize = 0;\n\t                this.uncompressedSize = 0;\n\t                this.crc32 = 0;\n\t                this.compressionMethod = null;\n\t                this.compressedContent = null\n\t            }\n\t            CompressedObject.prototype = {\n\t                getContent: function() {\n\t                    return null\n\t                },\n\t                getCompressedContent: function() {\n\t                    return null\n\t                }\n\t            };\n\t            module.exports = CompressedObject\n\t        }\n\t        , {}],\n\t        3: [function(_dereq_, module, exports) {\n\t            exports.STORE = {\n\t                magic: \"\\x00\\x00\",\n\t                compress: function(content) {\n\t                    return content\n\t                },\n\t                uncompress: function(content) {\n\t                    return content\n\t                },\n\t                compressInputType: null,\n\t                uncompressInputType: null\n\t            };\n\t            exports.DEFLATE = _dereq_(\"./flate\")\n\t        }\n\t        , {\n\t            \"./flate\": 8\n\t        }],\n\t        4: [function(_dereq_, module, exports) {\n\t            var utils = _dereq_(\"./utils\");\n\t            var table = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918E3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117];\n\t            module.exports = function crc32(input, crc) {\n\t                if (typeof input === \"undefined\" || !input.length)\n\t                    return 0;\n\t                var isArray = utils.getTypeOf(input) !== \"string\";\n\t                if (typeof crc == \"undefined\")\n\t                    crc = 0;\n\t                var x = 0;\n\t                var y = 0;\n\t                var b = 0;\n\t                crc = crc ^ -1;\n\t                for (var i = 0, iTop = input.length; i < iTop; i++) {\n\t                    b = isArray ? input[i] : input.charCodeAt(i);\n\t                    y = (crc ^ b) & 255;\n\t                    x = table[y];\n\t                    crc = crc >>> 8 ^ x\n\t                }\n\t                return crc ^ -1\n\t            }\n\t        }\n\t        , {\n\t            \"./utils\": 21\n\t        }],\n\t        5: [function(_dereq_, module, exports) {\n\t            var utils = _dereq_(\"./utils\");\n\t            function DataReader(data) {\n\t                this.data = null;\n\t                this.length = 0;\n\t                this.index = 0\n\t            }\n\t            DataReader.prototype = {\n\t                checkOffset: function(offset) {\n\t                    this.checkIndex(this.index + offset)\n\t                },\n\t                checkIndex: function(newIndex) {\n\t                    if (this.length < newIndex || newIndex < 0)\n\t                        throw new Error(\"End of data reached (data length = \" + this.length + \", asked index = \" + newIndex + \"). Corrupted zip ?\");\n\t                },\n\t                setIndex: function(newIndex) {\n\t                    this.checkIndex(newIndex);\n\t                    this.index = newIndex\n\t                },\n\t                skip: function(n) {\n\t                    this.setIndex(this.index + n)\n\t                },\n\t                byteAt: function(i) {},\n\t                readInt: function(size) {\n\t                    var result = 0, i;\n\t                    this.checkOffset(size);\n\t                    for (i = this.index + size - 1; i >= this.index; i--)\n\t                        result = (result << 8) + this.byteAt(i);\n\t                    this.index += size;\n\t                    return result\n\t                },\n\t                readString: function(size) {\n\t                    return utils.transformTo(\"string\", this.readData(size))\n\t                },\n\t                readData: function(size) {},\n\t                lastIndexOfSignature: function(sig) {},\n\t                readDate: function() {\n\t                    var dostime = this.readInt(4);\n\t                    return new Date((dostime >> 25 & 127) + 1980,(dostime >> 21 & 15) - 1,dostime >> 16 & 31,dostime >> 11 & 31,dostime >> 5 & 63,(dostime & 31) << 1)\n\t                }\n\t            };\n\t            module.exports = DataReader\n\t        }\n\t        , {\n\t            \"./utils\": 21\n\t        }],\n\t        6: [function(_dereq_, module, exports) {\n\t            exports.base64 = false;\n\t            exports.binary = false;\n\t            exports.dir = false;\n\t            exports.createFolders = false;\n\t            exports.date = null;\n\t            exports.compression = null;\n\t            exports.comment = null\n\t        }\n\t        , {}],\n\t        7: [function(_dereq_, module, exports) {\n\t            var utils = _dereq_(\"./utils\");\n\t            exports.string2binary = function(str) {\n\t                return utils.string2binary(str)\n\t            }\n\t            ;\n\t            exports.string2Uint8Array = function(str) {\n\t                return utils.transformTo(\"uint8array\", str)\n\t            }\n\t            ;\n\t            exports.uint8Array2String = function(array) {\n\t                return utils.transformTo(\"string\", array)\n\t            }\n\t            ;\n\t            exports.string2Blob = function(str) {\n\t                var buffer = utils.transformTo(\"arraybuffer\", str);\n\t                return utils.arrayBuffer2Blob(buffer)\n\t            }\n\t            ;\n\t            exports.arrayBuffer2Blob = function(buffer) {\n\t                return utils.arrayBuffer2Blob(buffer)\n\t            }\n\t            ;\n\t            exports.transformTo = function(outputType, input) {\n\t                return utils.transformTo(outputType, input)\n\t            }\n\t            ;\n\t            exports.getTypeOf = function(input) {\n\t                return utils.getTypeOf(input)\n\t            }\n\t            ;\n\t            exports.checkSupport = function(type) {\n\t                return utils.checkSupport(type)\n\t            }\n\t            ;\n\t            exports.MAX_VALUE_16BITS = utils.MAX_VALUE_16BITS;\n\t            exports.MAX_VALUE_32BITS = utils.MAX_VALUE_32BITS;\n\t            exports.pretty = function(str) {\n\t                return utils.pretty(str)\n\t            }\n\t            ;\n\t            exports.findCompression = function(compressionMethod) {\n\t                return utils.findCompression(compressionMethod)\n\t            }\n\t            ;\n\t            exports.isRegExp = function(object) {\n\t                return utils.isRegExp(object)\n\t            }\n\t        }\n\t        , {\n\t            \"./utils\": 21\n\t        }],\n\t        8: [function(_dereq_, module, exports) {\n\t            var USE_TYPEDARRAY = typeof Uint8Array !== \"undefined\" && typeof Uint16Array !== \"undefined\" && typeof Uint32Array !== \"undefined\";\n\t            var pako = _dereq_(\"pako\");\n\t            exports.uncompressInputType = USE_TYPEDARRAY ? \"uint8array\" : \"array\";\n\t            exports.compressInputType = USE_TYPEDARRAY ? \"uint8array\" : \"array\";\n\t            exports.magic = \"\\b\\x00\";\n\t            exports.compress = function(input) {\n\t                return pako.deflateRaw(input)\n\t            }\n\t            ;\n\t            exports.uncompress = function(input) {\n\t                return pako.inflateRaw(input)\n\t            }\n\t        }\n\t        , {\n\t            \"pako\": 24\n\t        }],\n\t        9: [function(_dereq_, module, exports) {\n\t            var base64 = _dereq_(\"./base64\");\n\t            function JSZip(data, options) {\n\t                if (!(this instanceof JSZip))\n\t                    return new JSZip(data,options);\n\t                this.files = {};\n\t                this.comment = null;\n\t                this.root = \"\";\n\t                if (data)\n\t                    this.load(data, options);\n\t                this.clone = function() {\n\t                    var newObj = new JSZip;\n\t                    for (var i in this)\n\t                        if (typeof this[i] !== \"function\")\n\t                            newObj[i] = this[i];\n\t                    return newObj\n\t                }\n\t            }\n\t            JSZip.prototype = _dereq_(\"./object\");\n\t            JSZip.prototype.load = _dereq_(\"./load\");\n\t            JSZip.support = _dereq_(\"./support\");\n\t            JSZip.defaults = _dereq_(\"./defaults\");\n\t            JSZip.utils = _dereq_(\"./deprecatedPublicUtils\");\n\t            JSZip.base64 = {\n\t                encode: function(input) {\n\t                    return base64.encode(input)\n\t                },\n\t                decode: function(input) {\n\t                    return base64.decode(input)\n\t                }\n\t            };\n\t            JSZip.compressions = _dereq_(\"./compressions\");\n\t            module.exports = JSZip\n\t        }\n\t        , {\n\t            \"./base64\": 1,\n\t            \"./compressions\": 3,\n\t            \"./defaults\": 6,\n\t            \"./deprecatedPublicUtils\": 7,\n\t            \"./load\": 10,\n\t            \"./object\": 13,\n\t            \"./support\": 17\n\t        }],\n\t        10: [function(_dereq_, module, exports) {\n\t            var base64 = _dereq_(\"./base64\");\n\t            var ZipEntries = _dereq_(\"./zipEntries\");\n\t            module.exports = function(data, options) {\n\t                var files, zipEntries, i, input;\n\t                options = options || {};\n\t                if (options.base64)\n\t                    data = base64.decode(data);\n\t                zipEntries = new ZipEntries(data,options);\n\t                files = zipEntries.files;\n\t                for (i = 0; i < files.length; i++) {\n\t                    input = files[i];\n\t                    this.file(input.fileName, input.decompressed, {\n\t                        binary: true,\n\t                        optimizedBinaryString: true,\n\t                        date: input.date,\n\t                        dir: input.dir,\n\t                        comment: input.fileComment.length ? input.fileComment : null,\n\t                        createFolders: options.createFolders\n\t                    })\n\t                }\n\t                if (zipEntries.zipComment.length)\n\t                    this.comment = zipEntries.zipComment;\n\t                return this\n\t            }\n\t        }\n\t        , {\n\t            \"./base64\": 1,\n\t            \"./zipEntries\": 22\n\t        }],\n\t        11: [function(_dereq_, module, exports) {\n\t            (function(Buffer) {\n\t                module.exports = function(data, encoding) {\n\t                    return new Buffer(data,encoding)\n\t                }\n\t                ;\n\t                module.exports.test = function(b) {\n\t                    return Buffer.isBuffer(b)\n\t                }\n\t            }\n\t            ).call(this, typeof Buffer !== \"undefined\" ? Buffer : undefined)\n\t        }\n\t        , {}],\n\t        12: [function(_dereq_, module, exports) {\n\t            var Uint8ArrayReader = _dereq_(\"./uint8ArrayReader\");\n\t            function NodeBufferReader(data) {\n\t                this.data = data;\n\t                this.length = this.data.length;\n\t                this.index = 0\n\t            }\n\t            NodeBufferReader.prototype = new Uint8ArrayReader;\n\t            NodeBufferReader.prototype.readData = function(size) {\n\t                this.checkOffset(size);\n\t                var result = this.data.slice(this.index, this.index + size);\n\t                this.index += size;\n\t                return result\n\t            }\n\t            ;\n\t            module.exports = NodeBufferReader\n\t        }\n\t        , {\n\t            \"./uint8ArrayReader\": 18\n\t        }],\n\t        13: [function(_dereq_, module, exports) {\n\t            var support = _dereq_(\"./support\");\n\t            var utils = _dereq_(\"./utils\");\n\t            var crc32 = _dereq_(\"./crc32\");\n\t            var signature = _dereq_(\"./signature\");\n\t            var defaults = _dereq_(\"./defaults\");\n\t            var base64 = _dereq_(\"./base64\");\n\t            var compressions = _dereq_(\"./compressions\");\n\t            var CompressedObject = _dereq_(\"./compressedObject\");\n\t            var nodeBuffer = _dereq_(\"./nodeBuffer\");\n\t            var utf8 = _dereq_(\"./utf8\");\n\t            var StringWriter = _dereq_(\"./stringWriter\");\n\t            var Uint8ArrayWriter = _dereq_(\"./uint8ArrayWriter\");\n\t            var getRawData = function(file) {\n\t                if (file._data instanceof CompressedObject) {\n\t                    file._data = file._data.getContent();\n\t                    file.options.binary = true;\n\t                    file.options.base64 = false;\n\t                    if (utils.getTypeOf(file._data) === \"uint8array\") {\n\t                        var copy = file._data;\n\t                        file._data = new Uint8Array(copy.length);\n\t                        if (copy.length !== 0)\n\t                            file._data.set(copy, 0)\n\t                    }\n\t                }\n\t                return file._data\n\t            };\n\t            var getBinaryData = function(file) {\n\t                var result = getRawData(file)\n\t                  , type = utils.getTypeOf(result);\n\t                if (type === \"string\") {\n\t                    if (!file.options.binary)\n\t                        if (support.nodebuffer)\n\t                            return nodeBuffer(result, \"utf-8\");\n\t                    return file.asBinary()\n\t                }\n\t                return result\n\t            };\n\t            var dataToString = function(asUTF8) {\n\t                var result = getRawData(this);\n\t                if (result === null || typeof result === \"undefined\")\n\t                    return \"\";\n\t                if (this.options.base64)\n\t                    result = base64.decode(result);\n\t                if (asUTF8 && this.options.binary)\n\t                    result = out.utf8decode(result);\n\t                else\n\t                    result = utils.transformTo(\"string\", result);\n\t                if (!asUTF8 && !this.options.binary)\n\t                    result = utils.transformTo(\"string\", out.utf8encode(result));\n\t                return result\n\t            };\n\t            var ZipObject = function(name, data, options) {\n\t                this.name = name;\n\t                this.dir = options.dir;\n\t                this.date = options.date;\n\t                this.comment = options.comment;\n\t                this._data = data;\n\t                this.options = options;\n\t                this._initialMetadata = {\n\t                    dir: options.dir,\n\t                    date: options.date\n\t                }\n\t            };\n\t            ZipObject.prototype = {\n\t                asText: function() {\n\t                    return dataToString.call(this, true)\n\t                },\n\t                asBinary: function() {\n\t                    return dataToString.call(this, false)\n\t                },\n\t                asNodeBuffer: function() {\n\t                    var result = getBinaryData(this);\n\t                    return utils.transformTo(\"nodebuffer\", result)\n\t                },\n\t                asUint8Array: function() {\n\t                    var result = getBinaryData(this);\n\t                    return utils.transformTo(\"uint8array\", result)\n\t                },\n\t                asArrayBuffer: function() {\n\t                    return this.asUint8Array().buffer\n\t                }\n\t            };\n\t            var decToHex = function(dec, bytes) {\n\t                var hex = \"\", i;\n\t                for (i = 0; i < bytes; i++) {\n\t                    hex += String.fromCharCode(dec & 255);\n\t                    dec = dec >>> 8\n\t                }\n\t                return hex\n\t            };\n\t            var extend = function() {\n\t                var result = {}, i, attr;\n\t                for (i = 0; i < arguments.length; i++)\n\t                    for (attr in arguments[i])\n\t                        if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === \"undefined\")\n\t                            result[attr] = arguments[i][attr];\n\t                return result\n\t            };\n\t            var prepareFileAttrs = function(o) {\n\t                o = o || {};\n\t                if (o.base64 === true && (o.binary === null || o.binary === undefined))\n\t                    o.binary = true;\n\t                o = extend(o, defaults);\n\t                o.date = o.date || new Date;\n\t                if (o.compression !== null)\n\t                    o.compression = o.compression.toUpperCase();\n\t                return o\n\t            };\n\t            var fileAdd = function(name, data, o) {\n\t                var dataType = utils.getTypeOf(data), parent;\n\t                o = prepareFileAttrs(o);\n\t                if (o.createFolders && (parent = parentFolder(name)))\n\t                    folderAdd.call(this, parent, true);\n\t                if (o.dir || data === null || typeof data === \"undefined\") {\n\t                    o.base64 = false;\n\t                    o.binary = false;\n\t                    data = null\n\t                } else if (dataType === \"string\") {\n\t                    if (o.binary && !o.base64)\n\t                        if (o.optimizedBinaryString !== true)\n\t                            data = utils.string2binary(data)\n\t                } else {\n\t                    o.base64 = false;\n\t                    o.binary = true;\n\t                    if (!dataType && !(data instanceof CompressedObject))\n\t                        throw new Error(\"The data of '\" + name + \"' is in an unsupported format !\");\n\t                    if (dataType === \"arraybuffer\")\n\t                        data = utils.transformTo(\"uint8array\", data)\n\t                }\n\t                var object = new ZipObject(name,data,o);\n\t                this.files[name] = object;\n\t                return object\n\t            };\n\t            var parentFolder = function(path) {\n\t                if (path.slice(-1) == \"/\")\n\t                    path = path.substring(0, path.length - 1);\n\t                var lastSlash = path.lastIndexOf(\"/\");\n\t                return lastSlash > 0 ? path.substring(0, lastSlash) : \"\"\n\t            };\n\t            var folderAdd = function(name, createFolders) {\n\t                if (name.slice(-1) != \"/\")\n\t                    name += \"/\";\n\t                createFolders = typeof createFolders !== \"undefined\" ? createFolders : false;\n\t                if (!this.files[name])\n\t                    fileAdd.call(this, name, null, {\n\t                        dir: true,\n\t                        createFolders: createFolders\n\t                    });\n\t                return this.files[name]\n\t            };\n\t            var generateCompressedObjectFrom = function(file, compression) {\n\t                var result = new CompressedObject, content;\n\t                if (file._data instanceof CompressedObject) {\n\t                    result.uncompressedSize = file._data.uncompressedSize;\n\t                    result.crc32 = file._data.crc32;\n\t                    if (result.uncompressedSize === 0 || file.dir) {\n\t                        compression = compressions[\"STORE\"];\n\t                        result.compressedContent = \"\";\n\t                        result.crc32 = 0\n\t                    } else if (file._data.compressionMethod === compression.magic)\n\t                        result.compressedContent = file._data.getCompressedContent();\n\t                    else {\n\t                        content = file._data.getContent();\n\t                        result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content))\n\t                    }\n\t                } else {\n\t                    content = getBinaryData(file);\n\t                    if (!content || content.length === 0 || file.dir) {\n\t                        compression = compressions[\"STORE\"];\n\t                        content = \"\"\n\t                    }\n\t                    result.uncompressedSize = content.length;\n\t                    result.crc32 = crc32(content);\n\t                    result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content))\n\t                }\n\t                result.compressedSize = result.compressedContent.length;\n\t                result.compressionMethod = compression.magic;\n\t                return result\n\t            };\n\t            var generateZipParts = function(name, file, compressedObject, offset) {\n\t                var data = compressedObject.compressedContent, utfEncodedFileName = utils.transformTo(\"string\", utf8.utf8encode(file.name)), comment = file.comment || \"\", utfEncodedComment = utils.transformTo(\"string\", utf8.utf8encode(comment)), useUTF8ForFileName = utfEncodedFileName.length !== file.name.length, useUTF8ForComment = utfEncodedComment.length !== comment.length, o = file.options, dosTime, dosDate, extraFields = \"\", unicodePathExtraField = \"\", unicodeCommentExtraField = \"\", dir, date;\n\t                if (file._initialMetadata.dir !== file.dir)\n\t                    dir = file.dir;\n\t                else\n\t                    dir = o.dir;\n\t                if (file._initialMetadata.date !== file.date)\n\t                    date = file.date;\n\t                else\n\t                    date = o.date;\n\t                dosTime = date.getHours();\n\t                dosTime = dosTime << 6;\n\t                dosTime = dosTime | date.getMinutes();\n\t                dosTime = dosTime << 5;\n\t                dosTime = dosTime | date.getSeconds() / 2;\n\t                dosDate = date.getFullYear() - 1980;\n\t                dosDate = dosDate << 4;\n\t                dosDate = dosDate | date.getMonth() + 1;\n\t                dosDate = dosDate << 5;\n\t                dosDate = dosDate | date.getDate();\n\t                if (useUTF8ForFileName) {\n\t                    unicodePathExtraField = decToHex(1, 1) + decToHex(crc32(utfEncodedFileName), 4) + utfEncodedFileName;\n\t                    extraFields += \"up\" + decToHex(unicodePathExtraField.length, 2) + unicodePathExtraField\n\t                }\n\t                if (useUTF8ForComment) {\n\t                    unicodeCommentExtraField = decToHex(1, 1) + decToHex(this.crc32(utfEncodedComment), 4) + utfEncodedComment;\n\t                    extraFields += \"uc\" + decToHex(unicodeCommentExtraField.length, 2) + unicodeCommentExtraField\n\t                }\n\t                var header = \"\";\n\t                header += \"\\n\\x00\";\n\t                header += useUTF8ForFileName || useUTF8ForComment ? \"\\x00\\b\" : \"\\x00\\x00\";\n\t                header += compressedObject.compressionMethod;\n\t                header += decToHex(dosTime, 2);\n\t                header += decToHex(dosDate, 2);\n\t                header += decToHex(compressedObject.crc32, 4);\n\t                header += decToHex(compressedObject.compressedSize, 4);\n\t                header += decToHex(compressedObject.uncompressedSize, 4);\n\t                header += decToHex(utfEncodedFileName.length, 2);\n\t                header += decToHex(extraFields.length, 2);\n\t                var fileRecord = signature.LOCAL_FILE_HEADER + header + utfEncodedFileName + extraFields;\n\t                var dirRecord = signature.CENTRAL_FILE_HEADER + \"\\u0014\\x00\" + header + decToHex(utfEncodedComment.length, 2) + \"\\x00\\x00\" + \"\\x00\\x00\" + (dir === true ? \"\\u0010\\x00\\x00\\x00\" : \"\\x00\\x00\\x00\\x00\") + decToHex(offset, 4) + utfEncodedFileName + extraFields + utfEncodedComment;\n\t                return {\n\t                    fileRecord: fileRecord,\n\t                    dirRecord: dirRecord,\n\t                    compressedObject: compressedObject\n\t                }\n\t            };\n\t            var out = {\n\t                load: function(stream, options) {\n\t                    throw new Error(\"Load method is not defined. Is the file jszip-load.js included ?\");\n\t                },\n\t                filter: function(search) {\n\t                    var result = [], filename, relativePath, file, fileClone;\n\t                    for (filename in this.files) {\n\t                        if (!this.files.hasOwnProperty(filename))\n\t                            continue;\n\t                        file = this.files[filename];\n\t                        fileClone = new ZipObject(file.name,file._data,extend(file.options));\n\t                        relativePath = filename.slice(this.root.length, filename.length);\n\t                        if (filename.slice(0, this.root.length) === this.root && search(relativePath, fileClone))\n\t                            result.push(fileClone)\n\t                    }\n\t                    return result\n\t                },\n\t                file: function(name, data, o) {\n\t                    if (arguments.length === 1)\n\t                        if (utils.isRegExp(name)) {\n\t                            var regexp = name;\n\t                            return this.filter(function(relativePath, file) {\n\t                                return !file.dir && regexp.test(relativePath)\n\t                            })\n\t                        } else\n\t                            return this.filter(function(relativePath, file) {\n\t                                return !file.dir && relativePath === name\n\t                            })[0] || null;\n\t                    else {\n\t                        name = this.root + name;\n\t                        fileAdd.call(this, name, data, o)\n\t                    }\n\t                    return this\n\t                },\n\t                folder: function(arg) {\n\t                    if (!arg)\n\t                        return this;\n\t                    if (utils.isRegExp(arg))\n\t                        return this.filter(function(relativePath, file) {\n\t                            return file.dir && arg.test(relativePath)\n\t                        });\n\t                    var name = this.root + arg;\n\t                    var newFolder = folderAdd.call(this, name);\n\t                    var ret = this.clone();\n\t                    ret.root = newFolder.name;\n\t                    return ret\n\t                },\n\t                remove: function(name) {\n\t                    name = this.root + name;\n\t                    var file = this.files[name];\n\t                    if (!file) {\n\t                        if (name.slice(-1) != \"/\")\n\t                            name += \"/\";\n\t                        file = this.files[name]\n\t                    }\n\t                    if (file && !file.dir)\n\t                        delete this.files[name];\n\t                    else {\n\t                        var kids = this.filter(function(relativePath, file) {\n\t                            return file.name.slice(0, name.length) === name\n\t                        });\n\t                        for (var i = 0; i < kids.length; i++)\n\t                            delete this.files[kids[i].name]\n\t                    }\n\t                    return this\n\t                },\n\t                generate: function(options) {\n\t                    options = extend(options || {}, {\n\t                        base64: true,\n\t                        compression: \"STORE\",\n\t                        type: \"base64\",\n\t                        comment: null\n\t                    });\n\t                    utils.checkSupport(options.type);\n\t                    var zipData = [], localDirLength = 0, centralDirLength = 0, writer, i, utfEncodedComment = utils.transformTo(\"string\", this.utf8encode(options.comment || this.comment || \"\"));\n\t                    for (var name in this.files) {\n\t                        if (!this.files.hasOwnProperty(name))\n\t                            continue;\n\t                        var file = this.files[name];\n\t                        var compressionName = file.options.compression || options.compression.toUpperCase();\n\t                        var compression = compressions[compressionName];\n\t                        if (!compression)\n\t                            throw new Error(compressionName + \" is not a valid compression method !\");\n\t                        var compressedObject = generateCompressedObjectFrom.call(this, file, compression);\n\t                        var zipPart = generateZipParts.call(this, name, file, compressedObject, localDirLength);\n\t                        localDirLength += zipPart.fileRecord.length + compressedObject.compressedSize;\n\t                        centralDirLength += zipPart.dirRecord.length;\n\t                        zipData.push(zipPart)\n\t                    }\n\t                    var dirEnd = \"\";\n\t                    dirEnd = signature.CENTRAL_DIRECTORY_END + \"\\x00\\x00\" + \"\\x00\\x00\" + decToHex(zipData.length, 2) + decToHex(zipData.length, 2) + decToHex(centralDirLength, 4) + decToHex(localDirLength, 4) + decToHex(utfEncodedComment.length, 2) + utfEncodedComment;\n\t                    var typeName = options.type.toLowerCase();\n\t                    if (typeName === \"uint8array\" || typeName === \"arraybuffer\" || typeName === \"blob\" || typeName === \"nodebuffer\")\n\t                        writer = new Uint8ArrayWriter(localDirLength + centralDirLength + dirEnd.length);\n\t                    else\n\t                        writer = new StringWriter(localDirLength + centralDirLength + dirEnd.length);\n\t                    for (i = 0; i < zipData.length; i++) {\n\t                        writer.append(zipData[i].fileRecord);\n\t                        writer.append(zipData[i].compressedObject.compressedContent)\n\t                    }\n\t                    for (i = 0; i < zipData.length; i++)\n\t                        writer.append(zipData[i].dirRecord);\n\t                    writer.append(dirEnd);\n\t                    var zip = writer.finalize();\n\t                    switch (options.type.toLowerCase()) {\n\t                    case \"uint8array\":\n\t                    case \"arraybuffer\":\n\t                    case \"nodebuffer\":\n\t                        return utils.transformTo(options.type.toLowerCase(), zip);\n\t                    case \"blob\":\n\t                        return utils.arrayBuffer2Blob(utils.transformTo(\"arraybuffer\", zip));\n\t                    case \"base64\":\n\t                        return options.base64 ? base64.encode(zip) : zip;\n\t                    default:\n\t                        return zip\n\t                    }\n\t                },\n\t                crc32: function(input, crc) {\n\t                    return crc32(input, crc)\n\t                },\n\t                utf8encode: function(string) {\n\t                    return utils.transformTo(\"string\", utf8.utf8encode(string))\n\t                },\n\t                utf8decode: function(input) {\n\t                    return utf8.utf8decode(input)\n\t                }\n\t            };\n\t            module.exports = out\n\t        }\n\t        , {\n\t            \"./base64\": 1,\n\t            \"./compressedObject\": 2,\n\t            \"./compressions\": 3,\n\t            \"./crc32\": 4,\n\t            \"./defaults\": 6,\n\t            \"./nodeBuffer\": 11,\n\t            \"./signature\": 14,\n\t            \"./stringWriter\": 16,\n\t            \"./support\": 17,\n\t            \"./uint8ArrayWriter\": 19,\n\t            \"./utf8\": 20,\n\t            \"./utils\": 21\n\t        }],\n\t        14: [function(_dereq_, module, exports) {\n\t            exports.LOCAL_FILE_HEADER = \"PK\\u0003\\u0004\";\n\t            exports.CENTRAL_FILE_HEADER = \"PK\\u0001\\u0002\";\n\t            exports.CENTRAL_DIRECTORY_END = \"PK\\u0005\\u0006\";\n\t            exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = \"PK\\u0006\\u0007\";\n\t            exports.ZIP64_CENTRAL_DIRECTORY_END = \"PK\\u0006\\u0006\";\n\t            exports.DATA_DESCRIPTOR = \"PK\\u0007\\b\"\n\t        }\n\t        , {}],\n\t        15: [function(_dereq_, module, exports) {\n\t            var DataReader = _dereq_(\"./dataReader\");\n\t            var utils = _dereq_(\"./utils\");\n\t            function StringReader(data, optimizedBinaryString) {\n\t                this.data = data;\n\t                if (!optimizedBinaryString)\n\t                    this.data = utils.string2binary(this.data);\n\t                this.length = this.data.length;\n\t                this.index = 0\n\t            }\n\t            StringReader.prototype = new DataReader;\n\t            StringReader.prototype.byteAt = function(i) {\n\t                return this.data.charCodeAt(i)\n\t            }\n\t            ;\n\t            StringReader.prototype.lastIndexOfSignature = function(sig) {\n\t                return this.data.lastIndexOf(sig)\n\t            }\n\t            ;\n\t            StringReader.prototype.readData = function(size) {\n\t                this.checkOffset(size);\n\t                var result = this.data.slice(this.index, this.index + size);\n\t                this.index += size;\n\t                return result\n\t            }\n\t            ;\n\t            module.exports = StringReader\n\t        }\n\t        , {\n\t            \"./dataReader\": 5,\n\t            \"./utils\": 21\n\t        }],\n\t        16: [function(_dereq_, module, exports) {\n\t            var utils = _dereq_(\"./utils\");\n\t            var StringWriter = function() {\n\t                this.data = []\n\t            };\n\t            StringWriter.prototype = {\n\t                append: function(input) {\n\t                    input = utils.transformTo(\"string\", input);\n\t                    this.data.push(input)\n\t                },\n\t                finalize: function() {\n\t                    return this.data.join(\"\")\n\t                }\n\t            };\n\t            module.exports = StringWriter\n\t        }\n\t        , {\n\t            \"./utils\": 21\n\t        }],\n\t        17: [function(_dereq_, module, exports) {\n\t            (function(Buffer) {\n\t                exports.base64 = true;\n\t                exports.array = true;\n\t                exports.string = true;\n\t                exports.arraybuffer = typeof ArrayBuffer !== \"undefined\" && typeof Uint8Array !== \"undefined\";\n\t                exports.nodebuffer = typeof Buffer !== \"undefined\";\n\t                exports.uint8array = typeof Uint8Array !== \"undefined\";\n\t                if (typeof ArrayBuffer === \"undefined\")\n\t                    exports.blob = false;\n\t                else {\n\t                    var buffer = new ArrayBuffer(0);\n\t                    try {\n\t                        exports.blob = (new Blob([buffer],{\n\t                            type: \"application/zip\"\n\t                        })).size === 0\n\t                    } catch (e) {\n\t                        try {\n\t                            var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n\t                            var builder = new Builder;\n\t                            builder.append(buffer);\n\t                            exports.blob = builder.getBlob(\"application/zip\").size === 0\n\t                        } catch (e) {\n\t                            exports.blob = false\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t            ).call(this, typeof Buffer !== \"undefined\" ? Buffer : undefined)\n\t        }\n\t        , {}],\n\t        18: [function(_dereq_, module, exports) {\n\t            var DataReader = _dereq_(\"./dataReader\");\n\t            function Uint8ArrayReader(data) {\n\t                if (data) {\n\t                    this.data = data;\n\t                    this.length = this.data.length;\n\t                    this.index = 0\n\t                }\n\t            }\n\t            Uint8ArrayReader.prototype = new DataReader;\n\t            Uint8ArrayReader.prototype.byteAt = function(i) {\n\t                return this.data[i]\n\t            }\n\t            ;\n\t            Uint8ArrayReader.prototype.lastIndexOfSignature = function(sig) {\n\t                var sig0 = sig.charCodeAt(0)\n\t                  , sig1 = sig.charCodeAt(1)\n\t                  , sig2 = sig.charCodeAt(2)\n\t                  , sig3 = sig.charCodeAt(3);\n\t                for (var i = this.length - 4; i >= 0; --i)\n\t                    if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3)\n\t                        return i;\n\t                return -1\n\t            }\n\t            ;\n\t            Uint8ArrayReader.prototype.readData = function(size) {\n\t                this.checkOffset(size);\n\t                if (size === 0)\n\t                    return new Uint8Array(0);\n\t                var result = this.data.subarray(this.index, this.index + size);\n\t                this.index += size;\n\t                return result\n\t            }\n\t            ;\n\t            module.exports = Uint8ArrayReader\n\t        }\n\t        , {\n\t            \"./dataReader\": 5\n\t        }],\n\t        19: [function(_dereq_, module, exports) {\n\t            var utils = _dereq_(\"./utils\");\n\t            var Uint8ArrayWriter = function(length) {\n\t                this.data = new Uint8Array(length);\n\t                this.index = 0\n\t            };\n\t            Uint8ArrayWriter.prototype = {\n\t                append: function(input) {\n\t                    if (input.length !== 0) {\n\t                        input = utils.transformTo(\"uint8array\", input);\n\t                        this.data.set(input, this.index);\n\t                        this.index += input.length\n\t                    }\n\t                },\n\t                finalize: function() {\n\t                    return this.data\n\t                }\n\t            };\n\t            module.exports = Uint8ArrayWriter\n\t        }\n\t        , {\n\t            \"./utils\": 21\n\t        }],\n\t        20: [function(_dereq_, module, exports) {\n\t            var utils = _dereq_(\"./utils\");\n\t            var support = _dereq_(\"./support\");\n\t            var nodeBuffer = _dereq_(\"./nodeBuffer\");\n\t            var _utf8len = new Array(256);\n\t            for (var i = 0; i < 256; i++)\n\t                _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;\n\t            _utf8len[254] = _utf8len[254] = 1;\n\t            var string2buf = function(str) {\n\t                var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\t                for (m_pos = 0; m_pos < str_len; m_pos++) {\n\t                    c = str.charCodeAt(m_pos);\n\t                    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {\n\t                        c2 = str.charCodeAt(m_pos + 1);\n\t                        if ((c2 & 64512) === 56320) {\n\t                            c = 65536 + (c - 55296 << 10) + (c2 - 56320);\n\t                            m_pos++\n\t                        }\n\t                    }\n\t                    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4\n\t                }\n\t                if (support.uint8array)\n\t                    buf = new Uint8Array(buf_len);\n\t                else\n\t                    buf = new Array(buf_len);\n\t                for (i = 0,\n\t                m_pos = 0; i < buf_len; m_pos++) {\n\t                    c = str.charCodeAt(m_pos);\n\t                    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {\n\t                        c2 = str.charCodeAt(m_pos + 1);\n\t                        if ((c2 & 64512) === 56320) {\n\t                            c = 65536 + (c - 55296 << 10) + (c2 - 56320);\n\t                            m_pos++\n\t                        }\n\t                    }\n\t                    if (c < 128)\n\t                        buf[i++] = c;\n\t                    else if (c < 2048) {\n\t                        buf[i++] = 192 | c >>> 6;\n\t                        buf[i++] = 128 | c & 63\n\t                    } else if (c < 65536) {\n\t                        buf[i++] = 224 | c >>> 12;\n\t                        buf[i++] = 128 | c >>> 6 & 63;\n\t                        buf[i++] = 128 | c & 63\n\t                    } else {\n\t                        buf[i++] = 240 | c >>> 18;\n\t                        buf[i++] = 128 | c >>> 12 & 63;\n\t                        buf[i++] = 128 | c >>> 6 & 63;\n\t                        buf[i++] = 128 | c & 63\n\t                    }\n\t                }\n\t                return buf\n\t            };\n\t            var utf8border = function(buf, max) {\n\t                var pos;\n\t                max = max || buf.length;\n\t                if (max > buf.length)\n\t                    max = buf.length;\n\t                pos = max - 1;\n\t                while (pos >= 0 && (buf[pos] & 192) === 128)\n\t                    pos--;\n\t                if (pos < 0)\n\t                    return max;\n\t                if (pos === 0)\n\t                    return max;\n\t                return pos + _utf8len[buf[pos]] > max ? pos : max\n\t            };\n\t            var buf2string = function(buf) {\n\t                var str, i, out, c, c_len;\n\t                var len = buf.length;\n\t                var utf16buf = new Array(len * 2);\n\t                for (out = 0,\n\t                i = 0; i < len; ) {\n\t                    c = buf[i++];\n\t                    if (c < 128) {\n\t                        utf16buf[out++] = c;\n\t                        continue\n\t                    }\n\t                    c_len = _utf8len[c];\n\t                    if (c_len > 4) {\n\t                        utf16buf[out++] = 65533;\n\t                        i += c_len - 1;\n\t                        continue\n\t                    }\n\t                    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;\n\t                    while (c_len > 1 && i < len) {\n\t                        c = c << 6 | buf[i++] & 63;\n\t                        c_len--\n\t                    }\n\t                    if (c_len > 1) {\n\t                        utf16buf[out++] = 65533;\n\t                        continue\n\t                    }\n\t                    if (c < 65536)\n\t                        utf16buf[out++] = c;\n\t                    else {\n\t                        c -= 65536;\n\t                        utf16buf[out++] = 55296 | c >> 10 & 1023;\n\t                        utf16buf[out++] = 56320 | c & 1023\n\t                    }\n\t                }\n\t                if (utf16buf.length !== out)\n\t                    if (utf16buf.subarray)\n\t                        utf16buf = utf16buf.subarray(0, out);\n\t                    else\n\t                        utf16buf.length = out;\n\t                return utils.applyFromCharCode(utf16buf)\n\t            };\n\t            exports.utf8encode = function utf8encode(str) {\n\t                if (support.nodebuffer)\n\t                    return nodeBuffer(str, \"utf-8\");\n\t                return string2buf(str)\n\t            }\n\t            ;\n\t            exports.utf8decode = function utf8decode(buf) {\n\t                if (support.nodebuffer)\n\t                    return utils.transformTo(\"nodebuffer\", buf).toString(\"utf-8\");\n\t                buf = utils.transformTo(support.uint8array ? \"uint8array\" : \"array\", buf);\n\t                var result = []\n\t                  , k = 0\n\t                  , len = buf.length\n\t                  , chunk = 65536;\n\t                while (k < len) {\n\t                    var nextBoundary = utf8border(buf, Math.min(k + chunk, len));\n\t                    if (support.uint8array)\n\t                        result.push(buf2string(buf.subarray(k, nextBoundary)));\n\t                    else\n\t                        result.push(buf2string(buf.slice(k, nextBoundary)));\n\t                    k = nextBoundary\n\t                }\n\t                return result.join(\"\")\n\t            }\n\t        }\n\t        , {\n\t            \"./nodeBuffer\": 11,\n\t            \"./support\": 17,\n\t            \"./utils\": 21\n\t        }],\n\t        21: [function(_dereq_, module, exports) {\n\t            var support = _dereq_(\"./support\");\n\t            var compressions = _dereq_(\"./compressions\");\n\t            var nodeBuffer = _dereq_(\"./nodeBuffer\");\n\t            exports.string2binary = function(str) {\n\t                var result = \"\";\n\t                for (var i = 0; i < str.length; i++)\n\t                    result += String.fromCharCode(str.charCodeAt(i) & 255);\n\t                return result\n\t            }\n\t            ;\n\t            exports.arrayBuffer2Blob = function(buffer) {\n\t                exports.checkSupport(\"blob\");\n\t                try {\n\t                    return new Blob([buffer],{\n\t                        type: \"application/zip\"\n\t                    })\n\t                } catch (e) {\n\t                    try {\n\t                        var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n\t                        var builder = new Builder;\n\t                        builder.append(buffer);\n\t                        return builder.getBlob(\"application/zip\")\n\t                    } catch (e) {\n\t                        throw new Error(\"Bug : can't construct the Blob.\");\n\t                    }\n\t                }\n\t            }\n\t            ;\n\t            function identity(input) {\n\t                return input\n\t            }\n\t            function stringToArrayLike(str, array) {\n\t                for (var i = 0; i < str.length; ++i)\n\t                    array[i] = str.charCodeAt(i) & 255;\n\t                return array\n\t            }\n\t            function arrayLikeToString(array) {\n\t                var chunk = 65536;\n\t                var result = []\n\t                  , len = array.length\n\t                  , type = exports.getTypeOf(array)\n\t                  , k = 0\n\t                  , canUseApply = true;\n\t                try {\n\t                    switch (type) {\n\t                    case \"uint8array\":\n\t                        String.fromCharCode.apply(null, new Uint8Array(0));\n\t                        break;\n\t                    case \"nodebuffer\":\n\t                        String.fromCharCode.apply(null, nodeBuffer(0));\n\t                        break\n\t                    }\n\t                } catch (e) {\n\t                    canUseApply = false\n\t                }\n\t                if (!canUseApply) {\n\t                    var resultStr = \"\";\n\t                    for (var i = 0; i < array.length; i++)\n\t                        resultStr += String.fromCharCode(array[i]);\n\t                    return resultStr\n\t                }\n\t                while (k < len && chunk > 1)\n\t                    try {\n\t                        if (type === \"array\" || type === \"nodebuffer\")\n\t                            result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));\n\t                        else\n\t                            result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));\n\t                        k += chunk\n\t                    } catch (e) {\n\t                        chunk = Math.floor(chunk / 2)\n\t                    }\n\t                return result.join(\"\")\n\t            }\n\t            exports.applyFromCharCode = arrayLikeToString;\n\t            function arrayLikeToArrayLike(arrayFrom, arrayTo) {\n\t                for (var i = 0; i < arrayFrom.length; i++)\n\t                    arrayTo[i] = arrayFrom[i];\n\t                return arrayTo\n\t            }\n\t            var transform = {};\n\t            transform[\"string\"] = {\n\t                \"string\": identity,\n\t                \"array\": function(input) {\n\t                    return stringToArrayLike(input, new Array(input.length))\n\t                },\n\t                \"arraybuffer\": function(input) {\n\t                    return transform[\"string\"][\"uint8array\"](input).buffer\n\t                },\n\t                \"uint8array\": function(input) {\n\t                    return stringToArrayLike(input, new Uint8Array(input.length))\n\t                },\n\t                \"nodebuffer\": function(input) {\n\t                    return stringToArrayLike(input, nodeBuffer(input.length))\n\t                }\n\t            };\n\t            transform[\"array\"] = {\n\t                \"string\": arrayLikeToString,\n\t                \"array\": identity,\n\t                \"arraybuffer\": function(input) {\n\t                    return (new Uint8Array(input)).buffer\n\t                },\n\t                \"uint8array\": function(input) {\n\t                    return new Uint8Array(input)\n\t                },\n\t                \"nodebuffer\": function(input) {\n\t                    return nodeBuffer(input)\n\t                }\n\t            };\n\t            transform[\"arraybuffer\"] = {\n\t                \"string\": function(input) {\n\t                    return arrayLikeToString(new Uint8Array(input))\n\t                },\n\t                \"array\": function(input) {\n\t                    return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength))\n\t                },\n\t                \"arraybuffer\": identity,\n\t                \"uint8array\": function(input) {\n\t                    return new Uint8Array(input)\n\t                },\n\t                \"nodebuffer\": function(input) {\n\t                    return nodeBuffer(new Uint8Array(input))\n\t                }\n\t            };\n\t            transform[\"uint8array\"] = {\n\t                \"string\": arrayLikeToString,\n\t                \"array\": function(input) {\n\t                    return arrayLikeToArrayLike(input, new Array(input.length))\n\t                },\n\t                \"arraybuffer\": function(input) {\n\t                    return input.buffer\n\t                },\n\t                \"uint8array\": identity,\n\t                \"nodebuffer\": function(input) {\n\t                    return nodeBuffer(input)\n\t                }\n\t            };\n\t            transform[\"nodebuffer\"] = {\n\t                \"string\": arrayLikeToString,\n\t                \"array\": function(input) {\n\t                    return arrayLikeToArrayLike(input, new Array(input.length))\n\t                },\n\t                \"arraybuffer\": function(input) {\n\t                    return transform[\"nodebuffer\"][\"uint8array\"](input).buffer\n\t                },\n\t                \"uint8array\": function(input) {\n\t                    return arrayLikeToArrayLike(input, new Uint8Array(input.length))\n\t                },\n\t                \"nodebuffer\": identity\n\t            };\n\t            exports.transformTo = function(outputType, input) {\n\t                if (!input)\n\t                    input = \"\";\n\t                if (!outputType)\n\t                    return input;\n\t                exports.checkSupport(outputType);\n\t                var inputType = exports.getTypeOf(input);\n\t                var result = transform[inputType][outputType](input);\n\t                return result\n\t            }\n\t            ;\n\t            exports.getTypeOf = function(input) {\n\t                if (typeof input === \"string\")\n\t                    return \"string\";\n\t                if (Object.prototype.toString.call(input) === \"[object Array]\")\n\t                    return \"array\";\n\t                if (support.nodebuffer && nodeBuffer.test(input))\n\t                    return \"nodebuffer\";\n\t                if (support.uint8array && input instanceof Uint8Array)\n\t                    return \"uint8array\";\n\t                if (support.arraybuffer && input instanceof ArrayBuffer)\n\t                    return \"arraybuffer\"\n\t            }\n\t            ;\n\t            exports.checkSupport = function(type) {\n\t                var supported = support[type.toLowerCase()];\n\t                if (!supported)\n\t                    throw new Error(type + \" is not supported by this browser\");\n\t            }\n\t            ;\n\t            exports.MAX_VALUE_16BITS = 65535;\n\t            exports.MAX_VALUE_32BITS = -1;\n\t            exports.pretty = function(str) {\n\t                var res = \"\", code, i;\n\t                for (i = 0; i < (str || \"\").length; i++) {\n\t                    code = str.charCodeAt(i);\n\t                    res += \"\\\\x\" + (code < 16 ? \"0\" : \"\") + code.toString(16).toUpperCase()\n\t                }\n\t                return res\n\t            }\n\t            ;\n\t            exports.findCompression = function(compressionMethod) {\n\t                for (var method in compressions) {\n\t                    if (!compressions.hasOwnProperty(method))\n\t                        continue;\n\t                    if (compressions[method].magic === compressionMethod)\n\t                        return compressions[method]\n\t                }\n\t                return null\n\t            }\n\t            ;\n\t            exports.isRegExp = function(object) {\n\t                return Object.prototype.toString.call(object) === \"[object RegExp]\"\n\t            }\n\t        }\n\t        , {\n\t            \"./compressions\": 3,\n\t            \"./nodeBuffer\": 11,\n\t            \"./support\": 17\n\t        }],\n\t        22: [function(_dereq_, module, exports) {\n\t            var StringReader = _dereq_(\"./stringReader\");\n\t            var NodeBufferReader = _dereq_(\"./nodeBufferReader\");\n\t            var Uint8ArrayReader = _dereq_(\"./uint8ArrayReader\");\n\t            var utils = _dereq_(\"./utils\");\n\t            var sig = _dereq_(\"./signature\");\n\t            var ZipEntry = _dereq_(\"./zipEntry\");\n\t            var support = _dereq_(\"./support\");\n\t            var jszipProto = _dereq_(\"./object\");\n\t            function ZipEntries(data, loadOptions) {\n\t                this.files = [];\n\t                this.loadOptions = loadOptions;\n\t                if (data)\n\t                    this.load(data)\n\t            }\n\t            ZipEntries.prototype = {\n\t                checkSignature: function(expectedSignature) {\n\t                    var signature = this.reader.readString(4);\n\t                    if (signature !== expectedSignature)\n\t                        throw new Error(\"Corrupted zip or bug : unexpected signature \" + \"(\" + utils.pretty(signature) + \", expected \" + utils.pretty(expectedSignature) + \")\");\n\t                },\n\t                readBlockEndOfCentral: function() {\n\t                    this.diskNumber = this.reader.readInt(2);\n\t                    this.diskWithCentralDirStart = this.reader.readInt(2);\n\t                    this.centralDirRecordsOnThisDisk = this.reader.readInt(2);\n\t                    this.centralDirRecords = this.reader.readInt(2);\n\t                    this.centralDirSize = this.reader.readInt(4);\n\t                    this.centralDirOffset = this.reader.readInt(4);\n\t                    this.zipCommentLength = this.reader.readInt(2);\n\t                    this.zipComment = this.reader.readString(this.zipCommentLength);\n\t                    this.zipComment = jszipProto.utf8decode(this.zipComment)\n\t                },\n\t                readBlockZip64EndOfCentral: function() {\n\t                    this.zip64EndOfCentralSize = this.reader.readInt(8);\n\t                    this.versionMadeBy = this.reader.readString(2);\n\t                    this.versionNeeded = this.reader.readInt(2);\n\t                    this.diskNumber = this.reader.readInt(4);\n\t                    this.diskWithCentralDirStart = this.reader.readInt(4);\n\t                    this.centralDirRecordsOnThisDisk = this.reader.readInt(8);\n\t                    this.centralDirRecords = this.reader.readInt(8);\n\t                    this.centralDirSize = this.reader.readInt(8);\n\t                    this.centralDirOffset = this.reader.readInt(8);\n\t                    this.zip64ExtensibleData = {};\n\t                    var extraDataSize = this.zip64EndOfCentralSize - 44, index = 0, extraFieldId, extraFieldLength, extraFieldValue;\n\t                    while (index < extraDataSize) {\n\t                        extraFieldId = this.reader.readInt(2);\n\t                        extraFieldLength = this.reader.readInt(4);\n\t                        extraFieldValue = this.reader.readString(extraFieldLength);\n\t                        this.zip64ExtensibleData[extraFieldId] = {\n\t                            id: extraFieldId,\n\t                            length: extraFieldLength,\n\t                            value: extraFieldValue\n\t                        }\n\t                    }\n\t                },\n\t                readBlockZip64EndOfCentralLocator: function() {\n\t                    this.diskWithZip64CentralDirStart = this.reader.readInt(4);\n\t                    this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);\n\t                    this.disksCount = this.reader.readInt(4);\n\t                    if (this.disksCount > 1)\n\t                        throw new Error(\"Multi-volumes zip are not supported\");\n\t                },\n\t                readLocalFiles: function() {\n\t                    var i, file;\n\t                    for (i = 0; i < this.files.length; i++) {\n\t                        file = this.files[i];\n\t                        this.reader.setIndex(file.localHeaderOffset);\n\t                        this.checkSignature(sig.LOCAL_FILE_HEADER);\n\t                        file.readLocalPart(this.reader);\n\t                        file.handleUTF8()\n\t                    }\n\t                },\n\t                readCentralDir: function() {\n\t                    var file;\n\t                    this.reader.setIndex(this.centralDirOffset);\n\t                    while (this.reader.readString(4) === sig.CENTRAL_FILE_HEADER) {\n\t                        file = new ZipEntry({\n\t                            zip64: this.zip64\n\t                        },this.loadOptions);\n\t                        file.readCentralPart(this.reader);\n\t                        this.files.push(file)\n\t                    }\n\t                },\n\t                readEndOfCentral: function() {\n\t                    var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);\n\t                    if (offset === -1)\n\t                        throw new Error(\"Corrupted zip : can't find end of central directory\");\n\t                    this.reader.setIndex(offset);\n\t                    this.checkSignature(sig.CENTRAL_DIRECTORY_END);\n\t                    this.readBlockEndOfCentral();\n\t                    if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {\n\t                        this.zip64 = true;\n\t                        offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);\n\t                        if (offset === -1)\n\t                            throw new Error(\"Corrupted zip : can't find the ZIP64 end of central directory locator\");\n\t                        this.reader.setIndex(offset);\n\t                        this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);\n\t                        this.readBlockZip64EndOfCentralLocator();\n\t                        this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);\n\t                        this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);\n\t                        this.readBlockZip64EndOfCentral()\n\t                    }\n\t                },\n\t                prepareReader: function(data) {\n\t                    var type = utils.getTypeOf(data);\n\t                    if (type === \"string\" && !support.uint8array)\n\t                        this.reader = new StringReader(data,this.loadOptions.optimizedBinaryString);\n\t                    else if (type === \"nodebuffer\")\n\t                        this.reader = new NodeBufferReader(data);\n\t                    else\n\t                        this.reader = new Uint8ArrayReader(utils.transformTo(\"uint8array\", data))\n\t                },\n\t                load: function(data) {\n\t                    this.prepareReader(data);\n\t                    this.readEndOfCentral();\n\t                    this.readCentralDir();\n\t                    this.readLocalFiles()\n\t                }\n\t            };\n\t            module.exports = ZipEntries\n\t        }\n\t        , {\n\t            \"./nodeBufferReader\": 12,\n\t            \"./object\": 13,\n\t            \"./signature\": 14,\n\t            \"./stringReader\": 15,\n\t            \"./support\": 17,\n\t            \"./uint8ArrayReader\": 18,\n\t            \"./utils\": 21,\n\t            \"./zipEntry\": 23\n\t        }],\n\t        23: [function(_dereq_, module, exports) {\n\t            var StringReader = _dereq_(\"./stringReader\");\n\t            var utils = _dereq_(\"./utils\");\n\t            var CompressedObject = _dereq_(\"./compressedObject\");\n\t            var jszipProto = _dereq_(\"./object\");\n\t            function ZipEntry(options, loadOptions) {\n\t                this.options = options;\n\t                this.loadOptions = loadOptions\n\t            }\n\t            ZipEntry.prototype = {\n\t                isEncrypted: function() {\n\t                    return (this.bitFlag & 1) === 1\n\t                },\n\t                useUTF8: function() {\n\t                    return (this.bitFlag & 2048) === 2048\n\t                },\n\t                prepareCompressedContent: function(reader, from, length) {\n\t                    return function() {\n\t                        var previousIndex = reader.index;\n\t                        reader.setIndex(from);\n\t                        var compressedFileData = reader.readData(length);\n\t                        reader.setIndex(previousIndex);\n\t                        return compressedFileData\n\t                    }\n\t                },\n\t                prepareContent: function(reader, from, length, compression, uncompressedSize) {\n\t                    return function() {\n\t                        var compressedFileData = utils.transformTo(compression.uncompressInputType, this.getCompressedContent());\n\t                        var uncompressedFileData = compression.uncompress(compressedFileData);\n\t                        if (uncompressedFileData.length !== uncompressedSize)\n\t                            throw new Error(\"Bug : uncompressed data size mismatch\");\n\t                        return uncompressedFileData\n\t                    }\n\t                },\n\t                readLocalPart: function(reader) {\n\t                    var compression, localExtraFieldsLength;\n\t                    reader.skip(22);\n\t                    this.fileNameLength = reader.readInt(2);\n\t                    localExtraFieldsLength = reader.readInt(2);\n\t                    this.fileName = reader.readString(this.fileNameLength);\n\t                    reader.skip(localExtraFieldsLength);\n\t                    if (this.compressedSize == -1 || this.uncompressedSize == -1)\n\t                        throw new Error(\"Bug or corrupted zip : didn't get enough informations from the central directory \" + \"(compressedSize == -1 || uncompressedSize == -1)\");\n\t                    compression = utils.findCompression(this.compressionMethod);\n\t                    if (compression === null)\n\t                        throw new Error(\"Corrupted zip : compression \" + utils.pretty(this.compressionMethod) + \" unknown (inner file : \" + this.fileName + \")\");\n\t                    this.decompressed = new CompressedObject;\n\t                    this.decompressed.compressedSize = this.compressedSize;\n\t                    this.decompressed.uncompressedSize = this.uncompressedSize;\n\t                    this.decompressed.crc32 = this.crc32;\n\t                    this.decompressed.compressionMethod = this.compressionMethod;\n\t                    this.decompressed.getCompressedContent = this.prepareCompressedContent(reader, reader.index, this.compressedSize, compression);\n\t                    this.decompressed.getContent = this.prepareContent(reader, reader.index, this.compressedSize, compression, this.uncompressedSize);\n\t                    if (this.loadOptions.checkCRC32) {\n\t                        this.decompressed = utils.transformTo(\"string\", this.decompressed.getContent());\n\t                        if (jszipProto.crc32(this.decompressed) !== this.crc32)\n\t                            throw new Error(\"Corrupted zip : CRC32 mismatch\");\n\t                    }\n\t                },\n\t                readCentralPart: function(reader) {\n\t                    this.versionMadeBy = reader.readString(2);\n\t                    this.versionNeeded = reader.readInt(2);\n\t                    this.bitFlag = reader.readInt(2);\n\t                    this.compressionMethod = reader.readString(2);\n\t                    this.date = reader.readDate();\n\t                    this.crc32 = reader.readInt(4);\n\t                    this.compressedSize = reader.readInt(4);\n\t                    this.uncompressedSize = reader.readInt(4);\n\t                    this.fileNameLength = reader.readInt(2);\n\t                    this.extraFieldsLength = reader.readInt(2);\n\t                    this.fileCommentLength = reader.readInt(2);\n\t                    this.diskNumberStart = reader.readInt(2);\n\t                    this.internalFileAttributes = reader.readInt(2);\n\t                    this.externalFileAttributes = reader.readInt(4);\n\t                    this.localHeaderOffset = reader.readInt(4);\n\t                    if (this.isEncrypted())\n\t                        throw new Error(\"Encrypted zip are not supported\");\n\t                    this.fileName = reader.readString(this.fileNameLength);\n\t                    this.readExtraFields(reader);\n\t                    this.parseZIP64ExtraField(reader);\n\t                    this.fileComment = reader.readString(this.fileCommentLength);\n\t                    this.dir = this.externalFileAttributes & 16 ? true : false\n\t                },\n\t                parseZIP64ExtraField: function(reader) {\n\t                    if (!this.extraFields[1])\n\t                        return;\n\t                    var extraReader = new StringReader(this.extraFields[1].value);\n\t                    if (this.uncompressedSize === utils.MAX_VALUE_32BITS)\n\t                        this.uncompressedSize = extraReader.readInt(8);\n\t                    if (this.compressedSize === utils.MAX_VALUE_32BITS)\n\t                        this.compressedSize = extraReader.readInt(8);\n\t                    if (this.localHeaderOffset === utils.MAX_VALUE_32BITS)\n\t                        this.localHeaderOffset = extraReader.readInt(8);\n\t                    if (this.diskNumberStart === utils.MAX_VALUE_32BITS)\n\t                        this.diskNumberStart = extraReader.readInt(4)\n\t                },\n\t                readExtraFields: function(reader) {\n\t                    var start = reader.index, extraFieldId, extraFieldLength, extraFieldValue;\n\t                    this.extraFields = this.extraFields || {};\n\t                    while (reader.index < start + this.extraFieldsLength) {\n\t                        extraFieldId = reader.readInt(2);\n\t                        extraFieldLength = reader.readInt(2);\n\t                        extraFieldValue = reader.readString(extraFieldLength);\n\t                        this.extraFields[extraFieldId] = {\n\t                            id: extraFieldId,\n\t                            length: extraFieldLength,\n\t                            value: extraFieldValue\n\t                        }\n\t                    }\n\t                },\n\t                handleUTF8: function() {\n\t                    if (this.useUTF8()) {\n\t                        this.fileName = jszipProto.utf8decode(this.fileName);\n\t                        this.fileComment = jszipProto.utf8decode(this.fileComment)\n\t                    } else {\n\t                        var upath = this.findExtraFieldUnicodePath();\n\t                        if (upath !== null)\n\t                            this.fileName = upath;\n\t                        var ucomment = this.findExtraFieldUnicodeComment();\n\t                        if (ucomment !== null)\n\t                            this.fileComment = ucomment\n\t                    }\n\t                },\n\t                findExtraFieldUnicodePath: function() {\n\t                    var upathField = this.extraFields[28789];\n\t                    if (upathField) {\n\t                        var extraReader = new StringReader(upathField.value);\n\t                        if (extraReader.readInt(1) !== 1)\n\t                            return null;\n\t                        if (jszipProto.crc32(this.fileName) !== extraReader.readInt(4))\n\t                            return null;\n\t                        return jszipProto.utf8decode(extraReader.readString(upathField.length - 5))\n\t                    }\n\t                    return null\n\t                },\n\t                findExtraFieldUnicodeComment: function() {\n\t                    var ucommentField = this.extraFields[25461];\n\t                    if (ucommentField) {\n\t                        var extraReader = new StringReader(ucommentField.value);\n\t                        if (extraReader.readInt(1) !== 1)\n\t                            return null;\n\t                        if (jszipProto.crc32(this.fileComment) !== extraReader.readInt(4))\n\t                            return null;\n\t                        return jszipProto.utf8decode(extraReader.readString(ucommentField.length - 5))\n\t                    }\n\t                    return null\n\t                }\n\t            };\n\t            module.exports = ZipEntry\n\t        }\n\t        , {\n\t            \"./compressedObject\": 2,\n\t            \"./object\": 13,\n\t            \"./stringReader\": 15,\n\t            \"./utils\": 21\n\t        }],\n\t        24: [function(_dereq_, module, exports) {\n\t            var assign = _dereq_(\"./lib/utils/common\").assign;\n\t            var deflate = _dereq_(\"./lib/deflate\");\n\t            var inflate = _dereq_(\"./lib/inflate\");\n\t            var constants = _dereq_(\"./lib/zlib/constants\");\n\t            var pako = {};\n\t            assign(pako, deflate, inflate, constants);\n\t            module.exports = pako\n\t        }\n\t        , {\n\t            \"./lib/deflate\": 25,\n\t            \"./lib/inflate\": 26,\n\t            \"./lib/utils/common\": 27,\n\t            \"./lib/zlib/constants\": 30\n\t        }],\n\t        25: [function(_dereq_, module, exports) {\n\t            var zlib_deflate = _dereq_(\"./zlib/deflate.js\");\n\t            var utils = _dereq_(\"./utils/common\");\n\t            var strings = _dereq_(\"./utils/strings\");\n\t            var msg = _dereq_(\"./zlib/messages\");\n\t            var zstream = _dereq_(\"./zlib/zstream\");\n\t            var Z_NO_FLUSH = 0;\n\t            var Z_FINISH = 4;\n\t            var Z_OK = 0;\n\t            var Z_STREAM_END = 1;\n\t            var Z_DEFAULT_COMPRESSION = -1;\n\t            var Z_DEFAULT_STRATEGY = 0;\n\t            var Z_DEFLATED = 8;\n\t            var Deflate = function(options) {\n\t                this.options = utils.assign({\n\t                    level: Z_DEFAULT_COMPRESSION,\n\t                    method: Z_DEFLATED,\n\t                    chunkSize: 16384,\n\t                    windowBits: 15,\n\t                    memLevel: 8,\n\t                    strategy: Z_DEFAULT_STRATEGY,\n\t                    to: \"\"\n\t                }, options || {});\n\t                var opt = this.options;\n\t                if (opt.raw && opt.windowBits > 0)\n\t                    opt.windowBits = -opt.windowBits;\n\t                else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16)\n\t                    opt.windowBits += 16;\n\t                this.err = 0;\n\t                this.msg = \"\";\n\t                this.ended = false;\n\t                this.chunks = [];\n\t                this.strm = new zstream;\n\t                this.strm.avail_out = 0;\n\t                var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);\n\t                if (status !== Z_OK)\n\t                    throw new Error(msg[status]);\n\t                if (opt.header)\n\t                    zlib_deflate.deflateSetHeader(this.strm, opt.header)\n\t            };\n\t            Deflate.prototype.push = function(data, mode) {\n\t                var strm = this.strm;\n\t                var chunkSize = this.options.chunkSize;\n\t                var status, _mode;\n\t                if (this.ended)\n\t                    return false;\n\t                _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;\n\t                if (typeof data === \"string\")\n\t                    strm.input = strings.string2buf(data);\n\t                else\n\t                    strm.input = data;\n\t                strm.next_in = 0;\n\t                strm.avail_in = strm.input.length;\n\t                do {\n\t                    if (strm.avail_out === 0) {\n\t                        strm.output = new utils.Buf8(chunkSize);\n\t                        strm.next_out = 0;\n\t                        strm.avail_out = chunkSize\n\t                    }\n\t                    status = zlib_deflate.deflate(strm, _mode);\n\t                    if (status !== Z_STREAM_END && status !== Z_OK) {\n\t                        this.onEnd(status);\n\t                        this.ended = true;\n\t                        return false\n\t                    }\n\t                    if (strm.avail_out === 0 || strm.avail_in === 0 && _mode === Z_FINISH)\n\t                        if (this.options.to === \"string\")\n\t                            this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));\n\t                        else\n\t                            this.onData(utils.shrinkBuf(strm.output, strm.next_out))\n\t                } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);\n\t                if (_mode === Z_FINISH) {\n\t                    status = zlib_deflate.deflateEnd(this.strm);\n\t                    this.onEnd(status);\n\t                    this.ended = true;\n\t                    return status === Z_OK\n\t                }\n\t                return true\n\t            }\n\t            ;\n\t            Deflate.prototype.onData = function(chunk) {\n\t                this.chunks.push(chunk)\n\t            }\n\t            ;\n\t            Deflate.prototype.onEnd = function(status) {\n\t                if (status === Z_OK)\n\t                    if (this.options.to === \"string\")\n\t                        this.result = this.chunks.join(\"\");\n\t                    else\n\t                        this.result = utils.flattenChunks(this.chunks);\n\t                this.chunks = [];\n\t                this.err = status;\n\t                this.msg = this.strm.msg\n\t            }\n\t            ;\n\t            function deflate(input, options) {\n\t                var deflator = new Deflate(options);\n\t                deflator.push(input, true);\n\t                if (deflator.err)\n\t                    throw deflator.msg;\n\t                return deflator.result\n\t            }\n\t            function deflateRaw(input, options) {\n\t                options = options || {};\n\t                options.raw = true;\n\t                return deflate(input, options)\n\t            }\n\t            function gzip(input, options) {\n\t                options = options || {};\n\t                options.gzip = true;\n\t                return deflate(input, options)\n\t            }\n\t            exports.Deflate = Deflate;\n\t            exports.deflate = deflate;\n\t            exports.deflateRaw = deflateRaw;\n\t            exports.gzip = gzip\n\t        }\n\t        , {\n\t            \"./utils/common\": 27,\n\t            \"./utils/strings\": 28,\n\t            \"./zlib/deflate.js\": 32,\n\t            \"./zlib/messages\": 37,\n\t            \"./zlib/zstream\": 39\n\t        }],\n\t        26: [function(_dereq_, module, exports) {\n\t            var zlib_inflate = _dereq_(\"./zlib/inflate.js\");\n\t            var utils = _dereq_(\"./utils/common\");\n\t            var strings = _dereq_(\"./utils/strings\");\n\t            var c = _dereq_(\"./zlib/constants\");\n\t            var msg = _dereq_(\"./zlib/messages\");\n\t            var zstream = _dereq_(\"./zlib/zstream\");\n\t            var gzheader = _dereq_(\"./zlib/gzheader\");\n\t            var Inflate = function(options) {\n\t                this.options = utils.assign({\n\t                    chunkSize: 16384,\n\t                    windowBits: 0,\n\t                    to: \"\"\n\t                }, options || {});\n\t                var opt = this.options;\n\t                if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {\n\t                    opt.windowBits = -opt.windowBits;\n\t                    if (opt.windowBits === 0)\n\t                        opt.windowBits = -15\n\t                }\n\t                if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits))\n\t                    opt.windowBits += 32;\n\t                if (opt.windowBits > 15 && opt.windowBits < 48)\n\t                    if ((opt.windowBits & 15) === 0)\n\t                        opt.windowBits |= 15;\n\t                this.err = 0;\n\t                this.msg = \"\";\n\t                this.ended = false;\n\t                this.chunks = [];\n\t                this.strm = new zstream;\n\t                this.strm.avail_out = 0;\n\t                var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);\n\t                if (status !== c.Z_OK)\n\t                    throw new Error(msg[status]);\n\t                this.header = new gzheader;\n\t                zlib_inflate.inflateGetHeader(this.strm, this.header)\n\t            };\n\t            Inflate.prototype.push = function(data, mode) {\n\t                var strm = this.strm;\n\t                var chunkSize = this.options.chunkSize;\n\t                var status, _mode;\n\t                var next_out_utf8, tail, utf8str;\n\t                if (this.ended)\n\t                    return false;\n\t                _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;\n\t                if (typeof data === \"string\")\n\t                    strm.input = strings.binstring2buf(data);\n\t                else\n\t                    strm.input = data;\n\t                strm.next_in = 0;\n\t                strm.avail_in = strm.input.length;\n\t                do {\n\t                    if (strm.avail_out === 0) {\n\t                        strm.output = new utils.Buf8(chunkSize);\n\t                        strm.next_out = 0;\n\t                        strm.avail_out = chunkSize\n\t                    }\n\t                    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);\n\t                    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {\n\t                        this.onEnd(status);\n\t                        this.ended = true;\n\t                        return false\n\t                    }\n\t                    if (strm.next_out)\n\t                        if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && _mode === c.Z_FINISH)\n\t                            if (this.options.to === \"string\") {\n\t                                next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n\t                                tail = strm.next_out - next_out_utf8;\n\t                                utf8str = strings.buf2string(strm.output, next_out_utf8);\n\t                                strm.next_out = tail;\n\t                                strm.avail_out = chunkSize - tail;\n\t                                if (tail)\n\t                                    utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);\n\t                                this.onData(utf8str)\n\t                            } else\n\t                                this.onData(utils.shrinkBuf(strm.output, strm.next_out))\n\t                } while (strm.avail_in > 0 && status !== c.Z_STREAM_END);\n\t                if (status === c.Z_STREAM_END)\n\t                    _mode = c.Z_FINISH;\n\t                if (_mode === c.Z_FINISH) {\n\t                    status = zlib_inflate.inflateEnd(this.strm);\n\t                    this.onEnd(status);\n\t                    this.ended = true;\n\t                    return status === c.Z_OK\n\t                }\n\t                return true\n\t            }\n\t            ;\n\t            Inflate.prototype.onData = function(chunk) {\n\t                this.chunks.push(chunk)\n\t            }\n\t            ;\n\t            Inflate.prototype.onEnd = function(status) {\n\t                if (status === c.Z_OK)\n\t                    if (this.options.to === \"string\")\n\t                        this.result = this.chunks.join(\"\");\n\t                    else\n\t                        this.result = utils.flattenChunks(this.chunks);\n\t                this.chunks = [];\n\t                this.err = status;\n\t                this.msg = this.strm.msg\n\t            }\n\t            ;\n\t            function inflate(input, options) {\n\t                var inflator = new Inflate(options);\n\t                inflator.push(input, true);\n\t                if (inflator.err)\n\t                    throw inflator.msg;\n\t                return inflator.result\n\t            }\n\t            function inflateRaw(input, options) {\n\t                options = options || {};\n\t                options.raw = true;\n\t                return inflate(input, options)\n\t            }\n\t            exports.Inflate = Inflate;\n\t            exports.inflate = inflate;\n\t            exports.inflateRaw = inflateRaw;\n\t            exports.ungzip = inflate\n\t        }\n\t        , {\n\t            \"./utils/common\": 27,\n\t            \"./utils/strings\": 28,\n\t            \"./zlib/constants\": 30,\n\t            \"./zlib/gzheader\": 33,\n\t            \"./zlib/inflate.js\": 35,\n\t            \"./zlib/messages\": 37,\n\t            \"./zlib/zstream\": 39\n\t        }],\n\t        27: [function(_dereq_, module, exports) {\n\t            var TYPED_OK = typeof Uint8Array !== \"undefined\" && typeof Uint16Array !== \"undefined\" && typeof Int32Array !== \"undefined\";\n\t            exports.assign = function(obj) {\n\t                var sources = Array.prototype.slice.call(arguments, 1);\n\t                while (sources.length) {\n\t                    var source = sources.shift();\n\t                    if (!source)\n\t                        continue;\n\t                    if (typeof source !== \"object\")\n\t                        throw new TypeError(source + \"must be non-object\");\n\t                    for (var p in source)\n\t                        if (source.hasOwnProperty(p))\n\t                            obj[p] = source[p]\n\t                }\n\t                return obj\n\t            }\n\t            ;\n\t            exports.shrinkBuf = function(buf, size) {\n\t                if (buf.length === size)\n\t                    return buf;\n\t                if (buf.subarray)\n\t                    return buf.subarray(0, size);\n\t                buf.length = size;\n\t                return buf\n\t            }\n\t            ;\n\t            var fnTyped = {\n\t                arraySet: function(dest, src, src_offs, len, dest_offs) {\n\t                    if (src.subarray && dest.subarray) {\n\t                        dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n\t                        return\n\t                    }\n\t                    for (var i = 0; i < len; i++)\n\t                        dest[dest_offs + i] = src[src_offs + i]\n\t                },\n\t                flattenChunks: function(chunks) {\n\t                    var i, l, len, pos, chunk, result;\n\t                    len = 0;\n\t                    for (i = 0,\n\t                    l = chunks.length; i < l; i++)\n\t                        len += chunks[i].length;\n\t                    result = new Uint8Array(len);\n\t                    pos = 0;\n\t                    for (i = 0,\n\t                    l = chunks.length; i < l; i++) {\n\t                        chunk = chunks[i];\n\t                        result.set(chunk, pos);\n\t                        pos += chunk.length\n\t                    }\n\t                    return result\n\t                }\n\t            };\n\t            var fnUntyped = {\n\t                arraySet: function(dest, src, src_offs, len, dest_offs) {\n\t                    for (var i = 0; i < len; i++)\n\t                        dest[dest_offs + i] = src[src_offs + i]\n\t                },\n\t                flattenChunks: function(chunks) {\n\t                    return [].concat.apply([], chunks)\n\t                }\n\t            };\n\t            exports.setTyped = function(on) {\n\t                if (on) {\n\t                    exports.Buf8 = Uint8Array;\n\t                    exports.Buf16 = Uint16Array;\n\t                    exports.Buf32 = Int32Array;\n\t                    exports.assign(exports, fnTyped)\n\t                } else {\n\t                    exports.Buf8 = Array;\n\t                    exports.Buf16 = Array;\n\t                    exports.Buf32 = Array;\n\t                    exports.assign(exports, fnUntyped)\n\t                }\n\t            }\n\t            ;\n\t            exports.setTyped(TYPED_OK)\n\t        }\n\t        , {}],\n\t        28: [function(_dereq_, module, exports) {\n\t            var utils = _dereq_(\"./common\");\n\t            var STR_APPLY_OK = true;\n\t            var STR_APPLY_UIA_OK = true;\n\t            try {\n\t                String.fromCharCode.apply(null, [0])\n\t            } catch (__) {\n\t                STR_APPLY_OK = false\n\t            }\n\t            try {\n\t                String.fromCharCode.apply(null, new Uint8Array(1))\n\t            } catch (__) {\n\t                STR_APPLY_UIA_OK = false\n\t            }\n\t            var _utf8len = new utils.Buf8(256);\n\t            for (var i = 0; i < 256; i++)\n\t                _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;\n\t            _utf8len[254] = _utf8len[254] = 1;\n\t            exports.string2buf = function(str) {\n\t                var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\t                for (m_pos = 0; m_pos < str_len; m_pos++) {\n\t                    c = str.charCodeAt(m_pos);\n\t                    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {\n\t                        c2 = str.charCodeAt(m_pos + 1);\n\t                        if ((c2 & 64512) === 56320) {\n\t                            c = 65536 + (c - 55296 << 10) + (c2 - 56320);\n\t                            m_pos++\n\t                        }\n\t                    }\n\t                    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4\n\t                }\n\t                buf = new utils.Buf8(buf_len);\n\t                for (i = 0,\n\t                m_pos = 0; i < buf_len; m_pos++) {\n\t                    c = str.charCodeAt(m_pos);\n\t                    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {\n\t                        c2 = str.charCodeAt(m_pos + 1);\n\t                        if ((c2 & 64512) === 56320) {\n\t                            c = 65536 + (c - 55296 << 10) + (c2 - 56320);\n\t                            m_pos++\n\t                        }\n\t                    }\n\t                    if (c < 128)\n\t                        buf[i++] = c;\n\t                    else if (c < 2048) {\n\t                        buf[i++] = 192 | c >>> 6;\n\t                        buf[i++] = 128 | c & 63\n\t                    } else if (c < 65536) {\n\t                        buf[i++] = 224 | c >>> 12;\n\t                        buf[i++] = 128 | c >>> 6 & 63;\n\t                        buf[i++] = 128 | c & 63\n\t                    } else {\n\t                        buf[i++] = 240 | c >>> 18;\n\t                        buf[i++] = 128 | c >>> 12 & 63;\n\t                        buf[i++] = 128 | c >>> 6 & 63;\n\t                        buf[i++] = 128 | c & 63\n\t                    }\n\t                }\n\t                return buf\n\t            }\n\t            ;\n\t            function buf2binstring(buf, len) {\n\t                if (len < 65537)\n\t                    if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK)\n\t                        return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));\n\t                var result = \"\";\n\t                for (var i = 0; i < len; i++)\n\t                    result += String.fromCharCode(buf[i]);\n\t                return result\n\t            }\n\t            exports.buf2binstring = function(buf) {\n\t                return buf2binstring(buf, buf.length)\n\t            }\n\t            ;\n\t            exports.binstring2buf = function(str) {\n\t                var buf = new utils.Buf8(str.length);\n\t                for (var i = 0, len = buf.length; i < len; i++)\n\t                    buf[i] = str.charCodeAt(i);\n\t                return buf\n\t            }\n\t            ;\n\t            exports.buf2string = function(buf, max) {\n\t                var i, out, c, c_len;\n\t                var len = max || buf.length;\n\t                var utf16buf = new Array(len * 2);\n\t                for (out = 0,\n\t                i = 0; i < len; ) {\n\t                    c = buf[i++];\n\t                    if (c < 128) {\n\t                        utf16buf[out++] = c;\n\t                        continue\n\t                    }\n\t                    c_len = _utf8len[c];\n\t                    if (c_len > 4) {\n\t                        utf16buf[out++] = 65533;\n\t                        i += c_len - 1;\n\t                        continue\n\t                    }\n\t                    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;\n\t                    while (c_len > 1 && i < len) {\n\t                        c = c << 6 | buf[i++] & 63;\n\t                        c_len--\n\t                    }\n\t                    if (c_len > 1) {\n\t                        utf16buf[out++] = 65533;\n\t                        continue\n\t                    }\n\t                    if (c < 65536)\n\t                        utf16buf[out++] = c;\n\t                    else {\n\t                        c -= 65536;\n\t                        utf16buf[out++] = 55296 | c >> 10 & 1023;\n\t                        utf16buf[out++] = 56320 | c & 1023\n\t                    }\n\t                }\n\t                return buf2binstring(utf16buf, out)\n\t            }\n\t            ;\n\t            exports.utf8border = function(buf, max) {\n\t                var pos;\n\t                max = max || buf.length;\n\t                if (max > buf.length)\n\t                    max = buf.length;\n\t                pos = max - 1;\n\t                while (pos >= 0 && (buf[pos] & 192) === 128)\n\t                    pos--;\n\t                if (pos < 0)\n\t                    return max;\n\t                if (pos === 0)\n\t                    return max;\n\t                return pos + _utf8len[buf[pos]] > max ? pos : max\n\t            }\n\t        }\n\t        , {\n\t            \"./common\": 27\n\t        }],\n\t        29: [function(_dereq_, module, exports) {\n\t            function adler32(adler, buf, len, pos) {\n\t                var s1 = adler & 65535 | 0\n\t                  , s2 = adler >>> 16 & 65535 | 0\n\t                  , n = 0;\n\t                while (len !== 0) {\n\t                    n = len > 2E3 ? 2E3 : len;\n\t                    len -= n;\n\t                    do {\n\t                        s1 = s1 + buf[pos++] | 0;\n\t                        s2 = s2 + s1 | 0\n\t                    } while (--n);\n\t                    s1 %= 65521;\n\t                    s2 %= 65521\n\t                }\n\t                return s1 | s2 << 16 | 0\n\t            }\n\t            module.exports = adler32\n\t        }\n\t        , {}],\n\t        30: [function(_dereq_, module, exports) {\n\t            module.exports = {\n\t                Z_NO_FLUSH: 0,\n\t                Z_PARTIAL_FLUSH: 1,\n\t                Z_SYNC_FLUSH: 2,\n\t                Z_FULL_FLUSH: 3,\n\t                Z_FINISH: 4,\n\t                Z_BLOCK: 5,\n\t                Z_TREES: 6,\n\t                Z_OK: 0,\n\t                Z_STREAM_END: 1,\n\t                Z_NEED_DICT: 2,\n\t                Z_ERRNO: -1,\n\t                Z_STREAM_ERROR: -2,\n\t                Z_DATA_ERROR: -3,\n\t                Z_BUF_ERROR: -5,\n\t                Z_NO_COMPRESSION: 0,\n\t                Z_BEST_SPEED: 1,\n\t                Z_BEST_COMPRESSION: 9,\n\t                Z_DEFAULT_COMPRESSION: -1,\n\t                Z_FILTERED: 1,\n\t                Z_HUFFMAN_ONLY: 2,\n\t                Z_RLE: 3,\n\t                Z_FIXED: 4,\n\t                Z_DEFAULT_STRATEGY: 0,\n\t                Z_BINARY: 0,\n\t                Z_TEXT: 1,\n\t                Z_UNKNOWN: 2,\n\t                Z_DEFLATED: 8\n\t            }\n\t        }\n\t        , {}],\n\t        31: [function(_dereq_, module, exports) {\n\t            function makeTable() {\n\t                var c, table = [];\n\t                for (var n = 0; n < 256; n++) {\n\t                    c = n;\n\t                    for (var k = 0; k < 8; k++)\n\t                        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;\n\t                    table[n] = c\n\t                }\n\t                return table\n\t            }\n\t            var crcTable = makeTable();\n\t            function crc32(crc, buf, len, pos) {\n\t                var t = crcTable\n\t                  , end = pos + len;\n\t                crc = crc ^ -1;\n\t                for (var i = pos; i < end; i++)\n\t                    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];\n\t                return crc ^ -1\n\t            }\n\t            module.exports = crc32\n\t        }\n\t        , {}],\n\t        32: [function(_dereq_, module, exports) {\n\t            var utils = _dereq_(\"../utils/common\");\n\t            var trees = _dereq_(\"./trees\");\n\t            var adler32 = _dereq_(\"./adler32\");\n\t            var crc32 = _dereq_(\"./crc32\");\n\t            var msg = _dereq_(\"./messages\");\n\t            var Z_NO_FLUSH = 0;\n\t            var Z_PARTIAL_FLUSH = 1;\n\t            var Z_FULL_FLUSH = 3;\n\t            var Z_FINISH = 4;\n\t            var Z_BLOCK = 5;\n\t            var Z_OK = 0;\n\t            var Z_STREAM_END = 1;\n\t            var Z_STREAM_ERROR = -2;\n\t            var Z_DATA_ERROR = -3;\n\t            var Z_BUF_ERROR = -5;\n\t            var Z_DEFAULT_COMPRESSION = -1;\n\t            var Z_FILTERED = 1;\n\t            var Z_HUFFMAN_ONLY = 2;\n\t            var Z_RLE = 3;\n\t            var Z_FIXED = 4;\n\t            var Z_DEFAULT_STRATEGY = 0;\n\t            var Z_UNKNOWN = 2;\n\t            var Z_DEFLATED = 8;\n\t            var MAX_MEM_LEVEL = 9;\n\t            var MAX_WBITS = 15;\n\t            var DEF_MEM_LEVEL = 8;\n\t            var LENGTH_CODES = 29;\n\t            var LITERALS = 256;\n\t            var L_CODES = LITERALS + 1 + LENGTH_CODES;\n\t            var D_CODES = 30;\n\t            var BL_CODES = 19;\n\t            var HEAP_SIZE = 2 * L_CODES + 1;\n\t            var MAX_BITS = 15;\n\t            var MIN_MATCH = 3;\n\t            var MAX_MATCH = 258;\n\t            var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;\n\t            var PRESET_DICT = 32;\n\t            var INIT_STATE = 42;\n\t            var EXTRA_STATE = 69;\n\t            var NAME_STATE = 73;\n\t            var COMMENT_STATE = 91;\n\t            var HCRC_STATE = 103;\n\t            var BUSY_STATE = 113;\n\t            var FINISH_STATE = 666;\n\t            var BS_NEED_MORE = 1;\n\t            var BS_BLOCK_DONE = 2;\n\t            var BS_FINISH_STARTED = 3;\n\t            var BS_FINISH_DONE = 4;\n\t            var OS_CODE = 3;\n\t            function err(strm, errorCode) {\n\t                strm.msg = msg[errorCode];\n\t                return errorCode\n\t            }\n\t            function rank(f) {\n\t                return (f << 1) - (f > 4 ? 9 : 0)\n\t            }\n\t            function zero(buf) {\n\t                var len = buf.length;\n\t                while (--len >= 0)\n\t                    buf[len] = 0\n\t            }\n\t            function flush_pending(strm) {\n\t                var s = strm.state;\n\t                var len = s.pending;\n\t                if (len > strm.avail_out)\n\t                    len = strm.avail_out;\n\t                if (len === 0)\n\t                    return;\n\t                utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n\t                strm.next_out += len;\n\t                s.pending_out += len;\n\t                strm.total_out += len;\n\t                strm.avail_out -= len;\n\t                s.pending -= len;\n\t                if (s.pending === 0)\n\t                    s.pending_out = 0\n\t            }\n\t            function flush_block_only(s, last) {\n\t                trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);\n\t                s.block_start = s.strstart;\n\t                flush_pending(s.strm)\n\t            }\n\t            function put_byte(s, b) {\n\t                s.pending_buf[s.pending++] = b\n\t            }\n\t            function putShortMSB(s, b) {\n\t                s.pending_buf[s.pending++] = b >>> 8 & 255;\n\t                s.pending_buf[s.pending++] = b & 255\n\t            }\n\t            function read_buf(strm, buf, start, size) {\n\t                var len = strm.avail_in;\n\t                if (len > size)\n\t                    len = size;\n\t                if (len === 0)\n\t                    return 0;\n\t                strm.avail_in -= len;\n\t                utils.arraySet(buf, strm.input, strm.next_in, len, start);\n\t                if (strm.state.wrap === 1)\n\t                    strm.adler = adler32(strm.adler, buf, len, start);\n\t                else if (strm.state.wrap === 2)\n\t                    strm.adler = crc32(strm.adler, buf, len, start);\n\t                strm.next_in += len;\n\t                strm.total_in += len;\n\t                return len\n\t            }\n\t            function longest_match(s, cur_match) {\n\t                var chain_length = s.max_chain_length;\n\t                var scan = s.strstart;\n\t                var match;\n\t                var len;\n\t                var best_len = s.prev_length;\n\t                var nice_match = s.nice_match;\n\t                var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;\n\t                var _win = s.window;\n\t                var wmask = s.w_mask;\n\t                var prev = s.prev;\n\t                var strend = s.strstart + MAX_MATCH;\n\t                var scan_end1 = _win[scan + best_len - 1];\n\t                var scan_end = _win[scan + best_len];\n\t                if (s.prev_length >= s.good_match)\n\t                    chain_length >>= 2;\n\t                if (nice_match > s.lookahead)\n\t                    nice_match = s.lookahead;\n\t                do {\n\t                    match = cur_match;\n\t                    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1])\n\t                        continue;\n\t                    scan += 2;\n\t                    match++;\n\t                    do\n\t                        ;\n\t                    while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);\n\t                    len = MAX_MATCH - (strend - scan);\n\t                    scan = strend - MAX_MATCH;\n\t                    if (len > best_len) {\n\t                        s.match_start = cur_match;\n\t                        best_len = len;\n\t                        if (len >= nice_match)\n\t                            break;\n\t                        scan_end1 = _win[scan + best_len - 1];\n\t                        scan_end = _win[scan + best_len]\n\t                    }\n\t                } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\t                if (best_len <= s.lookahead)\n\t                    return best_len;\n\t                return s.lookahead\n\t            }\n\t            function fill_window(s) {\n\t                var _w_size = s.w_size;\n\t                var p, n, m, more, str;\n\t                do {\n\t                    more = s.window_size - s.lookahead - s.strstart;\n\t                    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\t                        utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n\t                        s.match_start -= _w_size;\n\t                        s.strstart -= _w_size;\n\t                        s.block_start -= _w_size;\n\t                        n = s.hash_size;\n\t                        p = n;\n\t                        do {\n\t                            m = s.head[--p];\n\t                            s.head[p] = m >= _w_size ? m - _w_size : 0\n\t                        } while (--n);\n\t                        n = _w_size;\n\t                        p = n;\n\t                        do {\n\t                            m = s.prev[--p];\n\t                            s.prev[p] = m >= _w_size ? m - _w_size : 0\n\t                        } while (--n);\n\t                        more += _w_size\n\t                    }\n\t                    if (s.strm.avail_in === 0)\n\t                        break;\n\t                    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n\t                    s.lookahead += n;\n\t                    if (s.lookahead + s.insert >= MIN_MATCH) {\n\t                        str = s.strstart - s.insert;\n\t                        s.ins_h = s.window[str];\n\t                        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;\n\t                        while (s.insert) {\n\t                            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\t                            s.prev[str & s.w_mask] = s.head[s.ins_h];\n\t                            s.head[s.ins_h] = str;\n\t                            str++;\n\t                            s.insert--;\n\t                            if (s.lookahead + s.insert < MIN_MATCH)\n\t                                break\n\t                        }\n\t                    }\n\t                } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0)\n\t            }\n\t            function deflate_stored(s, flush) {\n\t                var max_block_size = 65535;\n\t                if (max_block_size > s.pending_buf_size - 5)\n\t                    max_block_size = s.pending_buf_size - 5;\n\t                for (; ; ) {\n\t                    if (s.lookahead <= 1) {\n\t                        fill_window(s);\n\t                        if (s.lookahead === 0 && flush === Z_NO_FLUSH)\n\t                            return BS_NEED_MORE;\n\t                        if (s.lookahead === 0)\n\t                            break\n\t                    }\n\t                    s.strstart += s.lookahead;\n\t                    s.lookahead = 0;\n\t                    var max_start = s.block_start + max_block_size;\n\t                    if (s.strstart === 0 || s.strstart >= max_start) {\n\t                        s.lookahead = s.strstart - max_start;\n\t                        s.strstart = max_start;\n\t                        flush_block_only(s, false);\n\t                        if (s.strm.avail_out === 0)\n\t                            return BS_NEED_MORE\n\t                    }\n\t                    if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {\n\t                        flush_block_only(s, false);\n\t                        if (s.strm.avail_out === 0)\n\t                            return BS_NEED_MORE\n\t                    }\n\t                }\n\t                s.insert = 0;\n\t                if (flush === Z_FINISH) {\n\t                    flush_block_only(s, true);\n\t                    if (s.strm.avail_out === 0)\n\t                        return BS_FINISH_STARTED;\n\t                    return BS_FINISH_DONE\n\t                }\n\t                if (s.strstart > s.block_start) {\n\t                    flush_block_only(s, false);\n\t                    if (s.strm.avail_out === 0)\n\t                        return BS_NEED_MORE\n\t                }\n\t                return BS_NEED_MORE\n\t            }\n\t            function deflate_fast(s, flush) {\n\t                var hash_head;\n\t                var bflush;\n\t                for (; ; ) {\n\t                    if (s.lookahead < MIN_LOOKAHEAD) {\n\t                        fill_window(s);\n\t                        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH)\n\t                            return BS_NEED_MORE;\n\t                        if (s.lookahead === 0)\n\t                            break\n\t                    }\n\t                    hash_head = 0;\n\t                    if (s.lookahead >= MIN_MATCH) {\n\t                        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n\t                        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n\t                        s.head[s.ins_h] = s.strstart\n\t                    }\n\t                    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD)\n\t                        s.match_length = longest_match(s, hash_head);\n\t                    if (s.match_length >= MIN_MATCH) {\n\t                        bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\t                        s.lookahead -= s.match_length;\n\t                        if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {\n\t                            s.match_length--;\n\t                            do {\n\t                                s.strstart++;\n\t                                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n\t                                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n\t                                s.head[s.ins_h] = s.strstart\n\t                            } while (--s.match_length !== 0);\n\t                            s.strstart++\n\t                        } else {\n\t                            s.strstart += s.match_length;\n\t                            s.match_length = 0;\n\t                            s.ins_h = s.window[s.strstart];\n\t                            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask\n\t                        }\n\t                    } else {\n\t                        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\t                        s.lookahead--;\n\t                        s.strstart++\n\t                    }\n\t                    if (bflush) {\n\t                        flush_block_only(s, false);\n\t                        if (s.strm.avail_out === 0)\n\t                            return BS_NEED_MORE\n\t                    }\n\t                }\n\t                s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n\t                if (flush === Z_FINISH) {\n\t                    flush_block_only(s, true);\n\t                    if (s.strm.avail_out === 0)\n\t                        return BS_FINISH_STARTED;\n\t                    return BS_FINISH_DONE\n\t                }\n\t                if (s.last_lit) {\n\t                    flush_block_only(s, false);\n\t                    if (s.strm.avail_out === 0)\n\t                        return BS_NEED_MORE\n\t                }\n\t                return BS_BLOCK_DONE\n\t            }\n\t            function deflate_slow(s, flush) {\n\t                var hash_head;\n\t                var bflush;\n\t                var max_insert;\n\t                for (; ; ) {\n\t                    if (s.lookahead < MIN_LOOKAHEAD) {\n\t                        fill_window(s);\n\t                        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH)\n\t                            return BS_NEED_MORE;\n\t                        if (s.lookahead === 0)\n\t                            break\n\t                    }\n\t                    hash_head = 0;\n\t                    if (s.lookahead >= MIN_MATCH) {\n\t                        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n\t                        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n\t                        s.head[s.ins_h] = s.strstart\n\t                    }\n\t                    s.prev_length = s.match_length;\n\t                    s.prev_match = s.match_start;\n\t                    s.match_length = MIN_MATCH - 1;\n\t                    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {\n\t                        s.match_length = longest_match(s, hash_head);\n\t                        if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096))\n\t                            s.match_length = MIN_MATCH - 1\n\t                    }\n\t                    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n\t                        max_insert = s.strstart + s.lookahead - MIN_MATCH;\n\t                        bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n\t                        s.lookahead -= s.prev_length - 1;\n\t                        s.prev_length -= 2;\n\t                        do\n\t                            if (++s.strstart <= max_insert) {\n\t                                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n\t                                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n\t                                s.head[s.ins_h] = s.strstart\n\t                            }\n\t                        while (--s.prev_length !== 0);\n\t                        s.match_available = 0;\n\t                        s.match_length = MIN_MATCH - 1;\n\t                        s.strstart++;\n\t                        if (bflush) {\n\t                            flush_block_only(s, false);\n\t                            if (s.strm.avail_out === 0)\n\t                                return BS_NEED_MORE\n\t                        }\n\t                    } else if (s.match_available) {\n\t                        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\t                        if (bflush)\n\t                            flush_block_only(s, false);\n\t                        s.strstart++;\n\t                        s.lookahead--;\n\t                        if (s.strm.avail_out === 0)\n\t                            return BS_NEED_MORE\n\t                    } else {\n\t                        s.match_available = 1;\n\t                        s.strstart++;\n\t                        s.lookahead--\n\t                    }\n\t                }\n\t                if (s.match_available) {\n\t                    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\t                    s.match_available = 0\n\t                }\n\t                s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n\t                if (flush === Z_FINISH) {\n\t                    flush_block_only(s, true);\n\t                    if (s.strm.avail_out === 0)\n\t                        return BS_FINISH_STARTED;\n\t                    return BS_FINISH_DONE\n\t                }\n\t                if (s.last_lit) {\n\t                    flush_block_only(s, false);\n\t                    if (s.strm.avail_out === 0)\n\t                        return BS_NEED_MORE\n\t                }\n\t                return BS_BLOCK_DONE\n\t            }\n\t            function deflate_rle(s, flush) {\n\t                var bflush;\n\t                var prev;\n\t                var scan, strend;\n\t                var _win = s.window;\n\t                for (; ; ) {\n\t                    if (s.lookahead <= MAX_MATCH) {\n\t                        fill_window(s);\n\t                        if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH)\n\t                            return BS_NEED_MORE;\n\t                        if (s.lookahead === 0)\n\t                            break\n\t                    }\n\t                    s.match_length = 0;\n\t                    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n\t                        scan = s.strstart - 1;\n\t                        prev = _win[scan];\n\t                        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n\t                            strend = s.strstart + MAX_MATCH;\n\t                            do\n\t                                ;\n\t                            while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);\n\t                            s.match_length = MAX_MATCH - (strend - scan);\n\t                            if (s.match_length > s.lookahead)\n\t                                s.match_length = s.lookahead\n\t                        }\n\t                    }\n\t                    if (s.match_length >= MIN_MATCH) {\n\t                        bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n\t                        s.lookahead -= s.match_length;\n\t                        s.strstart += s.match_length;\n\t                        s.match_length = 0\n\t                    } else {\n\t                        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\t                        s.lookahead--;\n\t                        s.strstart++\n\t                    }\n\t                    if (bflush) {\n\t                        flush_block_only(s, false);\n\t                        if (s.strm.avail_out === 0)\n\t                            return BS_NEED_MORE\n\t                    }\n\t                }\n\t                s.insert = 0;\n\t                if (flush === Z_FINISH) {\n\t                    flush_block_only(s, true);\n\t                    if (s.strm.avail_out === 0)\n\t                        return BS_FINISH_STARTED;\n\t                    return BS_FINISH_DONE\n\t                }\n\t                if (s.last_lit) {\n\t                    flush_block_only(s, false);\n\t                    if (s.strm.avail_out === 0)\n\t                        return BS_NEED_MORE\n\t                }\n\t                return BS_BLOCK_DONE\n\t            }\n\t            function deflate_huff(s, flush) {\n\t                var bflush;\n\t                for (; ; ) {\n\t                    if (s.lookahead === 0) {\n\t                        fill_window(s);\n\t                        if (s.lookahead === 0) {\n\t                            if (flush === Z_NO_FLUSH)\n\t                                return BS_NEED_MORE;\n\t                            break\n\t                        }\n\t                    }\n\t                    s.match_length = 0;\n\t                    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\t                    s.lookahead--;\n\t                    s.strstart++;\n\t                    if (bflush) {\n\t                        flush_block_only(s, false);\n\t                        if (s.strm.avail_out === 0)\n\t                            return BS_NEED_MORE\n\t                    }\n\t                }\n\t                s.insert = 0;\n\t                if (flush === Z_FINISH) {\n\t                    flush_block_only(s, true);\n\t                    if (s.strm.avail_out === 0)\n\t                        return BS_FINISH_STARTED;\n\t                    return BS_FINISH_DONE\n\t                }\n\t                if (s.last_lit) {\n\t                    flush_block_only(s, false);\n\t                    if (s.strm.avail_out === 0)\n\t                        return BS_NEED_MORE\n\t                }\n\t                return BS_BLOCK_DONE\n\t            }\n\t            var Config = function(good_length, max_lazy, nice_length, max_chain, func) {\n\t                this.good_length = good_length;\n\t                this.max_lazy = max_lazy;\n\t                this.nice_length = nice_length;\n\t                this.max_chain = max_chain;\n\t                this.func = func\n\t            };\n\t            var configuration_table;\n\t            configuration_table = [new Config(0,0,0,0,deflate_stored), new Config(4,4,8,4,deflate_fast), new Config(4,5,16,8,deflate_fast), new Config(4,6,32,32,deflate_fast), new Config(4,4,16,16,deflate_slow), new Config(8,16,32,32,deflate_slow), new Config(8,16,128,128,deflate_slow), new Config(8,32,128,256,deflate_slow), new Config(32,128,258,1024,deflate_slow), new Config(32,258,258,4096,deflate_slow)];\n\t            function lm_init(s) {\n\t                s.window_size = 2 * s.w_size;\n\t                zero(s.head);\n\t                s.max_lazy_match = configuration_table[s.level].max_lazy;\n\t                s.good_match = configuration_table[s.level].good_length;\n\t                s.nice_match = configuration_table[s.level].nice_length;\n\t                s.max_chain_length = configuration_table[s.level].max_chain;\n\t                s.strstart = 0;\n\t                s.block_start = 0;\n\t                s.lookahead = 0;\n\t                s.insert = 0;\n\t                s.match_length = s.prev_length = MIN_MATCH - 1;\n\t                s.match_available = 0;\n\t                s.ins_h = 0\n\t            }\n\t            function DeflateState() {\n\t                this.strm = null;\n\t                this.status = 0;\n\t                this.pending_buf = null;\n\t                this.pending_buf_size = 0;\n\t                this.pending_out = 0;\n\t                this.pending = 0;\n\t                this.wrap = 0;\n\t                this.gzhead = null;\n\t                this.gzindex = 0;\n\t                this.method = Z_DEFLATED;\n\t                this.last_flush = -1;\n\t                this.w_size = 0;\n\t                this.w_bits = 0;\n\t                this.w_mask = 0;\n\t                this.window = null;\n\t                this.window_size = 0;\n\t                this.prev = null;\n\t                this.head = null;\n\t                this.ins_h = 0;\n\t                this.hash_size = 0;\n\t                this.hash_bits = 0;\n\t                this.hash_mask = 0;\n\t                this.hash_shift = 0;\n\t                this.block_start = 0;\n\t                this.match_length = 0;\n\t                this.prev_match = 0;\n\t                this.match_available = 0;\n\t                this.strstart = 0;\n\t                this.match_start = 0;\n\t                this.lookahead = 0;\n\t                this.prev_length = 0;\n\t                this.max_chain_length = 0;\n\t                this.max_lazy_match = 0;\n\t                this.level = 0;\n\t                this.strategy = 0;\n\t                this.good_match = 0;\n\t                this.nice_match = 0;\n\t                this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);\n\t                this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);\n\t                this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);\n\t                zero(this.dyn_ltree);\n\t                zero(this.dyn_dtree);\n\t                zero(this.bl_tree);\n\t                this.l_desc = null;\n\t                this.d_desc = null;\n\t                this.bl_desc = null;\n\t                this.bl_count = new utils.Buf16(MAX_BITS + 1);\n\t                this.heap = new utils.Buf16(2 * L_CODES + 1);\n\t                zero(this.heap);\n\t                this.heap_len = 0;\n\t                this.heap_max = 0;\n\t                this.depth = new utils.Buf16(2 * L_CODES + 1);\n\t                zero(this.depth);\n\t                this.l_buf = 0;\n\t                this.lit_bufsize = 0;\n\t                this.last_lit = 0;\n\t                this.d_buf = 0;\n\t                this.opt_len = 0;\n\t                this.static_len = 0;\n\t                this.matches = 0;\n\t                this.insert = 0;\n\t                this.bi_buf = 0;\n\t                this.bi_valid = 0\n\t            }\n\t            function deflateResetKeep(strm) {\n\t                var s;\n\t                if (!strm || !strm.state)\n\t                    return err(strm, Z_STREAM_ERROR);\n\t                strm.total_in = strm.total_out = 0;\n\t                strm.data_type = Z_UNKNOWN;\n\t                s = strm.state;\n\t                s.pending = 0;\n\t                s.pending_out = 0;\n\t                if (s.wrap < 0)\n\t                    s.wrap = -s.wrap;\n\t                s.status = s.wrap ? INIT_STATE : BUSY_STATE;\n\t                strm.adler = s.wrap === 2 ? 0 : 1;\n\t                s.last_flush = Z_NO_FLUSH;\n\t                trees._tr_init(s);\n\t                return Z_OK\n\t            }\n\t            function deflateReset(strm) {\n\t                var ret = deflateResetKeep(strm);\n\t                if (ret === Z_OK)\n\t                    lm_init(strm.state);\n\t                return ret\n\t            }\n\t            function deflateSetHeader(strm, head) {\n\t                if (!strm || !strm.state)\n\t                    return Z_STREAM_ERROR;\n\t                if (strm.state.wrap !== 2)\n\t                    return Z_STREAM_ERROR;\n\t                strm.state.gzhead = head;\n\t                return Z_OK\n\t            }\n\t            function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n\t                if (!strm)\n\t                    return Z_STREAM_ERROR;\n\t                var wrap = 1;\n\t                if (level === Z_DEFAULT_COMPRESSION)\n\t                    level = 6;\n\t                if (windowBits < 0) {\n\t                    wrap = 0;\n\t                    windowBits = -windowBits\n\t                } else if (windowBits > 15) {\n\t                    wrap = 2;\n\t                    windowBits -= 16\n\t                }\n\t                if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED)\n\t                    return err(strm, Z_STREAM_ERROR);\n\t                if (windowBits === 8)\n\t                    windowBits = 9;\n\t                var s = new DeflateState;\n\t                strm.state = s;\n\t                s.strm = strm;\n\t                s.wrap = wrap;\n\t                s.gzhead = null;\n\t                s.w_bits = windowBits;\n\t                s.w_size = 1 << s.w_bits;\n\t                s.w_mask = s.w_size - 1;\n\t                s.hash_bits = memLevel + 7;\n\t                s.hash_size = 1 << s.hash_bits;\n\t                s.hash_mask = s.hash_size - 1;\n\t                s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\t                s.window = new utils.Buf8(s.w_size * 2);\n\t                s.head = new utils.Buf16(s.hash_size);\n\t                s.prev = new utils.Buf16(s.w_size);\n\t                s.lit_bufsize = 1 << memLevel + 6;\n\t                s.pending_buf_size = s.lit_bufsize * 4;\n\t                s.pending_buf = new utils.Buf8(s.pending_buf_size);\n\t                s.d_buf = s.lit_bufsize >> 1;\n\t                s.l_buf = (1 + 2) * s.lit_bufsize;\n\t                s.level = level;\n\t                s.strategy = strategy;\n\t                s.method = method;\n\t                return deflateReset(strm)\n\t            }\n\t            function deflateInit(strm, level) {\n\t                return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY)\n\t            }\n\t            function deflate(strm, flush) {\n\t                var old_flush, s;\n\t                var beg, val;\n\t                if (!strm || !strm.state || flush > Z_BLOCK || flush < 0)\n\t                    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n\t                s = strm.state;\n\t                if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH)\n\t                    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);\n\t                s.strm = strm;\n\t                old_flush = s.last_flush;\n\t                s.last_flush = flush;\n\t                if (s.status === INIT_STATE)\n\t                    if (s.wrap === 2) {\n\t                        strm.adler = 0;\n\t                        put_byte(s, 31);\n\t                        put_byte(s, 139);\n\t                        put_byte(s, 8);\n\t                        if (!s.gzhead) {\n\t                            put_byte(s, 0);\n\t                            put_byte(s, 0);\n\t                            put_byte(s, 0);\n\t                            put_byte(s, 0);\n\t                            put_byte(s, 0);\n\t                            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);\n\t                            put_byte(s, OS_CODE);\n\t                            s.status = BUSY_STATE\n\t                        } else {\n\t                            put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));\n\t                            put_byte(s, s.gzhead.time & 255);\n\t                            put_byte(s, s.gzhead.time >> 8 & 255);\n\t                            put_byte(s, s.gzhead.time >> 16 & 255);\n\t                            put_byte(s, s.gzhead.time >> 24 & 255);\n\t                            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);\n\t                            put_byte(s, s.gzhead.os & 255);\n\t                            if (s.gzhead.extra && s.gzhead.extra.length) {\n\t                                put_byte(s, s.gzhead.extra.length & 255);\n\t                                put_byte(s, s.gzhead.extra.length >> 8 & 255)\n\t                            }\n\t                            if (s.gzhead.hcrc)\n\t                                strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n\t                            s.gzindex = 0;\n\t                            s.status = EXTRA_STATE\n\t                        }\n\t                    } else {\n\t                        var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;\n\t                        var level_flags = -1;\n\t                        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2)\n\t                            level_flags = 0;\n\t                        else if (s.level < 6)\n\t                            level_flags = 1;\n\t                        else if (s.level === 6)\n\t                            level_flags = 2;\n\t                        else\n\t                            level_flags = 3;\n\t                        header |= level_flags << 6;\n\t                        if (s.strstart !== 0)\n\t                            header |= PRESET_DICT;\n\t                        header += 31 - header % 31;\n\t                        s.status = BUSY_STATE;\n\t                        putShortMSB(s, header);\n\t                        if (s.strstart !== 0) {\n\t                            putShortMSB(s, strm.adler >>> 16);\n\t                            putShortMSB(s, strm.adler & 65535)\n\t                        }\n\t                        strm.adler = 1\n\t                    }\n\t                if (s.status === EXTRA_STATE)\n\t                    if (s.gzhead.extra) {\n\t                        beg = s.pending;\n\t                        while (s.gzindex < (s.gzhead.extra.length & 65535)) {\n\t                            if (s.pending === s.pending_buf_size) {\n\t                                if (s.gzhead.hcrc && s.pending > beg)\n\t                                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n\t                                flush_pending(strm);\n\t                                beg = s.pending;\n\t                                if (s.pending === s.pending_buf_size)\n\t                                    break\n\t                            }\n\t                            put_byte(s, s.gzhead.extra[s.gzindex] & 255);\n\t                            s.gzindex++\n\t                        }\n\t                        if (s.gzhead.hcrc && s.pending > beg)\n\t                            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n\t                        if (s.gzindex === s.gzhead.extra.length) {\n\t                            s.gzindex = 0;\n\t                            s.status = NAME_STATE\n\t                        }\n\t                    } else\n\t                        s.status = NAME_STATE;\n\t                if (s.status === NAME_STATE)\n\t                    if (s.gzhead.name) {\n\t                        beg = s.pending;\n\t                        do {\n\t                            if (s.pending === s.pending_buf_size) {\n\t                                if (s.gzhead.hcrc && s.pending > beg)\n\t                                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n\t                                flush_pending(strm);\n\t                                beg = s.pending;\n\t                                if (s.pending === s.pending_buf_size) {\n\t                                    val = 1;\n\t                                    break\n\t                                }\n\t                            }\n\t                            if (s.gzindex < s.gzhead.name.length)\n\t                                val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;\n\t                            else\n\t                                val = 0;\n\t                            put_byte(s, val)\n\t                        } while (val !== 0);\n\t                        if (s.gzhead.hcrc && s.pending > beg)\n\t                            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n\t                        if (val === 0) {\n\t                            s.gzindex = 0;\n\t                            s.status = COMMENT_STATE\n\t                        }\n\t                    } else\n\t                        s.status = COMMENT_STATE;\n\t                if (s.status === COMMENT_STATE)\n\t                    if (s.gzhead.comment) {\n\t                        beg = s.pending;\n\t                        do {\n\t                            if (s.pending === s.pending_buf_size) {\n\t                                if (s.gzhead.hcrc && s.pending > beg)\n\t                                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n\t                                flush_pending(strm);\n\t                                beg = s.pending;\n\t                                if (s.pending === s.pending_buf_size) {\n\t                                    val = 1;\n\t                                    break\n\t                                }\n\t                            }\n\t                            if (s.gzindex < s.gzhead.comment.length)\n\t                                val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;\n\t                            else\n\t                                val = 0;\n\t                            put_byte(s, val)\n\t                        } while (val !== 0);\n\t                        if (s.gzhead.hcrc && s.pending > beg)\n\t                            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n\t                        if (val === 0)\n\t                            s.status = HCRC_STATE\n\t                    } else\n\t                        s.status = HCRC_STATE;\n\t                if (s.status === HCRC_STATE)\n\t                    if (s.gzhead.hcrc) {\n\t                        if (s.pending + 2 > s.pending_buf_size)\n\t                            flush_pending(strm);\n\t                        if (s.pending + 2 <= s.pending_buf_size) {\n\t                            put_byte(s, strm.adler & 255);\n\t                            put_byte(s, strm.adler >> 8 & 255);\n\t                            strm.adler = 0;\n\t                            s.status = BUSY_STATE\n\t                        }\n\t                    } else\n\t                        s.status = BUSY_STATE;\n\t                if (s.pending !== 0) {\n\t                    flush_pending(strm);\n\t                    if (strm.avail_out === 0) {\n\t                        s.last_flush = -1;\n\t                        return Z_OK\n\t                    }\n\t                } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH)\n\t                    return err(strm, Z_BUF_ERROR);\n\t                if (s.status === FINISH_STATE && strm.avail_in !== 0)\n\t                    return err(strm, Z_BUF_ERROR);\n\t                if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {\n\t                    var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);\n\t                    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE)\n\t                        s.status = FINISH_STATE;\n\t                    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n\t                        if (strm.avail_out === 0)\n\t                            s.last_flush = -1;\n\t                        return Z_OK\n\t                    }\n\t                    if (bstate === BS_BLOCK_DONE) {\n\t                        if (flush === Z_PARTIAL_FLUSH)\n\t                            trees._tr_align(s);\n\t                        else if (flush !== Z_BLOCK) {\n\t                            trees._tr_stored_block(s, 0, 0, false);\n\t                            if (flush === Z_FULL_FLUSH) {\n\t                                zero(s.head);\n\t                                if (s.lookahead === 0) {\n\t                                    s.strstart = 0;\n\t                                    s.block_start = 0;\n\t                                    s.insert = 0\n\t                                }\n\t                            }\n\t                        }\n\t                        flush_pending(strm);\n\t                        if (strm.avail_out === 0) {\n\t                            s.last_flush = -1;\n\t                            return Z_OK\n\t                        }\n\t                    }\n\t                }\n\t                if (flush !== Z_FINISH)\n\t                    return Z_OK;\n\t                if (s.wrap <= 0)\n\t                    return Z_STREAM_END;\n\t                if (s.wrap === 2) {\n\t                    put_byte(s, strm.adler & 255);\n\t                    put_byte(s, strm.adler >> 8 & 255);\n\t                    put_byte(s, strm.adler >> 16 & 255);\n\t                    put_byte(s, strm.adler >> 24 & 255);\n\t                    put_byte(s, strm.total_in & 255);\n\t                    put_byte(s, strm.total_in >> 8 & 255);\n\t                    put_byte(s, strm.total_in >> 16 & 255);\n\t                    put_byte(s, strm.total_in >> 24 & 255)\n\t                } else {\n\t                    putShortMSB(s, strm.adler >>> 16);\n\t                    putShortMSB(s, strm.adler & 65535)\n\t                }\n\t                flush_pending(strm);\n\t                if (s.wrap > 0)\n\t                    s.wrap = -s.wrap;\n\t                return s.pending !== 0 ? Z_OK : Z_STREAM_END\n\t            }\n\t            function deflateEnd(strm) {\n\t                var status;\n\t                if (!strm || !strm.state)\n\t                    return Z_STREAM_ERROR;\n\t                status = strm.state.status;\n\t                if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE)\n\t                    return err(strm, Z_STREAM_ERROR);\n\t                strm.state = null;\n\t                return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK\n\t            }\n\t            exports.deflateInit = deflateInit;\n\t            exports.deflateInit2 = deflateInit2;\n\t            exports.deflateReset = deflateReset;\n\t            exports.deflateResetKeep = deflateResetKeep;\n\t            exports.deflateSetHeader = deflateSetHeader;\n\t            exports.deflate = deflate;\n\t            exports.deflateEnd = deflateEnd;\n\t            exports.deflateInfo = \"pako deflate (from Nodeca project)\"\n\t        }\n\t        , {\n\t            \"../utils/common\": 27,\n\t            \"./adler32\": 29,\n\t            \"./crc32\": 31,\n\t            \"./messages\": 37,\n\t            \"./trees\": 38\n\t        }],\n\t        33: [function(_dereq_, module, exports) {\n\t            function GZheader() {\n\t                this.text = 0;\n\t                this.time = 0;\n\t                this.xflags = 0;\n\t                this.os = 0;\n\t                this.extra = null;\n\t                this.extra_len = 0;\n\t                this.name = \"\";\n\t                this.comment = \"\";\n\t                this.hcrc = 0;\n\t                this.done = false\n\t            }\n\t            module.exports = GZheader\n\t        }\n\t        , {}],\n\t        34: [function(_dereq_, module, exports) {\n\t            var BAD = 30;\n\t            var TYPE = 12;\n\t            module.exports = function inflate_fast(strm, start) {\n\t                var state;\n\t                var _in;\n\t                var last;\n\t                var _out;\n\t                var beg;\n\t                var end;\n\t                var dmax;\n\t                var wsize;\n\t                var whave;\n\t                var wnext;\n\t                var window;\n\t                var hold;\n\t                var bits;\n\t                var lcode;\n\t                var dcode;\n\t                var lmask;\n\t                var dmask;\n\t                var here;\n\t                var op;\n\t                var len;\n\t                var dist;\n\t                var from;\n\t                var from_source;\n\t                var input, output;\n\t                state = strm.state;\n\t                _in = strm.next_in;\n\t                input = strm.input;\n\t                last = _in + (strm.avail_in - 5);\n\t                _out = strm.next_out;\n\t                output = strm.output;\n\t                beg = _out - (start - strm.avail_out);\n\t                end = _out + (strm.avail_out - 257);\n\t                dmax = state.dmax;\n\t                wsize = state.wsize;\n\t                whave = state.whave;\n\t                wnext = state.wnext;\n\t                window = state.window;\n\t                hold = state.hold;\n\t                bits = state.bits;\n\t                lcode = state.lencode;\n\t                dcode = state.distcode;\n\t                lmask = (1 << state.lenbits) - 1;\n\t                dmask = (1 << state.distbits) - 1;\n\t                top: do {\n\t                    if (bits < 15) {\n\t                        hold += input[_in++] << bits;\n\t                        bits += 8;\n\t                        hold += input[_in++] << bits;\n\t                        bits += 8\n\t                    }\n\t                    here = lcode[hold & lmask];\n\t                    dolen: for (; ; ) {\n\t                        op = here >>> 24;\n\t                        hold >>>= op;\n\t                        bits -= op;\n\t                        op = here >>> 16 & 255;\n\t                        if (op === 0)\n\t                            output[_out++] = here & 65535;\n\t                        else if (op & 16) {\n\t                            len = here & 65535;\n\t                            op &= 15;\n\t                            if (op) {\n\t                                if (bits < op) {\n\t                                    hold += input[_in++] << bits;\n\t                                    bits += 8\n\t                                }\n\t                                len += hold & (1 << op) - 1;\n\t                                hold >>>= op;\n\t                                bits -= op\n\t                            }\n\t                            if (bits < 15) {\n\t                                hold += input[_in++] << bits;\n\t                                bits += 8;\n\t                                hold += input[_in++] << bits;\n\t                                bits += 8\n\t                            }\n\t                            here = dcode[hold & dmask];\n\t                            dodist: for (; ; ) {\n\t                                op = here >>> 24;\n\t                                hold >>>= op;\n\t                                bits -= op;\n\t                                op = here >>> 16 & 255;\n\t                                if (op & 16) {\n\t                                    dist = here & 65535;\n\t                                    op &= 15;\n\t                                    if (bits < op) {\n\t                                        hold += input[_in++] << bits;\n\t                                        bits += 8;\n\t                                        if (bits < op) {\n\t                                            hold += input[_in++] << bits;\n\t                                            bits += 8\n\t                                        }\n\t                                    }\n\t                                    dist += hold & (1 << op) - 1;\n\t                                    if (dist > dmax) {\n\t                                        strm.msg = \"invalid distance too far back\";\n\t                                        state.mode = BAD;\n\t                                        break top\n\t                                    }\n\t                                    hold >>>= op;\n\t                                    bits -= op;\n\t                                    op = _out - beg;\n\t                                    if (dist > op) {\n\t                                        op = dist - op;\n\t                                        if (op > whave)\n\t                                            if (state.sane) {\n\t                                                strm.msg = \"invalid distance too far back\";\n\t                                                state.mode = BAD;\n\t                                                break top\n\t                                            }\n\t                                        from = 0;\n\t                                        from_source = window;\n\t                                        if (wnext === 0) {\n\t                                            from += wsize - op;\n\t                                            if (op < len) {\n\t                                                len -= op;\n\t                                                do\n\t                                                    output[_out++] = window[from++];\n\t                                                while (--op);\n\t                                                from = _out - dist;\n\t                                                from_source = output\n\t                                            }\n\t                                        } else if (wnext < op) {\n\t                                            from += wsize + wnext - op;\n\t                                            op -= wnext;\n\t                                            if (op < len) {\n\t                                                len -= op;\n\t                                                do\n\t                                                    output[_out++] = window[from++];\n\t                                                while (--op);\n\t                                                from = 0;\n\t                                                if (wnext < len) {\n\t                                                    op = wnext;\n\t                                                    len -= op;\n\t                                                    do\n\t                                                        output[_out++] = window[from++];\n\t                                                    while (--op);\n\t                                                    from = _out - dist;\n\t                                                    from_source = output\n\t                                                }\n\t                                            }\n\t                                        } else {\n\t                                            from += wnext - op;\n\t                                            if (op < len) {\n\t                                                len -= op;\n\t                                                do\n\t                                                    output[_out++] = window[from++];\n\t                                                while (--op);\n\t                                                from = _out - dist;\n\t                                                from_source = output\n\t                                            }\n\t                                        }\n\t                                        while (len > 2) {\n\t                                            output[_out++] = from_source[from++];\n\t                                            output[_out++] = from_source[from++];\n\t                                            output[_out++] = from_source[from++];\n\t                                            len -= 3\n\t                                        }\n\t                                        if (len) {\n\t                                            output[_out++] = from_source[from++];\n\t                                            if (len > 1)\n\t                                                output[_out++] = from_source[from++]\n\t                                        }\n\t                                    } else {\n\t                                        from = _out - dist;\n\t                                        do {\n\t                                            output[_out++] = output[from++];\n\t                                            output[_out++] = output[from++];\n\t                                            output[_out++] = output[from++];\n\t                                            len -= 3\n\t                                        } while (len > 2);\n\t                                        if (len) {\n\t                                            output[_out++] = output[from++];\n\t                                            if (len > 1)\n\t                                                output[_out++] = output[from++]\n\t                                        }\n\t                                    }\n\t                                } else if ((op & 64) === 0) {\n\t                                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];\n\t                                    continue dodist\n\t                                } else {\n\t                                    strm.msg = \"invalid distance code\";\n\t                                    state.mode = BAD;\n\t                                    break top\n\t                                }\n\t                                break\n\t                            }\n\t                        } else if ((op & 64) === 0) {\n\t                            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];\n\t                            continue dolen\n\t                        } else if (op & 32) {\n\t                            state.mode = TYPE;\n\t                            break top\n\t                        } else {\n\t                            strm.msg = \"invalid literal/length code\";\n\t                            state.mode = BAD;\n\t                            break top\n\t                        }\n\t                        break\n\t                    }\n\t                } while (_in < last && _out < end);\n\t                len = bits >> 3;\n\t                _in -= len;\n\t                bits -= len << 3;\n\t                hold &= (1 << bits) - 1;\n\t                strm.next_in = _in;\n\t                strm.next_out = _out;\n\t                strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);\n\t                strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);\n\t                state.hold = hold;\n\t                state.bits = bits;\n\t                return\n\t            }\n\t        }\n\t        , {}],\n\t        35: [function(_dereq_, module, exports) {\n\t            var utils = _dereq_(\"../utils/common\");\n\t            var adler32 = _dereq_(\"./adler32\");\n\t            var crc32 = _dereq_(\"./crc32\");\n\t            var inflate_fast = _dereq_(\"./inffast\");\n\t            var inflate_table = _dereq_(\"./inftrees\");\n\t            var CODES = 0;\n\t            var LENS = 1;\n\t            var DISTS = 2;\n\t            var Z_FINISH = 4;\n\t            var Z_BLOCK = 5;\n\t            var Z_TREES = 6;\n\t            var Z_OK = 0;\n\t            var Z_STREAM_END = 1;\n\t            var Z_NEED_DICT = 2;\n\t            var Z_STREAM_ERROR = -2;\n\t            var Z_DATA_ERROR = -3;\n\t            var Z_MEM_ERROR = -4;\n\t            var Z_BUF_ERROR = -5;\n\t            var Z_DEFLATED = 8;\n\t            var HEAD = 1;\n\t            var FLAGS = 2;\n\t            var TIME = 3;\n\t            var OS = 4;\n\t            var EXLEN = 5;\n\t            var EXTRA = 6;\n\t            var NAME = 7;\n\t            var COMMENT = 8;\n\t            var HCRC = 9;\n\t            var DICTID = 10;\n\t            var DICT = 11;\n\t            var TYPE = 12;\n\t            var TYPEDO = 13;\n\t            var STORED = 14;\n\t            var COPY_ = 15;\n\t            var COPY = 16;\n\t            var TABLE = 17;\n\t            var LENLENS = 18;\n\t            var CODELENS = 19;\n\t            var LEN_ = 20;\n\t            var LEN = 21;\n\t            var LENEXT = 22;\n\t            var DIST = 23;\n\t            var DISTEXT = 24;\n\t            var MATCH = 25;\n\t            var LIT = 26;\n\t            var CHECK = 27;\n\t            var LENGTH = 28;\n\t            var DONE = 29;\n\t            var BAD = 30;\n\t            var MEM = 31;\n\t            var SYNC = 32;\n\t            var ENOUGH_LENS = 852;\n\t            var ENOUGH_DISTS = 592;\n\t            var MAX_WBITS = 15;\n\t            var DEF_WBITS = MAX_WBITS;\n\t            function ZSWAP32(q) {\n\t                return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24)\n\t            }\n\t            function InflateState() {\n\t                this.mode = 0;\n\t                this.last = false;\n\t                this.wrap = 0;\n\t                this.havedict = false;\n\t                this.flags = 0;\n\t                this.dmax = 0;\n\t                this.check = 0;\n\t                this.total = 0;\n\t                this.head = null;\n\t                this.wbits = 0;\n\t                this.wsize = 0;\n\t                this.whave = 0;\n\t                this.wnext = 0;\n\t                this.window = null;\n\t                this.hold = 0;\n\t                this.bits = 0;\n\t                this.length = 0;\n\t                this.offset = 0;\n\t                this.extra = 0;\n\t                this.lencode = null;\n\t                this.distcode = null;\n\t                this.lenbits = 0;\n\t                this.distbits = 0;\n\t                this.ncode = 0;\n\t                this.nlen = 0;\n\t                this.ndist = 0;\n\t                this.have = 0;\n\t                this.next = null;\n\t                this.lens = new utils.Buf16(320);\n\t                this.work = new utils.Buf16(288);\n\t                this.lendyn = null;\n\t                this.distdyn = null;\n\t                this.sane = 0;\n\t                this.back = 0;\n\t                this.was = 0\n\t            }\n\t            function inflateResetKeep(strm) {\n\t                var state;\n\t                if (!strm || !strm.state)\n\t                    return Z_STREAM_ERROR;\n\t                state = strm.state;\n\t                strm.total_in = strm.total_out = state.total = 0;\n\t                strm.msg = \"\";\n\t                if (state.wrap)\n\t                    strm.adler = state.wrap & 1;\n\t                state.mode = HEAD;\n\t                state.last = 0;\n\t                state.havedict = 0;\n\t                state.dmax = 32768;\n\t                state.head = null;\n\t                state.hold = 0;\n\t                state.bits = 0;\n\t                state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);\n\t                state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);\n\t                state.sane = 1;\n\t                state.back = -1;\n\t                return Z_OK\n\t            }\n\t            function inflateReset(strm) {\n\t                var state;\n\t                if (!strm || !strm.state)\n\t                    return Z_STREAM_ERROR;\n\t                state = strm.state;\n\t                state.wsize = 0;\n\t                state.whave = 0;\n\t                state.wnext = 0;\n\t                return inflateResetKeep(strm)\n\t            }\n\t            function inflateReset2(strm, windowBits) {\n\t                var wrap;\n\t                var state;\n\t                if (!strm || !strm.state)\n\t                    return Z_STREAM_ERROR;\n\t                state = strm.state;\n\t                if (windowBits < 0) {\n\t                    wrap = 0;\n\t                    windowBits = -windowBits\n\t                } else {\n\t                    wrap = (windowBits >> 4) + 1;\n\t                    if (windowBits < 48)\n\t                        windowBits &= 15\n\t                }\n\t                if (windowBits && (windowBits < 8 || windowBits > 15))\n\t                    return Z_STREAM_ERROR;\n\t                if (state.window !== null && state.wbits !== windowBits)\n\t                    state.window = null;\n\t                state.wrap = wrap;\n\t                state.wbits = windowBits;\n\t                return inflateReset(strm)\n\t            }\n\t            function inflateInit2(strm, windowBits) {\n\t                var ret;\n\t                var state;\n\t                if (!strm)\n\t                    return Z_STREAM_ERROR;\n\t                state = new InflateState;\n\t                strm.state = state;\n\t                state.window = null;\n\t                ret = inflateReset2(strm, windowBits);\n\t                if (ret !== Z_OK)\n\t                    strm.state = null;\n\t                return ret\n\t            }\n\t            function inflateInit(strm) {\n\t                return inflateInit2(strm, DEF_WBITS)\n\t            }\n\t            var virgin = true;\n\t            var lenfix, distfix;\n\t            function fixedtables(state) {\n\t                if (virgin) {\n\t                    var sym;\n\t                    lenfix = new utils.Buf32(512);\n\t                    distfix = new utils.Buf32(32);\n\t                    sym = 0;\n\t                    while (sym < 144)\n\t                        state.lens[sym++] = 8;\n\t                    while (sym < 256)\n\t                        state.lens[sym++] = 9;\n\t                    while (sym < 280)\n\t                        state.lens[sym++] = 7;\n\t                    while (sym < 288)\n\t                        state.lens[sym++] = 8;\n\t                    inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {\n\t                        bits: 9\n\t                    });\n\t                    sym = 0;\n\t                    while (sym < 32)\n\t                        state.lens[sym++] = 5;\n\t                    inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {\n\t                        bits: 5\n\t                    });\n\t                    virgin = false\n\t                }\n\t                state.lencode = lenfix;\n\t                state.lenbits = 9;\n\t                state.distcode = distfix;\n\t                state.distbits = 5\n\t            }\n\t            function updatewindow(strm, src, end, copy) {\n\t                var dist;\n\t                var state = strm.state;\n\t                if (state.window === null) {\n\t                    state.wsize = 1 << state.wbits;\n\t                    state.wnext = 0;\n\t                    state.whave = 0;\n\t                    state.window = new utils.Buf8(state.wsize)\n\t                }\n\t                if (copy >= state.wsize) {\n\t                    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);\n\t                    state.wnext = 0;\n\t                    state.whave = state.wsize\n\t                } else {\n\t                    dist = state.wsize - state.wnext;\n\t                    if (dist > copy)\n\t                        dist = copy;\n\t                    utils.arraySet(state.window, src, end - copy, dist, state.wnext);\n\t                    copy -= dist;\n\t                    if (copy) {\n\t                        utils.arraySet(state.window, src, end - copy, copy, 0);\n\t                        state.wnext = copy;\n\t                        state.whave = state.wsize\n\t                    } else {\n\t                        state.wnext += dist;\n\t                        if (state.wnext === state.wsize)\n\t                            state.wnext = 0;\n\t                        if (state.whave < state.wsize)\n\t                            state.whave += dist\n\t                    }\n\t                }\n\t                return 0\n\t            }\n\t            function inflate(strm, flush) {\n\t                var state;\n\t                var input, output;\n\t                var next;\n\t                var put;\n\t                var have, left;\n\t                var hold;\n\t                var bits;\n\t                var _in, _out;\n\t                var copy;\n\t                var from;\n\t                var from_source;\n\t                var here = 0;\n\t                var here_bits, here_op, here_val;\n\t                var last_bits, last_op, last_val;\n\t                var len;\n\t                var ret;\n\t                var hbuf = new utils.Buf8(4);\n\t                var opts;\n\t                var n;\n\t                var order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n\t                if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0)\n\t                    return Z_STREAM_ERROR;\n\t                state = strm.state;\n\t                if (state.mode === TYPE)\n\t                    state.mode = TYPEDO;\n\t                put = strm.next_out;\n\t                output = strm.output;\n\t                left = strm.avail_out;\n\t                next = strm.next_in;\n\t                input = strm.input;\n\t                have = strm.avail_in;\n\t                hold = state.hold;\n\t                bits = state.bits;\n\t                _in = have;\n\t                _out = left;\n\t                ret = Z_OK;\n\t                inf_leave: for (; ; )\n\t                    switch (state.mode) {\n\t                    case HEAD:\n\t                        if (state.wrap === 0) {\n\t                            state.mode = TYPEDO;\n\t                            break\n\t                        }\n\t                        while (bits < 16) {\n\t                            if (have === 0)\n\t                                break inf_leave;\n\t                            have--;\n\t                            hold += input[next++] << bits;\n\t                            bits += 8\n\t                        }\n\t                        if (state.wrap & 2 && hold === 35615) {\n\t                            state.check = 0;\n\t                            hbuf[0] = hold & 255;\n\t                            hbuf[1] = hold >>> 8 & 255;\n\t                            state.check = crc32(state.check, hbuf, 2, 0);\n\t                            hold = 0;\n\t                            bits = 0;\n\t                            state.mode = FLAGS;\n\t                            break\n\t                        }\n\t                        state.flags = 0;\n\t                        if (state.head)\n\t                            state.head.done = false;\n\t                        if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {\n\t                            strm.msg = \"incorrect header check\";\n\t                            state.mode = BAD;\n\t                            break\n\t                        }\n\t                        if ((hold & 15) !== Z_DEFLATED) {\n\t                            strm.msg = \"unknown compression method\";\n\t                            state.mode = BAD;\n\t                            break\n\t                        }\n\t                        hold >>>= 4;\n\t                        bits -= 4;\n\t                        len = (hold & 15) + 8;\n\t                        if (state.wbits === 0)\n\t                            state.wbits = len;\n\t                        else if (len > state.wbits) {\n\t                            strm.msg = \"invalid window size\";\n\t                            state.mode = BAD;\n\t                            break\n\t                        }\n\t                        state.dmax = 1 << len;\n\t                        strm.adler = state.check = 1;\n\t                        state.mode = hold & 512 ? DICTID : TYPE;\n\t                        hold = 0;\n\t                        bits = 0;\n\t                        break;\n\t                    case FLAGS:\n\t                        while (bits < 16) {\n\t                            if (have === 0)\n\t                                break inf_leave;\n\t                            have--;\n\t                            hold += input[next++] << bits;\n\t                            bits += 8\n\t                        }\n\t                        state.flags = hold;\n\t                        if ((state.flags & 255) !== Z_DEFLATED) {\n\t                            strm.msg = \"unknown compression method\";\n\t                            state.mode = BAD;\n\t                            break\n\t                        }\n\t                        if (state.flags & 57344) {\n\t                            strm.msg = \"unknown header flags set\";\n\t                            state.mode = BAD;\n\t                            break\n\t                        }\n\t                        if (state.head)\n\t                            state.head.text = hold >> 8 & 1;\n\t                        if (state.flags & 512) {\n\t                            hbuf[0] = hold & 255;\n\t                            hbuf[1] = hold >>> 8 & 255;\n\t                            state.check = crc32(state.check, hbuf, 2, 0)\n\t                        }\n\t                        hold = 0;\n\t                        bits = 0;\n\t                        state.mode = TIME;\n\t                    case TIME:\n\t                        while (bits < 32) {\n\t                            if (have === 0)\n\t                                break inf_leave;\n\t                            have--;\n\t                            hold += input[next++] << bits;\n\t                            bits += 8\n\t                        }\n\t                        if (state.head)\n\t                            state.head.time = hold;\n\t                        if (state.flags & 512) {\n\t                            hbuf[0] = hold & 255;\n\t                            hbuf[1] = hold >>> 8 & 255;\n\t                            hbuf[2] = hold >>> 16 & 255;\n\t                            hbuf[3] = hold >>> 24 & 255;\n\t                            state.check = crc32(state.check, hbuf, 4, 0)\n\t                        }\n\t                        hold = 0;\n\t                        bits = 0;\n\t                        state.mode = OS;\n\t                    case OS:\n\t                        while (bits < 16) {\n\t                            if (have === 0)\n\t                                break inf_leave;\n\t                            have--;\n\t                            hold += input[next++] << bits;\n\t                            bits += 8\n\t                        }\n\t                        if (state.head) {\n\t                            state.head.xflags = hold & 255;\n\t                            state.head.os = hold >> 8\n\t                        }\n\t                        if (state.flags & 512) {\n\t                            hbuf[0] = hold & 255;\n\t                            hbuf[1] = hold >>> 8 & 255;\n\t                            state.check = crc32(state.check, hbuf, 2, 0)\n\t                        }\n\t                        hold = 0;\n\t                        bits = 0;\n\t                        state.mode = EXLEN;\n\t                    case EXLEN:\n\t                        if (state.flags & 1024) {\n\t                            while (bits < 16) {\n\t                                if (have === 0)\n\t                                    break inf_leave;\n\t                                have--;\n\t                                hold += input[next++] << bits;\n\t                                bits += 8\n\t                            }\n\t                            state.length = hold;\n\t                            if (state.head)\n\t                                state.head.extra_len = hold;\n\t                            if (state.flags & 512) {\n\t                                hbuf[0] = hold & 255;\n\t                                hbuf[1] = hold >>> 8 & 255;\n\t                                state.check = crc32(state.check, hbuf, 2, 0)\n\t                            }\n\t                            hold = 0;\n\t                            bits = 0\n\t                        } else if (state.head)\n\t                            state.head.extra = null;\n\t                        state.mode = EXTRA;\n\t                    case EXTRA:\n\t                        if (state.flags & 1024) {\n\t                            copy = state.length;\n\t                            if (copy > have)\n\t                                copy = have;\n\t                            if (copy) {\n\t                                if (state.head) {\n\t                                    len = state.head.extra_len - state.length;\n\t                                    if (!state.head.extra)\n\t                                        state.head.extra = new Array(state.head.extra_len);\n\t                                    utils.arraySet(state.head.extra, input, next, copy, len)\n\t                                }\n\t                                if (state.flags & 512)\n\t                                    state.check = crc32(state.check, input, copy, next);\n\t                                have -= copy;\n\t                                next += copy;\n\t                                state.length -= copy\n\t                            }\n\t                            if (state.length)\n\t                                break inf_leave\n\t                        }\n\t                        state.length = 0;\n\t                        state.mode = NAME;\n\t                    case NAME:\n\t                        if (state.flags & 2048) {\n\t                            if (have === 0)\n\t                                break inf_leave;\n\t                            copy = 0;\n\t                            do {\n\t                                len = input[next + copy++];\n\t                                if (state.head && len && state.length < 65536)\n\t                                    state.head.name += String.fromCharCode(len)\n\t                            } while (len && copy < have);\n\t                            if (state.flags & 512)\n\t                                state.check = crc32(state.check, input, copy, next);\n\t                            have -= copy;\n\t                            next += copy;\n\t                            if (len)\n\t                                break inf_leave\n\t                        } else if (state.head)\n\t                            state.head.name = null;\n\t                        state.length = 0;\n\t                        state.mode = COMMENT;\n\t                    case COMMENT:\n\t                        if (state.flags & 4096) {\n\t                            if (have === 0)\n\t                                break inf_leave;\n\t                            copy = 0;\n\t                            do {\n\t                                len = input[next + copy++];\n\t                                if (state.head && len && state.length < 65536)\n\t                                    state.head.comment += String.fromCharCode(len)\n\t                            } while (len && copy < have);\n\t                            if (state.flags & 512)\n\t                                state.check = crc32(state.check, input, copy, next);\n\t                            have -= copy;\n\t                            next += copy;\n\t                            if (len)\n\t                                break inf_leave\n\t                        } else if (state.head)\n\t                            state.head.comment = null;\n\t                        state.mode = HCRC;\n\t                    case HCRC:\n\t                        if (state.flags & 512) {\n\t                            while (bits < 16) {\n\t                                if (have === 0)\n\t                                    break inf_leave;\n\t                                have--;\n\t                                hold += input[next++] << bits;\n\t                                bits += 8\n\t                            }\n\t                            if (hold !== (state.check & 65535)) {\n\t                                strm.msg = \"header crc mismatch\";\n\t                                state.mode = BAD;\n\t                                break\n\t                            }\n\t                            hold = 0;\n\t                            bits = 0\n\t                        }\n\t                        if (state.head) {\n\t                            state.head.hcrc = state.flags >> 9 & 1;\n\t                            state.head.done = true\n\t                        }\n\t                        strm.adler = state.check = 0;\n\t                        state.mode = TYPE;\n\t                        break;\n\t                    case DICTID:\n\t                        while (bits < 32) {\n\t                            if (have === 0)\n\t                                break inf_leave;\n\t                            have--;\n\t                            hold += input[next++] << bits;\n\t                            bits += 8\n\t                        }\n\t                        strm.adler = state.check = ZSWAP32(hold);\n\t                        hold = 0;\n\t                        bits = 0;\n\t                        state.mode = DICT;\n\t                    case DICT:\n\t                        if (state.havedict === 0) {\n\t                            strm.next_out = put;\n\t                            strm.avail_out = left;\n\t                            strm.next_in = next;\n\t                            strm.avail_in = have;\n\t                            state.hold = hold;\n\t                            state.bits = bits;\n\t                            return Z_NEED_DICT\n\t                        }\n\t                        strm.adler = state.check = 1;\n\t                        state.mode = TYPE;\n\t                    case TYPE:\n\t                        if (flush === Z_BLOCK || flush === Z_TREES)\n\t                            break inf_leave;\n\t                    case TYPEDO:\n\t                        if (state.last) {\n\t                            hold >>>= bits & 7;\n\t                            bits -= bits & 7;\n\t                            state.mode = CHECK;\n\t                            break\n\t                        }\n\t                        while (bits < 3) {\n\t                            if (have === 0)\n\t                                break inf_leave;\n\t                            have--;\n\t                            hold += input[next++] << bits;\n\t                            bits += 8\n\t                        }\n\t                        state.last = hold & 1;\n\t                        hold >>>= 1;\n\t                        bits -= 1;\n\t                        switch (hold & 3) {\n\t                        case 0:\n\t                            state.mode = STORED;\n\t                            break;\n\t                        case 1:\n\t                            fixedtables(state);\n\t                            state.mode = LEN_;\n\t                            if (flush === Z_TREES) {\n\t                                hold >>>= 2;\n\t                                bits -= 2;\n\t                                break inf_leave\n\t                            }\n\t                            break;\n\t                        case 2:\n\t                            state.mode = TABLE;\n\t                            break;\n\t                        case 3:\n\t                            strm.msg = \"invalid block type\";\n\t                            state.mode = BAD\n\t                        }\n\t                        hold >>>= 2;\n\t                        bits -= 2;\n\t                        break;\n\t                    case STORED:\n\t                        hold >>>= bits & 7;\n\t                        bits -= bits & 7;\n\t                        while (bits < 32) {\n\t                            if (have === 0)\n\t                                break inf_leave;\n\t                            have--;\n\t                            hold += input[next++] << bits;\n\t                            bits += 8\n\t                        }\n\t                        if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {\n\t                            strm.msg = \"invalid stored block lengths\";\n\t                            state.mode = BAD;\n\t                            break\n\t                        }\n\t                        state.length = hold & 65535;\n\t                        hold = 0;\n\t                        bits = 0;\n\t                        state.mode = COPY_;\n\t                        if (flush === Z_TREES)\n\t                            break inf_leave;\n\t                    case COPY_:\n\t                        state.mode = COPY;\n\t                    case COPY:\n\t                        copy = state.length;\n\t                        if (copy) {\n\t                            if (copy > have)\n\t                                copy = have;\n\t                            if (copy > left)\n\t                                copy = left;\n\t                            if (copy === 0)\n\t                                break inf_leave;\n\t                            utils.arraySet(output, input, next, copy, put);\n\t                            have -= copy;\n\t                            next += copy;\n\t                            left -= copy;\n\t                            put += copy;\n\t                            state.length -= copy;\n\t                            break\n\t                        }\n\t                        state.mode = TYPE;\n\t                        break;\n\t                    case TABLE:\n\t                        while (bits < 14) {\n\t                            if (have === 0)\n\t                                break inf_leave;\n\t                            have--;\n\t                            hold += input[next++] << bits;\n\t                            bits += 8\n\t                        }\n\t                        state.nlen = (hold & 31) + 257;\n\t                        hold >>>= 5;\n\t                        bits -= 5;\n\t                        state.ndist = (hold & 31) + 1;\n\t                        hold >>>= 5;\n\t                        bits -= 5;\n\t                        state.ncode = (hold & 15) + 4;\n\t                        hold >>>= 4;\n\t                        bits -= 4;\n\t                        if (state.nlen > 286 || state.ndist > 30) {\n\t                            strm.msg = \"too many length or distance symbols\";\n\t                            state.mode = BAD;\n\t                            break\n\t                        }\n\t                        state.have = 0;\n\t                        state.mode = LENLENS;\n\t                    case LENLENS:\n\t                        while (state.have < state.ncode) {\n\t                            while (bits < 3) {\n\t                                if (have === 0)\n\t                                    break inf_leave;\n\t                                have--;\n\t                                hold += input[next++] << bits;\n\t                                bits += 8\n\t                            }\n\t                            state.lens[order[state.have++]] = hold & 7;\n\t                            hold >>>= 3;\n\t                            bits -= 3\n\t                        }\n\t                        while (state.have < 19)\n\t                            state.lens[order[state.have++]] = 0;\n\t                        state.lencode = state.lendyn;\n\t                        state.lenbits = 7;\n\t                        opts = {\n\t                            bits: state.lenbits\n\t                        };\n\t                        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n\t                        state.lenbits = opts.bits;\n\t                        if (ret) {\n\t                            strm.msg = \"invalid code lengths set\";\n\t                            state.mode = BAD;\n\t                            break\n\t                        }\n\t                        state.have = 0;\n\t                        state.mode = CODELENS;\n\t                    case CODELENS:\n\t                        while (state.have < state.nlen + state.ndist) {\n\t                            for (; ; ) {\n\t                                here = state.lencode[hold & (1 << state.lenbits) - 1];\n\t                                here_bits = here >>> 24;\n\t                                here_op = here >>> 16 & 255;\n\t                                here_val = here & 65535;\n\t                                if (here_bits <= bits)\n\t                                    break;\n\t                                if (have === 0)\n\t                                    break inf_leave;\n\t                                have--;\n\t                                hold += input[next++] << bits;\n\t                                bits += 8\n\t                            }\n\t                            if (here_val < 16) {\n\t                                hold >>>= here_bits;\n\t                                bits -= here_bits;\n\t                                state.lens[state.have++] = here_val\n\t                            } else {\n\t                                if (here_val === 16) {\n\t                                    n = here_bits + 2;\n\t                                    while (bits < n) {\n\t                                        if (have === 0)\n\t                                            break inf_leave;\n\t                                        have--;\n\t                                        hold += input[next++] << bits;\n\t                                        bits += 8\n\t                                    }\n\t                                    hold >>>= here_bits;\n\t                                    bits -= here_bits;\n\t                                    if (state.have === 0) {\n\t                                        strm.msg = \"invalid bit length repeat\";\n\t                                        state.mode = BAD;\n\t                                        break\n\t                                    }\n\t                                    len = state.lens[state.have - 1];\n\t                                    copy = 3 + (hold & 3);\n\t                                    hold >>>= 2;\n\t                                    bits -= 2\n\t                                } else if (here_val === 17) {\n\t                                    n = here_bits + 3;\n\t                                    while (bits < n) {\n\t                                        if (have === 0)\n\t                                            break inf_leave;\n\t                                        have--;\n\t                                        hold += input[next++] << bits;\n\t                                        bits += 8\n\t                                    }\n\t                                    hold >>>= here_bits;\n\t                                    bits -= here_bits;\n\t                                    len = 0;\n\t                                    copy = 3 + (hold & 7);\n\t                                    hold >>>= 3;\n\t                                    bits -= 3\n\t                                } else {\n\t                                    n = here_bits + 7;\n\t                                    while (bits < n) {\n\t                                        if (have === 0)\n\t                                            break inf_leave;\n\t                                        have--;\n\t                                        hold += input[next++] << bits;\n\t                                        bits += 8\n\t                                    }\n\t                                    hold >>>= here_bits;\n\t                                    bits -= here_bits;\n\t                                    len = 0;\n\t                                    copy = 11 + (hold & 127);\n\t                                    hold >>>= 7;\n\t                                    bits -= 7\n\t                                }\n\t                                if (state.have + copy > state.nlen + state.ndist) {\n\t                                    strm.msg = \"invalid bit length repeat\";\n\t                                    state.mode = BAD;\n\t                                    break\n\t                                }\n\t                                while (copy--)\n\t                                    state.lens[state.have++] = len\n\t                            }\n\t                        }\n\t                        if (state.mode === BAD)\n\t                            break;\n\t                        if (state.lens[256] === 0) {\n\t                            strm.msg = \"invalid code -- missing end-of-block\";\n\t                            state.mode = BAD;\n\t                            break\n\t                        }\n\t                        state.lenbits = 9;\n\t                        opts = {\n\t                            bits: state.lenbits\n\t                        };\n\t                        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n\t                        state.lenbits = opts.bits;\n\t                        if (ret) {\n\t                            strm.msg = \"invalid literal/lengths set\";\n\t                            state.mode = BAD;\n\t                            break\n\t                        }\n\t                        state.distbits = 6;\n\t                        state.distcode = state.distdyn;\n\t                        opts = {\n\t                            bits: state.distbits\n\t                        };\n\t                        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n\t                        state.distbits = opts.bits;\n\t                        if (ret) {\n\t                            strm.msg = \"invalid distances set\";\n\t                            state.mode = BAD;\n\t                            break\n\t                        }\n\t                        state.mode = LEN_;\n\t                        if (flush === Z_TREES)\n\t                            break inf_leave;\n\t                    case LEN_:\n\t                        state.mode = LEN;\n\t                    case LEN:\n\t                        if (have >= 6 && left >= 258) {\n\t                            strm.next_out = put;\n\t                            strm.avail_out = left;\n\t                            strm.next_in = next;\n\t                            strm.avail_in = have;\n\t                            state.hold = hold;\n\t                            state.bits = bits;\n\t                            inflate_fast(strm, _out);\n\t                            put = strm.next_out;\n\t                            output = strm.output;\n\t                            left = strm.avail_out;\n\t                            next = strm.next_in;\n\t                            input = strm.input;\n\t                            have = strm.avail_in;\n\t                            hold = state.hold;\n\t                            bits = state.bits;\n\t                            if (state.mode === TYPE)\n\t                                state.back = -1;\n\t                            break\n\t                        }\n\t                        state.back = 0;\n\t                        for (; ; ) {\n\t                            here = state.lencode[hold & (1 << state.lenbits) - 1];\n\t                            here_bits = here >>> 24;\n\t                            here_op = here >>> 16 & 255;\n\t                            here_val = here & 65535;\n\t                            if (here_bits <= bits)\n\t                                break;\n\t                            if (have === 0)\n\t                                break inf_leave;\n\t                            have--;\n\t                            hold += input[next++] << bits;\n\t                            bits += 8\n\t                        }\n\t                        if (here_op && (here_op & 240) === 0) {\n\t                            last_bits = here_bits;\n\t                            last_op = here_op;\n\t                            last_val = here_val;\n\t                            for (; ; ) {\n\t                                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];\n\t                                here_bits = here >>> 24;\n\t                                here_op = here >>> 16 & 255;\n\t                                here_val = here & 65535;\n\t                                if (last_bits + here_bits <= bits)\n\t                                    break;\n\t                                if (have === 0)\n\t                                    break inf_leave;\n\t                                have--;\n\t                                hold += input[next++] << bits;\n\t                                bits += 8\n\t                            }\n\t                            hold >>>= last_bits;\n\t                            bits -= last_bits;\n\t                            state.back += last_bits\n\t                        }\n\t                        hold >>>= here_bits;\n\t                        bits -= here_bits;\n\t                        state.back += here_bits;\n\t                        state.length = here_val;\n\t                        if (here_op === 0) {\n\t                            state.mode = LIT;\n\t                            break\n\t                        }\n\t                        if (here_op & 32) {\n\t                            state.back = -1;\n\t                            state.mode = TYPE;\n\t                            break\n\t                        }\n\t                        if (here_op & 64) {\n\t                            strm.msg = \"invalid literal/length code\";\n\t                            state.mode = BAD;\n\t                            break\n\t                        }\n\t                        state.extra = here_op & 15;\n\t                        state.mode = LENEXT;\n\t                    case LENEXT:\n\t                        if (state.extra) {\n\t                            n = state.extra;\n\t                            while (bits < n) {\n\t                                if (have === 0)\n\t                                    break inf_leave;\n\t                                have--;\n\t                                hold += input[next++] << bits;\n\t                                bits += 8\n\t                            }\n\t                            state.length += hold & (1 << state.extra) - 1;\n\t                            hold >>>= state.extra;\n\t                            bits -= state.extra;\n\t                            state.back += state.extra\n\t                        }\n\t                        state.was = state.length;\n\t                        state.mode = DIST;\n\t                    case DIST:\n\t                        for (; ; ) {\n\t                            here = state.distcode[hold & (1 << state.distbits) - 1];\n\t                            here_bits = here >>> 24;\n\t                            here_op = here >>> 16 & 255;\n\t                            here_val = here & 65535;\n\t                            if (here_bits <= bits)\n\t                                break;\n\t                            if (have === 0)\n\t                                break inf_leave;\n\t                            have--;\n\t                            hold += input[next++] << bits;\n\t                            bits += 8\n\t                        }\n\t                        if ((here_op & 240) === 0) {\n\t                            last_bits = here_bits;\n\t                            last_op = here_op;\n\t                            last_val = here_val;\n\t                            for (; ; ) {\n\t                                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];\n\t                                here_bits = here >>> 24;\n\t                                here_op = here >>> 16 & 255;\n\t                                here_val = here & 65535;\n\t                                if (last_bits + here_bits <= bits)\n\t                                    break;\n\t                                if (have === 0)\n\t                                    break inf_leave;\n\t                                have--;\n\t                                hold += input[next++] << bits;\n\t                                bits += 8\n\t                            }\n\t                            hold >>>= last_bits;\n\t                            bits -= last_bits;\n\t                            state.back += last_bits\n\t                        }\n\t                        hold >>>= here_bits;\n\t                        bits -= here_bits;\n\t                        state.back += here_bits;\n\t                        if (here_op & 64) {\n\t                            strm.msg = \"invalid distance code\";\n\t                            state.mode = BAD;\n\t                            break\n\t                        }\n\t                        state.offset = here_val;\n\t                        state.extra = here_op & 15;\n\t                        state.mode = DISTEXT;\n\t                    case DISTEXT:\n\t                        if (state.extra) {\n\t                            n = state.extra;\n\t                            while (bits < n) {\n\t                                if (have === 0)\n\t                                    break inf_leave;\n\t                                have--;\n\t                                hold += input[next++] << bits;\n\t                                bits += 8\n\t                            }\n\t                            state.offset += hold & (1 << state.extra) - 1;\n\t                            hold >>>= state.extra;\n\t                            bits -= state.extra;\n\t                            state.back += state.extra\n\t                        }\n\t                        if (state.offset > state.dmax) {\n\t                            strm.msg = \"invalid distance too far back\";\n\t                            state.mode = BAD;\n\t                            break\n\t                        }\n\t                        state.mode = MATCH;\n\t                    case MATCH:\n\t                        if (left === 0)\n\t                            break inf_leave;\n\t                        copy = _out - left;\n\t                        if (state.offset > copy) {\n\t                            copy = state.offset - copy;\n\t                            if (copy > state.whave)\n\t                                if (state.sane) {\n\t                                    strm.msg = \"invalid distance too far back\";\n\t                                    state.mode = BAD;\n\t                                    break\n\t                                }\n\t                            if (copy > state.wnext) {\n\t                                copy -= state.wnext;\n\t                                from = state.wsize - copy\n\t                            } else\n\t                                from = state.wnext - copy;\n\t                            if (copy > state.length)\n\t                                copy = state.length;\n\t                            from_source = state.window\n\t                        } else {\n\t                            from_source = output;\n\t                            from = put - state.offset;\n\t                            copy = state.length\n\t                        }\n\t                        if (copy > left)\n\t                            copy = left;\n\t                        left -= copy;\n\t                        state.length -= copy;\n\t                        do\n\t                            output[put++] = from_source[from++];\n\t                        while (--copy);\n\t                        if (state.length === 0)\n\t                            state.mode = LEN;\n\t                        break;\n\t                    case LIT:\n\t                        if (left === 0)\n\t                            break inf_leave;\n\t                        output[put++] = state.length;\n\t                        left--;\n\t                        state.mode = LEN;\n\t                        break;\n\t                    case CHECK:\n\t                        if (state.wrap) {\n\t                            while (bits < 32) {\n\t                                if (have === 0)\n\t                                    break inf_leave;\n\t                                have--;\n\t                                hold |= input[next++] << bits;\n\t                                bits += 8\n\t                            }\n\t                            _out -= left;\n\t                            strm.total_out += _out;\n\t                            state.total += _out;\n\t                            if (_out)\n\t                                strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);\n\t                            _out = left;\n\t                            if ((state.flags ? hold : ZSWAP32(hold)) !== state.check) {\n\t                                strm.msg = \"incorrect data check\";\n\t                                state.mode = BAD;\n\t                                break\n\t                            }\n\t                            hold = 0;\n\t                            bits = 0\n\t                        }\n\t                        state.mode = LENGTH;\n\t                    case LENGTH:\n\t                        if (state.wrap && state.flags) {\n\t                            while (bits < 32) {\n\t                                if (have === 0)\n\t                                    break inf_leave;\n\t                                have--;\n\t                                hold += input[next++] << bits;\n\t                                bits += 8\n\t                            }\n\t                            if (hold !== (state.total & 4294967295)) {\n\t                                strm.msg = \"incorrect length check\";\n\t                                state.mode = BAD;\n\t                                break\n\t                            }\n\t                            hold = 0;\n\t                            bits = 0\n\t                        }\n\t                        state.mode = DONE;\n\t                    case DONE:\n\t                        ret = Z_STREAM_END;\n\t                        break inf_leave;\n\t                    case BAD:\n\t                        ret = Z_DATA_ERROR;\n\t                        break inf_leave;\n\t                    case MEM:\n\t                        return Z_MEM_ERROR;\n\t                    case SYNC:\n\t                    default:\n\t                        return Z_STREAM_ERROR\n\t                    }\n\t                strm.next_out = put;\n\t                strm.avail_out = left;\n\t                strm.next_in = next;\n\t                strm.avail_in = have;\n\t                state.hold = hold;\n\t                state.bits = bits;\n\t                if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH))\n\t                    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {\n\t                        state.mode = MEM;\n\t                        return Z_MEM_ERROR\n\t                    }\n\t                _in -= strm.avail_in;\n\t                _out -= strm.avail_out;\n\t                strm.total_in += _in;\n\t                strm.total_out += _out;\n\t                state.total += _out;\n\t                if (state.wrap && _out)\n\t                    strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);\n\t                strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n\t                if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK)\n\t                    ret = Z_BUF_ERROR;\n\t                return ret\n\t            }\n\t            function inflateEnd(strm) {\n\t                if (!strm || !strm.state)\n\t                    return Z_STREAM_ERROR;\n\t                var state = strm.state;\n\t                if (state.window)\n\t                    state.window = null;\n\t                strm.state = null;\n\t                return Z_OK\n\t            }\n\t            function inflateGetHeader(strm, head) {\n\t                var state;\n\t                if (!strm || !strm.state)\n\t                    return Z_STREAM_ERROR;\n\t                state = strm.state;\n\t                if ((state.wrap & 2) === 0)\n\t                    return Z_STREAM_ERROR;\n\t                state.head = head;\n\t                head.done = false;\n\t                return Z_OK\n\t            }\n\t            exports.inflateReset = inflateReset;\n\t            exports.inflateReset2 = inflateReset2;\n\t            exports.inflateResetKeep = inflateResetKeep;\n\t            exports.inflateInit = inflateInit;\n\t            exports.inflateInit2 = inflateInit2;\n\t            exports.inflate = inflate;\n\t            exports.inflateEnd = inflateEnd;\n\t            exports.inflateGetHeader = inflateGetHeader;\n\t            exports.inflateInfo = \"pako inflate (from Nodeca project)\"\n\t        }\n\t        , {\n\t            \"../utils/common\": 27,\n\t            \"./adler32\": 29,\n\t            \"./crc32\": 31,\n\t            \"./inffast\": 34,\n\t            \"./inftrees\": 36\n\t        }],\n\t        36: [function(_dereq_, module, exports) {\n\t            var utils = _dereq_(\"../utils/common\");\n\t            var MAXBITS = 15;\n\t            var ENOUGH_LENS = 852;\n\t            var ENOUGH_DISTS = 592;\n\t            var CODES = 0;\n\t            var LENS = 1;\n\t            var DISTS = 2;\n\t            var lbase = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];\n\t            var lext = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78];\n\t            var dbase = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0];\n\t            var dext = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];\n\t            module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {\n\t                var bits = opts.bits;\n\t                var len = 0;\n\t                var sym = 0;\n\t                var min = 0\n\t                  , max = 0;\n\t                var root = 0;\n\t                var curr = 0;\n\t                var drop = 0;\n\t                var left = 0;\n\t                var used = 0;\n\t                var huff = 0;\n\t                var incr;\n\t                var fill;\n\t                var low;\n\t                var mask;\n\t                var next;\n\t                var base = null;\n\t                var base_index = 0;\n\t                var end;\n\t                var count = new utils.Buf16(MAXBITS + 1);\n\t                var offs = new utils.Buf16(MAXBITS + 1);\n\t                var extra = null;\n\t                var extra_index = 0;\n\t                var here_bits, here_op, here_val;\n\t                for (len = 0; len <= MAXBITS; len++)\n\t                    count[len] = 0;\n\t                for (sym = 0; sym < codes; sym++)\n\t                    count[lens[lens_index + sym]]++;\n\t                root = bits;\n\t                for (max = MAXBITS; max >= 1; max--)\n\t                    if (count[max] !== 0)\n\t                        break;\n\t                if (root > max)\n\t                    root = max;\n\t                if (max === 0) {\n\t                    table[table_index++] = 1 << 24 | 64 << 16 | 0;\n\t                    table[table_index++] = 1 << 24 | 64 << 16 | 0;\n\t                    opts.bits = 1;\n\t                    return 0\n\t                }\n\t                for (min = 1; min < max; min++)\n\t                    if (count[min] !== 0)\n\t                        break;\n\t                if (root < min)\n\t                    root = min;\n\t                left = 1;\n\t                for (len = 1; len <= MAXBITS; len++) {\n\t                    left <<= 1;\n\t                    left -= count[len];\n\t                    if (left < 0)\n\t                        return -1\n\t                }\n\t                if (left > 0 && (type === CODES || max !== 1))\n\t                    return -1;\n\t                offs[1] = 0;\n\t                for (len = 1; len < MAXBITS; len++)\n\t                    offs[len + 1] = offs[len] + count[len];\n\t                for (sym = 0; sym < codes; sym++)\n\t                    if (lens[lens_index + sym] !== 0)\n\t                        work[offs[lens[lens_index + sym]]++] = sym;\n\t                if (type === CODES) {\n\t                    base = extra = work;\n\t                    end = 19\n\t                } else if (type === LENS) {\n\t                    base = lbase;\n\t                    base_index -= 257;\n\t                    extra = lext;\n\t                    extra_index -= 257;\n\t                    end = 256\n\t                } else {\n\t                    base = dbase;\n\t                    extra = dext;\n\t                    end = -1\n\t                }\n\t                huff = 0;\n\t                sym = 0;\n\t                len = min;\n\t                next = table_index;\n\t                curr = root;\n\t                drop = 0;\n\t                low = -1;\n\t                used = 1 << root;\n\t                mask = used - 1;\n\t                if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS)\n\t                    return 1;\n\t                var i = 0;\n\t                for (; ; ) {\n\t                    i++;\n\t                    here_bits = len - drop;\n\t                    if (work[sym] < end) {\n\t                        here_op = 0;\n\t                        here_val = work[sym]\n\t                    } else if (work[sym] > end) {\n\t                        here_op = extra[extra_index + work[sym]];\n\t                        here_val = base[base_index + work[sym]]\n\t                    } else {\n\t                        here_op = 32 + 64;\n\t                        here_val = 0\n\t                    }\n\t                    incr = 1 << len - drop;\n\t                    fill = 1 << curr;\n\t                    min = fill;\n\t                    do {\n\t                        fill -= incr;\n\t                        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0\n\t                    } while (fill !== 0);\n\t                    incr = 1 << len - 1;\n\t                    while (huff & incr)\n\t                        incr >>= 1;\n\t                    if (incr !== 0) {\n\t                        huff &= incr - 1;\n\t                        huff += incr\n\t                    } else\n\t                        huff = 0;\n\t                    sym++;\n\t                    if (--count[len] === 0) {\n\t                        if (len === max)\n\t                            break;\n\t                        len = lens[lens_index + work[sym]]\n\t                    }\n\t                    if (len > root && (huff & mask) !== low) {\n\t                        if (drop === 0)\n\t                            drop = root;\n\t                        next += min;\n\t                        curr = len - drop;\n\t                        left = 1 << curr;\n\t                        while (curr + drop < max) {\n\t                            left -= count[curr + drop];\n\t                            if (left <= 0)\n\t                                break;\n\t                            curr++;\n\t                            left <<= 1\n\t                        }\n\t                        used += 1 << curr;\n\t                        if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS)\n\t                            return 1;\n\t                        low = huff & mask;\n\t                        table[low] = root << 24 | curr << 16 | next - table_index | 0\n\t                    }\n\t                }\n\t                if (huff !== 0)\n\t                    table[next + huff] = len - drop << 24 | 64 << 16 | 0;\n\t                opts.bits = root;\n\t                return 0\n\t            }\n\t        }\n\t        , {\n\t            \"../utils/common\": 27\n\t        }],\n\t        37: [function(_dereq_, module, exports) {\n\t            module.exports = {\n\t                2: \"need dictionary\",\n\t                1: \"stream end\",\n\t                0: \"\",\n\t                \"-1\": \"file error\",\n\t                \"-2\": \"stream error\",\n\t                \"-3\": \"data error\",\n\t                \"-4\": \"insufficient memory\",\n\t                \"-5\": \"buffer error\",\n\t                \"-6\": \"incompatible version\"\n\t            }\n\t        }\n\t        , {}],\n\t        38: [function(_dereq_, module, exports) {\n\t            var utils = _dereq_(\"../utils/common\");\n\t            var Z_FIXED = 4;\n\t            var Z_BINARY = 0;\n\t            var Z_TEXT = 1;\n\t            var Z_UNKNOWN = 2;\n\t            function zero(buf) {\n\t                var len = buf.length;\n\t                while (--len >= 0)\n\t                    buf[len] = 0\n\t            }\n\t            var STORED_BLOCK = 0;\n\t            var STATIC_TREES = 1;\n\t            var DYN_TREES = 2;\n\t            var MIN_MATCH = 3;\n\t            var MAX_MATCH = 258;\n\t            var LENGTH_CODES = 29;\n\t            var LITERALS = 256;\n\t            var L_CODES = LITERALS + 1 + LENGTH_CODES;\n\t            var D_CODES = 30;\n\t            var BL_CODES = 19;\n\t            var HEAP_SIZE = 2 * L_CODES + 1;\n\t            var MAX_BITS = 15;\n\t            var Buf_size = 16;\n\t            var MAX_BL_BITS = 7;\n\t            var END_BLOCK = 256;\n\t            var REP_3_6 = 16;\n\t            var REPZ_3_10 = 17;\n\t            var REPZ_11_138 = 18;\n\t            var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];\n\t            var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];\n\t            var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];\n\t            var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n\t            var DIST_CODE_LEN = 512;\n\t            var static_ltree = new Array((L_CODES + 2) * 2);\n\t            zero(static_ltree);\n\t            var static_dtree = new Array(D_CODES * 2);\n\t            zero(static_dtree);\n\t            var _dist_code = new Array(DIST_CODE_LEN);\n\t            zero(_dist_code);\n\t            var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);\n\t            zero(_length_code);\n\t            var base_length = new Array(LENGTH_CODES);\n\t            zero(base_length);\n\t            var base_dist = new Array(D_CODES);\n\t            zero(base_dist);\n\t            var StaticTreeDesc = function(static_tree, extra_bits, extra_base, elems, max_length) {\n\t                this.static_tree = static_tree;\n\t                this.extra_bits = extra_bits;\n\t                this.extra_base = extra_base;\n\t                this.elems = elems;\n\t                this.max_length = max_length;\n\t                this.has_stree = static_tree && static_tree.length\n\t            };\n\t            var static_l_desc;\n\t            var static_d_desc;\n\t            var static_bl_desc;\n\t            var TreeDesc = function(dyn_tree, stat_desc) {\n\t                this.dyn_tree = dyn_tree;\n\t                this.max_code = 0;\n\t                this.stat_desc = stat_desc\n\t            };\n\t            function d_code(dist) {\n\t                return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)]\n\t            }\n\t            function put_short(s, w) {\n\t                s.pending_buf[s.pending++] = w & 255;\n\t                s.pending_buf[s.pending++] = w >>> 8 & 255\n\t            }\n\t            function send_bits(s, value, length) {\n\t                if (s.bi_valid > Buf_size - length) {\n\t                    s.bi_buf |= value << s.bi_valid & 65535;\n\t                    put_short(s, s.bi_buf);\n\t                    s.bi_buf = value >> Buf_size - s.bi_valid;\n\t                    s.bi_valid += length - Buf_size\n\t                } else {\n\t                    s.bi_buf |= value << s.bi_valid & 65535;\n\t                    s.bi_valid += length\n\t                }\n\t            }\n\t            function send_code(s, c, tree) {\n\t                send_bits(s, tree[c * 2], tree[c * 2 + 1])\n\t            }\n\t            function bi_reverse(code, len) {\n\t                var res = 0;\n\t                do {\n\t                    res |= code & 1;\n\t                    code >>>= 1;\n\t                    res <<= 1\n\t                } while (--len > 0);\n\t                return res >>> 1\n\t            }\n\t            function bi_flush(s) {\n\t                if (s.bi_valid === 16) {\n\t                    put_short(s, s.bi_buf);\n\t                    s.bi_buf = 0;\n\t                    s.bi_valid = 0\n\t                } else if (s.bi_valid >= 8) {\n\t                    s.pending_buf[s.pending++] = s.bi_buf & 255;\n\t                    s.bi_buf >>= 8;\n\t                    s.bi_valid -= 8\n\t                }\n\t            }\n\t            function gen_bitlen(s, desc) {\n\t                var tree = desc.dyn_tree;\n\t                var max_code = desc.max_code;\n\t                var stree = desc.stat_desc.static_tree;\n\t                var has_stree = desc.stat_desc.has_stree;\n\t                var extra = desc.stat_desc.extra_bits;\n\t                var base = desc.stat_desc.extra_base;\n\t                var max_length = desc.stat_desc.max_length;\n\t                var h;\n\t                var n, m;\n\t                var bits;\n\t                var xbits;\n\t                var f;\n\t                var overflow = 0;\n\t                for (bits = 0; bits <= MAX_BITS; bits++)\n\t                    s.bl_count[bits] = 0;\n\t                tree[s.heap[s.heap_max] * 2 + 1] = 0;\n\t                for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n\t                    n = s.heap[h];\n\t                    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;\n\t                    if (bits > max_length) {\n\t                        bits = max_length;\n\t                        overflow++\n\t                    }\n\t                    tree[n * 2 + 1] = bits;\n\t                    if (n > max_code)\n\t                        continue;\n\t                    s.bl_count[bits]++;\n\t                    xbits = 0;\n\t                    if (n >= base)\n\t                        xbits = extra[n - base];\n\t                    f = tree[n * 2];\n\t                    s.opt_len += f * (bits + xbits);\n\t                    if (has_stree)\n\t                        s.static_len += f * (stree[n * 2 + 1] + xbits)\n\t                }\n\t                if (overflow === 0)\n\t                    return;\n\t                do {\n\t                    bits = max_length - 1;\n\t                    while (s.bl_count[bits] === 0)\n\t                        bits--;\n\t                    s.bl_count[bits]--;\n\t                    s.bl_count[bits + 1] += 2;\n\t                    s.bl_count[max_length]--;\n\t                    overflow -= 2\n\t                } while (overflow > 0);\n\t                for (bits = max_length; bits !== 0; bits--) {\n\t                    n = s.bl_count[bits];\n\t                    while (n !== 0) {\n\t                        m = s.heap[--h];\n\t                        if (m > max_code)\n\t                            continue;\n\t                        if (tree[m * 2 + 1] !== bits) {\n\t                            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];\n\t                            tree[m * 2 + 1] = bits\n\t                        }\n\t                        n--\n\t                    }\n\t                }\n\t            }\n\t            function gen_codes(tree, max_code, bl_count) {\n\t                var next_code = new Array(MAX_BITS + 1);\n\t                var code = 0;\n\t                var bits;\n\t                var n;\n\t                for (bits = 1; bits <= MAX_BITS; bits++)\n\t                    next_code[bits] = code = code + bl_count[bits - 1] << 1;\n\t                for (n = 0; n <= max_code; n++) {\n\t                    var len = tree[n * 2 + 1];\n\t                    if (len === 0)\n\t                        continue;\n\t                    tree[n * 2] = bi_reverse(next_code[len]++, len)\n\t                }\n\t            }\n\t            function tr_static_init() {\n\t                var n;\n\t                var bits;\n\t                var length;\n\t                var code;\n\t                var dist;\n\t                var bl_count = new Array(MAX_BITS + 1);\n\t                length = 0;\n\t                for (code = 0; code < LENGTH_CODES - 1; code++) {\n\t                    base_length[code] = length;\n\t                    for (n = 0; n < 1 << extra_lbits[code]; n++)\n\t                        _length_code[length++] = code\n\t                }\n\t                _length_code[length - 1] = code;\n\t                dist = 0;\n\t                for (code = 0; code < 16; code++) {\n\t                    base_dist[code] = dist;\n\t                    for (n = 0; n < 1 << extra_dbits[code]; n++)\n\t                        _dist_code[dist++] = code\n\t                }\n\t                dist >>= 7;\n\t                for (; code < D_CODES; code++) {\n\t                    base_dist[code] = dist << 7;\n\t                    for (n = 0; n < 1 << extra_dbits[code] - 7; n++)\n\t                        _dist_code[256 + dist++] = code\n\t                }\n\t                for (bits = 0; bits <= MAX_BITS; bits++)\n\t                    bl_count[bits] = 0;\n\t                n = 0;\n\t                while (n <= 143) {\n\t                    static_ltree[n * 2 + 1] = 8;\n\t                    n++;\n\t                    bl_count[8]++\n\t                }\n\t                while (n <= 255) {\n\t                    static_ltree[n * 2 + 1] = 9;\n\t                    n++;\n\t                    bl_count[9]++\n\t                }\n\t                while (n <= 279) {\n\t                    static_ltree[n * 2 + 1] = 7;\n\t                    n++;\n\t                    bl_count[7]++\n\t                }\n\t                while (n <= 287) {\n\t                    static_ltree[n * 2 + 1] = 8;\n\t                    n++;\n\t                    bl_count[8]++\n\t                }\n\t                gen_codes(static_ltree, L_CODES + 1, bl_count);\n\t                for (n = 0; n < D_CODES; n++) {\n\t                    static_dtree[n * 2 + 1] = 5;\n\t                    static_dtree[n * 2] = bi_reverse(n, 5)\n\t                }\n\t                static_l_desc = new StaticTreeDesc(static_ltree,extra_lbits,LITERALS + 1,L_CODES,MAX_BITS);\n\t                static_d_desc = new StaticTreeDesc(static_dtree,extra_dbits,0,D_CODES,MAX_BITS);\n\t                static_bl_desc = new StaticTreeDesc(new Array(0),extra_blbits,0,BL_CODES,MAX_BL_BITS)\n\t            }\n\t            function init_block(s) {\n\t                var n;\n\t                for (n = 0; n < L_CODES; n++)\n\t                    s.dyn_ltree[n * 2] = 0;\n\t                for (n = 0; n < D_CODES; n++)\n\t                    s.dyn_dtree[n * 2] = 0;\n\t                for (n = 0; n < BL_CODES; n++)\n\t                    s.bl_tree[n * 2] = 0;\n\t                s.dyn_ltree[END_BLOCK * 2] = 1;\n\t                s.opt_len = s.static_len = 0;\n\t                s.last_lit = s.matches = 0\n\t            }\n\t            function bi_windup(s) {\n\t                if (s.bi_valid > 8)\n\t                    put_short(s, s.bi_buf);\n\t                else if (s.bi_valid > 0)\n\t                    s.pending_buf[s.pending++] = s.bi_buf;\n\t                s.bi_buf = 0;\n\t                s.bi_valid = 0\n\t            }\n\t            function copy_block(s, buf, len, header) {\n\t                bi_windup(s);\n\t                if (header) {\n\t                    put_short(s, len);\n\t                    put_short(s, ~len)\n\t                }\n\t                utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n\t                s.pending += len\n\t            }\n\t            function smaller(tree, n, m, depth) {\n\t                var _n2 = n * 2;\n\t                var _m2 = m * 2;\n\t                return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m]\n\t            }\n\t            function pqdownheap(s, tree, k) {\n\t                var v = s.heap[k];\n\t                var j = k << 1;\n\t                while (j <= s.heap_len) {\n\t                    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth))\n\t                        j++;\n\t                    if (smaller(tree, v, s.heap[j], s.depth))\n\t                        break;\n\t                    s.heap[k] = s.heap[j];\n\t                    k = j;\n\t                    j <<= 1\n\t                }\n\t                s.heap[k] = v\n\t            }\n\t            function compress_block(s, ltree, dtree) {\n\t                var dist;\n\t                var lc;\n\t                var lx = 0;\n\t                var code;\n\t                var extra;\n\t                if (s.last_lit !== 0) {\n\t                    do {\n\t                        dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];\n\t                        lc = s.pending_buf[s.l_buf + lx];\n\t                        lx++;\n\t                        if (dist === 0)\n\t                            send_code(s, lc, ltree);\n\t                        else {\n\t                            code = _length_code[lc];\n\t                            send_code(s, code + LITERALS + 1, ltree);\n\t                            extra = extra_lbits[code];\n\t                            if (extra !== 0) {\n\t                                lc -= base_length[code];\n\t                                send_bits(s, lc, extra)\n\t                            }\n\t                            dist--;\n\t                            code = d_code(dist);\n\t                            send_code(s, code, dtree);\n\t                            extra = extra_dbits[code];\n\t                            if (extra !== 0) {\n\t                                dist -= base_dist[code];\n\t                                send_bits(s, dist, extra)\n\t                            }\n\t                        }\n\t                    } while (lx < s.last_lit)\n\t                }\n\t                send_code(s, END_BLOCK, ltree)\n\t            }\n\t            function build_tree(s, desc) {\n\t                var tree = desc.dyn_tree;\n\t                var stree = desc.stat_desc.static_tree;\n\t                var has_stree = desc.stat_desc.has_stree;\n\t                var elems = desc.stat_desc.elems;\n\t                var n, m;\n\t                var max_code = -1;\n\t                var node;\n\t                s.heap_len = 0;\n\t                s.heap_max = HEAP_SIZE;\n\t                for (n = 0; n < elems; n++)\n\t                    if (tree[n * 2] !== 0) {\n\t                        s.heap[++s.heap_len] = max_code = n;\n\t                        s.depth[n] = 0\n\t                    } else\n\t                        tree[n * 2 + 1] = 0;\n\t                while (s.heap_len < 2) {\n\t                    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;\n\t                    tree[node * 2] = 1;\n\t                    s.depth[node] = 0;\n\t                    s.opt_len--;\n\t                    if (has_stree)\n\t                        s.static_len -= stree[node * 2 + 1]\n\t                }\n\t                desc.max_code = max_code;\n\t                for (n = s.heap_len >> 1; n >= 1; n--)\n\t                    pqdownheap(s, tree, n);\n\t                node = elems;\n\t                do {\n\t                    n = s.heap[1];\n\t                    s.heap[1] = s.heap[s.heap_len--];\n\t                    pqdownheap(s, tree, 1);\n\t                    m = s.heap[1];\n\t                    s.heap[--s.heap_max] = n;\n\t                    s.heap[--s.heap_max] = m;\n\t                    tree[node * 2] = tree[n * 2] + tree[m * 2];\n\t                    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n\t                    tree[n * 2 + 1] = tree[m * 2 + 1] = node;\n\t                    s.heap[1] = node++;\n\t                    pqdownheap(s, tree, 1)\n\t                } while (s.heap_len >= 2);\n\t                s.heap[--s.heap_max] = s.heap[1];\n\t                gen_bitlen(s, desc);\n\t                gen_codes(tree, max_code, s.bl_count)\n\t            }\n\t            function scan_tree(s, tree, max_code) {\n\t                var n;\n\t                var prevlen = -1;\n\t                var curlen;\n\t                var nextlen = tree[0 * 2 + 1];\n\t                var count = 0;\n\t                var max_count = 7;\n\t                var min_count = 4;\n\t                if (nextlen === 0) {\n\t                    max_count = 138;\n\t                    min_count = 3\n\t                }\n\t                tree[(max_code + 1) * 2 + 1] = 65535;\n\t                for (n = 0; n <= max_code; n++) {\n\t                    curlen = nextlen;\n\t                    nextlen = tree[(n + 1) * 2 + 1];\n\t                    if (++count < max_count && curlen === nextlen)\n\t                        continue;\n\t                    else if (count < min_count)\n\t                        s.bl_tree[curlen * 2] += count;\n\t                    else if (curlen !== 0) {\n\t                        if (curlen !== prevlen)\n\t                            s.bl_tree[curlen * 2]++;\n\t                        s.bl_tree[REP_3_6 * 2]++\n\t                    } else if (count <= 10)\n\t                        s.bl_tree[REPZ_3_10 * 2]++;\n\t                    else\n\t                        s.bl_tree[REPZ_11_138 * 2]++;\n\t                    count = 0;\n\t                    prevlen = curlen;\n\t                    if (nextlen === 0) {\n\t                        max_count = 138;\n\t                        min_count = 3\n\t                    } else if (curlen === nextlen) {\n\t                        max_count = 6;\n\t                        min_count = 3\n\t                    } else {\n\t                        max_count = 7;\n\t                        min_count = 4\n\t                    }\n\t                }\n\t            }\n\t            function send_tree(s, tree, max_code) {\n\t                var n;\n\t                var prevlen = -1;\n\t                var curlen;\n\t                var nextlen = tree[0 * 2 + 1];\n\t                var count = 0;\n\t                var max_count = 7;\n\t                var min_count = 4;\n\t                if (nextlen === 0) {\n\t                    max_count = 138;\n\t                    min_count = 3\n\t                }\n\t                for (n = 0; n <= max_code; n++) {\n\t                    curlen = nextlen;\n\t                    nextlen = tree[(n + 1) * 2 + 1];\n\t                    if (++count < max_count && curlen === nextlen)\n\t                        continue;\n\t                    else if (count < min_count) {\n\t                        do\n\t                            send_code(s, curlen, s.bl_tree);\n\t                        while (--count !== 0)\n\t                    } else if (curlen !== 0) {\n\t                        if (curlen !== prevlen) {\n\t                            send_code(s, curlen, s.bl_tree);\n\t                            count--\n\t                        }\n\t                        send_code(s, REP_3_6, s.bl_tree);\n\t                        send_bits(s, count - 3, 2)\n\t                    } else if (count <= 10) {\n\t                        send_code(s, REPZ_3_10, s.bl_tree);\n\t                        send_bits(s, count - 3, 3)\n\t                    } else {\n\t                        send_code(s, REPZ_11_138, s.bl_tree);\n\t                        send_bits(s, count - 11, 7)\n\t                    }\n\t                    count = 0;\n\t                    prevlen = curlen;\n\t                    if (nextlen === 0) {\n\t                        max_count = 138;\n\t                        min_count = 3\n\t                    } else if (curlen === nextlen) {\n\t                        max_count = 6;\n\t                        min_count = 3\n\t                    } else {\n\t                        max_count = 7;\n\t                        min_count = 4\n\t                    }\n\t                }\n\t            }\n\t            function build_bl_tree(s) {\n\t                var max_blindex;\n\t                scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n\t                scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\t                build_tree(s, s.bl_desc);\n\t                for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--)\n\t                    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0)\n\t                        break;\n\t                s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n\t                return max_blindex\n\t            }\n\t            function send_all_trees(s, lcodes, dcodes, blcodes) {\n\t                var rank;\n\t                send_bits(s, lcodes - 257, 5);\n\t                send_bits(s, dcodes - 1, 5);\n\t                send_bits(s, blcodes - 4, 4);\n\t                for (rank = 0; rank < blcodes; rank++)\n\t                    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);\n\t                send_tree(s, s.dyn_ltree, lcodes - 1);\n\t                send_tree(s, s.dyn_dtree, dcodes - 1)\n\t            }\n\t            function detect_data_type(s) {\n\t                var black_mask = 4093624447;\n\t                var n;\n\t                for (n = 0; n <= 31; n++,\n\t                black_mask >>>= 1)\n\t                    if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0)\n\t                        return Z_BINARY;\n\t                if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0)\n\t                    return Z_TEXT;\n\t                for (n = 32; n < LITERALS; n++)\n\t                    if (s.dyn_ltree[n * 2] !== 0)\n\t                        return Z_TEXT;\n\t                return Z_BINARY\n\t            }\n\t            var static_init_done = false;\n\t            function _tr_init(s) {\n\t                if (!static_init_done) {\n\t                    tr_static_init();\n\t                    static_init_done = true\n\t                }\n\t                s.l_desc = new TreeDesc(s.dyn_ltree,static_l_desc);\n\t                s.d_desc = new TreeDesc(s.dyn_dtree,static_d_desc);\n\t                s.bl_desc = new TreeDesc(s.bl_tree,static_bl_desc);\n\t                s.bi_buf = 0;\n\t                s.bi_valid = 0;\n\t                init_block(s)\n\t            }\n\t            function _tr_stored_block(s, buf, stored_len, last) {\n\t                send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);\n\t                copy_block(s, buf, stored_len, true)\n\t            }\n\t            function _tr_align(s) {\n\t                send_bits(s, STATIC_TREES << 1, 3);\n\t                send_code(s, END_BLOCK, static_ltree);\n\t                bi_flush(s)\n\t            }\n\t            function _tr_flush_block(s, buf, stored_len, last) {\n\t                var opt_lenb, static_lenb;\n\t                var max_blindex = 0;\n\t                if (s.level > 0) {\n\t                    if (s.strm.data_type === Z_UNKNOWN)\n\t                        s.strm.data_type = detect_data_type(s);\n\t                    build_tree(s, s.l_desc);\n\t                    build_tree(s, s.d_desc);\n\t                    max_blindex = build_bl_tree(s);\n\t                    opt_lenb = s.opt_len + 3 + 7 >>> 3;\n\t                    static_lenb = s.static_len + 3 + 7 >>> 3;\n\t                    if (static_lenb <= opt_lenb)\n\t                        opt_lenb = static_lenb\n\t                } else\n\t                    opt_lenb = static_lenb = stored_len + 5;\n\t                if (stored_len + 4 <= opt_lenb && buf !== -1)\n\t                    _tr_stored_block(s, buf, stored_len, last);\n\t                else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n\t                    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n\t                    compress_block(s, static_ltree, static_dtree)\n\t                } else {\n\t                    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n\t                    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n\t                    compress_block(s, s.dyn_ltree, s.dyn_dtree)\n\t                }\n\t                init_block(s);\n\t                if (last)\n\t                    bi_windup(s)\n\t            }\n\t            function _tr_tally(s, dist, lc) {\n\t                s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;\n\t                s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;\n\t                s.pending_buf[s.l_buf + s.last_lit] = lc & 255;\n\t                s.last_lit++;\n\t                if (dist === 0)\n\t                    s.dyn_ltree[lc * 2]++;\n\t                else {\n\t                    s.matches++;\n\t                    dist--;\n\t                    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;\n\t                    s.dyn_dtree[d_code(dist) * 2]++\n\t                }\n\t                return s.last_lit === s.lit_bufsize - 1\n\t            }\n\t            exports._tr_init = _tr_init;\n\t            exports._tr_stored_block = _tr_stored_block;\n\t            exports._tr_flush_block = _tr_flush_block;\n\t            exports._tr_tally = _tr_tally;\n\t            exports._tr_align = _tr_align\n\t        }\n\t        , {\n\t            \"../utils/common\": 27\n\t        }],\n\t        39: [function(_dereq_, module, exports) {\n\t            function ZStream() {\n\t                this.input = null;\n\t                this.next_in = 0;\n\t                this.avail_in = 0;\n\t                this.total_in = 0;\n\t                this.output = null;\n\t                this.next_out = 0;\n\t                this.avail_out = 0;\n\t                this.total_out = 0;\n\t                this.msg = \"\";\n\t                this.state = null;\n\t                this.data_type = 2;\n\t                this.adler = 0\n\t            }\n\t            module.exports = ZStream\n\t        }\n\t        , {}]\n\t    }, {}, [9])(9)\n\t});\n\n\treturn {\n\t\truntime,\n\t\todf\n\t}\n});\ndefine('skylark-webodf/main',[\r\n\t\"skylark-langx-ns\",\r\n\t\"./webodf\"\r\n],function(skylark,webodf) {\r\n\treturn skylark.attach(\"intg.webodf\",webodf)\r\n});\ndefine('skylark-webodf', ['skylark-webodf/main'], function (main) { return main; });\n\ndefine('skylark-viewerjs/ODFViewerPlugin',[\n    \"skylark-webodf\",\n    \"./viewerjs\"\n],function(webodf,viewerjs) {\n    function ODFViewerPlugin() {\n        \"use strict\";\n\n        function init(callback) {\n            /*\n            var lib = document.createElement('script'),\n                pluginCSS;\n\n            lib.async = false;\n            lib.src = './webodf.js';\n            lib.type = 'text/javascript';\n            lib.onload = function () {\n                runtime.loadClass('gui.HyperlinkClickHandler');\n                runtime.loadClass('odf.OdfCanvas');\n                runtime.loadClass('ops.Session');\n                runtime.loadClass('gui.CaretManager');\n                runtime.loadClass(\"gui.HyperlinkTooltipView\");\n                runtime.loadClass('gui.SessionController');\n                runtime.loadClass('gui.SvgSelectionView');\n                runtime.loadClass('gui.SelectionViewManager');\n                runtime.loadClass('gui.ShadowCursor');\n                runtime.loadClass('gui.SessionView');\n\n                callback();\n            };\n\n            document.head.appendChild(lib);\n            */\n            callback();\n        }\n\n        // that should probably be provided by webodf\n        function nsResolver(prefix) {\n            var ns = {\n                'draw' : \"urn:oasis:names:tc:opendocument:xmlns:drawing:1.0\",\n                'presentation' : \"urn:oasis:names:tc:opendocument:xmlns:presentation:1.0\",\n                'text' : \"urn:oasis:names:tc:opendocument:xmlns:text:1.0\",\n                'office' : \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\"\n            };\n            return ns[prefix] || console.log('prefix [' + prefix + '] unknown.');\n        }\n\n        var self = this,\n            pluginName = \"WebODF\",\n            pluginURL = \"http://webodf.org\",\n            odfCanvas = null,\n            odfElement = null,\n            initialized = false,\n            root = null,\n            documentType = null,\n            pages = [],\n            currentPage = null;\n\n        this.initialize = function (viewerElement, documentUrl) {\n            // If the URL has a fragment (#...), try to load the file it represents\n            init(function () {\n                var session,\n                    sessionController,\n                    sessionView,\n                    odtDocument,\n                    shadowCursor,\n                    selectionViewManager,\n                    caretManager,\n                    localMemberId = 'localuser',\n                    hyperlinkTooltipView,\n                    eventManager;\n\n                odfElement = document.getElementById('canvas');\n                odfCanvas = new webodf.odf.OdfCanvas(odfElement);\n                odfCanvas.load(documentUrl);\n\n                odfCanvas.addListener('statereadychange', function () {\n                    root = odfCanvas.odfContainer().rootElement;\n                    initialized = true;\n                    documentType = odfCanvas.odfContainer().getDocumentType(root);\n                    if (documentType === 'text') {\n                        odfCanvas.enableAnnotations(true, false);\n\n                        session = new ops.Session(odfCanvas);\n                        odtDocument = session.getOdtDocument();\n                        shadowCursor = new gui.ShadowCursor(odtDocument);\n                        sessionController = new gui.SessionController(session, localMemberId, shadowCursor, {});\n                        eventManager = sessionController.getEventManager();\n                        caretManager = new gui.CaretManager(sessionController, odfCanvas.getViewport());\n                        selectionViewManager = new gui.SelectionViewManager(gui.SvgSelectionView);\n                        sessionView = new gui.SessionView({\n                            caretAvatarsInitiallyVisible: false\n                        }, localMemberId, session, sessionController.getSessionConstraints(), caretManager, selectionViewManager);\n                        selectionViewManager.registerCursor(shadowCursor);\n                        hyperlinkTooltipView = new gui.HyperlinkTooltipView(odfCanvas,\n                            sessionController.getHyperlinkClickHandler().getModifier);\n                        eventManager.subscribe(\"mousemove\", hyperlinkTooltipView.showTooltip);\n                        eventManager.subscribe(\"mouseout\", hyperlinkTooltipView.hideTooltip);\n\n                        var op = new ops.OpAddMember();\n                        op.init({\n                            memberid: localMemberId,\n                            setProperties: {\n                                fillName: webodf.runtime.tr(\"Unknown Author\"),\n                                color: \"blue\"\n                            }\n                        });\n                        session.enqueue([op]);\n                        sessionController.insertLocalCursor();\n                    }\n\n                    self.onLoad();\n                });\n            });\n        };\n\n        this.isSlideshow = function () {\n            return documentType === 'presentation';\n        };\n\n        this.onLoad = function () {};\n\n        this.fitToWidth = function (width) {\n            odfCanvas.fitToWidth(width);\n        };\n\n        this.fitToHeight = function (height) {\n            odfCanvas.fitToHeight(height);\n        };\n\n        this.fitToPage = function (width, height) {\n            odfCanvas.fitToContainingElement(width, height);\n        };\n\n        this.fitSmart = function (width) {\n            odfCanvas.fitSmart(width);\n        };\n\n        this.getZoomLevel = function () {\n            return odfCanvas.getZoomLevel();\n        };\n\n        this.setZoomLevel = function (value) {\n            odfCanvas.setZoomLevel(value);\n        };\n\n        // return a list of tuples (pagename, pagenode)\n        this.getPages = function () {\n            var pageNodes = Array.prototype.slice.call(root.getElementsByTagNameNS(nsResolver('draw'), 'page')),\n                pages  = [],\n                i,\n                tuple;\n\n            for (i = 0; i < pageNodes.length; i += 1) {\n                tuple = [\n                    pageNodes[i].getAttribute('draw:name'),\n                    pageNodes[i]\n                ];\n                pages.push(tuple);\n            }\n            return pages;\n        };\n\n        this.showPage = function (n) {\n            odfCanvas.showPage(n);\n        };\n\n        this.getPluginName = function () {\n            return pluginName;\n        };\n\n        this.getPluginVersion = function () {\n            var version;\n\n            if (String(typeof webodf) !== \"undefined\") {\n                version = webodf.Version;\n            } else {\n                version = \"Unknown\";\n            }\n\n            return version;\n        };\n\n        this.getPluginURL = function () {\n            return pluginURL;\n        };\n    }\n\n    return viewerjs.ODFViewerPlugin = ODFViewerPlugin;\n});\n\n\n\ndefine('skylark-langx/skylark',[\r\n    \"skylark-langx-ns\"\r\n], function(ns) {\r\n\treturn ns;\r\n});\r\n\ndefine('skylark-pdfjs-display/pdfjs',[\r\n\t\"skylark-langx/skylark\"\r\n],function(skylark) {\r\n\treturn skylark.attach(\"intg.pdfjs\");\r\n});\ndefine('skylark-pdfjs-display/display',[\n  \"./pdfjs\"\n],function(pdfjs){\nreturn pdfjs.display = /******/ (() => { // webpackBootstrap\n/******/  \"use strict\";\n/******/  var __webpack_modules__ = ([\n/* 0 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n  Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n  }));\n  Object.defineProperty(exports, \"addLinkAttributes\", ({\n    enumerable: true,\n    get: function () {\n      return _display_utils.addLinkAttributes;\n    }\n  }));\n  Object.defineProperty(exports, \"getFilenameFromUrl\", ({\n    enumerable: true,\n    get: function () {\n      return _display_utils.getFilenameFromUrl;\n    }\n  }));\n  Object.defineProperty(exports, \"LinkTarget\", ({\n    enumerable: true,\n    get: function () {\n      return _display_utils.LinkTarget;\n    }\n  }));\n  Object.defineProperty(exports, \"loadScript\", ({\n    enumerable: true,\n    get: function () {\n      return _display_utils.loadScript;\n    }\n  }));\n  Object.defineProperty(exports, \"PDFDateString\", ({\n    enumerable: true,\n    get: function () {\n      return _display_utils.PDFDateString;\n    }\n  }));\n  Object.defineProperty(exports, \"RenderingCancelledException\", ({\n    enumerable: true,\n    get: function () {\n      return _display_utils.RenderingCancelledException;\n    }\n  }));\n  Object.defineProperty(exports, \"build\", ({\n    enumerable: true,\n    get: function () {\n      return _api.build;\n    }\n  }));\n  Object.defineProperty(exports, \"getDocument\", ({\n    enumerable: true,\n    get: function () {\n      return _api.getDocument;\n    }\n  }));\n  Object.defineProperty(exports, \"LoopbackPort\", ({\n    enumerable: true,\n    get: function () {\n      return _api.LoopbackPort;\n    }\n  }));\n  Object.defineProperty(exports, \"PDFDataRangeTransport\", ({\n    enumerable: true,\n    get: function () {\n      return _api.PDFDataRangeTransport;\n    }\n  }));\n  Object.defineProperty(exports, \"PDFWorker\", ({\n    enumerable: true,\n    get: function () {\n      return _api.PDFWorker;\n    }\n  }));\n  Object.defineProperty(exports, \"version\", ({\n    enumerable: true,\n    get: function () {\n      return _api.version;\n    }\n  }));\n  Object.defineProperty(exports, \"CMapCompressionType\", ({\n    enumerable: true,\n    get: function () {\n      return _util.CMapCompressionType;\n    }\n  }));\n  Object.defineProperty(exports, \"createObjectURL\", ({\n    enumerable: true,\n    get: function () {\n      return _util.createObjectURL;\n    }\n  }));\n  Object.defineProperty(exports, \"createPromiseCapability\", ({\n    enumerable: true,\n    get: function () {\n      return _util.createPromiseCapability;\n    }\n  }));\n  Object.defineProperty(exports, \"createValidAbsoluteUrl\", ({\n    enumerable: true,\n    get: function () {\n      return _util.createValidAbsoluteUrl;\n    }\n  }));\n  Object.defineProperty(exports, \"InvalidPDFException\", ({\n    enumerable: true,\n    get: function () {\n      return _util.InvalidPDFException;\n    }\n  }));\n  Object.defineProperty(exports, \"MissingPDFException\", ({\n    enumerable: true,\n    get: function () {\n      return _util.MissingPDFException;\n    }\n  }));\n  Object.defineProperty(exports, \"OPS\", ({\n    enumerable: true,\n    get: function () {\n      return _util.OPS;\n    }\n  }));\n  Object.defineProperty(exports, \"PasswordResponses\", ({\n    enumerable: true,\n    get: function () {\n      return _util.PasswordResponses;\n    }\n  }));\n  Object.defineProperty(exports, \"PermissionFlag\", ({\n    enumerable: true,\n    get: function () {\n      return _util.PermissionFlag;\n    }\n  }));\n  Object.defineProperty(exports, \"removeNullCharacters\", ({\n    enumerable: true,\n    get: function () {\n      return _util.removeNullCharacters;\n    }\n  }));\n  Object.defineProperty(exports, \"shadow\", ({\n    enumerable: true,\n    get: function () {\n      return _util.shadow;\n    }\n  }));\n  Object.defineProperty(exports, \"UnexpectedResponseException\", ({\n    enumerable: true,\n    get: function () {\n      return _util.UnexpectedResponseException;\n    }\n  }));\n  Object.defineProperty(exports, \"UNSUPPORTED_FEATURES\", ({\n    enumerable: true,\n    get: function () {\n      return _util.UNSUPPORTED_FEATURES;\n    }\n  }));\n  Object.defineProperty(exports, \"Util\", ({\n    enumerable: true,\n    get: function () {\n      return _util.Util;\n    }\n  }));\n  Object.defineProperty(exports, \"VerbosityLevel\", ({\n    enumerable: true,\n    get: function () {\n      return _util.VerbosityLevel;\n    }\n  }));\n  Object.defineProperty(exports, \"AnnotationLayer\", ({\n    enumerable: true,\n    get: function () {\n      return _annotation_layer.AnnotationLayer;\n    }\n  }));\n  Object.defineProperty(exports, \"apiCompatibilityParams\", ({\n    enumerable: true,\n    get: function () {\n      return _api_compatibility.apiCompatibilityParams;\n    }\n  }));\n  Object.defineProperty(exports, \"GlobalWorkerOptions\", ({\n    enumerable: true,\n    get: function () {\n      return _worker_options.GlobalWorkerOptions;\n    }\n  }));\n  Object.defineProperty(exports, \"renderTextLayer\", ({\n    enumerable: true,\n    get: function () {\n      return _text_layer.renderTextLayer;\n    }\n  }));\n  Object.defineProperty(exports, \"SVGGraphics\", ({\n    enumerable: true,\n    get: function () {\n      return _svg.SVGGraphics;\n    }\n  }));\n\n  var _display_utils = __w_pdfjs_require__(1);\n\n  var _api = __w_pdfjs_require__(5);\n\n  var _util = __w_pdfjs_require__(2);\n\n  var _annotation_layer = __w_pdfjs_require__(19);\n\n  var _api_compatibility = __w_pdfjs_require__(9);\n\n  var _worker_options = __w_pdfjs_require__(12);\n\n  var _text_layer = __w_pdfjs_require__(21);\n\n  var _svg = __w_pdfjs_require__(22);\n\n  const pdfjsVersion = '2.7.570';\n  const pdfjsBuild = 'f2c7338b0';\n  {\n    const {\n      isNodeJS\n    } = __w_pdfjs_require__(4);\n\n    if (isNodeJS) {\n      const PDFNodeStream = __w_pdfjs_require__(23).PDFNodeStream;\n\n      (0, _api.setPDFNetworkStreamFactory)(params => {\n        return new PDFNodeStream(params);\n      });\n    } else {\n      const PDFNetworkStream = __w_pdfjs_require__(26).PDFNetworkStream;\n\n      let PDFFetchStream;\n\n      if ((0, _display_utils.isFetchSupported)()) {\n        PDFFetchStream = __w_pdfjs_require__(27).PDFFetchStream;\n      }\n\n      (0, _api.setPDFNetworkStreamFactory)(params => {\n        if (PDFFetchStream && (0, _display_utils.isValidFetchUrl)(params.url)) {\n          return new PDFFetchStream(params);\n        }\n\n        return new PDFNetworkStream(params);\n      });\n    }\n  }\n\n  /***/ }),\n  /* 1 */\n  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\n  Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n  }));\n  exports.addLinkAttributes = addLinkAttributes;\n  exports.deprecated = deprecated;\n  exports.getFilenameFromUrl = getFilenameFromUrl;\n  exports.isFetchSupported = isFetchSupported;\n  exports.isValidFetchUrl = isValidFetchUrl;\n  exports.loadScript = loadScript;\n  exports.StatTimer = exports.RenderingCancelledException = exports.PDFDateString = exports.PageViewport = exports.LinkTarget = exports.DOMSVGFactory = exports.DOMCMapReaderFactory = exports.DOMCanvasFactory = exports.DEFAULT_LINK_REL = exports.BaseCMapReaderFactory = exports.BaseCanvasFactory = void 0;\n\n  var _util = __w_pdfjs_require__(2);\n\n  const DEFAULT_LINK_REL = \"noopener noreferrer nofollow\";\n  exports.DEFAULT_LINK_REL = DEFAULT_LINK_REL;\n  const SVG_NS = \"http://www.w3.org/2000/svg\";\n\n  class BaseCanvasFactory {\n    constructor() {\n      if (this.constructor === BaseCanvasFactory) {\n        (0, _util.unreachable)(\"Cannot initialize BaseCanvasFactory.\");\n      }\n    }\n\n    create(width, height) {\n      (0, _util.unreachable)(\"Abstract method `create` called.\");\n    }\n\n    reset(canvasAndContext, width, height) {\n      if (!canvasAndContext.canvas) {\n        throw new Error(\"Canvas is not specified\");\n      }\n\n      if (width <= 0 || height <= 0) {\n        throw new Error(\"Invalid canvas size\");\n      }\n\n      canvasAndContext.canvas.width = width;\n      canvasAndContext.canvas.height = height;\n    }\n\n    destroy(canvasAndContext) {\n      if (!canvasAndContext.canvas) {\n        throw new Error(\"Canvas is not specified\");\n      }\n\n      canvasAndContext.canvas.width = 0;\n      canvasAndContext.canvas.height = 0;\n      canvasAndContext.canvas = null;\n      canvasAndContext.context = null;\n    }\n\n  }\n\n  exports.BaseCanvasFactory = BaseCanvasFactory;\n\n  class DOMCanvasFactory extends BaseCanvasFactory {\n    constructor({\n      ownerDocument = globalThis.document\n    } = {}) {\n      super();\n      this._document = ownerDocument;\n    }\n\n    create(width, height) {\n      if (width <= 0 || height <= 0) {\n        throw new Error(\"Invalid canvas size\");\n      }\n\n      const canvas = this._document.createElement(\"canvas\");\n\n      const context = canvas.getContext(\"2d\");\n      canvas.width = width;\n      canvas.height = height;\n      return {\n        canvas,\n        context\n      };\n    }\n\n  }\n\n  exports.DOMCanvasFactory = DOMCanvasFactory;\n\n  class BaseCMapReaderFactory {\n    constructor({\n      baseUrl = null,\n      isCompressed = false\n    }) {\n      if (this.constructor === BaseCMapReaderFactory) {\n        (0, _util.unreachable)(\"Cannot initialize BaseCMapReaderFactory.\");\n      }\n\n      this.baseUrl = baseUrl;\n      this.isCompressed = isCompressed;\n    }\n\n    async fetch({\n      name\n    }) {\n      if (!this.baseUrl) {\n        throw new Error('The CMap \"baseUrl\" parameter must be specified, ensure that ' + 'the \"cMapUrl\" and \"cMapPacked\" API parameters are provided.');\n      }\n\n      if (!name) {\n        throw new Error(\"CMap name must be specified.\");\n      }\n\n      const url = this.baseUrl + name + (this.isCompressed ? \".bcmap\" : \"\");\n      const compressionType = this.isCompressed ? _util.CMapCompressionType.BINARY : _util.CMapCompressionType.NONE;\n      return this._fetchData(url, compressionType).catch(reason => {\n        throw new Error(`Unable to load ${this.isCompressed ? \"binary \" : \"\"}CMap at: ${url}`);\n      });\n    }\n\n    _fetchData(url, compressionType) {\n      (0, _util.unreachable)(\"Abstract method `_fetchData` called.\");\n    }\n\n  }\n\n  exports.BaseCMapReaderFactory = BaseCMapReaderFactory;\n\n  class DOMCMapReaderFactory extends BaseCMapReaderFactory {\n    _fetchData(url, compressionType) {\n      if (isFetchSupported() && isValidFetchUrl(url, document.baseURI)) {\n        return fetch(url).then(async response => {\n          if (!response.ok) {\n            throw new Error(response.statusText);\n          }\n\n          let cMapData;\n\n          if (this.isCompressed) {\n            cMapData = new Uint8Array(await response.arrayBuffer());\n          } else {\n            cMapData = (0, _util.stringToBytes)(await response.text());\n          }\n\n          return {\n            cMapData,\n            compressionType\n          };\n        });\n      }\n\n      return new Promise((resolve, reject) => {\n        const request = new XMLHttpRequest();\n        request.open(\"GET\", url, true);\n\n        if (this.isCompressed) {\n          request.responseType = \"arraybuffer\";\n        }\n\n        request.onreadystatechange = () => {\n          if (request.readyState !== XMLHttpRequest.DONE) {\n            return;\n          }\n\n          if (request.status === 200 || request.status === 0) {\n            let cMapData;\n\n            if (this.isCompressed && request.response) {\n              cMapData = new Uint8Array(request.response);\n            } else if (!this.isCompressed && request.responseText) {\n              cMapData = (0, _util.stringToBytes)(request.responseText);\n            }\n\n            if (cMapData) {\n              resolve({\n                cMapData,\n                compressionType\n              });\n              return;\n            }\n          }\n\n          reject(new Error(request.statusText));\n        };\n\n        request.send(null);\n      });\n    }\n\n  }\n\n  exports.DOMCMapReaderFactory = DOMCMapReaderFactory;\n\n  class DOMSVGFactory {\n    create(width, height) {\n      (0, _util.assert)(width > 0 && height > 0, \"Invalid SVG dimensions\");\n      const svg = document.createElementNS(SVG_NS, \"svg:svg\");\n      svg.setAttribute(\"version\", \"1.1\");\n      svg.setAttribute(\"width\", width + \"px\");\n      svg.setAttribute(\"height\", height + \"px\");\n      svg.setAttribute(\"preserveAspectRatio\", \"none\");\n      svg.setAttribute(\"viewBox\", \"0 0 \" + width + \" \" + height);\n      return svg;\n    }\n\n    createElement(type) {\n      (0, _util.assert)(typeof type === \"string\", \"Invalid SVG element type\");\n      return document.createElementNS(SVG_NS, type);\n    }\n\n  }\n\n  exports.DOMSVGFactory = DOMSVGFactory;\n\n  class PageViewport {\n    constructor({\n      viewBox,\n      scale,\n      rotation,\n      offsetX = 0,\n      offsetY = 0,\n      dontFlip = false\n    }) {\n      this.viewBox = viewBox;\n      this.scale = scale;\n      this.rotation = rotation;\n      this.offsetX = offsetX;\n      this.offsetY = offsetY;\n      const centerX = (viewBox[2] + viewBox[0]) / 2;\n      const centerY = (viewBox[3] + viewBox[1]) / 2;\n      let rotateA, rotateB, rotateC, rotateD;\n      rotation = rotation % 360;\n      rotation = rotation < 0 ? rotation + 360 : rotation;\n\n      switch (rotation) {\n        case 180:\n          rotateA = -1;\n          rotateB = 0;\n          rotateC = 0;\n          rotateD = 1;\n          break;\n\n        case 90:\n          rotateA = 0;\n          rotateB = 1;\n          rotateC = 1;\n          rotateD = 0;\n          break;\n\n        case 270:\n          rotateA = 0;\n          rotateB = -1;\n          rotateC = -1;\n          rotateD = 0;\n          break;\n\n        case 0:\n          rotateA = 1;\n          rotateB = 0;\n          rotateC = 0;\n          rotateD = -1;\n          break;\n\n        default:\n          throw new Error(\"PageViewport: Invalid rotation, must be a multiple of 90 degrees.\");\n      }\n\n      if (dontFlip) {\n        rotateC = -rotateC;\n        rotateD = -rotateD;\n      }\n\n      let offsetCanvasX, offsetCanvasY;\n      let width, height;\n\n      if (rotateA === 0) {\n        offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;\n        offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;\n        width = Math.abs(viewBox[3] - viewBox[1]) * scale;\n        height = Math.abs(viewBox[2] - viewBox[0]) * scale;\n      } else {\n        offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;\n        offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;\n        width = Math.abs(viewBox[2] - viewBox[0]) * scale;\n        height = Math.abs(viewBox[3] - viewBox[1]) * scale;\n      }\n\n      this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];\n      this.width = width;\n      this.height = height;\n    }\n\n    clone({\n      scale = this.scale,\n      rotation = this.rotation,\n      offsetX = this.offsetX,\n      offsetY = this.offsetY,\n      dontFlip = false\n    } = {}) {\n      return new PageViewport({\n        viewBox: this.viewBox.slice(),\n        scale,\n        rotation,\n        offsetX,\n        offsetY,\n        dontFlip\n      });\n    }\n\n    convertToViewportPoint(x, y) {\n      return _util.Util.applyTransform([x, y], this.transform);\n    }\n\n    convertToViewportRectangle(rect) {\n      const topLeft = _util.Util.applyTransform([rect[0], rect[1]], this.transform);\n\n      const bottomRight = _util.Util.applyTransform([rect[2], rect[3]], this.transform);\n\n      return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];\n    }\n\n    convertToPdfPoint(x, y) {\n      return _util.Util.applyInverseTransform([x, y], this.transform);\n    }\n\n  }\n\n  exports.PageViewport = PageViewport;\n\n  class RenderingCancelledException extends _util.BaseException {\n    constructor(msg, type) {\n      super(msg);\n      this.type = type;\n    }\n\n  }\n\n  exports.RenderingCancelledException = RenderingCancelledException;\n  const LinkTarget = {\n    NONE: 0,\n    SELF: 1,\n    BLANK: 2,\n    PARENT: 3,\n    TOP: 4\n  };\n  exports.LinkTarget = LinkTarget;\n\n  function addLinkAttributes(link, {\n    url,\n    target,\n    rel,\n    enabled = true\n  } = {}) {\n    (0, _util.assert)(url && typeof url === \"string\", 'addLinkAttributes: A valid \"url\" parameter must provided.');\n    const urlNullRemoved = (0, _util.removeNullCharacters)(url);\n\n    if (enabled) {\n      link.href = link.title = urlNullRemoved;\n    } else {\n      link.href = \"\";\n      link.title = `Disabled: ${urlNullRemoved}`;\n\n      link.onclick = () => {\n        return false;\n      };\n    }\n\n    let targetStr = \"\";\n\n    switch (target) {\n      case LinkTarget.NONE:\n        break;\n\n      case LinkTarget.SELF:\n        targetStr = \"_self\";\n        break;\n\n      case LinkTarget.BLANK:\n        targetStr = \"_blank\";\n        break;\n\n      case LinkTarget.PARENT:\n        targetStr = \"_parent\";\n        break;\n\n      case LinkTarget.TOP:\n        targetStr = \"_top\";\n        break;\n    }\n\n    link.target = targetStr;\n    link.rel = typeof rel === \"string\" ? rel : DEFAULT_LINK_REL;\n  }\n\n  function getFilenameFromUrl(url) {\n    const anchor = url.indexOf(\"#\");\n    const query = url.indexOf(\"?\");\n    const end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);\n    return url.substring(url.lastIndexOf(\"/\", end) + 1, end);\n  }\n\n  class StatTimer {\n    constructor() {\n      this.started = Object.create(null);\n      this.times = [];\n    }\n\n    time(name) {\n      if (name in this.started) {\n        (0, _util.warn)(`Timer is already running for ${name}`);\n      }\n\n      this.started[name] = Date.now();\n    }\n\n    timeEnd(name) {\n      if (!(name in this.started)) {\n        (0, _util.warn)(`Timer has not been started for ${name}`);\n      }\n\n      this.times.push({\n        name,\n        start: this.started[name],\n        end: Date.now()\n      });\n      delete this.started[name];\n    }\n\n    toString() {\n      const outBuf = [];\n      let longest = 0;\n\n      for (const time of this.times) {\n        const name = time.name;\n\n        if (name.length > longest) {\n          longest = name.length;\n        }\n      }\n\n      for (const time of this.times) {\n        const duration = time.end - time.start;\n        outBuf.push(`${time.name.padEnd(longest)} ${duration}ms\\n`);\n      }\n\n      return outBuf.join(\"\");\n    }\n\n  }\n\n  exports.StatTimer = StatTimer;\n\n  function isFetchSupported() {\n    return typeof fetch !== \"undefined\" && typeof Response !== \"undefined\" && \"body\" in Response.prototype && typeof ReadableStream !== \"undefined\";\n  }\n\n  function isValidFetchUrl(url, baseUrl) {\n    try {\n      const {\n        protocol\n      } = baseUrl ? new URL(url, baseUrl) : new URL(url);\n      return protocol === \"http:\" || protocol === \"https:\";\n    } catch (ex) {\n      return false;\n    }\n  }\n\n  function loadScript(src, removeScriptElement = false) {\n    return new Promise((resolve, reject) => {\n      const script = document.createElement(\"script\");\n      script.src = src;\n\n      script.onload = function (evt) {\n        if (removeScriptElement) {\n          script.remove();\n        }\n\n        resolve(evt);\n      };\n\n      script.onerror = function () {\n        reject(new Error(`Cannot load script at: ${script.src}`));\n      };\n\n      (document.head || document.documentElement).appendChild(script);\n    });\n  }\n\n  function deprecated(details) {\n    console.log(\"Deprecated API usage: \" + details);\n  }\n\n  let pdfDateStringRegex;\n\n  class PDFDateString {\n    static toDateObject(input) {\n      if (!input || !(0, _util.isString)(input)) {\n        return null;\n      }\n\n      if (!pdfDateStringRegex) {\n        pdfDateStringRegex = new RegExp(\"^D:\" + \"(\\\\d{4})\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"([Z|+|-])?\" + \"(\\\\d{2})?\" + \"'?\" + \"(\\\\d{2})?\" + \"'?\");\n      }\n\n      const matches = pdfDateStringRegex.exec(input);\n\n      if (!matches) {\n        return null;\n      }\n\n      const year = parseInt(matches[1], 10);\n      let month = parseInt(matches[2], 10);\n      month = month >= 1 && month <= 12 ? month - 1 : 0;\n      let day = parseInt(matches[3], 10);\n      day = day >= 1 && day <= 31 ? day : 1;\n      let hour = parseInt(matches[4], 10);\n      hour = hour >= 0 && hour <= 23 ? hour : 0;\n      let minute = parseInt(matches[5], 10);\n      minute = minute >= 0 && minute <= 59 ? minute : 0;\n      let second = parseInt(matches[6], 10);\n      second = second >= 0 && second <= 59 ? second : 0;\n      const universalTimeRelation = matches[7] || \"Z\";\n      let offsetHour = parseInt(matches[8], 10);\n      offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;\n      let offsetMinute = parseInt(matches[9], 10) || 0;\n      offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;\n\n      if (universalTimeRelation === \"-\") {\n        hour += offsetHour;\n        minute += offsetMinute;\n      } else if (universalTimeRelation === \"+\") {\n        hour -= offsetHour;\n        minute -= offsetMinute;\n      }\n\n      return new Date(Date.UTC(year, month, day, hour, minute, second));\n    }\n\n  }\n\n  exports.PDFDateString = PDFDateString;\n\n  /***/ }),\n  /* 2 */\n  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\n  Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n  }));\n  exports.arrayByteLength = arrayByteLength;\n  exports.arraysToBytes = arraysToBytes;\n  exports.assert = assert;\n  exports.bytesToString = bytesToString;\n  exports.createPromiseCapability = createPromiseCapability;\n  exports.createValidAbsoluteUrl = createValidAbsoluteUrl;\n  exports.encodeToXmlString = encodeToXmlString;\n  exports.escapeString = escapeString;\n  exports.getModificationDate = getModificationDate;\n  exports.getVerbosityLevel = getVerbosityLevel;\n  exports.info = info;\n  exports.isArrayBuffer = isArrayBuffer;\n  exports.isArrayEqual = isArrayEqual;\n  exports.isAscii = isAscii;\n  exports.isBool = isBool;\n  exports.isNum = isNum;\n  exports.isSameOrigin = isSameOrigin;\n  exports.isString = isString;\n  exports.objectFromEntries = objectFromEntries;\n  exports.objectSize = objectSize;\n  exports.removeNullCharacters = removeNullCharacters;\n  exports.setVerbosityLevel = setVerbosityLevel;\n  exports.shadow = shadow;\n  exports.string32 = string32;\n  exports.stringToBytes = stringToBytes;\n  exports.stringToPDFString = stringToPDFString;\n  exports.stringToUTF16BEString = stringToUTF16BEString;\n  exports.stringToUTF8String = stringToUTF8String;\n  exports.unreachable = unreachable;\n  exports.utf8StringToString = utf8StringToString;\n  exports.warn = warn;\n  exports.VerbosityLevel = exports.Util = exports.UNSUPPORTED_FEATURES = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.TextRenderingMode = exports.StreamType = exports.PermissionFlag = exports.PasswordResponses = exports.PasswordException = exports.PageActionEventType = exports.OPS = exports.MissingPDFException = exports.IsLittleEndianCached = exports.IsEvalSupportedCached = exports.InvalidPDFException = exports.ImageKind = exports.IDENTITY_MATRIX = exports.FormatError = exports.FontType = exports.FONT_IDENTITY_MATRIX = exports.DocumentActionEventType = exports.createObjectURL = exports.CMapCompressionType = exports.BaseException = exports.AnnotationType = exports.AnnotationStateModelType = exports.AnnotationReviewState = exports.AnnotationReplyType = exports.AnnotationMarkedState = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationBorderStyleType = exports.AnnotationActionEventType = exports.AbortException = void 0;\n\n  __w_pdfjs_require__(3);\n\n  const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];\n  exports.IDENTITY_MATRIX = IDENTITY_MATRIX;\n  const FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];\n  exports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;\n  const PermissionFlag = {\n    PRINT: 0x04,\n    MODIFY_CONTENTS: 0x08,\n    COPY: 0x10,\n    MODIFY_ANNOTATIONS: 0x20,\n    FILL_INTERACTIVE_FORMS: 0x100,\n    COPY_FOR_ACCESSIBILITY: 0x200,\n    ASSEMBLE: 0x400,\n    PRINT_HIGH_QUALITY: 0x800\n  };\n  exports.PermissionFlag = PermissionFlag;\n  const TextRenderingMode = {\n    FILL: 0,\n    STROKE: 1,\n    FILL_STROKE: 2,\n    INVISIBLE: 3,\n    FILL_ADD_TO_PATH: 4,\n    STROKE_ADD_TO_PATH: 5,\n    FILL_STROKE_ADD_TO_PATH: 6,\n    ADD_TO_PATH: 7,\n    FILL_STROKE_MASK: 3,\n    ADD_TO_PATH_FLAG: 4\n  };\n  exports.TextRenderingMode = TextRenderingMode;\n  const ImageKind = {\n    GRAYSCALE_1BPP: 1,\n    RGB_24BPP: 2,\n    RGBA_32BPP: 3\n  };\n  exports.ImageKind = ImageKind;\n  const AnnotationType = {\n    TEXT: 1,\n    LINK: 2,\n    FREETEXT: 3,\n    LINE: 4,\n    SQUARE: 5,\n    CIRCLE: 6,\n    POLYGON: 7,\n    POLYLINE: 8,\n    HIGHLIGHT: 9,\n    UNDERLINE: 10,\n    SQUIGGLY: 11,\n    STRIKEOUT: 12,\n    STAMP: 13,\n    CARET: 14,\n    INK: 15,\n    POPUP: 16,\n    FILEATTACHMENT: 17,\n    SOUND: 18,\n    MOVIE: 19,\n    WIDGET: 20,\n    SCREEN: 21,\n    PRINTERMARK: 22,\n    TRAPNET: 23,\n    WATERMARK: 24,\n    THREED: 25,\n    REDACT: 26\n  };\n  exports.AnnotationType = AnnotationType;\n  const AnnotationStateModelType = {\n    MARKED: \"Marked\",\n    REVIEW: \"Review\"\n  };\n  exports.AnnotationStateModelType = AnnotationStateModelType;\n  const AnnotationMarkedState = {\n    MARKED: \"Marked\",\n    UNMARKED: \"Unmarked\"\n  };\n  exports.AnnotationMarkedState = AnnotationMarkedState;\n  const AnnotationReviewState = {\n    ACCEPTED: \"Accepted\",\n    REJECTED: \"Rejected\",\n    CANCELLED: \"Cancelled\",\n    COMPLETED: \"Completed\",\n    NONE: \"None\"\n  };\n  exports.AnnotationReviewState = AnnotationReviewState;\n  const AnnotationReplyType = {\n    GROUP: \"Group\",\n    REPLY: \"R\"\n  };\n  exports.AnnotationReplyType = AnnotationReplyType;\n  const AnnotationFlag = {\n    INVISIBLE: 0x01,\n    HIDDEN: 0x02,\n    PRINT: 0x04,\n    NOZOOM: 0x08,\n    NOROTATE: 0x10,\n    NOVIEW: 0x20,\n    READONLY: 0x40,\n    LOCKED: 0x80,\n    TOGGLENOVIEW: 0x100,\n    LOCKEDCONTENTS: 0x200\n  };\n  exports.AnnotationFlag = AnnotationFlag;\n  const AnnotationFieldFlag = {\n    READONLY: 0x0000001,\n    REQUIRED: 0x0000002,\n    NOEXPORT: 0x0000004,\n    MULTILINE: 0x0001000,\n    PASSWORD: 0x0002000,\n    NOTOGGLETOOFF: 0x0004000,\n    RADIO: 0x0008000,\n    PUSHBUTTON: 0x0010000,\n    COMBO: 0x0020000,\n    EDIT: 0x0040000,\n    SORT: 0x0080000,\n    FILESELECT: 0x0100000,\n    MULTISELECT: 0x0200000,\n    DONOTSPELLCHECK: 0x0400000,\n    DONOTSCROLL: 0x0800000,\n    COMB: 0x1000000,\n    RICHTEXT: 0x2000000,\n    RADIOSINUNISON: 0x2000000,\n    COMMITONSELCHANGE: 0x4000000\n  };\n  exports.AnnotationFieldFlag = AnnotationFieldFlag;\n  const AnnotationBorderStyleType = {\n    SOLID: 1,\n    DASHED: 2,\n    BEVELED: 3,\n    INSET: 4,\n    UNDERLINE: 5\n  };\n  exports.AnnotationBorderStyleType = AnnotationBorderStyleType;\n  const AnnotationActionEventType = {\n    E: \"Mouse Enter\",\n    X: \"Mouse Exit\",\n    D: \"Mouse Down\",\n    U: \"Mouse Up\",\n    Fo: \"Focus\",\n    Bl: \"Blur\",\n    PO: \"PageOpen\",\n    PC: \"PageClose\",\n    PV: \"PageVisible\",\n    PI: \"PageInvisible\",\n    K: \"Keystroke\",\n    F: \"Format\",\n    V: \"Validate\",\n    C: \"Calculate\"\n  };\n  exports.AnnotationActionEventType = AnnotationActionEventType;\n  const DocumentActionEventType = {\n    WC: \"WillClose\",\n    WS: \"WillSave\",\n    DS: \"DidSave\",\n    WP: \"WillPrint\",\n    DP: \"DidPrint\"\n  };\n  exports.DocumentActionEventType = DocumentActionEventType;\n  const PageActionEventType = {\n    O: \"PageOpen\",\n    C: \"PageClose\"\n  };\n  exports.PageActionEventType = PageActionEventType;\n  const StreamType = {\n    UNKNOWN: \"UNKNOWN\",\n    FLATE: \"FLATE\",\n    LZW: \"LZW\",\n    DCT: \"DCT\",\n    JPX: \"JPX\",\n    JBIG: \"JBIG\",\n    A85: \"A85\",\n    AHX: \"AHX\",\n    CCF: \"CCF\",\n    RLX: \"RLX\"\n  };\n  exports.StreamType = StreamType;\n  const FontType = {\n    UNKNOWN: \"UNKNOWN\",\n    TYPE1: \"TYPE1\",\n    TYPE1C: \"TYPE1C\",\n    CIDFONTTYPE0: \"CIDFONTTYPE0\",\n    CIDFONTTYPE0C: \"CIDFONTTYPE0C\",\n    TRUETYPE: \"TRUETYPE\",\n    CIDFONTTYPE2: \"CIDFONTTYPE2\",\n    TYPE3: \"TYPE3\",\n    OPENTYPE: \"OPENTYPE\",\n    TYPE0: \"TYPE0\",\n    MMTYPE1: \"MMTYPE1\"\n  };\n  exports.FontType = FontType;\n  const VerbosityLevel = {\n    ERRORS: 0,\n    WARNINGS: 1,\n    INFOS: 5\n  };\n  exports.VerbosityLevel = VerbosityLevel;\n  const CMapCompressionType = {\n    NONE: 0,\n    BINARY: 1,\n    STREAM: 2\n  };\n  exports.CMapCompressionType = CMapCompressionType;\n  const OPS = {\n    dependency: 1,\n    setLineWidth: 2,\n    setLineCap: 3,\n    setLineJoin: 4,\n    setMiterLimit: 5,\n    setDash: 6,\n    setRenderingIntent: 7,\n    setFlatness: 8,\n    setGState: 9,\n    save: 10,\n    restore: 11,\n    transform: 12,\n    moveTo: 13,\n    lineTo: 14,\n    curveTo: 15,\n    curveTo2: 16,\n    curveTo3: 17,\n    closePath: 18,\n    rectangle: 19,\n    stroke: 20,\n    closeStroke: 21,\n    fill: 22,\n    eoFill: 23,\n    fillStroke: 24,\n    eoFillStroke: 25,\n    closeFillStroke: 26,\n    closeEOFillStroke: 27,\n    endPath: 28,\n    clip: 29,\n    eoClip: 30,\n    beginText: 31,\n    endText: 32,\n    setCharSpacing: 33,\n    setWordSpacing: 34,\n    setHScale: 35,\n    setLeading: 36,\n    setFont: 37,\n    setTextRenderingMode: 38,\n    setTextRise: 39,\n    moveText: 40,\n    setLeadingMoveText: 41,\n    setTextMatrix: 42,\n    nextLine: 43,\n    showText: 44,\n    showSpacedText: 45,\n    nextLineShowText: 46,\n    nextLineSetSpacingShowText: 47,\n    setCharWidth: 48,\n    setCharWidthAndBounds: 49,\n    setStrokeColorSpace: 50,\n    setFillColorSpace: 51,\n    setStrokeColor: 52,\n    setStrokeColorN: 53,\n    setFillColor: 54,\n    setFillColorN: 55,\n    setStrokeGray: 56,\n    setFillGray: 57,\n    setStrokeRGBColor: 58,\n    setFillRGBColor: 59,\n    setStrokeCMYKColor: 60,\n    setFillCMYKColor: 61,\n    shadingFill: 62,\n    beginInlineImage: 63,\n    beginImageData: 64,\n    endInlineImage: 65,\n    paintXObject: 66,\n    markPoint: 67,\n    markPointProps: 68,\n    beginMarkedContent: 69,\n    beginMarkedContentProps: 70,\n    endMarkedContent: 71,\n    beginCompat: 72,\n    endCompat: 73,\n    paintFormXObjectBegin: 74,\n    paintFormXObjectEnd: 75,\n    beginGroup: 76,\n    endGroup: 77,\n    beginAnnotations: 78,\n    endAnnotations: 79,\n    beginAnnotation: 80,\n    endAnnotation: 81,\n    paintJpegXObject: 82,\n    paintImageMaskXObject: 83,\n    paintImageMaskXObjectGroup: 84,\n    paintImageXObject: 85,\n    paintInlineImageXObject: 86,\n    paintInlineImageXObjectGroup: 87,\n    paintImageXObjectRepeat: 88,\n    paintImageMaskXObjectRepeat: 89,\n    paintSolidColorImageMask: 90,\n    constructPath: 91\n  };\n  exports.OPS = OPS;\n  const UNSUPPORTED_FEATURES = {\n    unknown: \"unknown\",\n    forms: \"forms\",\n    javaScript: \"javaScript\",\n    smask: \"smask\",\n    shadingPattern: \"shadingPattern\",\n    font: \"font\",\n    errorTilingPattern: \"errorTilingPattern\",\n    errorExtGState: \"errorExtGState\",\n    errorXObject: \"errorXObject\",\n    errorFontLoadType3: \"errorFontLoadType3\",\n    errorFontState: \"errorFontState\",\n    errorFontMissing: \"errorFontMissing\",\n    errorFontTranslate: \"errorFontTranslate\",\n    errorColorSpace: \"errorColorSpace\",\n    errorOperatorList: \"errorOperatorList\",\n    errorFontToUnicode: \"errorFontToUnicode\",\n    errorFontLoadNative: \"errorFontLoadNative\",\n    errorFontGetPath: \"errorFontGetPath\",\n    errorMarkedContent: \"errorMarkedContent\"\n  };\n  exports.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;\n  const PasswordResponses = {\n    NEED_PASSWORD: 1,\n    INCORRECT_PASSWORD: 2\n  };\n  exports.PasswordResponses = PasswordResponses;\n  let verbosity = VerbosityLevel.WARNINGS;\n\n  function setVerbosityLevel(level) {\n    if (Number.isInteger(level)) {\n      verbosity = level;\n    }\n  }\n\n  function getVerbosityLevel() {\n    return verbosity;\n  }\n\n  function info(msg) {\n    if (verbosity >= VerbosityLevel.INFOS) {\n      console.log(`Info: ${msg}`);\n    }\n  }\n\n  function warn(msg) {\n    if (verbosity >= VerbosityLevel.WARNINGS) {\n      console.log(`Warning: ${msg}`);\n    }\n  }\n\n  function unreachable(msg) {\n    throw new Error(msg);\n  }\n\n  function assert(cond, msg) {\n    if (!cond) {\n      unreachable(msg);\n    }\n  }\n\n  function isSameOrigin(baseUrl, otherUrl) {\n    let base;\n\n    try {\n      base = new URL(baseUrl);\n\n      if (!base.origin || base.origin === \"null\") {\n        return false;\n      }\n    } catch (e) {\n      return false;\n    }\n\n    const other = new URL(otherUrl, base);\n    return base.origin === other.origin;\n  }\n\n  function _isValidProtocol(url) {\n    if (!url) {\n      return false;\n    }\n\n    switch (url.protocol) {\n      case \"http:\":\n      case \"https:\":\n      case \"ftp:\":\n      case \"mailto:\":\n      case \"tel:\":\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  function createValidAbsoluteUrl(url, baseUrl) {\n    if (!url) {\n      return null;\n    }\n\n    try {\n      const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);\n\n      if (_isValidProtocol(absoluteUrl)) {\n        return absoluteUrl;\n      }\n    } catch (ex) {}\n\n    return null;\n  }\n\n  function shadow(obj, prop, value) {\n    Object.defineProperty(obj, prop, {\n      value,\n      enumerable: true,\n      configurable: true,\n      writable: false\n    });\n    return value;\n  }\n\n  const BaseException = function BaseExceptionClosure() {\n    function BaseException(message) {\n      if (this.constructor === BaseException) {\n        unreachable(\"Cannot initialize BaseException.\");\n      }\n\n      this.message = message;\n      this.name = this.constructor.name;\n    }\n\n    BaseException.prototype = new Error();\n    BaseException.constructor = BaseException;\n    return BaseException;\n  }();\n\n  exports.BaseException = BaseException;\n\n  class PasswordException extends BaseException {\n    constructor(msg, code) {\n      super(msg);\n      this.code = code;\n    }\n\n  }\n\n  exports.PasswordException = PasswordException;\n\n  class UnknownErrorException extends BaseException {\n    constructor(msg, details) {\n      super(msg);\n      this.details = details;\n    }\n\n  }\n\n  exports.UnknownErrorException = UnknownErrorException;\n\n  class InvalidPDFException extends BaseException {}\n\n  exports.InvalidPDFException = InvalidPDFException;\n\n  class MissingPDFException extends BaseException {}\n\n  exports.MissingPDFException = MissingPDFException;\n\n  class UnexpectedResponseException extends BaseException {\n    constructor(msg, status) {\n      super(msg);\n      this.status = status;\n    }\n\n  }\n\n  exports.UnexpectedResponseException = UnexpectedResponseException;\n\n  class FormatError extends BaseException {}\n\n  exports.FormatError = FormatError;\n\n  class AbortException extends BaseException {}\n\n  exports.AbortException = AbortException;\n  const NullCharactersRegExp = /\\x00/g;\n\n  function removeNullCharacters(str) {\n    if (typeof str !== \"string\") {\n      warn(\"The argument for removeNullCharacters must be a string.\");\n      return str;\n    }\n\n    return str.replace(NullCharactersRegExp, \"\");\n  }\n\n  function bytesToString(bytes) {\n    assert(bytes !== null && typeof bytes === \"object\" && bytes.length !== undefined, \"Invalid argument for bytesToString\");\n    const length = bytes.length;\n    const MAX_ARGUMENT_COUNT = 8192;\n\n    if (length < MAX_ARGUMENT_COUNT) {\n      return String.fromCharCode.apply(null, bytes);\n    }\n\n    const strBuf = [];\n\n    for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {\n      const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);\n      const chunk = bytes.subarray(i, chunkEnd);\n      strBuf.push(String.fromCharCode.apply(null, chunk));\n    }\n\n    return strBuf.join(\"\");\n  }\n\n  function stringToBytes(str) {\n    assert(typeof str === \"string\", \"Invalid argument for stringToBytes\");\n    const length = str.length;\n    const bytes = new Uint8Array(length);\n\n    for (let i = 0; i < length; ++i) {\n      bytes[i] = str.charCodeAt(i) & 0xff;\n    }\n\n    return bytes;\n  }\n\n  function arrayByteLength(arr) {\n    if (arr.length !== undefined) {\n      return arr.length;\n    }\n\n    assert(arr.byteLength !== undefined, \"arrayByteLength - invalid argument.\");\n    return arr.byteLength;\n  }\n\n  function arraysToBytes(arr) {\n    const length = arr.length;\n\n    if (length === 1 && arr[0] instanceof Uint8Array) {\n      return arr[0];\n    }\n\n    let resultLength = 0;\n\n    for (let i = 0; i < length; i++) {\n      resultLength += arrayByteLength(arr[i]);\n    }\n\n    let pos = 0;\n    const data = new Uint8Array(resultLength);\n\n    for (let i = 0; i < length; i++) {\n      let item = arr[i];\n\n      if (!(item instanceof Uint8Array)) {\n        if (typeof item === \"string\") {\n          item = stringToBytes(item);\n        } else {\n          item = new Uint8Array(item);\n        }\n      }\n\n      const itemLength = item.byteLength;\n      data.set(item, pos);\n      pos += itemLength;\n    }\n\n    return data;\n  }\n\n  function string32(value) {\n    return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);\n  }\n\n  function objectSize(obj) {\n    return Object.keys(obj).length;\n  }\n\n  function objectFromEntries(iterable) {\n    return Object.assign(Object.create(null), Object.fromEntries(iterable));\n  }\n\n  function isLittleEndian() {\n    const buffer8 = new Uint8Array(4);\n    buffer8[0] = 1;\n    const view32 = new Uint32Array(buffer8.buffer, 0, 1);\n    return view32[0] === 1;\n  }\n\n  const IsLittleEndianCached = {\n    get value() {\n      return shadow(this, \"value\", isLittleEndian());\n    }\n\n  };\n  exports.IsLittleEndianCached = IsLittleEndianCached;\n\n  function isEvalSupported() {\n    try {\n      new Function(\"\");\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  const IsEvalSupportedCached = {\n    get value() {\n      return shadow(this, \"value\", isEvalSupported());\n    }\n\n  };\n  exports.IsEvalSupportedCached = IsEvalSupportedCached;\n  const hexNumbers = [...Array(256).keys()].map(n => n.toString(16).padStart(2, \"0\"));\n\n  class Util {\n    static makeHexColor(r, g, b) {\n      return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;\n    }\n\n    static transform(m1, m2) {\n      return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];\n    }\n\n    static applyTransform(p, m) {\n      const xt = p[0] * m[0] + p[1] * m[2] + m[4];\n      const yt = p[0] * m[1] + p[1] * m[3] + m[5];\n      return [xt, yt];\n    }\n\n    static applyInverseTransform(p, m) {\n      const d = m[0] * m[3] - m[1] * m[2];\n      const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;\n      const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;\n      return [xt, yt];\n    }\n\n    static getAxialAlignedBoundingBox(r, m) {\n      const p1 = Util.applyTransform(r, m);\n      const p2 = Util.applyTransform(r.slice(2, 4), m);\n      const p3 = Util.applyTransform([r[0], r[3]], m);\n      const p4 = Util.applyTransform([r[2], r[1]], m);\n      return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];\n    }\n\n    static inverseTransform(m) {\n      const d = m[0] * m[3] - m[1] * m[2];\n      return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];\n    }\n\n    static apply3dTransform(m, v) {\n      return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];\n    }\n\n    static singularValueDecompose2dScale(m) {\n      const transpose = [m[0], m[2], m[1], m[3]];\n      const a = m[0] * transpose[0] + m[1] * transpose[2];\n      const b = m[0] * transpose[1] + m[1] * transpose[3];\n      const c = m[2] * transpose[0] + m[3] * transpose[2];\n      const d = m[2] * transpose[1] + m[3] * transpose[3];\n      const first = (a + d) / 2;\n      const second = Math.sqrt((a + d) * (a + d) - 4 * (a * d - c * b)) / 2;\n      const sx = first + second || 1;\n      const sy = first - second || 1;\n      return [Math.sqrt(sx), Math.sqrt(sy)];\n    }\n\n    static normalizeRect(rect) {\n      const r = rect.slice(0);\n\n      if (rect[0] > rect[2]) {\n        r[0] = rect[2];\n        r[2] = rect[0];\n      }\n\n      if (rect[1] > rect[3]) {\n        r[1] = rect[3];\n        r[3] = rect[1];\n      }\n\n      return r;\n    }\n\n    static intersect(rect1, rect2) {\n      function compare(a, b) {\n        return a - b;\n      }\n\n      const orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare);\n      const orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare);\n      const result = [];\n      rect1 = Util.normalizeRect(rect1);\n      rect2 = Util.normalizeRect(rect2);\n\n      if (orderedX[0] === rect1[0] && orderedX[1] === rect2[0] || orderedX[0] === rect2[0] && orderedX[1] === rect1[0]) {\n        result[0] = orderedX[1];\n        result[2] = orderedX[2];\n      } else {\n        return null;\n      }\n\n      if (orderedY[0] === rect1[1] && orderedY[1] === rect2[1] || orderedY[0] === rect2[1] && orderedY[1] === rect1[1]) {\n        result[1] = orderedY[1];\n        result[3] = orderedY[2];\n      } else {\n        return null;\n      }\n\n      return result;\n    }\n\n  }\n\n  exports.Util = Util;\n  const PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2D8, 0x2C7, 0x2C6, 0x2D9, 0x2DD, 0x2DB, 0x2DA, 0x2DC, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203A, 0x2212, 0x2030, 0x201E, 0x201C, 0x201D, 0x2018, 0x2019, 0x201A, 0x2122, 0xFB01, 0xFB02, 0x141, 0x152, 0x160, 0x178, 0x17D, 0x131, 0x142, 0x153, 0x161, 0x17E, 0, 0x20AC];\n\n  function stringToPDFString(str) {\n    const length = str.length,\n          strBuf = [];\n\n    if (str[0] === \"\\xFE\" && str[1] === \"\\xFF\") {\n      for (let i = 2; i < length; i += 2) {\n        strBuf.push(String.fromCharCode(str.charCodeAt(i) << 8 | str.charCodeAt(i + 1)));\n      }\n    } else if (str[0] === \"\\xFF\" && str[1] === \"\\xFE\") {\n      for (let i = 2; i < length; i += 2) {\n        strBuf.push(String.fromCharCode(str.charCodeAt(i + 1) << 8 | str.charCodeAt(i)));\n      }\n    } else {\n      for (let i = 0; i < length; ++i) {\n        const code = PDFStringTranslateTable[str.charCodeAt(i)];\n        strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));\n      }\n    }\n\n    return strBuf.join(\"\");\n  }\n\n  function escapeString(str) {\n    return str.replace(/([()\\\\\\n\\r])/g, match => {\n      if (match === \"\\n\") {\n        return \"\\\\n\";\n      } else if (match === \"\\r\") {\n        return \"\\\\r\";\n      }\n\n      return `\\\\${match}`;\n    });\n  }\n\n  function isAscii(str) {\n    return /^[\\x00-\\x7F]*$/.test(str);\n  }\n\n  function stringToUTF16BEString(str) {\n    const buf = [\"\\xFE\\xFF\"];\n\n    for (let i = 0, ii = str.length; i < ii; i++) {\n      const char = str.charCodeAt(i);\n      buf.push(String.fromCharCode(char >> 8 & 0xff));\n      buf.push(String.fromCharCode(char & 0xff));\n    }\n\n    return buf.join(\"\");\n  }\n\n  function stringToUTF8String(str) {\n    return decodeURIComponent(escape(str));\n  }\n\n  function utf8StringToString(str) {\n    return unescape(encodeURIComponent(str));\n  }\n\n  function isBool(v) {\n    return typeof v === \"boolean\";\n  }\n\n  function isNum(v) {\n    return typeof v === \"number\";\n  }\n\n  function isString(v) {\n    return typeof v === \"string\";\n  }\n\n  function isArrayBuffer(v) {\n    return typeof v === \"object\" && v !== null && v.byteLength !== undefined;\n  }\n\n  function isArrayEqual(arr1, arr2) {\n    if (arr1.length !== arr2.length) {\n      return false;\n    }\n\n    return arr1.every(function (element, index) {\n      return element === arr2[index];\n    });\n  }\n\n  function getModificationDate(date = new Date()) {\n    const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, \"0\"), date.getUTCDate().toString().padStart(2, \"0\"), date.getUTCHours().toString().padStart(2, \"0\"), date.getUTCMinutes().toString().padStart(2, \"0\"), date.getUTCSeconds().toString().padStart(2, \"0\")];\n    return buffer.join(\"\");\n  }\n\n  function createPromiseCapability() {\n    const capability = Object.create(null);\n    let isSettled = false;\n    Object.defineProperty(capability, \"settled\", {\n      get() {\n        return isSettled;\n      }\n\n    });\n    capability.promise = new Promise(function (resolve, reject) {\n      capability.resolve = function (data) {\n        isSettled = true;\n        resolve(data);\n      };\n\n      capability.reject = function (reason) {\n        isSettled = true;\n        reject(reason);\n      };\n    });\n    return capability;\n  }\n\n  const createObjectURL = function createObjectURLClosure() {\n    const digits = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n    return function createObjectURL(data, contentType, forceDataSchema = false) {\n      if (!forceDataSchema && URL.createObjectURL) {\n        const blob = new Blob([data], {\n          type: contentType\n        });\n        return URL.createObjectURL(blob);\n      }\n\n      let buffer = `data:${contentType};base64,`;\n\n      for (let i = 0, ii = data.length; i < ii; i += 3) {\n        const b1 = data[i] & 0xff;\n        const b2 = data[i + 1] & 0xff;\n        const b3 = data[i + 2] & 0xff;\n        const d1 = b1 >> 2,\n              d2 = (b1 & 3) << 4 | b2 >> 4;\n        const d3 = i + 1 < ii ? (b2 & 0xf) << 2 | b3 >> 6 : 64;\n        const d4 = i + 2 < ii ? b3 & 0x3f : 64;\n        buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];\n      }\n\n      return buffer;\n    };\n  }();\n\n  exports.createObjectURL = createObjectURL;\n  const XMLEntities = {\n    0x3c: \"&lt;\",\n    0x3e: \"&gt;\",\n    0x26: \"&amp;\",\n    0x22: \"&quot;\",\n    0x27: \"&apos;\"\n  };\n\n  function encodeToXmlString(str) {\n    const buffer = [];\n    let start = 0;\n\n    for (let i = 0, ii = str.length; i < ii; i++) {\n      const char = str.codePointAt(i);\n\n      if (0x20 <= char && char <= 0x7e) {\n        const entity = XMLEntities[char];\n\n        if (entity) {\n          if (start < i) {\n            buffer.push(str.substring(start, i));\n          }\n\n          buffer.push(entity);\n          start = i + 1;\n        }\n      } else {\n        if (start < i) {\n          buffer.push(str.substring(start, i));\n        }\n\n        buffer.push(`&#x${char.toString(16).toUpperCase()};`);\n\n        if (char > 0xd7ff && (char < 0xe000 || char > 0xfffd)) {\n          i++;\n        }\n\n        start = i + 1;\n      }\n    }\n\n    if (buffer.length === 0) {\n      return str;\n    }\n\n    if (start < str.length) {\n      buffer.push(str.substring(start, str.length));\n    }\n\n    return buffer.join(\"\");\n  }\n\n  /***/ }),\n  /* 3 */\n  /***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\n\n  var _is_node = __w_pdfjs_require__(4);\n\n  ;\n\n  /***/ }),\n  /* 4 */\n  /***/ ((__unused_webpack_module, exports) => {\n\n\n\n  Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n  }));\n  exports.isNodeJS = void 0;\n  const isNodeJS = typeof process === \"object\" && process + \"\" === \"[object process]\" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== \"browser\");\n  exports.isNodeJS = isNodeJS;\n\n  /***/ }),\n  /* 5 */\n  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\n  Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n  }));\n  exports.getDocument = getDocument;\n  exports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory;\n  exports.version = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultCMapReaderFactory = exports.DefaultCanvasFactory = exports.build = void 0;\n\n  var _util = __w_pdfjs_require__(2);\n\n  var _display_utils = __w_pdfjs_require__(1);\n\n  var _font_loader = __w_pdfjs_require__(6);\n\n  var _node_utils = __w_pdfjs_require__(7);\n\n  var _annotation_storage = __w_pdfjs_require__(8);\n\n  var _api_compatibility = __w_pdfjs_require__(9);\n\n  var _canvas = __w_pdfjs_require__(10);\n\n  var _worker_options = __w_pdfjs_require__(12);\n\n  var _is_node = __w_pdfjs_require__(4);\n\n  var _message_handler = __w_pdfjs_require__(13);\n\n  var _metadata = __w_pdfjs_require__(14);\n\n  var _optional_content_config = __w_pdfjs_require__(16);\n\n  var _transport_stream = __w_pdfjs_require__(17);\n\n  var _webgl = __w_pdfjs_require__(18);\n\n  const DEFAULT_RANGE_CHUNK_SIZE = 65536;\n  const RENDERING_CANCELLED_TIMEOUT = 100;\n  const DefaultCanvasFactory = _is_node.isNodeJS ? _node_utils.NodeCanvasFactory : _display_utils.DOMCanvasFactory;\n  exports.DefaultCanvasFactory = DefaultCanvasFactory;\n  const DefaultCMapReaderFactory = _is_node.isNodeJS ? _node_utils.NodeCMapReaderFactory : _display_utils.DOMCMapReaderFactory;\n  exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;\n  let createPDFNetworkStream;\n\n  function setPDFNetworkStreamFactory(pdfNetworkStreamFactory) {\n    createPDFNetworkStream = pdfNetworkStreamFactory;\n  }\n\n  function getDocument(src) {\n    const task = new PDFDocumentLoadingTask();\n    let source;\n\n    if (typeof src === \"string\") {\n      source = {\n        url: src\n      };\n    } else if ((0, _util.isArrayBuffer)(src)) {\n      source = {\n        data: src\n      };\n    } else if (src instanceof PDFDataRangeTransport) {\n      source = {\n        range: src\n      };\n    } else {\n      if (typeof src !== \"object\") {\n        throw new Error(\"Invalid parameter in getDocument, \" + \"need either Uint8Array, string or a parameter object\");\n      }\n\n      if (!src.url && !src.data && !src.range) {\n        throw new Error(\"Invalid parameter object: need either .data, .range or .url\");\n      }\n\n      source = src;\n    }\n\n    const params = Object.create(null);\n    let rangeTransport = null,\n        worker = null;\n\n    for (const key in source) {\n      if (key === \"url\" && typeof window !== \"undefined\") {\n        params[key] = new URL(source[key], window.location).href;\n        continue;\n      } else if (key === \"range\") {\n        rangeTransport = source[key];\n        continue;\n      } else if (key === \"worker\") {\n        worker = source[key];\n        continue;\n      } else if (key === \"data\" && !(source[key] instanceof Uint8Array)) {\n        const pdfBytes = source[key];\n\n        if (typeof pdfBytes === \"string\") {\n          params[key] = (0, _util.stringToBytes)(pdfBytes);\n        } else if (typeof pdfBytes === \"object\" && pdfBytes !== null && !isNaN(pdfBytes.length)) {\n          params[key] = new Uint8Array(pdfBytes);\n        } else if ((0, _util.isArrayBuffer)(pdfBytes)) {\n          params[key] = new Uint8Array(pdfBytes);\n        } else {\n          throw new Error(\"Invalid PDF binary data: either typed array, \" + \"string or array-like object is expected in the \" + \"data property.\");\n        }\n\n        continue;\n      }\n\n      params[key] = source[key];\n    }\n\n    params.rangeChunkSize = params.rangeChunkSize || DEFAULT_RANGE_CHUNK_SIZE;\n    params.CMapReaderFactory = params.CMapReaderFactory || DefaultCMapReaderFactory;\n    params.ignoreErrors = params.stopAtErrors !== true;\n    params.fontExtraProperties = params.fontExtraProperties === true;\n    params.pdfBug = params.pdfBug === true;\n\n    if (!Number.isInteger(params.maxImageSize)) {\n      params.maxImageSize = -1;\n    }\n\n    if (typeof params.isEvalSupported !== \"boolean\") {\n      params.isEvalSupported = true;\n    }\n\n    if (typeof params.disableFontFace !== \"boolean\") {\n      params.disableFontFace = _api_compatibility.apiCompatibilityParams.disableFontFace || false;\n    }\n\n    if (typeof params.ownerDocument === \"undefined\") {\n      params.ownerDocument = globalThis.document;\n    }\n\n    if (typeof params.disableRange !== \"boolean\") {\n      params.disableRange = false;\n    }\n\n    if (typeof params.disableStream !== \"boolean\") {\n      params.disableStream = false;\n    }\n\n    if (typeof params.disableAutoFetch !== \"boolean\") {\n      params.disableAutoFetch = false;\n    }\n\n    (0, _util.setVerbosityLevel)(params.verbosity);\n\n    if (!worker) {\n      const workerParams = {\n        verbosity: params.verbosity,\n        port: _worker_options.GlobalWorkerOptions.workerPort\n      };\n      worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);\n      task._worker = worker;\n    }\n\n    const docId = task.docId;\n    worker.promise.then(function () {\n      if (task.destroyed) {\n        throw new Error(\"Loading aborted\");\n      }\n\n      const workerIdPromise = _fetchDocument(worker, params, rangeTransport, docId);\n\n      const networkStreamPromise = new Promise(function (resolve) {\n        let networkStream;\n\n        if (rangeTransport) {\n          networkStream = new _transport_stream.PDFDataTransportStream({\n            length: params.length,\n            initialData: params.initialData,\n            progressiveDone: params.progressiveDone,\n            disableRange: params.disableRange,\n            disableStream: params.disableStream\n          }, rangeTransport);\n        } else if (!params.data) {\n          networkStream = createPDFNetworkStream({\n            url: params.url,\n            length: params.length,\n            httpHeaders: params.httpHeaders,\n            withCredentials: params.withCredentials,\n            rangeChunkSize: params.rangeChunkSize,\n            disableRange: params.disableRange,\n            disableStream: params.disableStream\n          });\n        }\n\n        resolve(networkStream);\n      });\n      return Promise.all([workerIdPromise, networkStreamPromise]).then(function ([workerId, networkStream]) {\n        if (task.destroyed) {\n          throw new Error(\"Loading aborted\");\n        }\n\n        const messageHandler = new _message_handler.MessageHandler(docId, workerId, worker.port);\n        messageHandler.postMessageTransfers = worker.postMessageTransfers;\n        const transport = new WorkerTransport(messageHandler, task, networkStream, params);\n        task._transport = transport;\n        messageHandler.send(\"Ready\", null);\n      });\n    }).catch(task._capability.reject);\n    return task;\n  }\n\n  function _fetchDocument(worker, source, pdfDataRangeTransport, docId) {\n    if (worker.destroyed) {\n      return Promise.reject(new Error(\"Worker was destroyed\"));\n    }\n\n    if (pdfDataRangeTransport) {\n      source.length = pdfDataRangeTransport.length;\n      source.initialData = pdfDataRangeTransport.initialData;\n      source.progressiveDone = pdfDataRangeTransport.progressiveDone;\n    }\n\n    return worker.messageHandler.sendWithPromise(\"GetDocRequest\", {\n      docId,\n      apiVersion: '2.7.570',\n      source: {\n        data: source.data,\n        url: source.url,\n        password: source.password,\n        disableAutoFetch: source.disableAutoFetch,\n        rangeChunkSize: source.rangeChunkSize,\n        length: source.length\n      },\n      maxImageSize: source.maxImageSize,\n      disableFontFace: source.disableFontFace,\n      postMessageTransfers: worker.postMessageTransfers,\n      docBaseUrl: source.docBaseUrl,\n      ignoreErrors: source.ignoreErrors,\n      isEvalSupported: source.isEvalSupported,\n      fontExtraProperties: source.fontExtraProperties\n    }).then(function (workerId) {\n      if (worker.destroyed) {\n        throw new Error(\"Worker was destroyed\");\n      }\n\n      return workerId;\n    });\n  }\n\n  const PDFDocumentLoadingTask = function PDFDocumentLoadingTaskClosure() {\n    let nextDocumentId = 0;\n\n    class PDFDocumentLoadingTask {\n      constructor() {\n        this._capability = (0, _util.createPromiseCapability)();\n        this._transport = null;\n        this._worker = null;\n        this.docId = \"d\" + nextDocumentId++;\n        this.destroyed = false;\n        this.onPassword = null;\n        this.onProgress = null;\n        this.onUnsupportedFeature = null;\n      }\n\n      get promise() {\n        return this._capability.promise;\n      }\n\n      destroy() {\n        this.destroyed = true;\n        const transportDestroyed = !this._transport ? Promise.resolve() : this._transport.destroy();\n        return transportDestroyed.then(() => {\n          this._transport = null;\n\n          if (this._worker) {\n            this._worker.destroy();\n\n            this._worker = null;\n          }\n        });\n      }\n\n    }\n\n    return PDFDocumentLoadingTask;\n  }();\n\n  class PDFDataRangeTransport {\n    constructor(length, initialData, progressiveDone = false) {\n      this.length = length;\n      this.initialData = initialData;\n      this.progressiveDone = progressiveDone;\n      this._rangeListeners = [];\n      this._progressListeners = [];\n      this._progressiveReadListeners = [];\n      this._progressiveDoneListeners = [];\n      this._readyCapability = (0, _util.createPromiseCapability)();\n    }\n\n    addRangeListener(listener) {\n      this._rangeListeners.push(listener);\n    }\n\n    addProgressListener(listener) {\n      this._progressListeners.push(listener);\n    }\n\n    addProgressiveReadListener(listener) {\n      this._progressiveReadListeners.push(listener);\n    }\n\n    addProgressiveDoneListener(listener) {\n      this._progressiveDoneListeners.push(listener);\n    }\n\n    onDataRange(begin, chunk) {\n      for (const listener of this._rangeListeners) {\n        listener(begin, chunk);\n      }\n    }\n\n    onDataProgress(loaded, total) {\n      this._readyCapability.promise.then(() => {\n        for (const listener of this._progressListeners) {\n          listener(loaded, total);\n        }\n      });\n    }\n\n    onDataProgressiveRead(chunk) {\n      this._readyCapability.promise.then(() => {\n        for (const listener of this._progressiveReadListeners) {\n          listener(chunk);\n        }\n      });\n    }\n\n    onDataProgressiveDone() {\n      this._readyCapability.promise.then(() => {\n        for (const listener of this._progressiveDoneListeners) {\n          listener();\n        }\n      });\n    }\n\n    transportReady() {\n      this._readyCapability.resolve();\n    }\n\n    requestDataRange(begin, end) {\n      (0, _util.unreachable)(\"Abstract method PDFDataRangeTransport.requestDataRange\");\n    }\n\n    abort() {}\n\n  }\n\n  exports.PDFDataRangeTransport = PDFDataRangeTransport;\n\n  class PDFDocumentProxy {\n    constructor(pdfInfo, transport) {\n      this._pdfInfo = pdfInfo;\n      this._transport = transport;\n    }\n\n    get annotationStorage() {\n      return (0, _util.shadow)(this, \"annotationStorage\", new _annotation_storage.AnnotationStorage());\n    }\n\n    get numPages() {\n      return this._pdfInfo.numPages;\n    }\n\n    get fingerprint() {\n      return this._pdfInfo.fingerprint;\n    }\n\n    getPage(pageNumber) {\n      return this._transport.getPage(pageNumber);\n    }\n\n    getPageIndex(ref) {\n      return this._transport.getPageIndex(ref);\n    }\n\n    getDestinations() {\n      return this._transport.getDestinations();\n    }\n\n    getDestination(id) {\n      return this._transport.getDestination(id);\n    }\n\n    getPageLabels() {\n      return this._transport.getPageLabels();\n    }\n\n    getPageLayout() {\n      return this._transport.getPageLayout();\n    }\n\n    getPageMode() {\n      return this._transport.getPageMode();\n    }\n\n    getViewerPreferences() {\n      return this._transport.getViewerPreferences();\n    }\n\n    getOpenAction() {\n      return this._transport.getOpenAction();\n    }\n\n    getAttachments() {\n      return this._transport.getAttachments();\n    }\n\n    getJavaScript() {\n      return this._transport.getJavaScript();\n    }\n\n    getJSActions() {\n      return this._transport.getDocJSActions();\n    }\n\n    getOutline() {\n      return this._transport.getOutline();\n    }\n\n    getOptionalContentConfig() {\n      return this._transport.getOptionalContentConfig();\n    }\n\n    getPermissions() {\n      return this._transport.getPermissions();\n    }\n\n    getMetadata() {\n      return this._transport.getMetadata();\n    }\n\n    getMarkInfo() {\n      return this._transport.getMarkInfo();\n    }\n\n    getData() {\n      return this._transport.getData();\n    }\n\n    getDownloadInfo() {\n      return this._transport.downloadInfoCapability.promise;\n    }\n\n    getStats() {\n      return this._transport.getStats();\n    }\n\n    cleanup() {\n      return this._transport.startCleanup();\n    }\n\n    destroy() {\n      return this.loadingTask.destroy();\n    }\n\n    get loadingParams() {\n      return this._transport.loadingParams;\n    }\n\n    get loadingTask() {\n      return this._transport.loadingTask;\n    }\n\n    saveDocument(annotationStorage) {\n      return this._transport.saveDocument(annotationStorage);\n    }\n\n    getFieldObjects() {\n      return this._transport.getFieldObjects();\n    }\n\n    hasJSActions() {\n      return this._transport.hasJSActions();\n    }\n\n    getCalculationOrderIds() {\n      return this._transport.getCalculationOrderIds();\n    }\n\n  }\n\n  exports.PDFDocumentProxy = PDFDocumentProxy;\n\n  class PDFPageProxy {\n    constructor(pageIndex, pageInfo, transport, ownerDocument, pdfBug = false) {\n      this._pageIndex = pageIndex;\n      this._pageInfo = pageInfo;\n      this._ownerDocument = ownerDocument;\n      this._transport = transport;\n      this._stats = pdfBug ? new _display_utils.StatTimer() : null;\n      this._pdfBug = pdfBug;\n      this.commonObjs = transport.commonObjs;\n      this.objs = new PDFObjects();\n      this.cleanupAfterRender = false;\n      this.pendingCleanup = false;\n      this._intentStates = new Map();\n      this.destroyed = false;\n    }\n\n    get pageNumber() {\n      return this._pageIndex + 1;\n    }\n\n    get rotate() {\n      return this._pageInfo.rotate;\n    }\n\n    get ref() {\n      return this._pageInfo.ref;\n    }\n\n    get userUnit() {\n      return this._pageInfo.userUnit;\n    }\n\n    get view() {\n      return this._pageInfo.view;\n    }\n\n    getViewport({\n      scale,\n      rotation = this.rotate,\n      offsetX = 0,\n      offsetY = 0,\n      dontFlip = false\n    } = {}) {\n      return new _display_utils.PageViewport({\n        viewBox: this.view,\n        scale,\n        rotation,\n        offsetX,\n        offsetY,\n        dontFlip\n      });\n    }\n\n    getAnnotations({\n      intent = null\n    } = {}) {\n      if (!this.annotationsPromise || this.annotationsIntent !== intent) {\n        this.annotationsPromise = this._transport.getAnnotations(this._pageIndex, intent);\n        this.annotationsIntent = intent;\n      }\n\n      return this.annotationsPromise;\n    }\n\n    getJSActions() {\n      return this._jsActionsPromise || (this._jsActionsPromise = this._transport.getPageJSActions(this._pageIndex));\n    }\n\n    render({\n      canvasContext,\n      viewport,\n      intent = \"display\",\n      enableWebGL = false,\n      renderInteractiveForms = false,\n      transform = null,\n      imageLayer = null,\n      canvasFactory = null,\n      background = null,\n      annotationStorage = null,\n      optionalContentConfigPromise = null\n    }) {\n      if (this._stats) {\n        this._stats.time(\"Overall\");\n      }\n\n      const renderingIntent = intent === \"print\" ? \"print\" : \"display\";\n      this.pendingCleanup = false;\n\n      if (!optionalContentConfigPromise) {\n        optionalContentConfigPromise = this._transport.getOptionalContentConfig();\n      }\n\n      let intentState = this._intentStates.get(renderingIntent);\n\n      if (!intentState) {\n        intentState = Object.create(null);\n\n        this._intentStates.set(renderingIntent, intentState);\n      }\n\n      if (intentState.streamReaderCancelTimeout) {\n        clearTimeout(intentState.streamReaderCancelTimeout);\n        intentState.streamReaderCancelTimeout = null;\n      }\n\n      const canvasFactoryInstance = canvasFactory || new DefaultCanvasFactory({\n        ownerDocument: this._ownerDocument\n      });\n      const webGLContext = new _webgl.WebGLContext({\n        enable: enableWebGL\n      });\n\n      if (!intentState.displayReadyCapability) {\n        intentState.displayReadyCapability = (0, _util.createPromiseCapability)();\n        intentState.operatorList = {\n          fnArray: [],\n          argsArray: [],\n          lastChunk: false\n        };\n\n        if (this._stats) {\n          this._stats.time(\"Page Request\");\n        }\n\n        this._pumpOperatorList({\n          pageIndex: this._pageIndex,\n          intent: renderingIntent,\n          renderInteractiveForms: renderInteractiveForms === true,\n          annotationStorage: annotationStorage && annotationStorage.getAll() || null  // lwf\n        });\n      }\n\n      const complete = error => {\n        const i = intentState.renderTasks.indexOf(internalRenderTask);\n\n        if (i >= 0) {\n          intentState.renderTasks.splice(i, 1);\n        }\n\n        if (this.cleanupAfterRender || renderingIntent === \"print\") {\n          this.pendingCleanup = true;\n        }\n\n        this._tryCleanup();\n\n        if (error) {\n          internalRenderTask.capability.reject(error);\n\n          this._abortOperatorList({\n            intentState,\n            reason: error\n          });\n        } else {\n          internalRenderTask.capability.resolve();\n        }\n\n        if (this._stats) {\n          this._stats.timeEnd(\"Rendering\");\n\n          this._stats.timeEnd(\"Overall\");\n        }\n      };\n\n      const internalRenderTask = new InternalRenderTask({\n        callback: complete,\n        params: {\n          canvasContext,\n          viewport,\n          transform,\n          imageLayer,\n          background\n        },\n        objs: this.objs,\n        commonObjs: this.commonObjs,\n        operatorList: intentState.operatorList,\n        pageIndex: this._pageIndex,\n        canvasFactory: canvasFactoryInstance,\n        webGLContext,\n        useRequestAnimationFrame: renderingIntent !== \"print\",\n        pdfBug: this._pdfBug\n      });\n\n      if (!intentState.renderTasks) {\n        intentState.renderTasks = [];\n      }\n\n      intentState.renderTasks.push(internalRenderTask);\n      const renderTask = internalRenderTask.task;\n      Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(([transparency, optionalContentConfig]) => {\n        if (this.pendingCleanup) {\n          complete();\n          return;\n        }\n\n        if (this._stats) {\n          this._stats.time(\"Rendering\");\n        }\n\n        internalRenderTask.initializeGraphics({\n          transparency,\n          optionalContentConfig\n        });\n        internalRenderTask.operatorListChanged();\n      }).catch(complete);\n      return renderTask;\n    }\n\n    getOperatorList() {\n      function operatorListChanged() {\n        if (intentState.operatorList.lastChunk) {\n          intentState.opListReadCapability.resolve(intentState.operatorList);\n          const i = intentState.renderTasks.indexOf(opListTask);\n\n          if (i >= 0) {\n            intentState.renderTasks.splice(i, 1);\n          }\n        }\n      }\n\n      const renderingIntent = \"oplist\";\n\n      let intentState = this._intentStates.get(renderingIntent);\n\n      if (!intentState) {\n        intentState = Object.create(null);\n\n        this._intentStates.set(renderingIntent, intentState);\n      }\n\n      let opListTask;\n\n      if (!intentState.opListReadCapability) {\n        opListTask = Object.create(null);\n        opListTask.operatorListChanged = operatorListChanged;\n        intentState.opListReadCapability = (0, _util.createPromiseCapability)();\n        intentState.renderTasks = [];\n        intentState.renderTasks.push(opListTask);\n        intentState.operatorList = {\n          fnArray: [],\n          argsArray: [],\n          lastChunk: false\n        };\n\n        if (this._stats) {\n          this._stats.time(\"Page Request\");\n        }\n\n        this._pumpOperatorList({\n          pageIndex: this._pageIndex,\n          intent: renderingIntent\n        });\n      }\n\n      return intentState.opListReadCapability.promise;\n    }\n\n    streamTextContent({\n      normalizeWhitespace = false,\n      disableCombineTextItems = false\n    } = {}) {\n      const TEXT_CONTENT_CHUNK_SIZE = 100;\n      return this._transport.messageHandler.sendWithStream(\"GetTextContent\", {\n        pageIndex: this._pageIndex,\n        normalizeWhitespace: normalizeWhitespace === true,\n        combineTextItems: disableCombineTextItems !== true\n      }, {\n        highWaterMark: TEXT_CONTENT_CHUNK_SIZE,\n\n        size(textContent) {\n          return textContent.items.length;\n        }\n\n      });\n    }\n\n    getTextContent(params = {}) {\n      const readableStream = this.streamTextContent(params);\n      return new Promise(function (resolve, reject) {\n        function pump() {\n          reader.read().then(function ({\n            value,\n            done\n          }) {\n            if (done) {\n              resolve(textContent);\n              return;\n            }\n\n            Object.assign(textContent.styles, value.styles);\n            textContent.items.push(...value.items);\n            pump();\n          }, reject);\n        }\n\n        const reader = readableStream.getReader();\n        const textContent = {\n          items: [],\n          styles: Object.create(null)\n        };\n        pump();\n      });\n    }\n\n    _destroy() {\n      this.destroyed = true;\n      this._transport.pageCache[this._pageIndex] = null;\n      const waitOn = [];\n\n      for (const [intent, intentState] of this._intentStates) {\n        this._abortOperatorList({\n          intentState,\n          reason: new Error(\"Page was destroyed.\"),\n          force: true\n        });\n\n        if (intent === \"oplist\") {\n          continue;\n        }\n\n        for (const internalRenderTask of intentState.renderTasks) {\n          waitOn.push(internalRenderTask.completed);\n          internalRenderTask.cancel();\n        }\n      }\n\n      this.objs.clear();\n      this.annotationsPromise = null;\n      this._jsActionsPromise = null;\n      this.pendingCleanup = false;\n      return Promise.all(waitOn);\n    }\n\n    cleanup(resetStats = false) {\n      this.pendingCleanup = true;\n      return this._tryCleanup(resetStats);\n    }\n\n    _tryCleanup(resetStats = false) {\n      if (!this.pendingCleanup) {\n        return false;\n      }\n\n      for (const {\n        renderTasks,\n        operatorList\n      } of this._intentStates.values()) {\n        if (renderTasks.length !== 0 || !operatorList.lastChunk) {\n          return false;\n        }\n      }\n\n      this._intentStates.clear();\n\n      this.objs.clear();\n      this.annotationsPromise = null;\n      this._jsActionsPromise = null;\n\n      if (resetStats && this._stats) {\n        this._stats = new _display_utils.StatTimer();\n      }\n\n      this.pendingCleanup = false;\n      return true;\n    }\n\n    _startRenderPage(transparency, intent) {\n      const intentState = this._intentStates.get(intent);\n\n      if (!intentState) {\n        return;\n      }\n\n      if (this._stats) {\n        this._stats.timeEnd(\"Page Request\");\n      }\n\n      if (intentState.displayReadyCapability) {\n        intentState.displayReadyCapability.resolve(transparency);\n      }\n    }\n\n    _renderPageChunk(operatorListChunk, intentState) {\n      for (let i = 0, ii = operatorListChunk.length; i < ii; i++) {\n        intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);\n        intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);\n      }\n\n      intentState.operatorList.lastChunk = operatorListChunk.lastChunk;\n\n      for (let i = 0; i < intentState.renderTasks.length; i++) {\n        intentState.renderTasks[i].operatorListChanged();\n      }\n\n      if (operatorListChunk.lastChunk) {\n        this._tryCleanup();\n      }\n    }\n\n    _pumpOperatorList(args) {\n      (0, _util.assert)(args.intent, 'PDFPageProxy._pumpOperatorList: Expected \"intent\" argument.');\n\n      const readableStream = this._transport.messageHandler.sendWithStream(\"GetOperatorList\", args);\n\n      const reader = readableStream.getReader();\n\n      const intentState = this._intentStates.get(args.intent);\n\n      intentState.streamReader = reader;\n\n      const pump = () => {\n        reader.read().then(({\n          value,\n          done\n        }) => {\n          if (done) {\n            intentState.streamReader = null;\n            return;\n          }\n\n          if (this._transport.destroyed) {\n            return;\n          }\n\n          this._renderPageChunk(value, intentState);\n\n          pump();\n        }, reason => {\n          intentState.streamReader = null;\n\n          if (this._transport.destroyed) {\n            return;\n          }\n\n          if (intentState.operatorList) {\n            intentState.operatorList.lastChunk = true;\n\n            for (let i = 0; i < intentState.renderTasks.length; i++) {\n              intentState.renderTasks[i].operatorListChanged();\n            }\n\n            this._tryCleanup();\n          }\n\n          if (intentState.displayReadyCapability) {\n            intentState.displayReadyCapability.reject(reason);\n          } else if (intentState.opListReadCapability) {\n            intentState.opListReadCapability.reject(reason);\n          } else {\n            throw reason;\n          }\n        });\n      };\n\n      pump();\n    }\n\n    _abortOperatorList({\n      intentState,\n      reason,\n      force = false\n    }) {\n      (0, _util.assert)(reason instanceof Error || typeof reason === \"object\" && reason !== null, 'PDFPageProxy._abortOperatorList: Expected \"reason\" argument.');\n\n      if (!intentState.streamReader) {\n        return;\n      }\n\n      if (!force) {\n        if (intentState.renderTasks.length !== 0) {\n          return;\n        }\n\n        if (reason instanceof _display_utils.RenderingCancelledException) {\n          intentState.streamReaderCancelTimeout = setTimeout(() => {\n            this._abortOperatorList({\n              intentState,\n              reason,\n              force: true\n            });\n\n            intentState.streamReaderCancelTimeout = null;\n          }, RENDERING_CANCELLED_TIMEOUT);\n          return;\n        }\n      }\n\n      intentState.streamReader.cancel(new _util.AbortException(reason && reason.message)); // lwf\n      intentState.streamReader = null;\n\n      if (this._transport.destroyed) {\n        return;\n      }\n\n      for (const [intent, curIntentState] of this._intentStates) {\n        if (curIntentState === intentState) {\n          this._intentStates.delete(intent);\n\n          break;\n        }\n      }\n\n      this.cleanup();\n    }\n\n    get stats() {\n      return this._stats;\n    }\n\n  }\n\n  exports.PDFPageProxy = PDFPageProxy;\n\n  class LoopbackPort {\n    constructor(defer = true) {\n      this._listeners = [];\n      this._defer = defer;\n      this._deferred = Promise.resolve(undefined);\n    }\n\n    postMessage(obj, transfers) {\n      function cloneValue(value) {\n        if (typeof value !== \"object\" || value === null) {\n          return value;\n        }\n\n        if (cloned.has(value)) {\n          return cloned.get(value);\n        }\n\n        let buffer, result;\n\n        if ((buffer = value.buffer) && (0, _util.isArrayBuffer)(buffer)) {\n          if (transfers && transfers.includes(buffer)) { // lwf\n            result = new value.constructor(buffer, value.byteOffset, value.byteLength);\n          } else {\n            result = new value.constructor(value);\n          }\n\n          cloned.set(value, result);\n          return result;\n        }\n\n        result = Array.isArray(value) ? [] : {};\n        cloned.set(value, result);\n\n        for (const i in value) {\n          let desc,\n              p = value;\n\n          while (!(desc = Object.getOwnPropertyDescriptor(p, i))) {\n            p = Object.getPrototypeOf(p);\n          }\n\n          if (typeof desc.value === \"undefined\") {\n            continue;\n          }\n\n          if (typeof desc.value === \"function\") {\n            if (value.hasOwnProperty && value.hasOwnProperty(i)) {\n              throw new Error(`LoopbackPort.postMessage - cannot clone: ${value[i]}`);\n            }\n\n            continue;\n          }\n\n          result[i] = cloneValue(desc.value);\n        }\n\n        return result;\n      }\n\n      if (!this._defer) {\n        this._listeners.forEach(listener => {\n          listener.call(this, {\n            data: obj\n          });\n        });\n\n        return;\n      }\n\n      const cloned = new WeakMap();\n      const e = {\n        data: cloneValue(obj)\n      };\n\n      this._deferred.then(() => {\n        this._listeners.forEach(listener => {\n          listener.call(this, e);\n        });\n      });\n    }\n\n    addEventListener(name, listener) {\n      this._listeners.push(listener);\n    }\n\n    removeEventListener(name, listener) {\n      const i = this._listeners.indexOf(listener);\n\n      this._listeners.splice(i, 1);\n    }\n\n    terminate() {\n      this._listeners.length = 0;\n    }\n\n  }\n\n  exports.LoopbackPort = LoopbackPort;\n\n  const PDFWorker = function PDFWorkerClosure() {\n    const pdfWorkerPorts = new WeakMap();\n    let isWorkerDisabled = false;\n    let fallbackWorkerSrc;\n    let nextFakeWorkerId = 0;\n    let fakeWorkerCapability;\n\n    if (_is_node.isNodeJS && typeof require === \"function\") {\n      isWorkerDisabled = true;\n      fallbackWorkerSrc = \"./skylark-pdfjs-worker-all.js\"; //\"./pdf.worker.js\";\n    } else if (typeof document === \"object\" && \"currentScript\" in document) {\n      const pdfjsFilePath = document.currentScript && document.currentScript.src; // lwf\n\n      if (pdfjsFilePath) {\n        fallbackWorkerSrc = pdfjsFilePath.replace(/(\\.(?:min\\.)?js)(\\?.*)?$/i, \".worker$1$2\");\n      }\n    }\n\n    function getWorkerSrc() {\n      if (_worker_options.GlobalWorkerOptions.workerSrc) {\n        return _worker_options.GlobalWorkerOptions.workerSrc;\n      }\n\n      if (typeof fallbackWorkerSrc !== \"undefined\") {\n        if (!_is_node.isNodeJS) {\n          (0, _display_utils.deprecated)('No \"GlobalWorkerOptions.workerSrc\" specified.');\n        }\n\n        return fallbackWorkerSrc;\n      }\n\n      throw new Error('No \"GlobalWorkerOptions.workerSrc\" specified.');\n    }\n\n    function getMainThreadWorkerMessageHandler() {\n      let mainWorkerMessageHandler;\n\n      try {\n        ///mainWorkerMessageHandler = globalThis.pdfjsWorker && globalThis.pdfjsWorker.WorkerMessageHandler;  // lwf\n        mainWorkerMessageHandler = pdfjs.worker.WorkerMessageHandler; \n      } catch (ex) {}\n\n      return mainWorkerMessageHandler || null;\n    }\n\n    function setupFakeWorkerGlobal() {\n      if (fakeWorkerCapability) {\n        return fakeWorkerCapability.promise;\n      }\n\n      fakeWorkerCapability = (0, _util.createPromiseCapability)();\n\n      const loader = async function () {\n        const mainWorkerMessageHandler = getMainThreadWorkerMessageHandler();\n\n        if (mainWorkerMessageHandler) {\n          return mainWorkerMessageHandler;\n        }\n\n        if (_is_node.isNodeJS && typeof require === \"function\") {\n          const worker = eval(\"require\")(getWorkerSrc());\n          return worker.WorkerMessageHandler;\n        }\n\n        await (0, _display_utils.loadScript)(getWorkerSrc());\n        return window.pdfjsWorker.WorkerMessageHandler;\n      };\n\n      loader().then(fakeWorkerCapability.resolve, fakeWorkerCapability.reject);\n      return fakeWorkerCapability.promise;\n    }\n\n    function createCDNWrapper(url) {\n      const wrapper = \"importScripts('\" + url + \"');\";\n      return URL.createObjectURL(new Blob([wrapper]));\n    }\n\n    class PDFWorker {\n      constructor({\n        name = null,\n        port = null,\n        verbosity = (0, _util.getVerbosityLevel)()\n      } = {}) {\n        if (port && pdfWorkerPorts.has(port)) {\n          throw new Error(\"Cannot use more than one PDFWorker per port\");\n        }\n\n        this.name = name;\n        this.destroyed = false;\n        this.postMessageTransfers = true;\n        this.verbosity = verbosity;\n        this._readyCapability = (0, _util.createPromiseCapability)();\n        this._port = null;\n        this._webWorker = null;\n        this._messageHandler = null;\n\n        if (port) {\n          pdfWorkerPorts.set(port, this);\n\n          this._initializeFromPort(port);\n\n          return;\n        }\n\n        this._initialize();\n      }\n\n      get promise() {\n        return this._readyCapability.promise;\n      }\n\n      get port() {\n        return this._port;\n      }\n\n      get messageHandler() {\n        return this._messageHandler;\n      }\n\n      _initializeFromPort(port) {\n        this._port = port;\n        this._messageHandler = new _message_handler.MessageHandler(\"main\", \"worker\", port);\n\n        this._messageHandler.on(\"ready\", function () {});\n\n        this._readyCapability.resolve();\n      }\n\n      _initialize() {\n        if (typeof Worker !== \"undefined\" && !isWorkerDisabled && !getMainThreadWorkerMessageHandler()) {\n          let workerSrc = getWorkerSrc();\n\n          try {\n            if (!(0, _util.isSameOrigin)(window.location.href, workerSrc)) {\n              workerSrc = createCDNWrapper(new URL(workerSrc, window.location).href);\n            }\n\n            const worker = new Worker(workerSrc);\n            const messageHandler = new _message_handler.MessageHandler(\"main\", \"worker\", worker);\n\n            const terminateEarly = () => {\n              worker.removeEventListener(\"error\", onWorkerError);\n              messageHandler.destroy();\n              worker.terminate();\n\n              if (this.destroyed) {\n                this._readyCapability.reject(new Error(\"Worker was destroyed\"));\n              } else {\n                this._setupFakeWorker();\n              }\n            };\n\n            const onWorkerError = () => {\n              if (!this._webWorker) {\n                terminateEarly();\n              }\n            };\n\n            worker.addEventListener(\"error\", onWorkerError);\n            messageHandler.on(\"test\", data => {\n              worker.removeEventListener(\"error\", onWorkerError);\n\n              if (this.destroyed) {\n                terminateEarly();\n                return;\n              }\n\n              if (data) {\n                this._messageHandler = messageHandler;\n                this._port = worker;\n                this._webWorker = worker;\n\n                if (!data.supportTransfers) {\n                  this.postMessageTransfers = false;\n                }\n\n                this._readyCapability.resolve();\n\n                messageHandler.send(\"configure\", {\n                  verbosity: this.verbosity\n                });\n              } else {\n                this._setupFakeWorker();\n\n                messageHandler.destroy();\n                worker.terminate();\n              }\n            });\n            messageHandler.on(\"ready\", data => {\n              worker.removeEventListener(\"error\", onWorkerError);\n\n              if (this.destroyed) {\n                terminateEarly();\n                return;\n              }\n\n              try {\n                sendTest();\n              } catch (e) {\n                this._setupFakeWorker();\n              }\n            });\n\n            const sendTest = () => {\n              const testObj = new Uint8Array([this.postMessageTransfers ? 255 : 0]);\n\n              try {\n                messageHandler.send(\"test\", testObj, [testObj.buffer]);\n              } catch (ex) {\n                (0, _util.warn)(\"Cannot use postMessage transfers.\");\n                testObj[0] = 0;\n                messageHandler.send(\"test\", testObj);\n              }\n            };\n\n            sendTest();\n            return;\n          } catch (e) {\n            (0, _util.info)(\"The worker has been disabled.\");\n          }\n        }\n\n        this._setupFakeWorker();\n      }\n\n      _setupFakeWorker() {\n        if (!isWorkerDisabled) {\n          (0, _util.warn)(\"Setting up fake worker.\");\n          isWorkerDisabled = true;\n        }\n\n        setupFakeWorkerGlobal().then(WorkerMessageHandler => {\n          if (this.destroyed) {\n            this._readyCapability.reject(new Error(\"Worker was destroyed\"));\n\n            return;\n          }\n\n          const port = new LoopbackPort();\n          this._port = port;\n          const id = \"fake\" + nextFakeWorkerId++;\n          const workerHandler = new _message_handler.MessageHandler(id + \"_worker\", id, port);\n          WorkerMessageHandler.setup(workerHandler, port);\n          const messageHandler = new _message_handler.MessageHandler(id, id + \"_worker\", port);\n          this._messageHandler = messageHandler;\n\n          this._readyCapability.resolve();\n\n          messageHandler.send(\"configure\", {\n            verbosity: this.verbosity\n          });\n        }).catch(reason => {\n          this._readyCapability.reject(new Error(`Setting up fake worker failed: \"${reason.message}\".`));\n        });\n      }\n\n      destroy() {\n        this.destroyed = true;\n\n        if (this._webWorker) {\n          this._webWorker.terminate();\n\n          this._webWorker = null;\n        }\n\n        pdfWorkerPorts.delete(this._port);\n        this._port = null;\n\n        if (this._messageHandler) {\n          this._messageHandler.destroy();\n\n          this._messageHandler = null;\n        }\n      }\n\n      static fromPort(params) {\n        if (!params || !params.port) {\n          throw new Error(\"PDFWorker.fromPort - invalid method signature.\");\n        }\n\n        if (pdfWorkerPorts.has(params.port)) {\n          return pdfWorkerPorts.get(params.port);\n        }\n\n        return new PDFWorker(params);\n      }\n\n      static getWorkerSrc() {\n        return getWorkerSrc();\n      }\n\n    }\n\n    return PDFWorker;\n  }();\n\n  exports.PDFWorker = PDFWorker;\n\n  class WorkerTransport {\n    constructor(messageHandler, loadingTask, networkStream, params) {\n      this.messageHandler = messageHandler;\n      this.loadingTask = loadingTask;\n      this.commonObjs = new PDFObjects();\n      this.fontLoader = new _font_loader.FontLoader({\n        docId: loadingTask.docId,\n        onUnsupportedFeature: this._onUnsupportedFeature.bind(this),\n        ownerDocument: params.ownerDocument\n      });\n      this._params = params;\n      this.CMapReaderFactory = new params.CMapReaderFactory({\n        baseUrl: params.cMapUrl,\n        isCompressed: params.cMapPacked\n      });\n      this.destroyed = false;\n      this.destroyCapability = null;\n      this._passwordCapability = null;\n      this._networkStream = networkStream;\n      this._fullReader = null;\n      this._lastProgress = null;\n      this.pageCache = [];\n      this.pagePromises = [];\n      this.downloadInfoCapability = (0, _util.createPromiseCapability)();\n      this.setupMessageHandler();\n    }\n\n    get loadingTaskSettled() {\n      return this.loadingTask._capability.settled;\n    }\n\n    destroy() {\n      if (this.destroyCapability) {\n        return this.destroyCapability.promise;\n      }\n\n      this.destroyed = true;\n      this.destroyCapability = (0, _util.createPromiseCapability)();\n\n      if (this._passwordCapability) {\n        this._passwordCapability.reject(new Error(\"Worker was destroyed during onPassword callback\"));\n      }\n\n      const waitOn = [];\n      this.pageCache.forEach(function (page) {\n        if (page) {\n          waitOn.push(page._destroy());\n        }\n      });\n      this.pageCache.length = 0;\n      this.pagePromises.length = 0;\n      const terminated = this.messageHandler.sendWithPromise(\"Terminate\", null);\n      waitOn.push(terminated);\n\n      if (this.loadingTaskSettled) {\n        const annotationStorageResetModified = this.loadingTask.promise.then(pdfDocument => {\n          if (pdfDocument.hasOwnProperty(\"annotationStorage\")) {\n            pdfDocument.annotationStorage.resetModified();\n          }\n        }).catch(() => {});\n        waitOn.push(annotationStorageResetModified);\n      }\n\n      Promise.all(waitOn).then(() => {\n        this.commonObjs.clear();\n        this.fontLoader.clear();\n        this._hasJSActionsPromise = null;\n\n        if (this._networkStream) {\n          this._networkStream.cancelAllRequests(new _util.AbortException(\"Worker was terminated.\"));\n        }\n\n        if (this.messageHandler) {\n          this.messageHandler.destroy();\n          this.messageHandler = null;\n        }\n\n        this.destroyCapability.resolve();\n      }, this.destroyCapability.reject);\n      return this.destroyCapability.promise;\n    }\n\n    setupMessageHandler() {\n      const {\n        messageHandler,\n        loadingTask\n      } = this;\n      messageHandler.on(\"GetReader\", (data, sink) => {\n        (0, _util.assert)(this._networkStream, \"GetReader - no `IPDFStream` instance available.\");\n        this._fullReader = this._networkStream.getFullReader();\n\n        this._fullReader.onProgress = evt => {\n          this._lastProgress = {\n            loaded: evt.loaded,\n            total: evt.total\n          };\n        };\n\n        sink.onPull = () => {\n          this._fullReader.read().then(function ({\n            value,\n            done\n          }) {\n            if (done) {\n              sink.close();\n              return;\n            }\n\n            (0, _util.assert)((0, _util.isArrayBuffer)(value), \"GetReader - expected an ArrayBuffer.\");\n            sink.enqueue(new Uint8Array(value), 1, [value]);\n          }).catch(reason => {\n            sink.error(reason);\n          });\n        };\n\n        sink.onCancel = reason => {\n          this._fullReader.cancel(reason);\n\n          sink.ready.catch(readyReason => {\n            if (this.destroyed) {\n              return;\n            }\n\n            throw readyReason;\n          });\n        };\n      });\n      messageHandler.on(\"ReaderHeadersReady\", data => {\n        const headersCapability = (0, _util.createPromiseCapability)();\n        const fullReader = this._fullReader;\n        fullReader.headersReady.then(() => {\n          if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {\n            if (this._lastProgress && loadingTask.onProgress) {\n              loadingTask.onProgress(this._lastProgress);\n            }\n\n            fullReader.onProgress = evt => {\n              if (loadingTask.onProgress) {\n                loadingTask.onProgress({\n                  loaded: evt.loaded,\n                  total: evt.total\n                });\n              }\n            };\n          }\n\n          headersCapability.resolve({\n            isStreamingSupported: fullReader.isStreamingSupported,\n            isRangeSupported: fullReader.isRangeSupported,\n            contentLength: fullReader.contentLength\n          });\n        }, headersCapability.reject);\n        return headersCapability.promise;\n      });\n      messageHandler.on(\"GetRangeReader\", (data, sink) => {\n        (0, _util.assert)(this._networkStream, \"GetRangeReader - no `IPDFStream` instance available.\");\n\n        const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);\n\n        if (!rangeReader) {\n          sink.close();\n          return;\n        }\n\n        sink.onPull = () => {\n          rangeReader.read().then(function ({\n            value,\n            done\n          }) {\n            if (done) {\n              sink.close();\n              return;\n            }\n\n            (0, _util.assert)((0, _util.isArrayBuffer)(value), \"GetRangeReader - expected an ArrayBuffer.\");\n            sink.enqueue(new Uint8Array(value), 1, [value]);\n          }).catch(reason => {\n            sink.error(reason);\n          });\n        };\n\n        sink.onCancel = reason => {\n          rangeReader.cancel(reason);\n          sink.ready.catch(readyReason => {\n            if (this.destroyed) {\n              return;\n            }\n\n            throw readyReason;\n          });\n        };\n      });\n      messageHandler.on(\"GetDoc\", ({\n        pdfInfo\n      }) => {\n        this._numPages = pdfInfo.numPages;\n\n        loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));\n      });\n      messageHandler.on(\"DocException\", function (ex) {\n        let reason;\n\n        switch (ex.name) {\n          case \"PasswordException\":\n            reason = new _util.PasswordException(ex.message, ex.code);\n            break;\n\n          case \"InvalidPDFException\":\n            reason = new _util.InvalidPDFException(ex.message);\n            break;\n\n          case \"MissingPDFException\":\n            reason = new _util.MissingPDFException(ex.message);\n            break;\n\n          case \"UnexpectedResponseException\":\n            reason = new _util.UnexpectedResponseException(ex.message, ex.status);\n            break;\n\n          case \"UnknownErrorException\":\n            reason = new _util.UnknownErrorException(ex.message, ex.details);\n            break;\n        }\n\n        if (!(reason instanceof Error)) {\n          const msg = \"DocException - expected a valid Error.\";\n          (0, _util.warn)(msg);\n        }\n\n        loadingTask._capability.reject(reason);\n      });\n      messageHandler.on(\"PasswordRequest\", exception => {\n        this._passwordCapability = (0, _util.createPromiseCapability)();\n\n        if (loadingTask.onPassword) {\n          const updatePassword = password => {\n            this._passwordCapability.resolve({\n              password\n            });\n          };\n\n          try {\n            loadingTask.onPassword(updatePassword, exception.code);\n          } catch (ex) {\n            this._passwordCapability.reject(ex);\n          }\n        } else {\n          this._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));\n        }\n\n        return this._passwordCapability.promise;\n      });\n      messageHandler.on(\"DataLoaded\", data => {\n        if (loadingTask.onProgress) {\n          loadingTask.onProgress({\n            loaded: data.length,\n            total: data.length\n          });\n        }\n\n        this.downloadInfoCapability.resolve(data);\n      });\n      messageHandler.on(\"StartRenderPage\", data => {\n        if (this.destroyed) {\n          return;\n        }\n\n        const page = this.pageCache[data.pageIndex];\n\n        page._startRenderPage(data.transparency, data.intent);\n      });\n      messageHandler.on(\"commonobj\", data => {\n        if (this.destroyed) {\n          return;\n        }\n\n        const [id, type, exportedData] = data;\n\n        if (this.commonObjs.has(id)) {\n          return;\n        }\n\n        switch (type) {\n          case \"Font\":\n            const params = this._params;\n\n            if (\"error\" in exportedData) {\n              const exportedError = exportedData.error;\n              (0, _util.warn)(`Error during font loading: ${exportedError}`);\n              this.commonObjs.resolve(id, exportedError);\n              break;\n            }\n\n            let fontRegistry = null;\n\n            if (params.pdfBug && globalThis.FontInspector && globalThis.FontInspector.enabled) { //lwf\n              fontRegistry = {\n                registerFont(font, url) {\n                  globalThis.FontInspector.fontAdded(font, url);\n                }\n\n              };\n            }\n\n            const font = new _font_loader.FontFaceObject(exportedData, {\n              isEvalSupported: params.isEvalSupported,\n              disableFontFace: params.disableFontFace,\n              ignoreErrors: params.ignoreErrors,\n              onUnsupportedFeature: this._onUnsupportedFeature.bind(this),\n              fontRegistry\n            });\n            this.fontLoader.bind(font).catch(reason => {\n              return messageHandler.sendWithPromise(\"FontFallback\", {\n                id\n              });\n            }).finally(() => {\n              if (!params.fontExtraProperties && font.data) {\n                font.data = null;\n              }\n\n              this.commonObjs.resolve(id, font);\n            });\n            break;\n\n          case \"FontPath\":\n          case \"Image\":\n            this.commonObjs.resolve(id, exportedData);\n            break;\n\n          default:\n            throw new Error(`Got unknown common object type ${type}`);\n        }\n      });\n      messageHandler.on(\"obj\", data => {\n        if (this.destroyed) {\n          return undefined;\n        }\n\n        const [id, pageIndex, type, imageData] = data;\n        const pageProxy = this.pageCache[pageIndex];\n\n        if (pageProxy.objs.has(id)) {\n          return undefined;\n        }\n\n        switch (type) {\n          case \"Image\":\n            pageProxy.objs.resolve(id, imageData);\n            const MAX_IMAGE_SIZE_TO_STORE = 8000000;\n\n            if (imageData && imageData.data && imageData.data.length > MAX_IMAGE_SIZE_TO_STORE) { //lwf\n              pageProxy.cleanupAfterRender = true;\n            }\n\n            break;\n\n          default:\n            throw new Error(`Got unknown object type ${type}`);\n        }\n\n        return undefined;\n      });\n      messageHandler.on(\"DocProgress\", data => {\n        if (this.destroyed) {\n          return;\n        }\n\n        if (loadingTask.onProgress) {\n          loadingTask.onProgress({\n            loaded: data.loaded,\n            total: data.total\n          });\n        }\n      });\n      messageHandler.on(\"UnsupportedFeature\", this._onUnsupportedFeature.bind(this));\n      messageHandler.on(\"FetchBuiltInCMap\", (data, sink) => {\n        if (this.destroyed) {\n          sink.error(new Error(\"Worker was destroyed\"));\n          return;\n        }\n\n        let fetched = false;\n\n        sink.onPull = () => {\n          if (fetched) {\n            sink.close();\n            return;\n          }\n\n          fetched = true;\n          this.CMapReaderFactory.fetch(data).then(function (builtInCMap) {\n            sink.enqueue(builtInCMap, 1, [builtInCMap.cMapData.buffer]);\n          }).catch(function (reason) {\n            sink.error(reason);\n          });\n        };\n      });\n    }\n\n    _onUnsupportedFeature({\n      featureId\n    }) {\n      if (this.destroyed) {\n        return;\n      }\n\n      if (this.loadingTask.onUnsupportedFeature) {\n        this.loadingTask.onUnsupportedFeature(featureId);\n      }\n    }\n\n    getData() {\n      return this.messageHandler.sendWithPromise(\"GetData\", null);\n    }\n\n    getPage(pageNumber) {\n      if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {\n        return Promise.reject(new Error(\"Invalid page request\"));\n      }\n\n      const pageIndex = pageNumber - 1;\n\n      if (pageIndex in this.pagePromises) {\n        return this.pagePromises[pageIndex];\n      }\n\n      const promise = this.messageHandler.sendWithPromise(\"GetPage\", {\n        pageIndex\n      }).then(pageInfo => {\n        if (this.destroyed) {\n          throw new Error(\"Transport destroyed\");\n        }\n\n        const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.ownerDocument, this._params.pdfBug);\n        this.pageCache[pageIndex] = page;\n        return page;\n      });\n      this.pagePromises[pageIndex] = promise;\n      return promise;\n    }\n\n    getPageIndex(ref) {\n      return this.messageHandler.sendWithPromise(\"GetPageIndex\", {\n        ref\n      }).catch(function (reason) {\n        return Promise.reject(new Error(reason));\n      });\n    }\n\n    getAnnotations(pageIndex, intent) {\n      return this.messageHandler.sendWithPromise(\"GetAnnotations\", {\n        pageIndex,\n        intent\n      });\n    }\n\n    saveDocument(annotationStorage) {\n      return this.messageHandler.sendWithPromise(\"SaveDocument\", {\n        numPages: this._numPages,\n        annotationStorage: annotationStorage && annotationStorage.getAll() || null,  // lwf\n        filename: this._fullReader && this._fullReader.filename || null // lwf\n      }).finally(() => {\n        if (annotationStorage) {\n          annotationStorage.resetModified();\n        }\n      });\n    }\n\n    getFieldObjects() {\n      return this.messageHandler.sendWithPromise(\"GetFieldObjects\", null);\n    }\n\n    hasJSActions() {\n      return this._hasJSActionsPromise || (this._hasJSActionsPromise = this.messageHandler.sendWithPromise(\"HasJSActions\", null));\n    }\n\n    getCalculationOrderIds() {\n      return this.messageHandler.sendWithPromise(\"GetCalculationOrderIds\", null);\n    }\n\n    getDestinations() {\n      return this.messageHandler.sendWithPromise(\"GetDestinations\", null);\n    }\n\n    getDestination(id) {\n      if (typeof id !== \"string\") {\n        return Promise.reject(new Error(\"Invalid destination request.\"));\n      }\n\n      return this.messageHandler.sendWithPromise(\"GetDestination\", {\n        id\n      });\n    }\n\n    getPageLabels() {\n      return this.messageHandler.sendWithPromise(\"GetPageLabels\", null);\n    }\n\n    getPageLayout() {\n      return this.messageHandler.sendWithPromise(\"GetPageLayout\", null);\n    }\n\n    getPageMode() {\n      return this.messageHandler.sendWithPromise(\"GetPageMode\", null);\n    }\n\n    getViewerPreferences() {\n      return this.messageHandler.sendWithPromise(\"GetViewerPreferences\", null);\n    }\n\n    getOpenAction() {\n      return this.messageHandler.sendWithPromise(\"GetOpenAction\", null);\n    }\n\n    getAttachments() {\n      return this.messageHandler.sendWithPromise(\"GetAttachments\", null);\n    }\n\n    getJavaScript() {\n      return this.messageHandler.sendWithPromise(\"GetJavaScript\", null);\n    }\n\n    getDocJSActions() {\n      return this.messageHandler.sendWithPromise(\"GetDocJSActions\", null);\n    }\n\n    getPageJSActions(pageIndex) {\n      return this.messageHandler.sendWithPromise(\"GetPageJSActions\", {\n        pageIndex\n      });\n    }\n\n    getOutline() {\n      return this.messageHandler.sendWithPromise(\"GetOutline\", null);\n    }\n\n    getOptionalContentConfig() {\n      return this.messageHandler.sendWithPromise(\"GetOptionalContentConfig\", null).then(results => {\n        return new _optional_content_config.OptionalContentConfig(results);\n      });\n    }\n\n    getPermissions() {\n      return this.messageHandler.sendWithPromise(\"GetPermissions\", null);\n    }\n\n    getMetadata() {\n      return this.messageHandler.sendWithPromise(\"GetMetadata\", null).then(results => {\n        return {\n          info: results[0],\n          metadata: results[1] ? new _metadata.Metadata(results[1]) : null,\n          contentDispositionFilename: this._fullReader && this._fullReader.filename || null, // lwf\n          contentLength: this._fullReader && this._fullReader.contentLength || null  // lwf\n        };\n      });\n    }\n\n    getMarkInfo() {\n      return this.messageHandler.sendWithPromise(\"GetMarkInfo\", null);\n    }\n\n    getStats() {\n      return this.messageHandler.sendWithPromise(\"GetStats\", null);\n    }\n\n    startCleanup() {\n      return this.messageHandler.sendWithPromise(\"Cleanup\", null).then(() => {\n        for (let i = 0, ii = this.pageCache.length; i < ii; i++) {\n          const page = this.pageCache[i];\n\n          if (page) {\n            const cleanupSuccessful = page.cleanup();\n\n            if (!cleanupSuccessful) {\n              throw new Error(`startCleanup: Page ${i + 1} is currently rendering.`);\n            }\n          }\n        }\n\n        this.commonObjs.clear();\n        this.fontLoader.clear();\n        this._hasJSActionsPromise = null;\n      });\n    }\n\n    get loadingParams() {\n      const params = this._params;\n      return (0, _util.shadow)(this, \"loadingParams\", {\n        disableAutoFetch: params.disableAutoFetch,\n        disableFontFace: params.disableFontFace\n      });\n    }\n\n  }\n\n  class PDFObjects {\n    constructor() {\n      this._objs = Object.create(null);\n    }\n\n    _ensureObj(objId) {\n      if (this._objs[objId]) {\n        return this._objs[objId];\n      }\n\n      return this._objs[objId] = {\n        capability: (0, _util.createPromiseCapability)(),\n        data: null,\n        resolved: false\n      };\n    }\n\n    get(objId, callback = null) {\n      if (callback) {\n        this._ensureObj(objId).capability.promise.then(callback);\n\n        return null;\n      }\n\n      const obj = this._objs[objId];\n\n      if (!obj || !obj.resolved) {\n        throw new Error(`Requesting object that isn't resolved yet ${objId}.`);\n      }\n\n      return obj.data;\n    }\n\n    has(objId) {\n      const obj = this._objs[objId];\n      return obj && obj.resolved || false; // lwf\n    }\n\n    resolve(objId, data) {\n      const obj = this._ensureObj(objId);\n\n      obj.resolved = true;\n      obj.data = data;\n      obj.capability.resolve(data);\n    }\n\n    clear() {\n      this._objs = Object.create(null);\n    }\n\n  }\n\n  class RenderTask {\n    constructor(internalRenderTask) {\n      this._internalRenderTask = internalRenderTask;\n      this.onContinue = null;\n    }\n\n    get promise() {\n      return this._internalRenderTask.capability.promise;\n    }\n\n    cancel() {\n      this._internalRenderTask.cancel();\n    }\n\n  }\n\n  const InternalRenderTask = function InternalRenderTaskClosure() {\n    const canvasInRendering = new WeakSet();\n\n    class InternalRenderTask {\n      constructor({\n        callback,\n        params,\n        objs,\n        commonObjs,\n        operatorList,\n        pageIndex,\n        canvasFactory,\n        webGLContext,\n        useRequestAnimationFrame = false,\n        pdfBug = false\n      }) {\n        this.callback = callback;\n        this.params = params;\n        this.objs = objs;\n        this.commonObjs = commonObjs;\n        this.operatorListIdx = null;\n        this.operatorList = operatorList;\n        this._pageIndex = pageIndex;\n        this.canvasFactory = canvasFactory;\n        this.webGLContext = webGLContext;\n        this._pdfBug = pdfBug;\n        this.running = false;\n        this.graphicsReadyCallback = null;\n        this.graphicsReady = false;\n        this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== \"undefined\";\n        this.cancelled = false;\n        this.capability = (0, _util.createPromiseCapability)();\n        this.task = new RenderTask(this);\n        this._continueBound = this._continue.bind(this);\n        this._scheduleNextBound = this._scheduleNext.bind(this);\n        this._nextBound = this._next.bind(this);\n        this._canvas = params.canvasContext.canvas;\n      }\n\n      get completed() {\n        return this.capability.promise.catch(function () {});\n      }\n\n      initializeGraphics({\n        transparency = false,\n        optionalContentConfig\n      }) {\n        if (this.cancelled) {\n          return;\n        }\n\n        if (this._canvas) {\n          if (canvasInRendering.has(this._canvas)) {\n            throw new Error(\"Cannot use the same canvas during multiple render() operations. \" + \"Use different canvas or ensure previous operations were \" + \"cancelled or completed.\");\n          }\n\n          canvasInRendering.add(this._canvas);\n        }\n\n        if (this._pdfBug && globalThis.StepperManager && globalThis.StepperManager.enabled) { // lwf\n          this.stepper = globalThis.StepperManager.create(this._pageIndex);\n          this.stepper.init(this.operatorList);\n          this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();\n        }\n\n        const {\n          canvasContext,\n          viewport,\n          transform,\n          imageLayer,\n          background\n        } = this.params;\n        this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.webGLContext, imageLayer, optionalContentConfig);\n        this.gfx.beginDrawing({\n          transform,\n          viewport,\n          transparency,\n          background\n        });\n        this.operatorListIdx = 0;\n        this.graphicsReady = true;\n\n        if (this.graphicsReadyCallback) {\n          this.graphicsReadyCallback();\n        }\n      }\n\n      cancel(error = null) {\n        this.running = false;\n        this.cancelled = true;\n\n        if (this.gfx) {\n          this.gfx.endDrawing();\n        }\n\n        if (this._canvas) {\n          canvasInRendering.delete(this._canvas);\n        }\n\n        this.callback(error || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, \"canvas\"));\n      }\n\n      operatorListChanged() {\n        if (!this.graphicsReady) {\n          if (!this.graphicsReadyCallback) {\n            this.graphicsReadyCallback = this._continueBound;\n          }\n\n          return;\n        }\n\n        if (this.stepper) {\n          this.stepper.updateOperatorList(this.operatorList);\n        }\n\n        if (this.running) {\n          return;\n        }\n\n        this._continue();\n      }\n\n      _continue() {\n        this.running = true;\n\n        if (this.cancelled) {\n          return;\n        }\n\n        if (this.task.onContinue) {\n          this.task.onContinue(this._scheduleNextBound);\n        } else {\n          this._scheduleNext();\n        }\n      }\n\n      _scheduleNext() {\n        if (this._useRequestAnimationFrame) {\n          window.requestAnimationFrame(() => {\n            this._nextBound().catch(this.cancel.bind(this));\n          });\n        } else {\n          Promise.resolve().then(this._nextBound).catch(this.cancel.bind(this));\n        }\n      }\n\n      async _next() {\n        if (this.cancelled) {\n          return;\n        }\n\n        this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);\n\n        if (this.operatorListIdx === this.operatorList.argsArray.length) {\n          this.running = false;\n\n          if (this.operatorList.lastChunk) {\n            this.gfx.endDrawing();\n\n            if (this._canvas) {\n              canvasInRendering.delete(this._canvas);\n            }\n\n            this.callback();\n          }\n        }\n      }\n\n    }\n\n    return InternalRenderTask;\n  }();\n\n  const version = '2.7.570';\n  exports.version = version;\n  const build = 'f2c7338b0';\n  exports.build = build;\n\n  /***/ }),\n  /* 6 */\n  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\n  Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n  }));\n  exports.FontLoader = exports.FontFaceObject = void 0;\n\n  var _util = __w_pdfjs_require__(2);\n\n  class BaseFontLoader {\n    constructor({\n      docId,\n      onUnsupportedFeature,\n      ownerDocument = globalThis.document\n    }) {\n      if (this.constructor === BaseFontLoader) {\n        (0, _util.unreachable)(\"Cannot initialize BaseFontLoader.\");\n      }\n\n      this.docId = docId;\n      this._onUnsupportedFeature = onUnsupportedFeature;\n      this._document = ownerDocument;\n      this.nativeFontFaces = [];\n      this.styleElement = null;\n    }\n\n    addNativeFontFace(nativeFontFace) {\n      this.nativeFontFaces.push(nativeFontFace);\n\n      this._document.fonts.add(nativeFontFace);\n    }\n\n    insertRule(rule) {\n      let styleElement = this.styleElement;\n\n      if (!styleElement) {\n        styleElement = this.styleElement = this._document.createElement(\"style\");\n        styleElement.id = `PDFJS_FONT_STYLE_TAG_${this.docId}`;\n\n        this._document.documentElement.getElementsByTagName(\"head\")[0].appendChild(styleElement);\n      }\n\n      const styleSheet = styleElement.sheet;\n      styleSheet.insertRule(rule, styleSheet.cssRules.length);\n    }\n\n    clear() {\n      this.nativeFontFaces.forEach(nativeFontFace => {\n        this._document.fonts.delete(nativeFontFace);\n      });\n      this.nativeFontFaces.length = 0;\n\n      if (this.styleElement) {\n        this.styleElement.remove();\n        this.styleElement = null;\n      }\n    }\n\n    async bind(font) {\n      if (font.attached || font.missingFile) {\n        return;\n      }\n\n      font.attached = true;\n\n      if (this.isFontLoadingAPISupported) {\n        const nativeFontFace = font.createNativeFontFace();\n\n        if (nativeFontFace) {\n          this.addNativeFontFace(nativeFontFace);\n\n          try {\n            await nativeFontFace.loaded;\n          } catch (ex) {\n            this._onUnsupportedFeature({\n              featureId: _util.UNSUPPORTED_FEATURES.errorFontLoadNative\n            });\n\n            (0, _util.warn)(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);\n            font.disableFontFace = true;\n            throw ex;\n          }\n        }\n\n        return;\n      }\n\n      const rule = font.createFontFaceRule();\n\n      if (rule) {\n        this.insertRule(rule);\n\n        if (this.isSyncFontLoadingSupported) {\n          return;\n        }\n\n        await new Promise(resolve => {\n          const request = this._queueLoadingCallback(resolve);\n\n          this._prepareFontLoadEvent([rule], [font], request);\n        });\n      }\n    }\n\n    _queueLoadingCallback(callback) {\n      (0, _util.unreachable)(\"Abstract method `_queueLoadingCallback`.\");\n    }\n\n    get isFontLoadingAPISupported() {\n      return (0, _util.shadow)(this, \"isFontLoadingAPISupported\", !!(this._document && this._document.fonts)); // lwf\n    }\n\n    get isSyncFontLoadingSupported() {\n      (0, _util.unreachable)(\"Abstract method `isSyncFontLoadingSupported`.\");\n    }\n\n    get _loadTestFont() {\n      (0, _util.unreachable)(\"Abstract method `_loadTestFont`.\");\n    }\n\n    _prepareFontLoadEvent(rules, fontsToLoad, request) {\n      (0, _util.unreachable)(\"Abstract method `_prepareFontLoadEvent`.\");\n    }\n\n  }\n\n  let FontLoader;\n  exports.FontLoader = FontLoader;\n  {\n    exports.FontLoader = FontLoader = class GenericFontLoader extends BaseFontLoader {\n      constructor(params) {\n        super(params);\n        this.loadingContext = {\n          requests: [],\n          nextRequestId: 0\n        };\n        this.loadTestFontId = 0;\n      }\n\n      get isSyncFontLoadingSupported() {\n        let supported = false;\n\n        if (typeof navigator === \"undefined\") {\n          supported = true;\n        } else {\n          const m = /Mozilla\\/5.0.*?rv:(\\d+).*? Gecko/.exec(navigator.userAgent);\n\n          if (m && m[1] >= 14) { // lwf\n            supported = true;\n          }\n        }\n\n        return (0, _util.shadow)(this, \"isSyncFontLoadingSupported\", supported);\n      }\n\n      _queueLoadingCallback(callback) {\n        function completeRequest() {\n          (0, _util.assert)(!request.done, \"completeRequest() cannot be called twice.\");\n          request.done = true;\n\n          while (context.requests.length > 0 && context.requests[0].done) {\n            const otherRequest = context.requests.shift();\n            setTimeout(otherRequest.callback, 0);\n          }\n        }\n\n        const context = this.loadingContext;\n        const request = {\n          id: `pdfjs-font-loading-${context.nextRequestId++}`,\n          done: false,\n          complete: completeRequest,\n          callback\n        };\n        context.requests.push(request);\n        return request;\n      }\n\n      get _loadTestFont() {\n        const getLoadTestFont = function () {\n          return atob(\"T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA\" + \"FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA\" + \"ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA\" + \"AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1\" + \"AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD\" + \"6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM\" + \"AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D\" + \"IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA\" + \"AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA\" + \"AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB\" + \"AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY\" + \"AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA\" + \"AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA\" + \"AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC\" + \"AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3\" + \"Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj\" + \"FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==\");\n        };\n\n        return (0, _util.shadow)(this, \"_loadTestFont\", getLoadTestFont());\n      }\n\n      _prepareFontLoadEvent(rules, fonts, request) {\n        function int32(data, offset) {\n          return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;\n        }\n\n        function spliceString(s, offset, remove, insert) {\n          const chunk1 = s.substring(0, offset);\n          const chunk2 = s.substring(offset + remove);\n          return chunk1 + insert + chunk2;\n        }\n\n        let i, ii;\n\n        const canvas = this._document.createElement(\"canvas\");\n\n        canvas.width = 1;\n        canvas.height = 1;\n        const ctx = canvas.getContext(\"2d\");\n        let called = 0;\n\n        function isFontReady(name, callback) {\n          called++;\n\n          if (called > 30) {\n            (0, _util.warn)(\"Load test font never loaded.\");\n            callback();\n            return;\n          }\n\n          ctx.font = \"30px \" + name;\n          ctx.fillText(\".\", 0, 20);\n          const imageData = ctx.getImageData(0, 0, 1, 1);\n\n          if (imageData.data[3] > 0) {\n            callback();\n            return;\n          }\n\n          setTimeout(isFontReady.bind(null, name, callback));\n        }\n\n        const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;\n        let data = this._loadTestFont;\n        const COMMENT_OFFSET = 976;\n        data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);\n        const CFF_CHECKSUM_OFFSET = 16;\n        const XXXX_VALUE = 0x58585858;\n        let checksum = int32(data, CFF_CHECKSUM_OFFSET);\n\n        for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {\n          checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;\n        }\n\n        if (i < loadTestFontId.length) {\n          checksum = checksum - XXXX_VALUE + int32(loadTestFontId + \"XXX\", i) | 0;\n        }\n\n        data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util.string32)(checksum));\n        const url = `url(data:font/opentype;base64,${btoa(data)});`;\n        const rule = `@font-face {font-family:\"${loadTestFontId}\";src:${url}}`;\n        this.insertRule(rule);\n        const names = [];\n\n        for (i = 0, ii = fonts.length; i < ii; i++) {\n          names.push(fonts[i].loadedName);\n        }\n\n        names.push(loadTestFontId);\n\n        const div = this._document.createElement(\"div\");\n\n        div.style.visibility = \"hidden\";\n        div.style.width = div.style.height = \"10px\";\n        div.style.position = \"absolute\";\n        div.style.top = div.style.left = \"0px\";\n\n        for (i = 0, ii = names.length; i < ii; ++i) {\n          const span = this._document.createElement(\"span\");\n\n          span.textContent = \"Hi\";\n          span.style.fontFamily = names[i];\n          div.appendChild(span);\n        }\n\n        this._document.body.appendChild(div);\n\n        isFontReady(loadTestFontId, () => {\n          this._document.body.removeChild(div);\n\n          request.complete();\n        });\n      }\n\n    };\n  }\n\n  class FontFaceObject {\n    constructor(translatedData, {\n      isEvalSupported = true,\n      disableFontFace = false,\n      ignoreErrors = false,\n      onUnsupportedFeature = null,\n      fontRegistry = null\n    }) {\n      this.compiledGlyphs = Object.create(null);\n\n      for (const i in translatedData) {\n        this[i] = translatedData[i];\n      }\n\n      this.isEvalSupported = isEvalSupported !== false;\n      this.disableFontFace = disableFontFace === true;\n      this.ignoreErrors = ignoreErrors === true;\n      this._onUnsupportedFeature = onUnsupportedFeature;\n      this.fontRegistry = fontRegistry;\n    }\n\n    createNativeFontFace() {\n      if (!this.data || this.disableFontFace) {\n        return null;\n      }\n\n      const nativeFontFace = new FontFace(this.loadedName, this.data, {});\n\n      if (this.fontRegistry) {\n        this.fontRegistry.registerFont(this);\n      }\n\n      return nativeFontFace;\n    }\n\n    createFontFaceRule() {\n      if (!this.data || this.disableFontFace) {\n        return null;\n      }\n\n      const data = (0, _util.bytesToString)(new Uint8Array(this.data));\n      const url = `url(data:${this.mimetype};base64,${btoa(data)});`;\n      const rule = `@font-face {font-family:\"${this.loadedName}\";src:${url}}`;\n\n      if (this.fontRegistry) {\n        this.fontRegistry.registerFont(this, url);\n      }\n\n      return rule;\n    }\n\n    getPathGenerator(objs, character) {\n      if (this.compiledGlyphs[character] !== undefined) {\n        return this.compiledGlyphs[character];\n      }\n\n      let cmds, current;\n\n      try {\n        cmds = objs.get(this.loadedName + \"_path_\" + character);\n      } catch (ex) {\n        if (!this.ignoreErrors) {\n          throw ex;\n        }\n\n        if (this._onUnsupportedFeature) {\n          this._onUnsupportedFeature({\n            featureId: _util.UNSUPPORTED_FEATURES.errorFontGetPath\n          });\n        }\n\n        (0, _util.warn)(`getPathGenerator - ignoring character: \"${ex}\".`);\n        return this.compiledGlyphs[character] = function (c, size) {};\n      }\n\n      if (this.isEvalSupported && _util.IsEvalSupportedCached.value) {\n        let args,\n            js = \"\";\n\n        for (let i = 0, ii = cmds.length; i < ii; i++) {\n          current = cmds[i];\n\n          if (current.args !== undefined) {\n            args = current.args.join(\",\");\n          } else {\n            args = \"\";\n          }\n\n          js += \"c.\" + current.cmd + \"(\" + args + \");\\n\";\n        }\n\n        return this.compiledGlyphs[character] = new Function(\"c\", \"size\", js);\n      }\n\n      return this.compiledGlyphs[character] = function (c, size) {\n        for (let i = 0, ii = cmds.length; i < ii; i++) {\n          current = cmds[i];\n\n          if (current.cmd === \"scale\") {\n            current.args = [size, -size];\n          }\n\n          c[current.cmd].apply(c, current.args);\n        }\n      };\n    }\n\n  }\n\n  exports.FontFaceObject = FontFaceObject;\n\n  /***/ }),\n  /* 7 */\n  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\n  Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n  }));\n  exports.NodeCMapReaderFactory = exports.NodeCanvasFactory = void 0;\n\n  var _display_utils = __w_pdfjs_require__(1);\n\n  var _is_node = __w_pdfjs_require__(4);\n\n  var _util = __w_pdfjs_require__(2);\n\n  let NodeCanvasFactory = class {\n    constructor() {\n      (0, _util.unreachable)(\"Not implemented: NodeCanvasFactory\");\n    }\n\n  };\n  exports.NodeCanvasFactory = NodeCanvasFactory;\n  let NodeCMapReaderFactory = class {\n    constructor() {\n      (0, _util.unreachable)(\"Not implemented: NodeCMapReaderFactory\");\n    }\n\n  };\n  exports.NodeCMapReaderFactory = NodeCMapReaderFactory;\n\n  if (_is_node.isNodeJS) {\n    exports.NodeCanvasFactory = NodeCanvasFactory = class extends _display_utils.BaseCanvasFactory {\n      create(width, height) {\n        if (width <= 0 || height <= 0) {\n          throw new Error(\"Invalid canvas size\");\n        }\n\n        const Canvas = require(\"canvas\");\n\n        const canvas = Canvas.createCanvas(width, height);\n        return {\n          canvas,\n          context: canvas.getContext(\"2d\")\n        };\n      }\n\n    };\n    exports.NodeCMapReaderFactory = NodeCMapReaderFactory = class extends _display_utils.BaseCMapReaderFactory {\n      _fetchData(url, compressionType) {\n        return new Promise((resolve, reject) => {\n          const fs = require(\"fs\");\n\n          fs.readFile(url, (error, data) => {\n            if (error || !data) {\n              reject(new Error(error));\n              return;\n            }\n\n            resolve({\n              cMapData: new Uint8Array(data),\n              compressionType\n            });\n          });\n        });\n      }\n\n    };\n  }\n\n  /***/ }),\n  /* 8 */\n  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\n  Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n  }));\n  exports.AnnotationStorage = void 0;\n\n  var _util = __w_pdfjs_require__(2);\n\n  class AnnotationStorage {\n    constructor() {\n      this._storage = new Map();\n      this._modified = false;\n      this.onSetModified = null;\n      this.onResetModified = null;\n    }\n\n    getOrCreateValue(key, defaultValue) {\n      if (this._storage.has(key)) {\n        return this._storage.get(key);\n      }\n\n      this._storage.set(key, defaultValue);\n\n      return defaultValue;\n    }\n\n    setValue(key, value) {\n      const obj = this._storage.get(key);\n\n      let modified = false;\n\n      if (obj !== undefined) {\n        for (const [entry, val] of Object.entries(value)) {\n          if (obj[entry] !== val) {\n            modified = true;\n            obj[entry] = val;\n          }\n        }\n      } else {\n        this._storage.set(key, value);\n\n        modified = true;\n      }\n\n      if (modified) {\n        this._setModified();\n      }\n    }\n\n    getAll() {\n      if (this._storage.size === 0) {\n        return null;\n      }\n\n      return (0, _util.objectFromEntries)(this._storage);\n    }\n\n    get size() {\n      return this._storage.size;\n    }\n\n    _setModified() {\n      if (!this._modified) {\n        this._modified = true;\n\n        if (typeof this.onSetModified === \"function\") {\n          this.onSetModified();\n        }\n      }\n    }\n\n    resetModified() {\n      if (this._modified) {\n        this._modified = false;\n\n        if (typeof this.onResetModified === \"function\") {\n          this.onResetModified();\n        }\n      }\n    }\n\n  }\n\n  exports.AnnotationStorage = AnnotationStorage;\n\n  /***/ }),\n  /* 9 */\n  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\n  Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n  }));\n  exports.apiCompatibilityParams = void 0;\n\n  var _is_node = __w_pdfjs_require__(4);\n\n  const compatibilityParams = Object.create(null);\n  {\n    (function checkFontFace() {\n      if (_is_node.isNodeJS) {\n        compatibilityParams.disableFontFace = true;\n      }\n    })();\n  }\n  const apiCompatibilityParams = Object.freeze(compatibilityParams);\n  exports.apiCompatibilityParams = apiCompatibilityParams;\n\n  /***/ }),\n  /* 10 */\n  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\n  Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n  }));\n  exports.CanvasGraphics = void 0;\n\n  var _util = __w_pdfjs_require__(2);\n\n  var _pattern_helper = __w_pdfjs_require__(11);\n\n  const MIN_FONT_SIZE = 16;\n  const MAX_FONT_SIZE = 100;\n  const MAX_GROUP_SIZE = 4096;\n  const COMPILE_TYPE3_GLYPHS = true;\n  const MAX_SIZE_TO_COMPILE = 1000;\n  const FULL_CHUNK_HEIGHT = 16;\n\n  function addContextCurrentTransform(ctx) {\n    if (!ctx.mozCurrentTransform) {\n      ctx._originalSave = ctx.save;\n      ctx._originalRestore = ctx.restore;\n      ctx._originalRotate = ctx.rotate;\n      ctx._originalScale = ctx.scale;\n      ctx._originalTranslate = ctx.translate;\n      ctx._originalTransform = ctx.transform;\n      ctx._originalSetTransform = ctx.setTransform;\n      ctx._transformMatrix = ctx._transformMatrix || [1, 0, 0, 1, 0, 0];\n      ctx._transformStack = [];\n      Object.defineProperty(ctx, \"mozCurrentTransform\", {\n        get: function getCurrentTransform() {\n          return this._transformMatrix;\n        }\n      });\n      Object.defineProperty(ctx, \"mozCurrentTransformInverse\", {\n        get: function getCurrentTransformInverse() {\n          const m = this._transformMatrix;\n          const a = m[0],\n                b = m[1],\n                c = m[2],\n                d = m[3],\n                e = m[4],\n                f = m[5];\n          const ad_bc = a * d - b * c;\n          const bc_ad = b * c - a * d;\n          return [d / ad_bc, b / bc_ad, c / bc_ad, a / ad_bc, (d * e - c * f) / bc_ad, (b * e - a * f) / ad_bc];\n        }\n      });\n\n      ctx.save = function ctxSave() {\n        const old = this._transformMatrix;\n\n        this._transformStack.push(old);\n\n        this._transformMatrix = old.slice(0, 6);\n\n        this._originalSave();\n      };\n\n      ctx.restore = function ctxRestore() {\n        const prev = this._transformStack.pop();\n\n        if (prev) {\n          this._transformMatrix = prev;\n\n          this._originalRestore();\n        }\n      };\n\n      ctx.translate = function ctxTranslate(x, y) {\n        const m = this._transformMatrix;\n        m[4] = m[0] * x + m[2] * y + m[4];\n        m[5] = m[1] * x + m[3] * y + m[5];\n\n        this._originalTranslate(x, y);\n      };\n\n      ctx.scale = function ctxScale(x, y) {\n        const m = this._transformMatrix;\n        m[0] = m[0] * x;\n        m[1] = m[1] * x;\n        m[2] = m[2] * y;\n        m[3] = m[3] * y;\n\n        this._originalScale(x, y);\n      };\n\n      ctx.transform = function ctxTransform(a, b, c, d, e, f) {\n        const m = this._transformMatrix;\n        this._transformMatrix = [m[0] * a + m[2] * b, m[1] * a + m[3] * b, m[0] * c + m[2] * d, m[1] * c + m[3] * d, m[0] * e + m[2] * f + m[4], m[1] * e + m[3] * f + m[5]];\n\n        ctx._originalTransform(a, b, c, d, e, f);\n      };\n\n      ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {\n        this._transformMatrix = [a, b, c, d, e, f];\n\n        ctx._originalSetTransform(a, b, c, d, e, f);\n      };\n\n      ctx.rotate = function ctxRotate(angle) {\n        const cosValue = Math.cos(angle);\n        const sinValue = Math.sin(angle);\n        const m = this._transformMatrix;\n        this._transformMatrix = [m[0] * cosValue + m[2] * sinValue, m[1] * cosValue + m[3] * sinValue, m[0] * -sinValue + m[2] * cosValue, m[1] * -sinValue + m[3] * cosValue, m[4], m[5]];\n\n        this._originalRotate(angle);\n      };\n    }\n  }\n\n  const CachedCanvases = function CachedCanvasesClosure() {\n    function CachedCanvases(canvasFactory) {\n      this.canvasFactory = canvasFactory;\n      this.cache = Object.create(null);\n    }\n\n    CachedCanvases.prototype = {\n      getCanvas: function CachedCanvases_getCanvas(id, width, height, trackTransform) {\n        let canvasEntry;\n\n        if (this.cache[id] !== undefined) {\n          canvasEntry = this.cache[id];\n          this.canvasFactory.reset(canvasEntry, width, height);\n          canvasEntry.context.setTransform(1, 0, 0, 1, 0, 0);\n        } else {\n          canvasEntry = this.canvasFactory.create(width, height);\n          this.cache[id] = canvasEntry;\n        }\n\n        if (trackTransform) {\n          addContextCurrentTransform(canvasEntry.context);\n        }\n\n        return canvasEntry;\n      },\n\n      clear() {\n        for (const id in this.cache) {\n          const canvasEntry = this.cache[id];\n          this.canvasFactory.destroy(canvasEntry);\n          delete this.cache[id];\n        }\n      }\n\n    };\n    return CachedCanvases;\n  }();\n\n  function compileType3Glyph(imgData) {\n    const POINT_TO_PROCESS_LIMIT = 1000;\n    const width = imgData.width,\n          height = imgData.height,\n          width1 = width + 1;\n    let i, ii, j, j0;\n    const points = new Uint8Array(width1 * (height + 1));\n    const POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);\n    const lineSize = width + 7 & ~7,\n          data0 = imgData.data;\n    const data = new Uint8Array(lineSize * height);\n    let pos = 0;\n\n    for (i = 0, ii = data0.length; i < ii; i++) {\n      const elem = data0[i];\n      let mask = 128;\n\n      while (mask > 0) {\n        data[pos++] = elem & mask ? 0 : 255;\n        mask >>= 1;\n      }\n    }\n\n    let count = 0;\n    pos = 0;\n\n    if (data[pos] !== 0) {\n      points[0] = 1;\n      ++count;\n    }\n\n    for (j = 1; j < width; j++) {\n      if (data[pos] !== data[pos + 1]) {\n        points[j] = data[pos] ? 2 : 1;\n        ++count;\n      }\n\n      pos++;\n    }\n\n    if (data[pos] !== 0) {\n      points[j] = 2;\n      ++count;\n    }\n\n    for (i = 1; i < height; i++) {\n      pos = i * lineSize;\n      j0 = i * width1;\n\n      if (data[pos - lineSize] !== data[pos]) {\n        points[j0] = data[pos] ? 1 : 8;\n        ++count;\n      }\n\n      let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);\n\n      for (j = 1; j < width; j++) {\n        sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);\n\n        if (POINT_TYPES[sum]) {\n          points[j0 + j] = POINT_TYPES[sum];\n          ++count;\n        }\n\n        pos++;\n      }\n\n      if (data[pos - lineSize] !== data[pos]) {\n        points[j0 + j] = data[pos] ? 2 : 4;\n        ++count;\n      }\n\n      if (count > POINT_TO_PROCESS_LIMIT) {\n        return null;\n      }\n    }\n\n    pos = lineSize * (height - 1);\n    j0 = i * width1;\n\n    if (data[pos] !== 0) {\n      points[j0] = 8;\n      ++count;\n    }\n\n    for (j = 1; j < width; j++) {\n      if (data[pos] !== data[pos + 1]) {\n        points[j0 + j] = data[pos] ? 4 : 8;\n        ++count;\n      }\n\n      pos++;\n    }\n\n    if (data[pos] !== 0) {\n      points[j0 + j] = 4;\n      ++count;\n    }\n\n    if (count > POINT_TO_PROCESS_LIMIT) {\n      return null;\n    }\n\n    const steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);\n    const outlines = [];\n\n    for (i = 0; count && i <= height; i++) {\n      let p = i * width1;\n      const end = p + width;\n\n      while (p < end && !points[p]) {\n        p++;\n      }\n\n      if (p === end) {\n        continue;\n      }\n\n      const coords = [p % width1, i];\n      const p0 = p;\n      let type = points[p];\n\n      do {\n        const step = steps[type];\n\n        do {\n          p += step;\n        } while (!points[p]);\n\n        const pp = points[p];\n\n        if (pp !== 5 && pp !== 10) {\n          type = pp;\n          points[p] = 0;\n        } else {\n          type = pp & 0x33 * type >> 4;\n          points[p] &= type >> 2 | type << 2;\n        }\n\n        coords.push(p % width1);\n        coords.push(p / width1 | 0);\n\n        if (!points[p]) {\n          --count;\n        }\n      } while (p0 !== p);\n\n      outlines.push(coords);\n      --i;\n    }\n\n    const drawOutline = function (c) {\n      c.save();\n      c.scale(1 / width, -1 / height);\n      c.translate(0, -height);\n      c.beginPath();\n\n      for (let k = 0, kk = outlines.length; k < kk; k++) {\n        const o = outlines[k];\n        c.moveTo(o[0], o[1]);\n\n        for (let l = 2, ll = o.length; l < ll; l += 2) {\n          c.lineTo(o[l], o[l + 1]);\n        }\n      }\n\n      c.fill();\n      c.beginPath();\n      c.restore();\n    };\n\n    return drawOutline;\n  }\n\n  const CanvasExtraState = function CanvasExtraStateClosure() {\n    function CanvasExtraState() {\n      this.alphaIsShape = false;\n      this.fontSize = 0;\n      this.fontSizeScale = 1;\n      this.textMatrix = _util.IDENTITY_MATRIX;\n      this.textMatrixScale = 1;\n      this.fontMatrix = _util.FONT_IDENTITY_MATRIX;\n      this.leading = 0;\n      this.x = 0;\n      this.y = 0;\n      this.lineX = 0;\n      this.lineY = 0;\n      this.charSpacing = 0;\n      this.wordSpacing = 0;\n      this.textHScale = 1;\n      this.textRenderingMode = _util.TextRenderingMode.FILL;\n      this.textRise = 0;\n      this.fillColor = \"#000000\";\n      this.strokeColor = \"#000000\";\n      this.patternFill = false;\n      this.fillAlpha = 1;\n      this.strokeAlpha = 1;\n      this.lineWidth = 1;\n      this.activeSMask = null;\n      this.resumeSMaskCtx = null;\n      this.transferMaps = null;\n    }\n\n    CanvasExtraState.prototype = {\n      clone: function CanvasExtraState_clone() {\n        return Object.create(this);\n      },\n      setCurrentPoint: function CanvasExtraState_setCurrentPoint(x, y) {\n        this.x = x;\n        this.y = y;\n      }\n    };\n    return CanvasExtraState;\n  }();\n\n  const CanvasGraphics = function CanvasGraphicsClosure() {\n    const EXECUTION_TIME = 15;\n    const EXECUTION_STEPS = 10;\n\n    function CanvasGraphics(canvasCtx, commonObjs, objs, canvasFactory, webGLContext, imageLayer, optionalContentConfig) {\n      this.ctx = canvasCtx;\n      this.current = new CanvasExtraState();\n      this.stateStack = [];\n      this.pendingClip = null;\n      this.pendingEOFill = false;\n      this.res = null;\n      this.xobjs = null;\n      this.commonObjs = commonObjs;\n      this.objs = objs;\n      this.canvasFactory = canvasFactory;\n      this.webGLContext = webGLContext;\n      this.imageLayer = imageLayer;\n      this.groupStack = [];\n      this.processingType3 = null;\n      this.baseTransform = null;\n      this.baseTransformStack = [];\n      this.groupLevel = 0;\n      this.smaskStack = [];\n      this.smaskCounter = 0;\n      this.tempSMask = null;\n      this.contentVisible = true;\n      this.markedContentStack = [];\n      this.optionalContentConfig = optionalContentConfig;\n      this.cachedCanvases = new CachedCanvases(this.canvasFactory);\n\n      if (canvasCtx) {\n        addContextCurrentTransform(canvasCtx);\n      }\n\n      this._cachedGetSinglePixelWidth = null;\n    }\n\n    function putBinaryImageData(ctx, imgData, transferMaps = null) {\n      if (typeof ImageData !== \"undefined\" && imgData instanceof ImageData) {\n        ctx.putImageData(imgData, 0, 0);\n        return;\n      }\n\n      const height = imgData.height,\n            width = imgData.width;\n      const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n      const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n      const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n      const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n      let srcPos = 0,\n          destPos;\n      const src = imgData.data;\n      const dest = chunkImgData.data;\n      let i, j, thisChunkHeight, elemsInThisChunk;\n      let transferMapRed, transferMapGreen, transferMapBlue, transferMapGray;\n\n      if (transferMaps) {\n        switch (transferMaps.length) {\n          case 1:\n            transferMapRed = transferMaps[0];\n            transferMapGreen = transferMaps[0];\n            transferMapBlue = transferMaps[0];\n            transferMapGray = transferMaps[0];\n            break;\n\n          case 4:\n            transferMapRed = transferMaps[0];\n            transferMapGreen = transferMaps[1];\n            transferMapBlue = transferMaps[2];\n            transferMapGray = transferMaps[3];\n            break;\n        }\n      }\n\n      if (imgData.kind === _util.ImageKind.GRAYSCALE_1BPP) {\n        const srcLength = src.byteLength;\n        const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);\n        const dest32DataLength = dest32.length;\n        const fullSrcDiff = width + 7 >> 3;\n        let white = 0xffffffff;\n        let black = _util.IsLittleEndianCached.value ? 0xff000000 : 0x000000ff;\n\n        if (transferMapGray) {\n          if (transferMapGray[0] === 0xff && transferMapGray[0xff] === 0) {\n            [white, black] = [black, white];\n          }\n        }\n\n        for (i = 0; i < totalChunks; i++) {\n          thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n          destPos = 0;\n\n          for (j = 0; j < thisChunkHeight; j++) {\n            const srcDiff = srcLength - srcPos;\n            let k = 0;\n            const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;\n            const kEndUnrolled = kEnd & ~7;\n            let mask = 0;\n            let srcByte = 0;\n\n            for (; k < kEndUnrolled; k += 8) {\n              srcByte = src[srcPos++];\n              dest32[destPos++] = srcByte & 128 ? white : black;\n              dest32[destPos++] = srcByte & 64 ? white : black;\n              dest32[destPos++] = srcByte & 32 ? white : black;\n              dest32[destPos++] = srcByte & 16 ? white : black;\n              dest32[destPos++] = srcByte & 8 ? white : black;\n              dest32[destPos++] = srcByte & 4 ? white : black;\n              dest32[destPos++] = srcByte & 2 ? white : black;\n              dest32[destPos++] = srcByte & 1 ? white : black;\n            }\n\n            for (; k < kEnd; k++) {\n              if (mask === 0) {\n                srcByte = src[srcPos++];\n                mask = 128;\n              }\n\n              dest32[destPos++] = srcByte & mask ? white : black;\n              mask >>= 1;\n            }\n          }\n\n          while (destPos < dest32DataLength) {\n            dest32[destPos++] = 0;\n          }\n\n          ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n        }\n      } else if (imgData.kind === _util.ImageKind.RGBA_32BPP) {\n        const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);\n        j = 0;\n        elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;\n\n        for (i = 0; i < fullChunks; i++) {\n          dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n          srcPos += elemsInThisChunk;\n\n          if (hasTransferMaps) {\n            for (let k = 0; k < elemsInThisChunk; k += 4) {\n              if (transferMapRed) {\n                dest[k + 0] = transferMapRed[dest[k + 0]];\n              }\n\n              if (transferMapGreen) {\n                dest[k + 1] = transferMapGreen[dest[k + 1]];\n              }\n\n              if (transferMapBlue) {\n                dest[k + 2] = transferMapBlue[dest[k + 2]];\n              }\n            }\n          }\n\n          ctx.putImageData(chunkImgData, 0, j);\n          j += FULL_CHUNK_HEIGHT;\n        }\n\n        if (i < totalChunks) {\n          elemsInThisChunk = width * partialChunkHeight * 4;\n          dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n\n          if (hasTransferMaps) {\n            for (let k = 0; k < elemsInThisChunk; k += 4) {\n              if (transferMapRed) {\n                dest[k + 0] = transferMapRed[dest[k + 0]];\n              }\n\n              if (transferMapGreen) {\n                dest[k + 1] = transferMapGreen[dest[k + 1]];\n              }\n\n              if (transferMapBlue) {\n                dest[k + 2] = transferMapBlue[dest[k + 2]];\n              }\n            }\n          }\n\n          ctx.putImageData(chunkImgData, 0, j);\n        }\n      } else if (imgData.kind === _util.ImageKind.RGB_24BPP) {\n        const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);\n        thisChunkHeight = FULL_CHUNK_HEIGHT;\n        elemsInThisChunk = width * thisChunkHeight;\n\n        for (i = 0; i < totalChunks; i++) {\n          if (i >= fullChunks) {\n            thisChunkHeight = partialChunkHeight;\n            elemsInThisChunk = width * thisChunkHeight;\n          }\n\n          destPos = 0;\n\n          for (j = elemsInThisChunk; j--;) {\n            dest[destPos++] = src[srcPos++];\n            dest[destPos++] = src[srcPos++];\n            dest[destPos++] = src[srcPos++];\n            dest[destPos++] = 255;\n          }\n\n          if (hasTransferMaps) {\n            for (let k = 0; k < destPos; k += 4) {\n              if (transferMapRed) {\n                dest[k + 0] = transferMapRed[dest[k + 0]];\n              }\n\n              if (transferMapGreen) {\n                dest[k + 1] = transferMapGreen[dest[k + 1]];\n              }\n\n              if (transferMapBlue) {\n                dest[k + 2] = transferMapBlue[dest[k + 2]];\n              }\n            }\n          }\n\n          ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n        }\n      } else {\n        throw new Error(`bad image kind: ${imgData.kind}`);\n      }\n    }\n\n    function putBinaryImageMask(ctx, imgData) {\n      const height = imgData.height,\n            width = imgData.width;\n      const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n      const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n      const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n      const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n      let srcPos = 0;\n      const src = imgData.data;\n      const dest = chunkImgData.data;\n\n      for (let i = 0; i < totalChunks; i++) {\n        const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n        let destPos = 3;\n\n        for (let j = 0; j < thisChunkHeight; j++) {\n          let elem,\n              mask = 0;\n\n          for (let k = 0; k < width; k++) {\n            if (!mask) {\n              elem = src[srcPos++];\n              mask = 128;\n            }\n\n            dest[destPos] = elem & mask ? 0 : 255;\n            destPos += 4;\n            mask >>= 1;\n          }\n        }\n\n        ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n      }\n    }\n\n    function copyCtxState(sourceCtx, destCtx) {\n      const properties = [\"strokeStyle\", \"fillStyle\", \"fillRule\", \"globalAlpha\", \"lineWidth\", \"lineCap\", \"lineJoin\", \"miterLimit\", \"globalCompositeOperation\", \"font\"];\n\n      for (let i = 0, ii = properties.length; i < ii; i++) {\n        const property = properties[i];\n\n        if (sourceCtx[property] !== undefined) {\n          destCtx[property] = sourceCtx[property];\n        }\n      }\n\n      if (sourceCtx.setLineDash !== undefined) {\n        destCtx.setLineDash(sourceCtx.getLineDash());\n        destCtx.lineDashOffset = sourceCtx.lineDashOffset;\n      }\n    }\n\n    function resetCtxToDefault(ctx) {\n      ctx.strokeStyle = \"#000000\";\n      ctx.fillStyle = \"#000000\";\n      ctx.fillRule = \"nonzero\";\n      ctx.globalAlpha = 1;\n      ctx.lineWidth = 1;\n      ctx.lineCap = \"butt\";\n      ctx.lineJoin = \"miter\";\n      ctx.miterLimit = 10;\n      ctx.globalCompositeOperation = \"source-over\";\n      ctx.font = \"10px sans-serif\";\n\n      if (ctx.setLineDash !== undefined) {\n        ctx.setLineDash([]);\n        ctx.lineDashOffset = 0;\n      }\n    }\n\n    function composeSMaskBackdrop(bytes, r0, g0, b0) {\n      const length = bytes.length;\n\n      for (let i = 3; i < length; i += 4) {\n        const alpha = bytes[i];\n\n        if (alpha === 0) {\n          bytes[i - 3] = r0;\n          bytes[i - 2] = g0;\n          bytes[i - 1] = b0;\n        } else if (alpha < 255) {\n          const alpha_ = 255 - alpha;\n          bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;\n          bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;\n          bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;\n        }\n      }\n    }\n\n    function composeSMaskAlpha(maskData, layerData, transferMap) {\n      const length = maskData.length;\n      const scale = 1 / 255;\n\n      for (let i = 3; i < length; i += 4) {\n        const alpha = transferMap ? transferMap[maskData[i]] : maskData[i];\n        layerData[i] = layerData[i] * alpha * scale | 0;\n      }\n    }\n\n    function composeSMaskLuminosity(maskData, layerData, transferMap) {\n      const length = maskData.length;\n\n      for (let i = 3; i < length; i += 4) {\n        const y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;\n        layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;\n      }\n    }\n\n    function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap) {\n      const hasBackdrop = !!backdrop;\n      const r0 = hasBackdrop ? backdrop[0] : 0;\n      const g0 = hasBackdrop ? backdrop[1] : 0;\n      const b0 = hasBackdrop ? backdrop[2] : 0;\n      let composeFn;\n\n      if (subtype === \"Luminosity\") {\n        composeFn = composeSMaskLuminosity;\n      } else {\n        composeFn = composeSMaskAlpha;\n      }\n\n      const PIXELS_TO_PROCESS = 1048576;\n      const chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));\n\n      for (let row = 0; row < height; row += chunkSize) {\n        const chunkHeight = Math.min(chunkSize, height - row);\n        const maskData = maskCtx.getImageData(0, row, width, chunkHeight);\n        const layerData = layerCtx.getImageData(0, row, width, chunkHeight);\n\n        if (hasBackdrop) {\n          composeSMaskBackdrop(maskData.data, r0, g0, b0);\n        }\n\n        composeFn(maskData.data, layerData.data, transferMap);\n        maskCtx.putImageData(layerData, 0, row);\n      }\n    }\n\n    function composeSMask(ctx, smask, layerCtx, webGLContext) {\n      const mask = smask.canvas;\n      const maskCtx = smask.context;\n      ctx.setTransform(smask.scaleX, 0, 0, smask.scaleY, smask.offsetX, smask.offsetY);\n      const backdrop = smask.backdrop || null;\n\n      if (!smask.transferMap && webGLContext.isEnabled) {\n        const composed = webGLContext.composeSMask({\n          layer: layerCtx.canvas,\n          mask,\n          properties: {\n            subtype: smask.subtype,\n            backdrop\n          }\n        });\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.drawImage(composed, smask.offsetX, smask.offsetY);\n        return;\n      }\n\n      genericComposeSMask(maskCtx, layerCtx, mask.width, mask.height, smask.subtype, backdrop, smask.transferMap);\n      ctx.drawImage(mask, 0, 0);\n    }\n\n    const LINE_CAP_STYLES = [\"butt\", \"round\", \"square\"];\n    const LINE_JOIN_STYLES = [\"miter\", \"round\", \"bevel\"];\n    const NORMAL_CLIP = {};\n    const EO_CLIP = {};\n    CanvasGraphics.prototype = {\n      beginDrawing({\n        transform,\n        viewport,\n        transparency = false,\n        background = null\n      }) {\n        const width = this.ctx.canvas.width;\n        const height = this.ctx.canvas.height;\n        this.ctx.save();\n        this.ctx.fillStyle = background || \"rgb(255, 255, 255)\";\n        this.ctx.fillRect(0, 0, width, height);\n        this.ctx.restore();\n\n        if (transparency) {\n          const transparentCanvas = this.cachedCanvases.getCanvas(\"transparent\", width, height, true);\n          this.compositeCtx = this.ctx;\n          this.transparentCanvas = transparentCanvas.canvas;\n          this.ctx = transparentCanvas.context;\n          this.ctx.save();\n          this.ctx.transform.apply(this.ctx, this.compositeCtx.mozCurrentTransform);\n        }\n\n        this.ctx.save();\n        resetCtxToDefault(this.ctx);\n\n        if (transform) {\n          this.ctx.transform.apply(this.ctx, transform);\n        }\n\n        this.ctx.transform.apply(this.ctx, viewport.transform);\n        this.baseTransform = this.ctx.mozCurrentTransform.slice();\n        this._combinedScaleFactor = Math.hypot(this.baseTransform[0], this.baseTransform[2]);\n\n        if (this.imageLayer) {\n          this.imageLayer.beginLayout();\n        }\n      },\n\n      executeOperatorList: function CanvasGraphics_executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {\n        const argsArray = operatorList.argsArray;\n        const fnArray = operatorList.fnArray;\n        let i = executionStartIdx || 0;\n        const argsArrayLen = argsArray.length;\n\n        if (argsArrayLen === i) {\n          return i;\n        }\n\n        const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === \"function\";\n        const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;\n        let steps = 0;\n        const commonObjs = this.commonObjs;\n        const objs = this.objs;\n        let fnId;\n\n        while (true) {\n          if (stepper !== undefined && i === stepper.nextBreakPoint) {\n            stepper.breakIt(i, continueCallback);\n            return i;\n          }\n\n          fnId = fnArray[i];\n\n          if (fnId !== _util.OPS.dependency) {\n            this[fnId].apply(this, argsArray[i]);\n          } else {\n            for (const depObjId of argsArray[i]) {\n              const objsPool = depObjId.startsWith(\"g_\") ? commonObjs : objs;\n\n              if (!objsPool.has(depObjId)) {\n                objsPool.get(depObjId, continueCallback);\n                return i;\n              }\n            }\n          }\n\n          i++;\n\n          if (i === argsArrayLen) {\n            return i;\n          }\n\n          if (chunkOperations && ++steps > EXECUTION_STEPS) {\n            if (Date.now() > endTime) {\n              continueCallback();\n              return i;\n            }\n\n            steps = 0;\n          }\n        }\n      },\n      endDrawing: function CanvasGraphics_endDrawing() {\n        while (this.stateStack.length || this.current.activeSMask !== null) {\n          this.restore();\n        }\n\n        this.ctx.restore();\n\n        if (this.transparentCanvas) {\n          this.ctx = this.compositeCtx;\n          this.ctx.save();\n          this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n          this.ctx.drawImage(this.transparentCanvas, 0, 0);\n          this.ctx.restore();\n          this.transparentCanvas = null;\n        }\n\n        this.cachedCanvases.clear();\n        this.webGLContext.clear();\n\n        if (this.imageLayer) {\n          this.imageLayer.endLayout();\n        }\n      },\n      setLineWidth: function CanvasGraphics_setLineWidth(width) {\n        this.current.lineWidth = width;\n        this.ctx.lineWidth = width;\n      },\n      setLineCap: function CanvasGraphics_setLineCap(style) {\n        this.ctx.lineCap = LINE_CAP_STYLES[style];\n      },\n      setLineJoin: function CanvasGraphics_setLineJoin(style) {\n        this.ctx.lineJoin = LINE_JOIN_STYLES[style];\n      },\n      setMiterLimit: function CanvasGraphics_setMiterLimit(limit) {\n        this.ctx.miterLimit = limit;\n      },\n      setDash: function CanvasGraphics_setDash(dashArray, dashPhase) {\n        const ctx = this.ctx;\n\n        if (ctx.setLineDash !== undefined) {\n          ctx.setLineDash(dashArray);\n          ctx.lineDashOffset = dashPhase;\n        }\n      },\n\n      setRenderingIntent(intent) {},\n\n      setFlatness(flatness) {},\n\n      setGState: function CanvasGraphics_setGState(states) {\n        for (let i = 0, ii = states.length; i < ii; i++) {\n          const state = states[i];\n          const key = state[0];\n          const value = state[1];\n\n          switch (key) {\n            case \"LW\":\n              this.setLineWidth(value);\n              break;\n\n            case \"LC\":\n              this.setLineCap(value);\n              break;\n\n            case \"LJ\":\n              this.setLineJoin(value);\n              break;\n\n            case \"ML\":\n              this.setMiterLimit(value);\n              break;\n\n            case \"D\":\n              this.setDash(value[0], value[1]);\n              break;\n\n            case \"RI\":\n              this.setRenderingIntent(value);\n              break;\n\n            case \"FL\":\n              this.setFlatness(value);\n              break;\n\n            case \"Font\":\n              this.setFont(value[0], value[1]);\n              break;\n\n            case \"CA\":\n              this.current.strokeAlpha = state[1];\n              break;\n\n            case \"ca\":\n              this.current.fillAlpha = state[1];\n              this.ctx.globalAlpha = state[1];\n              break;\n\n            case \"BM\":\n              this.ctx.globalCompositeOperation = value;\n              break;\n\n            case \"SMask\":\n              if (this.current.activeSMask) {\n                if (this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1].activeSMask === this.current.activeSMask) {\n                  this.suspendSMaskGroup();\n                } else {\n                  this.endSMaskGroup();\n                }\n              }\n\n              this.current.activeSMask = value ? this.tempSMask : null;\n\n              if (this.current.activeSMask) {\n                this.beginSMaskGroup();\n              }\n\n              this.tempSMask = null;\n              break;\n\n            case \"TR\":\n              this.current.transferMaps = value;\n          }\n        }\n      },\n      beginSMaskGroup: function CanvasGraphics_beginSMaskGroup() {\n        const activeSMask = this.current.activeSMask;\n        const drawnWidth = activeSMask.canvas.width;\n        const drawnHeight = activeSMask.canvas.height;\n        const cacheId = \"smaskGroupAt\" + this.groupLevel;\n        const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);\n        const currentCtx = this.ctx;\n        const currentTransform = currentCtx.mozCurrentTransform;\n        this.ctx.save();\n        const groupCtx = scratchCanvas.context;\n        groupCtx.scale(1 / activeSMask.scaleX, 1 / activeSMask.scaleY);\n        groupCtx.translate(-activeSMask.offsetX, -activeSMask.offsetY);\n        groupCtx.transform.apply(groupCtx, currentTransform);\n        activeSMask.startTransformInverse = groupCtx.mozCurrentTransformInverse;\n        copyCtxState(currentCtx, groupCtx);\n        this.ctx = groupCtx;\n        this.setGState([[\"BM\", \"source-over\"], [\"ca\", 1], [\"CA\", 1]]);\n        this.groupStack.push(currentCtx);\n        this.groupLevel++;\n      },\n      suspendSMaskGroup: function CanvasGraphics_endSMaskGroup() {\n        const groupCtx = this.ctx;\n        this.groupLevel--;\n        this.ctx = this.groupStack.pop();\n        composeSMask(this.ctx, this.current.activeSMask, groupCtx, this.webGLContext);\n        this.ctx.restore();\n        this.ctx.save();\n        copyCtxState(groupCtx, this.ctx);\n        this.current.resumeSMaskCtx = groupCtx;\n\n        const deltaTransform = _util.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);\n\n        this.ctx.transform.apply(this.ctx, deltaTransform);\n        groupCtx.save();\n        groupCtx.setTransform(1, 0, 0, 1, 0, 0);\n        groupCtx.clearRect(0, 0, groupCtx.canvas.width, groupCtx.canvas.height);\n        groupCtx.restore();\n      },\n      resumeSMaskGroup: function CanvasGraphics_resumeSMaskGroup() {\n        const groupCtx = this.current.resumeSMaskCtx;\n        const currentCtx = this.ctx;\n        this.ctx = groupCtx;\n        this.groupStack.push(currentCtx);\n        this.groupLevel++;\n      },\n      endSMaskGroup: function CanvasGraphics_endSMaskGroup() {\n        const groupCtx = this.ctx;\n        this.groupLevel--;\n        this.ctx = this.groupStack.pop();\n        composeSMask(this.ctx, this.current.activeSMask, groupCtx, this.webGLContext);\n        this.ctx.restore();\n        copyCtxState(groupCtx, this.ctx);\n\n        const deltaTransform = _util.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);\n\n        this.ctx.transform.apply(this.ctx, deltaTransform);\n      },\n      save: function CanvasGraphics_save() {\n        this.ctx.save();\n        const old = this.current;\n        this.stateStack.push(old);\n        this.current = old.clone();\n        this.current.resumeSMaskCtx = null;\n      },\n      restore: function CanvasGraphics_restore() {\n        if (this.current.resumeSMaskCtx) {\n          this.resumeSMaskGroup();\n        }\n\n        if (this.current.activeSMask !== null && (this.stateStack.length === 0 || this.stateStack[this.stateStack.length - 1].activeSMask !== this.current.activeSMask)) {\n          this.endSMaskGroup();\n        }\n\n        if (this.stateStack.length !== 0) {\n          this.current = this.stateStack.pop();\n          this.ctx.restore();\n          this.pendingClip = null;\n          this._cachedGetSinglePixelWidth = null;\n        } else {\n          this.current.activeSMask = null;\n        }\n      },\n      transform: function CanvasGraphics_transform(a, b, c, d, e, f) {\n        this.ctx.transform(a, b, c, d, e, f);\n        this._cachedGetSinglePixelWidth = null;\n      },\n      constructPath: function CanvasGraphics_constructPath(ops, args) {\n        const ctx = this.ctx;\n        const current = this.current;\n        let x = current.x,\n            y = current.y;\n\n        for (let i = 0, j = 0, ii = ops.length; i < ii; i++) {\n          switch (ops[i] | 0) {\n            case _util.OPS.rectangle:\n              x = args[j++];\n              y = args[j++];\n              const width = args[j++];\n              const height = args[j++];\n              const xw = x + width;\n              const yh = y + height;\n              ctx.moveTo(x, y);\n\n              if (width === 0 || height === 0) {\n                ctx.lineTo(xw, yh);\n              } else {\n                ctx.lineTo(xw, y);\n                ctx.lineTo(xw, yh);\n                ctx.lineTo(x, yh);\n              }\n\n              ctx.closePath();\n              break;\n\n            case _util.OPS.moveTo:\n              x = args[j++];\n              y = args[j++];\n              ctx.moveTo(x, y);\n              break;\n\n            case _util.OPS.lineTo:\n              x = args[j++];\n              y = args[j++];\n              ctx.lineTo(x, y);\n              break;\n\n            case _util.OPS.curveTo:\n              x = args[j + 4];\n              y = args[j + 5];\n              ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);\n              j += 6;\n              break;\n\n            case _util.OPS.curveTo2:\n              ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);\n              x = args[j + 2];\n              y = args[j + 3];\n              j += 4;\n              break;\n\n            case _util.OPS.curveTo3:\n              x = args[j + 2];\n              y = args[j + 3];\n              ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);\n              j += 4;\n              break;\n\n            case _util.OPS.closePath:\n              ctx.closePath();\n              break;\n          }\n        }\n\n        current.setCurrentPoint(x, y);\n      },\n      closePath: function CanvasGraphics_closePath() {\n        this.ctx.closePath();\n      },\n      stroke: function CanvasGraphics_stroke(consumePath) {\n        consumePath = typeof consumePath !== \"undefined\" ? consumePath : true;\n        const ctx = this.ctx;\n        const strokeColor = this.current.strokeColor;\n        ctx.globalAlpha = this.current.strokeAlpha;\n\n        if (this.contentVisible) {\n          if (typeof strokeColor === \"object\" && strokeColor && strokeColor.getPattern) { // lwf\n            ctx.save();\n            const transform = ctx.mozCurrentTransform;\n\n            const scale = _util.Util.singularValueDecompose2dScale(transform)[0];\n\n            ctx.strokeStyle = strokeColor.getPattern(ctx, this);\n            const lineWidth = this.getSinglePixelWidth();\n            const scaledLineWidth = this.current.lineWidth * scale;\n\n            if (lineWidth < 0 && -lineWidth >= scaledLineWidth) {\n              ctx.resetTransform();\n              ctx.lineWidth = Math.round(this._combinedScaleFactor);\n            } else {\n              ctx.lineWidth = Math.max(lineWidth, scaledLineWidth);\n            }\n\n            ctx.stroke();\n            ctx.restore();\n          } else {\n            const lineWidth = this.getSinglePixelWidth();\n\n            if (lineWidth < 0 && -lineWidth >= this.current.lineWidth) {\n              ctx.save();\n              ctx.resetTransform();\n              ctx.lineWidth = Math.round(this._combinedScaleFactor);\n              ctx.stroke();\n              ctx.restore();\n            } else {\n              ctx.lineWidth = Math.max(lineWidth, this.current.lineWidth);\n              ctx.stroke();\n            }\n          }\n        }\n\n        if (consumePath) {\n          this.consumePath();\n        }\n\n        ctx.globalAlpha = this.current.fillAlpha;\n      },\n      closeStroke: function CanvasGraphics_closeStroke() {\n        this.closePath();\n        this.stroke();\n      },\n      fill: function CanvasGraphics_fill(consumePath) {\n        consumePath = typeof consumePath !== \"undefined\" ? consumePath : true;\n        const ctx = this.ctx;\n        const fillColor = this.current.fillColor;\n        const isPatternFill = this.current.patternFill;\n        let needRestore = false;\n\n        if (isPatternFill) {\n          ctx.save();\n\n          if (this.baseTransform) {\n            ctx.setTransform.apply(ctx, this.baseTransform);\n          }\n\n          ctx.fillStyle = fillColor.getPattern(ctx, this);\n          needRestore = true;\n        }\n\n        if (this.contentVisible) {\n          if (this.pendingEOFill) {\n            ctx.fill(\"evenodd\");\n            this.pendingEOFill = false;\n          } else {\n            ctx.fill();\n          }\n        }\n\n        if (needRestore) {\n          ctx.restore();\n        }\n\n        if (consumePath) {\n          this.consumePath();\n        }\n      },\n      eoFill: function CanvasGraphics_eoFill() {\n        this.pendingEOFill = true;\n        this.fill();\n      },\n      fillStroke: function CanvasGraphics_fillStroke() {\n        this.fill(false);\n        this.stroke(false);\n        this.consumePath();\n      },\n      eoFillStroke: function CanvasGraphics_eoFillStroke() {\n        this.pendingEOFill = true;\n        this.fillStroke();\n      },\n      closeFillStroke: function CanvasGraphics_closeFillStroke() {\n        this.closePath();\n        this.fillStroke();\n      },\n      closeEOFillStroke: function CanvasGraphics_closeEOFillStroke() {\n        this.pendingEOFill = true;\n        this.closePath();\n        this.fillStroke();\n      },\n      endPath: function CanvasGraphics_endPath() {\n        this.consumePath();\n      },\n      clip: function CanvasGraphics_clip() {\n        this.pendingClip = NORMAL_CLIP;\n      },\n      eoClip: function CanvasGraphics_eoClip() {\n        this.pendingClip = EO_CLIP;\n      },\n      beginText: function CanvasGraphics_beginText() {\n        this.current.textMatrix = _util.IDENTITY_MATRIX;\n        this.current.textMatrixScale = 1;\n        this.current.x = this.current.lineX = 0;\n        this.current.y = this.current.lineY = 0;\n      },\n      endText: function CanvasGraphics_endText() {\n        const paths = this.pendingTextPaths;\n        const ctx = this.ctx;\n\n        if (paths === undefined) {\n          ctx.beginPath();\n          return;\n        }\n\n        ctx.save();\n        ctx.beginPath();\n\n        for (let i = 0; i < paths.length; i++) {\n          const path = paths[i];\n          ctx.setTransform.apply(ctx, path.transform);\n          ctx.translate(path.x, path.y);\n          path.addToPath(ctx, path.fontSize);\n        }\n\n        ctx.restore();\n        ctx.clip();\n        ctx.beginPath();\n        delete this.pendingTextPaths;\n      },\n      setCharSpacing: function CanvasGraphics_setCharSpacing(spacing) {\n        this.current.charSpacing = spacing;\n      },\n      setWordSpacing: function CanvasGraphics_setWordSpacing(spacing) {\n        this.current.wordSpacing = spacing;\n      },\n      setHScale: function CanvasGraphics_setHScale(scale) {\n        this.current.textHScale = scale / 100;\n      },\n      setLeading: function CanvasGraphics_setLeading(leading) {\n        this.current.leading = -leading;\n      },\n      setFont: function CanvasGraphics_setFont(fontRefName, size) {\n        const fontObj = this.commonObjs.get(fontRefName);\n        const current = this.current;\n\n        if (!fontObj) {\n          throw new Error(`Can't find font for ${fontRefName}`);\n        }\n\n        current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;\n\n        if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {\n          (0, _util.warn)(\"Invalid font matrix for font \" + fontRefName);\n        }\n\n        if (size < 0) {\n          size = -size;\n          current.fontDirection = -1;\n        } else {\n          current.fontDirection = 1;\n        }\n\n        this.current.font = fontObj;\n        this.current.fontSize = size;\n\n        if (fontObj.isType3Font) {\n          return;\n        }\n\n        const name = fontObj.loadedName || \"sans-serif\";\n        let bold = \"normal\";\n\n        if (fontObj.black) {\n          bold = \"900\";\n        } else if (fontObj.bold) {\n          bold = \"bold\";\n        }\n\n        const italic = fontObj.italic ? \"italic\" : \"normal\";\n        const typeface = `\"${name}\", ${fontObj.fallbackName}`;\n        let browserFontSize = size;\n\n        if (size < MIN_FONT_SIZE) {\n          browserFontSize = MIN_FONT_SIZE;\n        } else if (size > MAX_FONT_SIZE) {\n          browserFontSize = MAX_FONT_SIZE;\n        }\n\n        this.current.fontSizeScale = size / browserFontSize;\n        this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;\n      },\n      setTextRenderingMode: function CanvasGraphics_setTextRenderingMode(mode) {\n        this.current.textRenderingMode = mode;\n      },\n      setTextRise: function CanvasGraphics_setTextRise(rise) {\n        this.current.textRise = rise;\n      },\n      moveText: function CanvasGraphics_moveText(x, y) {\n        this.current.x = this.current.lineX += x;\n        this.current.y = this.current.lineY += y;\n      },\n      setLeadingMoveText: function CanvasGraphics_setLeadingMoveText(x, y) {\n        this.setLeading(-y);\n        this.moveText(x, y);\n      },\n      setTextMatrix: function CanvasGraphics_setTextMatrix(a, b, c, d, e, f) {\n        this.current.textMatrix = [a, b, c, d, e, f];\n        this.current.textMatrixScale = Math.sqrt(a * a + b * b);\n        this.current.x = this.current.lineX = 0;\n        this.current.y = this.current.lineY = 0;\n      },\n      nextLine: function CanvasGraphics_nextLine() {\n        this.moveText(0, this.current.leading);\n      },\n\n      paintChar(character, x, y, patternTransform, resetLineWidthToOne) {\n        const ctx = this.ctx;\n        const current = this.current;\n        const font = current.font;\n        const textRenderingMode = current.textRenderingMode;\n        const fontSize = current.fontSize / current.fontSizeScale;\n        const fillStrokeMode = textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n        const isAddToPathSet = !!(textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);\n        const patternFill = current.patternFill && !font.missingFile;\n        let addToPath;\n\n        if (font.disableFontFace || isAddToPathSet || patternFill) {\n          addToPath = font.getPathGenerator(this.commonObjs, character);\n        }\n\n        if (font.disableFontFace || patternFill) {\n          ctx.save();\n          ctx.translate(x, y);\n          ctx.beginPath();\n          addToPath(ctx, fontSize);\n\n          if (patternTransform) {\n            ctx.setTransform.apply(ctx, patternTransform);\n          }\n\n          if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n            ctx.fill();\n          }\n\n          if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n            if (resetLineWidthToOne) {\n              ctx.resetTransform();\n              ctx.lineWidth = Math.round(this._combinedScaleFactor);\n            }\n\n            ctx.stroke();\n          }\n\n          ctx.restore();\n        } else {\n          if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n            ctx.fillText(character, x, y);\n          }\n\n          if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n            if (resetLineWidthToOne) {\n              ctx.save();\n              ctx.moveTo(x, y);\n              ctx.resetTransform();\n              ctx.lineWidth = Math.round(this._combinedScaleFactor);\n              ctx.strokeText(character, 0, 0);\n              ctx.restore();\n            } else {\n              ctx.strokeText(character, x, y);\n            }\n          }\n        }\n\n        if (isAddToPathSet) {\n          const paths = this.pendingTextPaths || (this.pendingTextPaths = []);\n          paths.push({\n            transform: ctx.mozCurrentTransform,\n            x,\n            y,\n            fontSize,\n            addToPath\n          });\n        }\n      },\n\n      get isFontSubpixelAAEnabled() {\n        const {\n          context: ctx\n        } = this.cachedCanvases.getCanvas(\"isFontSubpixelAAEnabled\", 10, 10);\n        ctx.scale(1.5, 1);\n        ctx.fillText(\"I\", 0, 10);\n        const data = ctx.getImageData(0, 0, 10, 10).data;\n        let enabled = false;\n\n        for (let i = 3; i < data.length; i += 4) {\n          if (data[i] > 0 && data[i] < 255) {\n            enabled = true;\n            break;\n          }\n        }\n\n        return (0, _util.shadow)(this, \"isFontSubpixelAAEnabled\", enabled);\n      },\n\n      showText: function CanvasGraphics_showText(glyphs) {\n        const current = this.current;\n        const font = current.font;\n\n        if (font.isType3Font) {\n          return this.showType3Text(glyphs);\n        }\n\n        const fontSize = current.fontSize;\n\n        if (fontSize === 0) {\n          return undefined;\n        }\n\n        const ctx = this.ctx;\n        const fontSizeScale = current.fontSizeScale;\n        const charSpacing = current.charSpacing;\n        const wordSpacing = current.wordSpacing;\n        const fontDirection = current.fontDirection;\n        const textHScale = current.textHScale * fontDirection;\n        const glyphsLength = glyphs.length;\n        const vertical = font.vertical;\n        const spacingDir = vertical ? 1 : -1;\n        const defaultVMetrics = font.defaultVMetrics;\n        const widthAdvanceScale = fontSize * current.fontMatrix[0];\n        const simpleFillText = current.textRenderingMode === _util.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;\n        ctx.save();\n        let patternTransform;\n\n        if (current.patternFill) {\n          ctx.save();\n          const pattern = current.fillColor.getPattern(ctx, this);\n          patternTransform = ctx.mozCurrentTransform;\n          ctx.restore();\n          ctx.fillStyle = pattern;\n        }\n\n        ctx.transform.apply(ctx, current.textMatrix);\n        ctx.translate(current.x, current.y + current.textRise);\n\n        if (fontDirection > 0) {\n          ctx.scale(textHScale, -1);\n        } else {\n          ctx.scale(textHScale, 1);\n        }\n\n        let lineWidth = current.lineWidth;\n        let resetLineWidthToOne = false;\n        const scale = current.textMatrixScale;\n\n        if (scale === 0 || lineWidth === 0) {\n          const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n\n          if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n            this._cachedGetSinglePixelWidth = null;\n            lineWidth = this.getSinglePixelWidth();\n            resetLineWidthToOne = lineWidth < 0;\n          }\n        } else {\n          lineWidth /= scale;\n        }\n\n        if (fontSizeScale !== 1.0) {\n          ctx.scale(fontSizeScale, fontSizeScale);\n          lineWidth /= fontSizeScale;\n        }\n\n        ctx.lineWidth = lineWidth;\n        let x = 0,\n            i;\n\n        for (i = 0; i < glyphsLength; ++i) {\n          const glyph = glyphs[i];\n\n          if ((0, _util.isNum)(glyph)) {\n            x += spacingDir * glyph * fontSize / 1000;\n            continue;\n          }\n\n          let restoreNeeded = false;\n          const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n          const character = glyph.fontChar;\n          const accent = glyph.accent;\n          let scaledX, scaledY;\n          let width = glyph.width;\n\n          if (vertical) {\n            const vmetric = glyph.vmetric || defaultVMetrics;\n            const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;\n            const vy = vmetric[2] * widthAdvanceScale;\n            width = vmetric ? -vmetric[0] : width;\n            scaledX = vx / fontSizeScale;\n            scaledY = (x + vy) / fontSizeScale;\n          } else {\n            scaledX = x / fontSizeScale;\n            scaledY = 0;\n          }\n\n          if (font.remeasure && width > 0) {\n            const measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;\n\n            if (width < measuredWidth && this.isFontSubpixelAAEnabled) {\n              const characterScaleX = width / measuredWidth;\n              restoreNeeded = true;\n              ctx.save();\n              ctx.scale(characterScaleX, 1);\n              scaledX /= characterScaleX;\n            } else if (width !== measuredWidth) {\n              scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;\n            }\n          }\n\n          if (this.contentVisible && (glyph.isInFont || font.missingFile)) {\n            if (simpleFillText && !accent) {\n              ctx.fillText(character, scaledX, scaledY);\n            } else {\n              this.paintChar(character, scaledX, scaledY, patternTransform, resetLineWidthToOne);\n\n              if (accent) {\n                const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;\n                const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;\n                this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform, resetLineWidthToOne);\n              }\n            }\n          }\n\n          let charWidth;\n\n          if (vertical) {\n            charWidth = width * widthAdvanceScale - spacing * fontDirection;\n          } else {\n            charWidth = width * widthAdvanceScale + spacing * fontDirection;\n          }\n\n          x += charWidth;\n\n          if (restoreNeeded) {\n            ctx.restore();\n          }\n        }\n\n        if (vertical) {\n          current.y -= x;\n        } else {\n          current.x += x * textHScale;\n        }\n\n        ctx.restore();\n      },\n      showType3Text: function CanvasGraphics_showType3Text(glyphs) {\n        const ctx = this.ctx;\n        const current = this.current;\n        const font = current.font;\n        const fontSize = current.fontSize;\n        const fontDirection = current.fontDirection;\n        const spacingDir = font.vertical ? 1 : -1;\n        const charSpacing = current.charSpacing;\n        const wordSpacing = current.wordSpacing;\n        const textHScale = current.textHScale * fontDirection;\n        const fontMatrix = current.fontMatrix || _util.FONT_IDENTITY_MATRIX;\n        const glyphsLength = glyphs.length;\n        const isTextInvisible = current.textRenderingMode === _util.TextRenderingMode.INVISIBLE;\n        let i, glyph, width, spacingLength;\n\n        if (isTextInvisible || fontSize === 0) {\n          return;\n        }\n\n        this._cachedGetSinglePixelWidth = null;\n        ctx.save();\n        ctx.transform.apply(ctx, current.textMatrix);\n        ctx.translate(current.x, current.y);\n        ctx.scale(textHScale, fontDirection);\n\n        for (i = 0; i < glyphsLength; ++i) {\n          glyph = glyphs[i];\n\n          if ((0, _util.isNum)(glyph)) {\n            spacingLength = spacingDir * glyph * fontSize / 1000;\n            this.ctx.translate(spacingLength, 0);\n            current.x += spacingLength * textHScale;\n            continue;\n          }\n\n          const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n          const operatorList = font.charProcOperatorList[glyph.operatorListId];\n\n          if (!operatorList) {\n            (0, _util.warn)(`Type3 character \"${glyph.operatorListId}\" is not available.`);\n            continue;\n          }\n\n          if (this.contentVisible) {\n            this.processingType3 = glyph;\n            this.save();\n            ctx.scale(fontSize, fontSize);\n            ctx.transform.apply(ctx, fontMatrix);\n            this.executeOperatorList(operatorList);\n            this.restore();\n          }\n\n          const transformed = _util.Util.applyTransform([glyph.width, 0], fontMatrix);\n\n          width = transformed[0] * fontSize + spacing;\n          ctx.translate(width, 0);\n          current.x += width * textHScale;\n        }\n\n        ctx.restore();\n        this.processingType3 = null;\n      },\n      setCharWidth: function CanvasGraphics_setCharWidth(xWidth, yWidth) {},\n      setCharWidthAndBounds: function CanvasGraphics_setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {\n        this.ctx.rect(llx, lly, urx - llx, ury - lly);\n        this.clip();\n        this.endPath();\n      },\n      getColorN_Pattern: function CanvasGraphics_getColorN_Pattern(IR) {\n        let pattern;\n\n        if (IR[0] === \"TilingPattern\") {\n          const color = IR[1];\n          const baseTransform = this.baseTransform || this.ctx.mozCurrentTransform.slice();\n          const canvasGraphicsFactory = {\n            createCanvasGraphics: ctx => {\n              return new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory, this.webGLContext);\n            }\n          };\n          pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);\n        } else {\n          pattern = (0, _pattern_helper.getShadingPatternFromIR)(IR);\n        }\n\n        return pattern;\n      },\n      setStrokeColorN: function CanvasGraphics_setStrokeColorN() {\n        this.current.strokeColor = this.getColorN_Pattern(arguments);\n      },\n      setFillColorN: function CanvasGraphics_setFillColorN() {\n        this.current.fillColor = this.getColorN_Pattern(arguments);\n        this.current.patternFill = true;\n      },\n      setStrokeRGBColor: function CanvasGraphics_setStrokeRGBColor(r, g, b) {\n        const color = _util.Util.makeHexColor(r, g, b);\n\n        this.ctx.strokeStyle = color;\n        this.current.strokeColor = color;\n      },\n      setFillRGBColor: function CanvasGraphics_setFillRGBColor(r, g, b) {\n        const color = _util.Util.makeHexColor(r, g, b);\n\n        this.ctx.fillStyle = color;\n        this.current.fillColor = color;\n        this.current.patternFill = false;\n      },\n      shadingFill: function CanvasGraphics_shadingFill(patternIR) {\n        if (!this.contentVisible) {\n          return;\n        }\n\n        const ctx = this.ctx;\n        this.save();\n        const pattern = (0, _pattern_helper.getShadingPatternFromIR)(patternIR);\n        ctx.fillStyle = pattern.getPattern(ctx, this, true);\n        const inv = ctx.mozCurrentTransformInverse;\n\n        if (inv) {\n          const canvas = ctx.canvas;\n          const width = canvas.width;\n          const height = canvas.height;\n\n          const bl = _util.Util.applyTransform([0, 0], inv);\n\n          const br = _util.Util.applyTransform([0, height], inv);\n\n          const ul = _util.Util.applyTransform([width, 0], inv);\n\n          const ur = _util.Util.applyTransform([width, height], inv);\n\n          const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);\n          const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);\n          const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);\n          const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);\n          this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);\n        } else {\n          this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);\n        }\n\n        this.restore();\n      },\n      beginInlineImage: function CanvasGraphics_beginInlineImage() {\n        (0, _util.unreachable)(\"Should not call beginInlineImage\");\n      },\n      beginImageData: function CanvasGraphics_beginImageData() {\n        (0, _util.unreachable)(\"Should not call beginImageData\");\n      },\n      paintFormXObjectBegin: function CanvasGraphics_paintFormXObjectBegin(matrix, bbox) {\n        if (!this.contentVisible) {\n          return;\n        }\n\n        this.save();\n        this.baseTransformStack.push(this.baseTransform);\n\n        if (Array.isArray(matrix) && matrix.length === 6) {\n          this.transform.apply(this, matrix);\n        }\n\n        this.baseTransform = this.ctx.mozCurrentTransform;\n\n        if (bbox) {\n          const width = bbox[2] - bbox[0];\n          const height = bbox[3] - bbox[1];\n          this.ctx.rect(bbox[0], bbox[1], width, height);\n          this.clip();\n          this.endPath();\n        }\n      },\n      paintFormXObjectEnd: function CanvasGraphics_paintFormXObjectEnd() {\n        if (!this.contentVisible) {\n          return;\n        }\n\n        this.restore();\n        this.baseTransform = this.baseTransformStack.pop();\n      },\n      beginGroup: function CanvasGraphics_beginGroup(group) {\n        if (!this.contentVisible) {\n          return;\n        }\n\n        this.save();\n        const currentCtx = this.ctx;\n\n        if (!group.isolated) {\n          (0, _util.info)(\"TODO: Support non-isolated groups.\");\n        }\n\n        if (group.knockout) {\n          (0, _util.warn)(\"Knockout groups not supported.\");\n        }\n\n        const currentTransform = currentCtx.mozCurrentTransform;\n\n        if (group.matrix) {\n          currentCtx.transform.apply(currentCtx, group.matrix);\n        }\n\n        if (!group.bbox) {\n          throw new Error(\"Bounding box is required.\");\n        }\n\n        let bounds = _util.Util.getAxialAlignedBoundingBox(group.bbox, currentCtx.mozCurrentTransform);\n\n        const canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];\n        bounds = _util.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];\n        const offsetX = Math.floor(bounds[0]);\n        const offsetY = Math.floor(bounds[1]);\n        let drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);\n        let drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);\n        let scaleX = 1,\n            scaleY = 1;\n\n        if (drawnWidth > MAX_GROUP_SIZE) {\n          scaleX = drawnWidth / MAX_GROUP_SIZE;\n          drawnWidth = MAX_GROUP_SIZE;\n        }\n\n        if (drawnHeight > MAX_GROUP_SIZE) {\n          scaleY = drawnHeight / MAX_GROUP_SIZE;\n          drawnHeight = MAX_GROUP_SIZE;\n        }\n\n        let cacheId = \"groupAt\" + this.groupLevel;\n\n        if (group.smask) {\n          cacheId += \"_smask_\" + this.smaskCounter++ % 2;\n        }\n\n        const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);\n        const groupCtx = scratchCanvas.context;\n        groupCtx.scale(1 / scaleX, 1 / scaleY);\n        groupCtx.translate(-offsetX, -offsetY);\n        groupCtx.transform.apply(groupCtx, currentTransform);\n\n        if (group.smask) {\n          this.smaskStack.push({\n            canvas: scratchCanvas.canvas,\n            context: groupCtx,\n            offsetX,\n            offsetY,\n            scaleX,\n            scaleY,\n            subtype: group.smask.subtype,\n            backdrop: group.smask.backdrop,\n            transferMap: group.smask.transferMap || null,\n            startTransformInverse: null\n          });\n        } else {\n          currentCtx.setTransform(1, 0, 0, 1, 0, 0);\n          currentCtx.translate(offsetX, offsetY);\n          currentCtx.scale(scaleX, scaleY);\n        }\n\n        copyCtxState(currentCtx, groupCtx);\n        this.ctx = groupCtx;\n        this.setGState([[\"BM\", \"source-over\"], [\"ca\", 1], [\"CA\", 1]]);\n        this.groupStack.push(currentCtx);\n        this.groupLevel++;\n        this.current.activeSMask = null;\n      },\n      endGroup: function CanvasGraphics_endGroup(group) {\n        if (!this.contentVisible) {\n          return;\n        }\n\n        this.groupLevel--;\n        const groupCtx = this.ctx;\n        this.ctx = this.groupStack.pop();\n\n        if (this.ctx.imageSmoothingEnabled !== undefined) {\n          this.ctx.imageSmoothingEnabled = false;\n        } else {\n          this.ctx.mozImageSmoothingEnabled = false;\n        }\n\n        if (group.smask) {\n          this.tempSMask = this.smaskStack.pop();\n        } else {\n          this.ctx.drawImage(groupCtx.canvas, 0, 0);\n        }\n\n        this.restore();\n      },\n      beginAnnotations: function CanvasGraphics_beginAnnotations() {\n        this.save();\n\n        if (this.baseTransform) {\n          this.ctx.setTransform.apply(this.ctx, this.baseTransform);\n        }\n      },\n      endAnnotations: function CanvasGraphics_endAnnotations() {\n        this.restore();\n      },\n      beginAnnotation: function CanvasGraphics_beginAnnotation(rect, transform, matrix) {\n        this.save();\n        resetCtxToDefault(this.ctx);\n        this.current = new CanvasExtraState();\n\n        if (Array.isArray(rect) && rect.length === 4) {\n          const width = rect[2] - rect[0];\n          const height = rect[3] - rect[1];\n          this.ctx.rect(rect[0], rect[1], width, height);\n          this.clip();\n          this.endPath();\n        }\n\n        this.transform.apply(this, transform);\n        this.transform.apply(this, matrix);\n      },\n      endAnnotation: function CanvasGraphics_endAnnotation() {\n        this.restore();\n      },\n      paintImageMaskXObject: function CanvasGraphics_paintImageMaskXObject(img) {\n        if (!this.contentVisible) {\n          return;\n        }\n\n        const ctx = this.ctx;\n        const width = img.width,\n              height = img.height;\n        const fillColor = this.current.fillColor;\n        const isPatternFill = this.current.patternFill;\n        const glyph = this.processingType3;\n\n        if (COMPILE_TYPE3_GLYPHS && glyph && glyph.compiled === undefined) {\n          if (width <= MAX_SIZE_TO_COMPILE && height <= MAX_SIZE_TO_COMPILE) {\n            glyph.compiled = compileType3Glyph({\n              data: img.data,\n              width,\n              height\n            });\n          } else {\n            glyph.compiled = null;\n          }\n        }\n\n        if (glyph && glyph.compiled) { // lwf\n          glyph.compiled(ctx);\n          return;\n        }\n\n        const maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n        const maskCtx = maskCanvas.context;\n        maskCtx.save();\n        putBinaryImageMask(maskCtx, img);\n        maskCtx.globalCompositeOperation = \"source-in\";\n        maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;\n        maskCtx.fillRect(0, 0, width, height);\n        maskCtx.restore();\n        this.paintInlineImageXObject(maskCanvas.canvas);\n      },\n\n      paintImageMaskXObjectRepeat(imgData, scaleX, skewX = 0, skewY = 0, scaleY, positions) {\n        if (!this.contentVisible) {\n          return;\n        }\n\n        const width = imgData.width;\n        const height = imgData.height;\n        const fillColor = this.current.fillColor;\n        const isPatternFill = this.current.patternFill;\n        const maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n        const maskCtx = maskCanvas.context;\n        maskCtx.save();\n        putBinaryImageMask(maskCtx, imgData);\n        maskCtx.globalCompositeOperation = \"source-in\";\n        maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;\n        maskCtx.fillRect(0, 0, width, height);\n        maskCtx.restore();\n        const ctx = this.ctx;\n\n        for (let i = 0, ii = positions.length; i < ii; i += 2) {\n          ctx.save();\n          ctx.transform(scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]);\n          ctx.scale(1, -1);\n          ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);\n          ctx.restore();\n        }\n      },\n\n      paintImageMaskXObjectGroup: function CanvasGraphics_paintImageMaskXObjectGroup(images) {\n        if (!this.contentVisible) {\n          return;\n        }\n\n        const ctx = this.ctx;\n        const fillColor = this.current.fillColor;\n        const isPatternFill = this.current.patternFill;\n\n        for (let i = 0, ii = images.length; i < ii; i++) {\n          const image = images[i];\n          const width = image.width,\n                height = image.height;\n          const maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n          const maskCtx = maskCanvas.context;\n          maskCtx.save();\n          putBinaryImageMask(maskCtx, image);\n          maskCtx.globalCompositeOperation = \"source-in\";\n          maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;\n          maskCtx.fillRect(0, 0, width, height);\n          maskCtx.restore();\n          ctx.save();\n          ctx.transform.apply(ctx, image.transform);\n          ctx.scale(1, -1);\n          ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);\n          ctx.restore();\n        }\n      },\n      paintImageXObject: function CanvasGraphics_paintImageXObject(objId) {\n        if (!this.contentVisible) {\n          return;\n        }\n\n        const imgData = objId.startsWith(\"g_\") ? this.commonObjs.get(objId) : this.objs.get(objId);\n\n        if (!imgData) {\n          (0, _util.warn)(\"Dependent image isn't ready yet\");\n          return;\n        }\n\n        this.paintInlineImageXObject(imgData);\n      },\n      paintImageXObjectRepeat: function CanvasGraphics_paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {\n        if (!this.contentVisible) {\n          return;\n        }\n\n        const imgData = objId.startsWith(\"g_\") ? this.commonObjs.get(objId) : this.objs.get(objId);\n\n        if (!imgData) {\n          (0, _util.warn)(\"Dependent image isn't ready yet\");\n          return;\n        }\n\n        const width = imgData.width;\n        const height = imgData.height;\n        const map = [];\n\n        for (let i = 0, ii = positions.length; i < ii; i += 2) {\n          map.push({\n            transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],\n            x: 0,\n            y: 0,\n            w: width,\n            h: height\n          });\n        }\n\n        this.paintInlineImageXObjectGroup(imgData, map);\n      },\n      paintInlineImageXObject: function CanvasGraphics_paintInlineImageXObject(imgData) {\n        if (!this.contentVisible) {\n          return;\n        }\n\n        const width = imgData.width;\n        const height = imgData.height;\n        const ctx = this.ctx;\n        this.save();\n        ctx.scale(1 / width, -1 / height);\n        const currentTransform = ctx.mozCurrentTransformInverse;\n        const a = currentTransform[0],\n              b = currentTransform[1];\n        let widthScale = Math.max(Math.sqrt(a * a + b * b), 1);\n        const c = currentTransform[2],\n              d = currentTransform[3];\n        let heightScale = Math.max(Math.sqrt(c * c + d * d), 1);\n        let imgToPaint, tmpCanvas, tmpCtx;\n\n        if (typeof HTMLElement === \"function\" && imgData instanceof HTMLElement || !imgData.data) {\n          imgToPaint = imgData;\n        } else {\n          tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n          tmpCtx = tmpCanvas.context;\n          putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);\n          imgToPaint = tmpCanvas.canvas;\n        }\n\n        let paintWidth = width,\n            paintHeight = height;\n        let tmpCanvasId = \"prescale1\";\n\n        while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {\n          let newWidth = paintWidth,\n              newHeight = paintHeight;\n\n          if (widthScale > 2 && paintWidth > 1) {\n            newWidth = Math.ceil(paintWidth / 2);\n            widthScale /= paintWidth / newWidth;\n          }\n\n          if (heightScale > 2 && paintHeight > 1) {\n            newHeight = Math.ceil(paintHeight / 2);\n            heightScale /= paintHeight / newHeight;\n          }\n\n          tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);\n          tmpCtx = tmpCanvas.context;\n          tmpCtx.clearRect(0, 0, newWidth, newHeight);\n          tmpCtx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);\n          imgToPaint = tmpCanvas.canvas;\n          paintWidth = newWidth;\n          paintHeight = newHeight;\n          tmpCanvasId = tmpCanvasId === \"prescale1\" ? \"prescale2\" : \"prescale1\";\n        }\n\n        ctx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, -height, width, height);\n\n        if (this.imageLayer) {\n          const position = this.getCanvasPosition(0, -height);\n          this.imageLayer.appendImage({\n            imgData,\n            left: position[0],\n            top: position[1],\n            width: width / currentTransform[0],\n            height: height / currentTransform[3]\n          });\n        }\n\n        this.restore();\n      },\n      paintInlineImageXObjectGroup: function CanvasGraphics_paintInlineImageXObjectGroup(imgData, map) {\n        if (!this.contentVisible) {\n          return;\n        }\n\n        const ctx = this.ctx;\n        const w = imgData.width;\n        const h = imgData.height;\n        const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", w, h);\n        const tmpCtx = tmpCanvas.context;\n        putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);\n\n        for (let i = 0, ii = map.length; i < ii; i++) {\n          const entry = map[i];\n          ctx.save();\n          ctx.transform.apply(ctx, entry.transform);\n          ctx.scale(1, -1);\n          ctx.drawImage(tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);\n\n          if (this.imageLayer) {\n            const position = this.getCanvasPosition(entry.x, entry.y);\n            this.imageLayer.appendImage({\n              imgData,\n              left: position[0],\n              top: position[1],\n              width: w,\n              height: h\n            });\n          }\n\n          ctx.restore();\n        }\n      },\n      paintSolidColorImageMask: function CanvasGraphics_paintSolidColorImageMask() {\n        if (!this.contentVisible) {\n          return;\n        }\n\n        this.ctx.fillRect(0, 0, 1, 1);\n      },\n      markPoint: function CanvasGraphics_markPoint(tag) {},\n      markPointProps: function CanvasGraphics_markPointProps(tag, properties) {},\n      beginMarkedContent: function CanvasGraphics_beginMarkedContent(tag) {\n        this.markedContentStack.push({\n          visible: true\n        });\n      },\n      beginMarkedContentProps: function CanvasGraphics_beginMarkedContentProps(tag, properties) {\n        if (tag === \"OC\") {\n          this.markedContentStack.push({\n            visible: this.optionalContentConfig.isVisible(properties)\n          });\n        } else {\n          this.markedContentStack.push({\n            visible: true\n          });\n        }\n\n        this.contentVisible = this.isContentVisible();\n      },\n      endMarkedContent: function CanvasGraphics_endMarkedContent() {\n        this.markedContentStack.pop();\n        this.contentVisible = this.isContentVisible();\n      },\n      beginCompat: function CanvasGraphics_beginCompat() {},\n      endCompat: function CanvasGraphics_endCompat() {},\n      consumePath: function CanvasGraphics_consumePath() {\n        const ctx = this.ctx;\n\n        if (this.pendingClip) {\n          if (this.pendingClip === EO_CLIP) {\n            ctx.clip(\"evenodd\");\n          } else {\n            ctx.clip();\n          }\n\n          this.pendingClip = null;\n        }\n\n        ctx.beginPath();\n      },\n\n      getSinglePixelWidth() {\n        if (this._cachedGetSinglePixelWidth === null) {\n          const m = this.ctx.mozCurrentTransform;\n          const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);\n          const sqNorm1 = m[0] ** 2 + m[2] ** 2;\n          const sqNorm2 = m[1] ** 2 + m[3] ** 2;\n          const pixelHeight = Math.sqrt(Math.max(sqNorm1, sqNorm2)) / absDet;\n\n          if (sqNorm1 !== sqNorm2 && this._combinedScaleFactor * pixelHeight > 1) {\n            this._cachedGetSinglePixelWidth = -(this._combinedScaleFactor * pixelHeight);\n          } else if (absDet > Number.EPSILON) {\n            this._cachedGetSinglePixelWidth = pixelHeight * 1.0000001;\n          } else {\n            this._cachedGetSinglePixelWidth = 1;\n          }\n        }\n\n        return this._cachedGetSinglePixelWidth;\n      },\n\n      getCanvasPosition: function CanvasGraphics_getCanvasPosition(x, y) {\n        const transform = this.ctx.mozCurrentTransform;\n        return [transform[0] * x + transform[2] * y + transform[4], transform[1] * x + transform[3] * y + transform[5]];\n      },\n      isContentVisible: function CanvasGraphics_isContentVisible() {\n        for (let i = this.markedContentStack.length - 1; i >= 0; i--) {\n          if (!this.markedContentStack[i].visible) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n    };\n\n    for (const op in _util.OPS) {\n      CanvasGraphics.prototype[_util.OPS[op]] = CanvasGraphics.prototype[op];\n    }\n\n    return CanvasGraphics;\n  }();\n\n  exports.CanvasGraphics = CanvasGraphics;\n\n  /***/ }),\n  /* 11 */\n  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\n  Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n  }));\n  exports.getShadingPatternFromIR = getShadingPatternFromIR;\n  exports.TilingPattern = void 0;\n\n  var _util = __w_pdfjs_require__(2);\n\n  const ShadingIRs = {};\n\n  function applyBoundingBox(ctx, bbox) {\n    if (!bbox || typeof Path2D === \"undefined\") {\n      return;\n    }\n\n    const width = bbox[2] - bbox[0];\n    const height = bbox[3] - bbox[1];\n    const region = new Path2D();\n    region.rect(bbox[0], bbox[1], width, height);\n    ctx.clip(region);\n  }\n\n  ShadingIRs.RadialAxial = {\n    fromIR: function RadialAxial_fromIR(raw) {\n      const type = raw[1];\n      const bbox = raw[2];\n      const colorStops = raw[3];\n      const p0 = raw[4];\n      const p1 = raw[5];\n      const r0 = raw[6];\n      const r1 = raw[7];\n      return {\n        getPattern: function RadialAxial_getPattern(ctx) {\n          applyBoundingBox(ctx, bbox);\n          let grad;\n\n          if (type === \"axial\") {\n            grad = ctx.createLinearGradient(p0[0], p0[1], p1[0], p1[1]);\n          } else if (type === \"radial\") {\n            grad = ctx.createRadialGradient(p0[0], p0[1], r0, p1[0], p1[1], r1);\n          }\n\n          for (let i = 0, ii = colorStops.length; i < ii; ++i) {\n            const c = colorStops[i];\n            grad.addColorStop(c[0], c[1]);\n          }\n\n          return grad;\n        }\n      };\n    }\n  };\n\n  const createMeshCanvas = function createMeshCanvasClosure() {\n    function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {\n      const coords = context.coords,\n            colors = context.colors;\n      const bytes = data.data,\n            rowSize = data.width * 4;\n      let tmp;\n\n      if (coords[p1 + 1] > coords[p2 + 1]) {\n        tmp = p1;\n        p1 = p2;\n        p2 = tmp;\n        tmp = c1;\n        c1 = c2;\n        c2 = tmp;\n      }\n\n      if (coords[p2 + 1] > coords[p3 + 1]) {\n        tmp = p2;\n        p2 = p3;\n        p3 = tmp;\n        tmp = c2;\n        c2 = c3;\n        c3 = tmp;\n      }\n\n      if (coords[p1 + 1] > coords[p2 + 1]) {\n        tmp = p1;\n        p1 = p2;\n        p2 = tmp;\n        tmp = c1;\n        c1 = c2;\n        c2 = tmp;\n      }\n\n      const x1 = (coords[p1] + context.offsetX) * context.scaleX;\n      const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;\n      const x2 = (coords[p2] + context.offsetX) * context.scaleX;\n      const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;\n      const x3 = (coords[p3] + context.offsetX) * context.scaleX;\n      const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;\n\n      if (y1 >= y3) {\n        return;\n      }\n\n      const c1r = colors[c1],\n            c1g = colors[c1 + 1],\n            c1b = colors[c1 + 2];\n      const c2r = colors[c2],\n            c2g = colors[c2 + 1],\n            c2b = colors[c2 + 2];\n      const c3r = colors[c3],\n            c3g = colors[c3 + 1],\n            c3b = colors[c3 + 2];\n      const minY = Math.round(y1),\n            maxY = Math.round(y3);\n      let xa, car, cag, cab;\n      let xb, cbr, cbg, cbb;\n\n      for (let y = minY; y <= maxY; y++) {\n        if (y < y2) {\n          let k;\n\n          if (y < y1) {\n            k = 0;\n          } else if (y1 === y2) {\n            k = 1;\n          } else {\n            k = (y1 - y) / (y1 - y2);\n          }\n\n          xa = x1 - (x1 - x2) * k;\n          car = c1r - (c1r - c2r) * k;\n          cag = c1g - (c1g - c2g) * k;\n          cab = c1b - (c1b - c2b) * k;\n        } else {\n          let k;\n\n          if (y > y3) {\n            k = 1;\n          } else if (y2 === y3) {\n            k = 0;\n          } else {\n            k = (y2 - y) / (y2 - y3);\n          }\n\n          xa = x2 - (x2 - x3) * k;\n          car = c2r - (c2r - c3r) * k;\n          cag = c2g - (c2g - c3g) * k;\n          cab = c2b - (c2b - c3b) * k;\n        }\n\n        let k;\n\n        if (y < y1) {\n          k = 0;\n        } else if (y > y3) {\n          k = 1;\n        } else {\n          k = (y1 - y) / (y1 - y3);\n        }\n\n        xb = x1 - (x1 - x3) * k;\n        cbr = c1r - (c1r - c3r) * k;\n        cbg = c1g - (c1g - c3g) * k;\n        cbb = c1b - (c1b - c3b) * k;\n        const x1_ = Math.round(Math.min(xa, xb));\n        const x2_ = Math.round(Math.max(xa, xb));\n        let j = rowSize * y + x1_ * 4;\n\n        for (let x = x1_; x <= x2_; x++) {\n          k = (xa - x) / (xa - xb);\n\n          if (k < 0) {\n            k = 0;\n          } else if (k > 1) {\n            k = 1;\n          }\n\n          bytes[j++] = car - (car - cbr) * k | 0;\n          bytes[j++] = cag - (cag - cbg) * k | 0;\n          bytes[j++] = cab - (cab - cbb) * k | 0;\n          bytes[j++] = 255;\n        }\n      }\n    }\n\n    function drawFigure(data, figure, context) {\n      const ps = figure.coords;\n      const cs = figure.colors;\n      let i, ii;\n\n      switch (figure.type) {\n        case \"lattice\":\n          const verticesPerRow = figure.verticesPerRow;\n          const rows = Math.floor(ps.length / verticesPerRow) - 1;\n          const cols = verticesPerRow - 1;\n\n          for (i = 0; i < rows; i++) {\n            let q = i * verticesPerRow;\n\n            for (let j = 0; j < cols; j++, q++) {\n              drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);\n              drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);\n            }\n          }\n\n          break;\n\n        case \"triangles\":\n          for (i = 0, ii = ps.length; i < ii; i += 3) {\n            drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);\n          }\n\n          break;\n\n        default:\n          throw new Error(\"illegal figure\");\n      }\n    }\n\n    function createMeshCanvas(bounds, combinesScale, coords, colors, figures, backgroundColor, cachedCanvases, webGLContext) {\n      const EXPECTED_SCALE = 1.1;\n      const MAX_PATTERN_SIZE = 3000;\n      const BORDER_SIZE = 2;\n      const offsetX = Math.floor(bounds[0]);\n      const offsetY = Math.floor(bounds[1]);\n      const boundsWidth = Math.ceil(bounds[2]) - offsetX;\n      const boundsHeight = Math.ceil(bounds[3]) - offsetY;\n      const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinesScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n      const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinesScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n      const scaleX = boundsWidth / width;\n      const scaleY = boundsHeight / height;\n      const context = {\n        coords,\n        colors,\n        offsetX: -offsetX,\n        offsetY: -offsetY,\n        scaleX: 1 / scaleX,\n        scaleY: 1 / scaleY\n      };\n      const paddedWidth = width + BORDER_SIZE * 2;\n      const paddedHeight = height + BORDER_SIZE * 2;\n      let canvas, tmpCanvas, i, ii;\n\n      if (webGLContext.isEnabled) {\n        canvas = webGLContext.drawFigures({\n          width,\n          height,\n          backgroundColor,\n          figures,\n          context\n        });\n        tmpCanvas = cachedCanvases.getCanvas(\"mesh\", paddedWidth, paddedHeight, false);\n        tmpCanvas.context.drawImage(canvas, BORDER_SIZE, BORDER_SIZE);\n        canvas = tmpCanvas.canvas;\n      } else {\n        tmpCanvas = cachedCanvases.getCanvas(\"mesh\", paddedWidth, paddedHeight, false);\n        const tmpCtx = tmpCanvas.context;\n        const data = tmpCtx.createImageData(width, height);\n\n        if (backgroundColor) {\n          const bytes = data.data;\n\n          for (i = 0, ii = bytes.length; i < ii; i += 4) {\n            bytes[i] = backgroundColor[0];\n            bytes[i + 1] = backgroundColor[1];\n            bytes[i + 2] = backgroundColor[2];\n            bytes[i + 3] = 255;\n          }\n        }\n\n        for (i = 0; i < figures.length; i++) {\n          drawFigure(data, figures[i], context);\n        }\n\n        tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);\n        canvas = tmpCanvas.canvas;\n      }\n\n      return {\n        canvas,\n        offsetX: offsetX - BORDER_SIZE * scaleX,\n        offsetY: offsetY - BORDER_SIZE * scaleY,\n        scaleX,\n        scaleY\n      };\n    }\n\n    return createMeshCanvas;\n  }();\n\n  ShadingIRs.Mesh = {\n    fromIR: function Mesh_fromIR(raw) {\n      const coords = raw[2];\n      const colors = raw[3];\n      const figures = raw[4];\n      const bounds = raw[5];\n      const matrix = raw[6];\n      const bbox = raw[7];\n      const background = raw[8];\n      return {\n        getPattern: function Mesh_getPattern(ctx, owner, shadingFill) {\n          applyBoundingBox(ctx, bbox);\n          let scale;\n\n          if (shadingFill) {\n            scale = _util.Util.singularValueDecompose2dScale(ctx.mozCurrentTransform);\n          } else {\n            scale = _util.Util.singularValueDecompose2dScale(owner.baseTransform);\n\n            if (matrix) {\n              const matrixScale = _util.Util.singularValueDecompose2dScale(matrix);\n\n              scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];\n            }\n          }\n\n          const temporaryPatternCanvas = createMeshCanvas(bounds, scale, coords, colors, figures, shadingFill ? null : background, owner.cachedCanvases, owner.webGLContext);\n\n          if (!shadingFill) {\n            ctx.setTransform.apply(ctx, owner.baseTransform);\n\n            if (matrix) {\n              ctx.transform.apply(ctx, matrix);\n            }\n          }\n\n          ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n          ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);\n          return ctx.createPattern(temporaryPatternCanvas.canvas, \"no-repeat\");\n        }\n      };\n    }\n  };\n  ShadingIRs.Dummy = {\n    fromIR: function Dummy_fromIR() {\n      return {\n        getPattern: function Dummy_fromIR_getPattern() {\n          return \"hotpink\";\n        }\n      };\n    }\n  };\n\n  function getShadingPatternFromIR(raw) {\n    const shadingIR = ShadingIRs[raw[0]];\n\n    if (!shadingIR) {\n      throw new Error(`Unknown IR type: ${raw[0]}`);\n    }\n\n    return shadingIR.fromIR(raw);\n  }\n\n  const TilingPattern = function TilingPatternClosure() {\n    const PaintType = {\n      COLORED: 1,\n      UNCOLORED: 2\n    };\n    const MAX_PATTERN_SIZE = 3000;\n\n    function TilingPattern(IR, color, ctx, canvasGraphicsFactory, baseTransform) {\n      this.operatorList = IR[2];\n      this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];\n      this.bbox = IR[4];\n      this.xstep = IR[5];\n      this.ystep = IR[6];\n      this.paintType = IR[7];\n      this.tilingType = IR[8];\n      this.color = color;\n      this.canvasGraphicsFactory = canvasGraphicsFactory;\n      this.baseTransform = baseTransform;\n      this.ctx = ctx;\n    }\n\n    TilingPattern.prototype = {\n      createPatternCanvas: function TilinPattern_createPatternCanvas(owner) {\n        const operatorList = this.operatorList;\n        const bbox = this.bbox;\n        const xstep = this.xstep;\n        const ystep = this.ystep;\n        const paintType = this.paintType;\n        const tilingType = this.tilingType;\n        const color = this.color;\n        const canvasGraphicsFactory = this.canvasGraphicsFactory;\n        (0, _util.info)(\"TilingType: \" + tilingType);\n        const x0 = bbox[0],\n              y0 = bbox[1],\n              x1 = bbox[2],\n              y1 = bbox[3];\n\n        const matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);\n\n        const curMatrixScale = _util.Util.singularValueDecompose2dScale(this.baseTransform);\n\n        const combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];\n        const dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);\n        const dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);\n        const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", dimx.size, dimy.size, true);\n        const tmpCtx = tmpCanvas.context;\n        const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);\n        graphics.groupLevel = owner.groupLevel;\n        this.setFillAndStrokeStyleToContext(graphics, paintType, color);\n        graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);\n        graphics.transform(1, 0, 0, 1, -x0, -y0);\n        this.clipBbox(graphics, bbox, x0, y0, x1, y1);\n        graphics.executeOperatorList(operatorList);\n        this.ctx.transform(1, 0, 0, 1, x0, y0);\n        this.ctx.scale(1 / dimx.scale, 1 / dimy.scale);\n        return tmpCanvas.canvas;\n      },\n      getSizeAndScale: function TilingPattern_getSizeAndScale(step, realOutputSize, scale) {\n        step = Math.abs(step);\n        const maxSize = Math.max(MAX_PATTERN_SIZE, realOutputSize);\n        let size = Math.ceil(step * scale);\n\n        if (size >= maxSize) {\n          size = maxSize;\n        } else {\n          scale = size / step;\n        }\n\n        return {\n          scale,\n          size\n        };\n      },\n      clipBbox: function clipBbox(graphics, bbox, x0, y0, x1, y1) {\n        if (Array.isArray(bbox) && bbox.length === 4) {\n          const bboxWidth = x1 - x0;\n          const bboxHeight = y1 - y0;\n          graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);\n          graphics.clip();\n          graphics.endPath();\n        }\n      },\n      setFillAndStrokeStyleToContext: function setFillAndStrokeStyleToContext(graphics, paintType, color) {\n        const context = graphics.ctx,\n              current = graphics.current;\n\n        switch (paintType) {\n          case PaintType.COLORED:\n            const ctx = this.ctx;\n            context.fillStyle = ctx.fillStyle;\n            context.strokeStyle = ctx.strokeStyle;\n            current.fillColor = ctx.fillStyle;\n            current.strokeColor = ctx.strokeStyle;\n            break;\n\n          case PaintType.UNCOLORED:\n            const cssColor = _util.Util.makeHexColor(color[0], color[1], color[2]);\n\n            context.fillStyle = cssColor;\n            context.strokeStyle = cssColor;\n            current.fillColor = cssColor;\n            current.strokeColor = cssColor;\n            break;\n\n          default:\n            throw new _util.FormatError(`Unsupported paint type: ${paintType}`);\n        }\n      },\n      getPattern: function TilingPattern_getPattern(ctx, owner) {\n        ctx = this.ctx;\n        ctx.setTransform.apply(ctx, this.baseTransform);\n        ctx.transform.apply(ctx, this.matrix);\n        const temporaryPatternCanvas = this.createPatternCanvas(owner);\n        return ctx.createPattern(temporaryPatternCanvas, \"repeat\");\n      }\n    };\n    return TilingPattern;\n  }();\n\n  exports.TilingPattern = TilingPattern;\n\n  /***/ }),\n  /* 12 */\n  /***/ ((__unused_webpack_module, exports) => {\n\n\n\n  Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n  }));\n  exports.GlobalWorkerOptions = void 0;\n  const GlobalWorkerOptions = Object.create(null);\n  exports.GlobalWorkerOptions = GlobalWorkerOptions;\n  GlobalWorkerOptions.workerPort = GlobalWorkerOptions.workerPort === undefined ? null : GlobalWorkerOptions.workerPort;\n  GlobalWorkerOptions.workerSrc = GlobalWorkerOptions.workerSrc === undefined ? \"\" : GlobalWorkerOptions.workerSrc;\n\n  /***/ }),\n  /* 13 */\n  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\n  Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n  }));\n  exports.MessageHandler = void 0;\n\n  var _util = __w_pdfjs_require__(2);\n\n  const CallbackKind = {\n    UNKNOWN: 0,\n    DATA: 1,\n    ERROR: 2\n  };\n  const StreamKind = {\n    UNKNOWN: 0,\n    CANCEL: 1,\n    CANCEL_COMPLETE: 2,\n    CLOSE: 3,\n    ENQUEUE: 4,\n    ERROR: 5,\n    PULL: 6,\n    PULL_COMPLETE: 7,\n    START_COMPLETE: 8\n  };\n\n  function wrapReason(reason) {\n    if (typeof reason !== \"object\" || reason === null) {\n      return reason;\n    }\n\n    switch (reason.name) {\n      case \"AbortException\":\n        return new _util.AbortException(reason.message);\n\n      case \"MissingPDFException\":\n        return new _util.MissingPDFException(reason.message);\n\n      case \"UnexpectedResponseException\":\n        return new _util.UnexpectedResponseException(reason.message, reason.status);\n\n      case \"UnknownErrorException\":\n        return new _util.UnknownErrorException(reason.message, reason.details);\n\n      default:\n        return new _util.UnknownErrorException(reason.message, reason.toString());\n    }\n  }\n\n  class MessageHandler {\n    constructor(sourceName, targetName, comObj) {\n      this.sourceName = sourceName;\n      this.targetName = targetName;\n      this.comObj = comObj;\n      this.callbackId = 1;\n      this.streamId = 1;\n      this.postMessageTransfers = true;\n      this.streamSinks = Object.create(null);\n      this.streamControllers = Object.create(null);\n      this.callbackCapabilities = Object.create(null);\n      this.actionHandler = Object.create(null);\n\n      this._onComObjOnMessage = event => {\n        const data = event.data;\n\n        if (data.targetName !== this.sourceName) {\n          return;\n        }\n\n        if (data.stream) {\n          this._processStreamMessage(data);\n\n          return;\n        }\n\n        if (data.callback) {\n          const callbackId = data.callbackId;\n          const capability = this.callbackCapabilities[callbackId];\n\n          if (!capability) {\n            throw new Error(`Cannot resolve callback ${callbackId}`);\n          }\n\n          delete this.callbackCapabilities[callbackId];\n\n          if (data.callback === CallbackKind.DATA) {\n            capability.resolve(data.data);\n          } else if (data.callback === CallbackKind.ERROR) {\n            capability.reject(wrapReason(data.reason));\n          } else {\n            throw new Error(\"Unexpected callback case\");\n          }\n\n          return;\n        }\n\n        const action = this.actionHandler[data.action];\n\n        if (!action) {\n          throw new Error(`Unknown action from worker: ${data.action}`);\n        }\n\n        if (data.callbackId) {\n          const cbSourceName = this.sourceName;\n          const cbTargetName = data.sourceName;\n          new Promise(function (resolve) {\n            resolve(action(data.data));\n          }).then(function (result) {\n            comObj.postMessage({\n              sourceName: cbSourceName,\n              targetName: cbTargetName,\n              callback: CallbackKind.DATA,\n              callbackId: data.callbackId,\n              data: result\n            });\n          }, function (reason) {\n            comObj.postMessage({\n              sourceName: cbSourceName,\n              targetName: cbTargetName,\n              callback: CallbackKind.ERROR,\n              callbackId: data.callbackId,\n              reason: wrapReason(reason)\n            });\n          });\n          return;\n        }\n\n        if (data.streamId) {\n          this._createStreamSink(data);\n\n          return;\n        }\n\n        action(data.data);\n      };\n\n      comObj.addEventListener(\"message\", this._onComObjOnMessage);\n    }\n\n    on(actionName, handler) {\n      const ah = this.actionHandler;\n\n      if (ah[actionName]) {\n        throw new Error(`There is already an actionName called \"${actionName}\"`);\n      }\n\n      ah[actionName] = handler;\n    }\n\n    send(actionName, data, transfers) {\n      this._postMessage({\n        sourceName: this.sourceName,\n        targetName: this.targetName,\n        action: actionName,\n        data\n      }, transfers);\n    }\n\n    sendWithPromise(actionName, data, transfers) {\n      const callbackId = this.callbackId++;\n      const capability = (0, _util.createPromiseCapability)();\n      this.callbackCapabilities[callbackId] = capability;\n\n      try {\n        this._postMessage({\n          sourceName: this.sourceName,\n          targetName: this.targetName,\n          action: actionName,\n          callbackId,\n          data\n        }, transfers);\n      } catch (ex) {\n        capability.reject(ex);\n      }\n\n      return capability.promise;\n    }\n\n    sendWithStream(actionName, data, queueingStrategy, transfers) {\n      const streamId = this.streamId++;\n      const sourceName = this.sourceName;\n      const targetName = this.targetName;\n      const comObj = this.comObj;\n      return new ReadableStream({\n        start: controller => {\n          const startCapability = (0, _util.createPromiseCapability)();\n          this.streamControllers[streamId] = {\n            controller,\n            startCall: startCapability,\n            pullCall: null,\n            cancelCall: null,\n            isClosed: false\n          };\n\n          this._postMessage({\n            sourceName,\n            targetName,\n            action: actionName,\n            streamId,\n            data,\n            desiredSize: controller.desiredSize\n          }, transfers);\n\n          return startCapability.promise;\n        },\n        pull: controller => {\n          const pullCapability = (0, _util.createPromiseCapability)();\n          this.streamControllers[streamId].pullCall = pullCapability;\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.PULL,\n            streamId,\n            desiredSize: controller.desiredSize\n          });\n          return pullCapability.promise;\n        },\n        cancel: reason => {\n          (0, _util.assert)(reason instanceof Error, \"cancel must have a valid reason\");\n          const cancelCapability = (0, _util.createPromiseCapability)();\n          this.streamControllers[streamId].cancelCall = cancelCapability;\n          this.streamControllers[streamId].isClosed = true;\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.CANCEL,\n            streamId,\n            reason: wrapReason(reason)\n          });\n          return cancelCapability.promise;\n        }\n      }, queueingStrategy);\n    }\n\n    _createStreamSink(data) {\n      const self = this;\n      const action = this.actionHandler[data.action];\n      const streamId = data.streamId;\n      const sourceName = this.sourceName;\n      const targetName = data.sourceName;\n      const comObj = this.comObj;\n      const streamSink = {\n        enqueue(chunk, size = 1, transfers) {\n          if (this.isCancelled) {\n            return;\n          }\n\n          const lastDesiredSize = this.desiredSize;\n          this.desiredSize -= size;\n\n          if (lastDesiredSize > 0 && this.desiredSize <= 0) {\n            this.sinkCapability = (0, _util.createPromiseCapability)();\n            this.ready = this.sinkCapability.promise;\n          }\n\n          self._postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.ENQUEUE,\n            streamId,\n            chunk\n          }, transfers);\n        },\n\n        close() {\n          if (this.isCancelled) {\n            return;\n          }\n\n          this.isCancelled = true;\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.CLOSE,\n            streamId\n          });\n          delete self.streamSinks[streamId];\n        },\n\n        error(reason) {\n          (0, _util.assert)(reason instanceof Error, \"error must have a valid reason\");\n\n          if (this.isCancelled) {\n            return;\n          }\n\n          this.isCancelled = true;\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.ERROR,\n            streamId,\n            reason: wrapReason(reason)\n          });\n        },\n\n        sinkCapability: (0, _util.createPromiseCapability)(),\n        onPull: null,\n        onCancel: null,\n        isCancelled: false,\n        desiredSize: data.desiredSize,\n        ready: null\n      };\n      streamSink.sinkCapability.resolve();\n      streamSink.ready = streamSink.sinkCapability.promise;\n      this.streamSinks[streamId] = streamSink;\n      new Promise(function (resolve) {\n        resolve(action(data.data, streamSink));\n      }).then(function () {\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.START_COMPLETE,\n          streamId,\n          success: true\n        });\n      }, function (reason) {\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.START_COMPLETE,\n          streamId,\n          reason: wrapReason(reason)\n        });\n      });\n    }\n\n    _processStreamMessage(data) {\n      const streamId = data.streamId;\n      const sourceName = this.sourceName;\n      const targetName = data.sourceName;\n      const comObj = this.comObj;\n\n      switch (data.stream) {\n        case StreamKind.START_COMPLETE:\n          if (data.success) {\n            this.streamControllers[streamId].startCall.resolve();\n          } else {\n            this.streamControllers[streamId].startCall.reject(wrapReason(data.reason));\n          }\n\n          break;\n\n        case StreamKind.PULL_COMPLETE:\n          if (data.success) {\n            this.streamControllers[streamId].pullCall.resolve();\n          } else {\n            this.streamControllers[streamId].pullCall.reject(wrapReason(data.reason));\n          }\n\n          break;\n\n        case StreamKind.PULL:\n          if (!this.streamSinks[streamId]) {\n            comObj.postMessage({\n              sourceName,\n              targetName,\n              stream: StreamKind.PULL_COMPLETE,\n              streamId,\n              success: true\n            });\n            break;\n          }\n\n          if (this.streamSinks[streamId].desiredSize <= 0 && data.desiredSize > 0) {\n            this.streamSinks[streamId].sinkCapability.resolve();\n          }\n\n          this.streamSinks[streamId].desiredSize = data.desiredSize;\n          const {\n            onPull\n          } = this.streamSinks[data.streamId];\n          new Promise(function (resolve) {\n            resolve(onPull && onPull());\n          }).then(function () {\n            comObj.postMessage({\n              sourceName,\n              targetName,\n              stream: StreamKind.PULL_COMPLETE,\n              streamId,\n              success: true\n            });\n          }, function (reason) {\n            comObj.postMessage({\n              sourceName,\n              targetName,\n              stream: StreamKind.PULL_COMPLETE,\n              streamId,\n              reason: wrapReason(reason)\n            });\n          });\n          break;\n\n        case StreamKind.ENQUEUE:\n          (0, _util.assert)(this.streamControllers[streamId], \"enqueue should have stream controller\");\n\n          if (this.streamControllers[streamId].isClosed) {\n            break;\n          }\n\n          this.streamControllers[streamId].controller.enqueue(data.chunk);\n          break;\n\n        case StreamKind.CLOSE:\n          (0, _util.assert)(this.streamControllers[streamId], \"close should have stream controller\");\n\n          if (this.streamControllers[streamId].isClosed) {\n            break;\n          }\n\n          this.streamControllers[streamId].isClosed = true;\n          this.streamControllers[streamId].controller.close();\n\n          this._deleteStreamController(streamId);\n\n          break;\n\n        case StreamKind.ERROR:\n          (0, _util.assert)(this.streamControllers[streamId], \"error should have stream controller\");\n          this.streamControllers[streamId].controller.error(wrapReason(data.reason));\n\n          this._deleteStreamController(streamId);\n\n          break;\n\n        case StreamKind.CANCEL_COMPLETE:\n          if (data.success) {\n            this.streamControllers[streamId].cancelCall.resolve();\n          } else {\n            this.streamControllers[streamId].cancelCall.reject(wrapReason(data.reason));\n          }\n\n          this._deleteStreamController(streamId);\n\n          break;\n\n        case StreamKind.CANCEL:\n          if (!this.streamSinks[streamId]) {\n            break;\n          }\n\n          const {\n            onCancel\n          } = this.streamSinks[data.streamId];\n          new Promise(function (resolve) {\n            resolve(onCancel && onCancel(wrapReason(data.reason)));\n          }).then(function () {\n            comObj.postMessage({\n              sourceName,\n              targetName,\n              stream: StreamKind.CANCEL_COMPLETE,\n              streamId,\n              success: true\n            });\n          }, function (reason) {\n            comObj.postMessage({\n              sourceName,\n              targetName,\n              stream: StreamKind.CANCEL_COMPLETE,\n              streamId,\n              reason: wrapReason(reason)\n            });\n          });\n          this.streamSinks[streamId].sinkCapability.reject(wrapReason(data.reason));\n          this.streamSinks[streamId].isCancelled = true;\n          delete this.streamSinks[streamId];\n          break;\n\n        default:\n          throw new Error(\"Unexpected stream case\");\n      }\n    }\n\n    async _deleteStreamController(streamId) {\n      await Promise.allSettled([this.streamControllers[streamId].startCall, this.streamControllers[streamId].pullCall, this.streamControllers[streamId].cancelCall].map(function (capability) {\n        return capability && capability.promise;\n      }));\n      delete this.streamControllers[streamId];\n    }\n\n    _postMessage(message, transfers) {\n      if (transfers && this.postMessageTransfers) {\n        this.comObj.postMessage(message, transfers);\n      } else {\n        this.comObj.postMessage(message);\n      }\n    }\n\n    destroy() {\n      this.comObj.removeEventListener(\"message\", this._onComObjOnMessage);\n    }\n\n  }\n\n  exports.MessageHandler = MessageHandler;\n\n  /***/ }),\n  /* 14 */\n  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\n  Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n  }));\n  exports.Metadata = void 0;\n\n  var _util = __w_pdfjs_require__(2);\n\n  var _xml_parser = __w_pdfjs_require__(15);\n\n  class Metadata {\n    constructor(data) {\n      (0, _util.assert)(typeof data === \"string\", \"Metadata: input is not a string\");\n      data = this._repair(data);\n      const parser = new _xml_parser.SimpleXMLParser({\n        lowerCaseName: true\n      });\n      const xmlDocument = parser.parseFromString(data);\n      this._metadataMap = new Map();\n\n      if (xmlDocument) {\n        this._parse(xmlDocument);\n      }\n\n      this._data = data;\n    }\n\n    _repair(data) {\n      return data.replace(/^[^<]+/, \"\").replace(/>\\\\376\\\\377([^<]+)/g, function (all, codes) {\n        const bytes = codes.replace(/\\\\([0-3])([0-7])([0-7])/g, function (code, d1, d2, d3) {\n          return String.fromCharCode(d1 * 64 + d2 * 8 + d3 * 1);\n        }).replace(/&(amp|apos|gt|lt|quot);/g, function (str, name) {\n          switch (name) {\n            case \"amp\":\n              return \"&\";\n\n            case \"apos\":\n              return \"'\";\n\n            case \"gt\":\n              return \">\";\n\n            case \"lt\":\n              return \"<\";\n\n            case \"quot\":\n              return '\"';\n          }\n\n          throw new Error(`_repair: ${name} isn't defined.`);\n        });\n        let chars = \"\";\n\n        for (let i = 0, ii = bytes.length; i < ii; i += 2) {\n          const code = bytes.charCodeAt(i) * 256 + bytes.charCodeAt(i + 1);\n\n          if (code >= 32 && code < 127 && code !== 60 && code !== 62 && code !== 38) {\n            chars += String.fromCharCode(code);\n          } else {\n            chars += \"&#x\" + (0x10000 + code).toString(16).substring(1) + \";\";\n          }\n        }\n\n        return \">\" + chars;\n      });\n    }\n\n    _getSequence(entry) {\n      const name = entry.nodeName;\n\n      if (name !== \"rdf:bag\" && name !== \"rdf:seq\" && name !== \"rdf:alt\") {\n        return null;\n      }\n\n      return entry.childNodes.filter(node => node.nodeName === \"rdf:li\");\n    }\n\n    _getCreators(entry) {\n      if (entry.nodeName !== \"dc:creator\") {\n        return false;\n      }\n\n      if (!entry.hasChildNodes()) {\n        return true;\n      }\n\n      const seqNode = entry.childNodes[0];\n      const authors = this._getSequence(seqNode) || [];\n\n      this._metadataMap.set(entry.nodeName, authors.map(node => node.textContent.trim()));\n\n      return true;\n    }\n\n    _parse(xmlDocument) {\n      let rdf = xmlDocument.documentElement;\n\n      if (rdf.nodeName !== \"rdf:rdf\") {\n        rdf = rdf.firstChild;\n\n        while (rdf && rdf.nodeName !== \"rdf:rdf\") {\n          rdf = rdf.nextSibling;\n        }\n      }\n\n      if (!rdf || rdf.nodeName !== \"rdf:rdf\" || !rdf.hasChildNodes()) {\n        return;\n      }\n\n      for (const desc of rdf.childNodes) {\n        if (desc.nodeName !== \"rdf:description\") {\n          continue;\n        }\n\n        for (const entry of desc.childNodes) {\n          const name = entry.nodeName;\n\n          if (name === \"#text\") {\n            continue;\n          }\n\n          if (this._getCreators(entry)) {\n            continue;\n          }\n\n          this._metadataMap.set(name, entry.textContent.trim());\n        }\n      }\n    }\n\n    getRaw() {\n      return this._data;\n    }\n\n    get(name) {\n      return this._metadataMap.get(name) || null; //lwf\n    }\n\n    getAll() {\n      return (0, _util.objectFromEntries)(this._metadataMap);\n    }\n\n    has(name) {\n      return this._metadataMap.has(name);\n    }\n\n  }\n\n  exports.Metadata = Metadata;\n\n  /***/ }),\n  /* 15 */\n  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\n  Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n  }));\n  exports.SimpleXMLParser = exports.SimpleDOMNode = void 0;\n\n  var _util = __w_pdfjs_require__(2);\n\n  const XMLParserErrorCode = {\n    NoError: 0,\n    EndOfDocument: -1,\n    UnterminatedCdat: -2,\n    UnterminatedXmlDeclaration: -3,\n    UnterminatedDoctypeDeclaration: -4,\n    UnterminatedComment: -5,\n    MalformedElement: -6,\n    OutOfMemory: -7,\n    UnterminatedAttributeValue: -8,\n    UnterminatedElement: -9,\n    ElementNeverBegun: -10\n  };\n\n  function isWhitespace(s, index) {\n    const ch = s[index];\n    return ch === \" \" || ch === \"\\n\" || ch === \"\\r\" || ch === \"\\t\";\n  }\n\n  function isWhitespaceString(s) {\n    for (let i = 0, ii = s.length; i < ii; i++) {\n      if (!isWhitespace(s, i)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  class XMLParserBase {\n    _resolveEntities(s) {\n      return s.replace(/&([^;]+);/g, (all, entity) => {\n        if (entity.substring(0, 2) === \"#x\") {\n          return String.fromCodePoint(parseInt(entity.substring(2), 16));\n        } else if (entity.substring(0, 1) === \"#\") {\n          return String.fromCodePoint(parseInt(entity.substring(1), 10));\n        }\n\n        switch (entity) {\n          case \"lt\":\n            return \"<\";\n\n          case \"gt\":\n            return \">\";\n\n          case \"amp\":\n            return \"&\";\n\n          case \"quot\":\n            return '\"';\n        }\n\n        return this.onResolveEntity(entity);\n      });\n    }\n\n    _parseContent(s, start) {\n      const attributes = [];\n      let pos = start;\n\n      function skipWs() {\n        while (pos < s.length && isWhitespace(s, pos)) {\n          ++pos;\n        }\n      }\n\n      while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== \">\" && s[pos] !== \"/\") {\n        ++pos;\n      }\n\n      const name = s.substring(start, pos);\n      skipWs();\n\n      while (pos < s.length && s[pos] !== \">\" && s[pos] !== \"/\" && s[pos] !== \"?\") {\n        skipWs();\n        let attrName = \"\",\n            attrValue = \"\";\n\n        while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== \"=\") {\n          attrName += s[pos];\n          ++pos;\n        }\n\n        skipWs();\n\n        if (s[pos] !== \"=\") {\n          return null;\n        }\n\n        ++pos;\n        skipWs();\n        const attrEndChar = s[pos];\n\n        if (attrEndChar !== '\"' && attrEndChar !== \"'\") {\n          return null;\n        }\n\n        const attrEndIndex = s.indexOf(attrEndChar, ++pos);\n\n        if (attrEndIndex < 0) {\n          return null;\n        }\n\n        attrValue = s.substring(pos, attrEndIndex);\n        attributes.push({\n          name: attrName,\n          value: this._resolveEntities(attrValue)\n        });\n        pos = attrEndIndex + 1;\n        skipWs();\n      }\n\n      return {\n        name,\n        attributes,\n        parsed: pos - start\n      };\n    }\n\n    _parseProcessingInstruction(s, start) {\n      let pos = start;\n\n      function skipWs() {\n        while (pos < s.length && isWhitespace(s, pos)) {\n          ++pos;\n        }\n      }\n\n      while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== \">\" && s[pos] !== \"/\") {\n        ++pos;\n      }\n\n      const name = s.substring(start, pos);\n      skipWs();\n      const attrStart = pos;\n\n      while (pos < s.length && (s[pos] !== \"?\" || s[pos + 1] !== \">\")) {\n        ++pos;\n      }\n\n      const value = s.substring(attrStart, pos);\n      return {\n        name,\n        value,\n        parsed: pos - start\n      };\n    }\n\n    parseXml(s) {\n      let i = 0;\n\n      while (i < s.length) {\n        const ch = s[i];\n        let j = i;\n\n        if (ch === \"<\") {\n          ++j;\n          const ch2 = s[j];\n          let q;\n\n          switch (ch2) {\n            case \"/\":\n              ++j;\n              q = s.indexOf(\">\", j);\n\n              if (q < 0) {\n                this.onError(XMLParserErrorCode.UnterminatedElement);\n                return;\n              }\n\n              this.onEndElement(s.substring(j, q));\n              j = q + 1;\n              break;\n\n            case \"?\":\n              ++j;\n\n              const pi = this._parseProcessingInstruction(s, j);\n\n              if (s.substring(j + pi.parsed, j + pi.parsed + 2) !== \"?>\") {\n                this.onError(XMLParserErrorCode.UnterminatedXmlDeclaration);\n                return;\n              }\n\n              this.onPi(pi.name, pi.value);\n              j += pi.parsed + 2;\n              break;\n\n            case \"!\":\n              if (s.substring(j + 1, j + 3) === \"--\") {\n                q = s.indexOf(\"-->\", j + 3);\n\n                if (q < 0) {\n                  this.onError(XMLParserErrorCode.UnterminatedComment);\n                  return;\n                }\n\n                this.onComment(s.substring(j + 3, q));\n                j = q + 3;\n              } else if (s.substring(j + 1, j + 8) === \"[CDATA[\") {\n                q = s.indexOf(\"]]>\", j + 8);\n\n                if (q < 0) {\n                  this.onError(XMLParserErrorCode.UnterminatedCdat);\n                  return;\n                }\n\n                this.onCdata(s.substring(j + 8, q));\n                j = q + 3;\n              } else if (s.substring(j + 1, j + 8) === \"DOCTYPE\") {\n                const q2 = s.indexOf(\"[\", j + 8);\n                let complexDoctype = false;\n                q = s.indexOf(\">\", j + 8);\n\n                if (q < 0) {\n                  this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);\n                  return;\n                }\n\n                if (q2 > 0 && q > q2) {\n                  q = s.indexOf(\"]>\", j + 8);\n\n                  if (q < 0) {\n                    this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);\n                    return;\n                  }\n\n                  complexDoctype = true;\n                }\n\n                const doctypeContent = s.substring(j + 8, q + (complexDoctype ? 1 : 0));\n                this.onDoctype(doctypeContent);\n                j = q + (complexDoctype ? 2 : 1);\n              } else {\n                this.onError(XMLParserErrorCode.MalformedElement);\n                return;\n              }\n\n              break;\n\n            default:\n              const content = this._parseContent(s, j);\n\n              if (content === null) {\n                this.onError(XMLParserErrorCode.MalformedElement);\n                return;\n              }\n\n              let isClosed = false;\n\n              if (s.substring(j + content.parsed, j + content.parsed + 2) === \"/>\") {\n                isClosed = true;\n              } else if (s.substring(j + content.parsed, j + content.parsed + 1) !== \">\") {\n                this.onError(XMLParserErrorCode.UnterminatedElement);\n                return;\n              }\n\n              this.onBeginElement(content.name, content.attributes, isClosed);\n              j += content.parsed + (isClosed ? 2 : 1);\n              break;\n          }\n        } else {\n          while (j < s.length && s[j] !== \"<\") {\n            j++;\n          }\n\n          const text = s.substring(i, j);\n          this.onText(this._resolveEntities(text));\n        }\n\n        i = j;\n      }\n    }\n\n    onResolveEntity(name) {\n      return `&${name};`;\n    }\n\n    onPi(name, value) {}\n\n    onComment(text) {}\n\n    onCdata(text) {}\n\n    onDoctype(doctypeContent) {}\n\n    onText(text) {}\n\n    onBeginElement(name, attributes, isEmpty) {}\n\n    onEndElement(name) {}\n\n    onError(code) {}\n\n  }\n\n  class SimpleDOMNode {\n    constructor(nodeName, nodeValue) {\n      this.nodeName = nodeName;\n      this.nodeValue = nodeValue;\n      Object.defineProperty(this, \"parentNode\", {\n        value: null,\n        writable: true\n      });\n    }\n\n    get firstChild() {\n      return this.childNodes && this.childNodes[0];\n    }\n\n    get nextSibling() {\n      const childNodes = this.parentNode.childNodes;\n\n      if (!childNodes) {\n        return undefined;\n      }\n\n      const index = childNodes.indexOf(this);\n\n      if (index === -1) {\n        return undefined;\n      }\n\n      return childNodes[index + 1];\n    }\n\n    get textContent() {\n      if (!this.childNodes) {\n        return this.nodeValue || \"\";\n      }\n\n      return this.childNodes.map(function (child) {\n        return child.textContent;\n      }).join(\"\");\n    }\n\n    hasChildNodes() {\n      return this.childNodes && this.childNodes.length > 0;\n    }\n\n    searchNode(paths, pos) {\n      if (pos >= paths.length) {\n        return this;\n      }\n\n      const component = paths[pos];\n      const stack = [];\n      let node = this;\n\n      while (true) {\n        if (component.name === node.nodeName) {\n          if (component.pos === 0) {\n            const res = node.searchNode(paths, pos + 1);\n\n            if (res !== null) {\n              return res;\n            }\n          } else if (stack.length === 0) {\n            return null;\n          } else {\n            const [parent] = stack.pop();\n            let siblingPos = 0;\n\n            for (const child of parent.childNodes) {\n              if (component.name === child.nodeName) {\n                if (siblingPos === component.pos) {\n                  return child.searchNode(paths, pos + 1);\n                }\n\n                siblingPos++;\n              }\n            }\n\n            return node.searchNode(paths, pos + 1);\n          }\n        }\n\n        if (node.childNodes && node.childNodes.length !== 0) {\n          stack.push([node, 0]);\n          node = node.childNodes[0];\n        } else if (stack.length === 0) {\n          return null;\n        } else {\n          while (stack.length !== 0) {\n            const [parent, currentPos] = stack.pop();\n            const newPos = currentPos + 1;\n\n            if (newPos < parent.childNodes.length) {\n              stack.push([parent, newPos]);\n              node = parent.childNodes[newPos];\n              break;\n            }\n          }\n\n          if (stack.length === 0) {\n            return null;\n          }\n        }\n      }\n    }\n\n    dump(buffer) {\n      if (this.nodeName === \"#text\") {\n        buffer.push((0, _util.encodeToXmlString)(this.nodeValue));\n        return;\n      }\n\n      buffer.push(`<${this.nodeName}`);\n\n      if (this.attributes) {\n        for (const attribute of this.attributes) {\n          buffer.push(` ${attribute.name}=\"${(0, _util.encodeToXmlString)(attribute.value)}\"`);\n        }\n      }\n\n      if (this.hasChildNodes()) {\n        buffer.push(\">\");\n\n        for (const child of this.childNodes) {\n          child.dump(buffer);\n        }\n\n        buffer.push(`</${this.nodeName}>`);\n      } else if (this.nodeValue) {\n        buffer.push(`>${(0, _util.encodeToXmlString)(this.nodeValue)}</${this.nodeName}>`);\n      } else {\n        buffer.push(\"/>\");\n      }\n    }\n\n  }\n\n  exports.SimpleDOMNode = SimpleDOMNode;\n\n  class SimpleXMLParser extends XMLParserBase {\n    constructor({\n      hasAttributes = false,\n      lowerCaseName = false\n    }) {\n      super();\n      this._currentFragment = null;\n      this._stack = null;\n      this._errorCode = XMLParserErrorCode.NoError;\n      this._hasAttributes = hasAttributes;\n      this._lowerCaseName = lowerCaseName;\n    }\n\n    parseFromString(data) {\n      this._currentFragment = [];\n      this._stack = [];\n      this._errorCode = XMLParserErrorCode.NoError;\n      this.parseXml(data);\n\n      if (this._errorCode !== XMLParserErrorCode.NoError) {\n        return undefined;\n      }\n\n      const [documentElement] = this._currentFragment;\n\n      if (!documentElement) {\n        return undefined;\n      }\n\n      return {\n        documentElement\n      };\n    }\n\n    onResolveEntity(name) {\n      switch (name) {\n        case \"apos\":\n          return \"'\";\n      }\n\n      return super.onResolveEntity(name);\n    }\n\n    onText(text) {\n      if (isWhitespaceString(text)) {\n        return;\n      }\n\n      const node = new SimpleDOMNode(\"#text\", text);\n\n      this._currentFragment.push(node);\n    }\n\n    onCdata(text) {\n      const node = new SimpleDOMNode(\"#text\", text);\n\n      this._currentFragment.push(node);\n    }\n\n    onBeginElement(name, attributes, isEmpty) {\n      if (this._lowerCaseName) {\n        name = name.toLowerCase();\n      }\n\n      const node = new SimpleDOMNode(name);\n      node.childNodes = [];\n\n      if (this._hasAttributes) {\n        node.attributes = attributes;\n      }\n\n      this._currentFragment.push(node);\n\n      if (isEmpty) {\n        return;\n      }\n\n      this._stack.push(this._currentFragment);\n\n      this._currentFragment = node.childNodes;\n    }\n\n    onEndElement(name) {\n      this._currentFragment = this._stack.pop() || [];\n      const lastElement = this._currentFragment[this._currentFragment.length - 1];\n\n      if (!lastElement) {\n        return;\n      }\n\n      for (let i = 0, ii = lastElement.childNodes.length; i < ii; i++) {\n        lastElement.childNodes[i].parentNode = lastElement;\n      }\n    }\n\n    onError(code) {\n      this._errorCode = code;\n    }\n\n  }\n\n  exports.SimpleXMLParser = SimpleXMLParser;\n\n  /***/ }),\n  /* 16 */\n  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\n  Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n  }));\n  exports.OptionalContentConfig = void 0;\n\n  var _util = __w_pdfjs_require__(2);\n\n  class OptionalContentGroup {\n    constructor(name, intent) {\n      this.visible = true;\n      this.name = name;\n      this.intent = intent;\n    }\n\n  }\n\n  class OptionalContentConfig {\n    constructor(data) {\n      this.name = null;\n      this.creator = null;\n      this._order = null;\n      this._groups = new Map();\n\n      if (data === null) {\n        return;\n      }\n\n      this.name = data.name;\n      this.creator = data.creator;\n      this._order = data.order;\n\n      for (const group of data.groups) {\n        this._groups.set(group.id, new OptionalContentGroup(group.name, group.intent));\n      }\n\n      if (data.baseState === \"OFF\") {\n        for (const group of this._groups) {\n          group.visible = false;\n        }\n      }\n\n      for (const on of data.on) {\n        this._groups.get(on).visible = true;\n      }\n\n      for (const off of data.off) {\n        this._groups.get(off).visible = false;\n      }\n    }\n\n    isVisible(group) {\n      if (group.type === \"OCG\") {\n        if (!this._groups.has(group.id)) {\n          (0, _util.warn)(`Optional content group not found: ${group.id}`);\n          return true;\n        }\n\n        return this._groups.get(group.id).visible;\n      } else if (group.type === \"OCMD\") {\n        if (group.expression) {\n          (0, _util.warn)(\"Visibility expression not supported yet.\");\n        }\n\n        if (!group.policy || group.policy === \"AnyOn\") {\n          for (const id of group.ids) {\n            if (!this._groups.has(id)) {\n              (0, _util.warn)(`Optional content group not found: ${id}`);\n              return true;\n            }\n\n            if (this._groups.get(id).visible) {\n              return true;\n            }\n          }\n\n          return false;\n        } else if (group.policy === \"AllOn\") {\n          for (const id of group.ids) {\n            if (!this._groups.has(id)) {\n              (0, _util.warn)(`Optional content group not found: ${id}`);\n              return true;\n            }\n\n            if (!this._groups.get(id).visible) {\n              return false;\n            }\n          }\n\n          return true;\n        } else if (group.policy === \"AnyOff\") {\n          for (const id of group.ids) {\n            if (!this._groups.has(id)) {\n              (0, _util.warn)(`Optional content group not found: ${id}`);\n              return true;\n            }\n\n            if (!this._groups.get(id).visible) {\n              return true;\n            }\n          }\n\n          return false;\n        } else if (group.policy === \"AllOff\") {\n          for (const id of group.ids) {\n            if (!this._groups.has(id)) {\n              (0, _util.warn)(`Optional content group not found: ${id}`);\n              return true;\n            }\n\n            if (this._groups.get(id).visible) {\n              return false;\n            }\n          }\n\n          return true;\n        }\n\n        (0, _util.warn)(`Unknown optional content policy ${group.policy}.`);\n        return true;\n      }\n\n      (0, _util.warn)(`Unknown group type ${group.type}.`);\n      return true;\n    }\n\n    setVisibility(id, visible = true) {\n      if (!this._groups.has(id)) {\n        (0, _util.warn)(`Optional content group not found: ${id}`);\n        return;\n      }\n\n      this._groups.get(id).visible = !!visible;\n    }\n\n    getOrder() {\n      if (!this._groups.size) {\n        return null;\n      }\n\n      if (this._order) {\n        return this._order.slice();\n      }\n\n      return Array.from(this._groups.keys());\n    }\n\n    getGroups() {\n      if (!this._groups.size) {\n        return null;\n      }\n\n      return (0, _util.objectFromEntries)(this._groups);\n    }\n\n    getGroup(id) {\n      return this._groups.get(id) || null;\n    }\n\n  }\n\n  exports.OptionalContentConfig = OptionalContentConfig;\n\n  /***/ }),\n  /* 17 */\n  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\n  Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n  }));\n  exports.PDFDataTransportStream = void 0;\n\n  var _util = __w_pdfjs_require__(2);\n\n  class PDFDataTransportStream {\n    constructor(params, pdfDataRangeTransport) {\n      (0, _util.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required \"pdfDataRangeTransport\" argument.');\n      this._queuedChunks = [];\n      this._progressiveDone = params.progressiveDone || false;\n      const initialData = params.initialData;\n\n      if (initialData && initialData.length > 0) { // lwf\n        const buffer = new Uint8Array(initialData).buffer;\n\n        this._queuedChunks.push(buffer);\n      }\n\n      this._pdfDataRangeTransport = pdfDataRangeTransport;\n      this._isStreamingSupported = !params.disableStream;\n      this._isRangeSupported = !params.disableRange;\n      this._contentLength = params.length;\n      this._fullRequestReader = null;\n      this._rangeReaders = [];\n\n      this._pdfDataRangeTransport.addRangeListener((begin, chunk) => {\n        this._onReceiveData({\n          begin,\n          chunk\n        });\n      });\n\n      this._pdfDataRangeTransport.addProgressListener((loaded, total) => {\n        this._onProgress({\n          loaded,\n          total\n        });\n      });\n\n      this._pdfDataRangeTransport.addProgressiveReadListener(chunk => {\n        this._onReceiveData({\n          chunk\n        });\n      });\n\n      this._pdfDataRangeTransport.addProgressiveDoneListener(() => {\n        this._onProgressiveDone();\n      });\n\n      this._pdfDataRangeTransport.transportReady();\n    }\n\n    _onReceiveData(args) {\n      const buffer = new Uint8Array(args.chunk).buffer;\n\n      if (args.begin === undefined) {\n        if (this._fullRequestReader) {\n          this._fullRequestReader._enqueue(buffer);\n        } else {\n          this._queuedChunks.push(buffer);\n        }\n      } else {\n        const found = this._rangeReaders.some(function (rangeReader) {\n          if (rangeReader._begin !== args.begin) {\n            return false;\n          }\n\n          rangeReader._enqueue(buffer);\n\n          return true;\n        });\n\n        (0, _util.assert)(found, \"_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.\");\n      }\n    }\n\n    get _progressiveDataLength() {\n      return this._fullRequestReader && this._fullRequestReader._loaded || 0; // lwf\n    }\n\n    _onProgress(evt) {\n      if (evt.total === undefined) {\n        const firstReader = this._rangeReaders[0];\n\n        if (firstReader && firstReader.onProgress) { // lwf\n          firstReader.onProgress({\n            loaded: evt.loaded\n          });\n        }\n      } else {\n        const fullReader = this._fullRequestReader;\n\n        if (fullReader && fullReader.onProgress) { // lwf\n          fullReader.onProgress({\n            loaded: evt.loaded,\n            total: evt.total\n          });\n        }\n      }\n    }\n\n    _onProgressiveDone() {\n      if (this._fullRequestReader) {\n        this._fullRequestReader.progressiveDone();\n      }\n\n      this._progressiveDone = true;\n    }\n\n    _removeRangeReader(reader) {\n      const i = this._rangeReaders.indexOf(reader);\n\n      if (i >= 0) {\n        this._rangeReaders.splice(i, 1);\n      }\n    }\n\n    getFullReader() {\n      (0, _util.assert)(!this._fullRequestReader, \"PDFDataTransportStream.getFullReader can only be called once.\");\n      const queuedChunks = this._queuedChunks;\n      this._queuedChunks = null;\n      return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone);\n    }\n\n    getRangeReader(begin, end) {\n      if (end <= this._progressiveDataLength) {\n        return null;\n      }\n\n      const reader = new PDFDataTransportStreamRangeReader(this, begin, end);\n\n      this._pdfDataRangeTransport.requestDataRange(begin, end);\n\n      this._rangeReaders.push(reader);\n\n      return reader;\n    }\n\n    cancelAllRequests(reason) {\n      if (this._fullRequestReader) {\n        this._fullRequestReader.cancel(reason);\n      }\n\n      const readers = this._rangeReaders.slice(0);\n\n      readers.forEach(function (rangeReader) {\n        rangeReader.cancel(reason);\n      });\n\n      this._pdfDataRangeTransport.abort();\n    }\n\n  }\n\n  exports.PDFDataTransportStream = PDFDataTransportStream;\n\n  class PDFDataTransportStreamReader {\n    constructor(stream, queuedChunks, progressiveDone = false) {\n      this._stream = stream;\n      this._done = progressiveDone || false;\n      this._filename = null;\n      this._queuedChunks = queuedChunks || [];\n      this._loaded = 0;\n\n      for (const chunk of this._queuedChunks) {\n        this._loaded += chunk.byteLength;\n      }\n\n      this._requests = [];\n      this._headersReady = Promise.resolve();\n      stream._fullRequestReader = this;\n      this.onProgress = null;\n    }\n\n    _enqueue(chunk) {\n      if (this._done) {\n        return;\n      }\n\n      if (this._requests.length > 0) {\n        const requestCapability = this._requests.shift();\n\n        requestCapability.resolve({\n          value: chunk,\n          done: false\n        });\n      } else {\n        this._queuedChunks.push(chunk);\n      }\n\n      this._loaded += chunk.byteLength;\n    }\n\n    get headersReady() {\n      return this._headersReady;\n    }\n\n    get filename() {\n      return this._filename;\n    }\n\n    get isRangeSupported() {\n      return this._stream._isRangeSupported;\n    }\n\n    get isStreamingSupported() {\n      return this._stream._isStreamingSupported;\n    }\n\n    get contentLength() {\n      return this._stream._contentLength;\n    }\n\n    async read() {\n      if (this._queuedChunks.length > 0) {\n        const chunk = this._queuedChunks.shift();\n\n        return {\n          value: chunk,\n          done: false\n        };\n      }\n\n      if (this._done) {\n        return {\n          value: undefined,\n          done: true\n        };\n      }\n\n      const requestCapability = (0, _util.createPromiseCapability)();\n\n      this._requests.push(requestCapability);\n\n      return requestCapability.promise;\n    }\n\n    cancel(reason) {\n      this._done = true;\n\n      this._requests.forEach(function (requestCapability) {\n        requestCapability.resolve({\n          value: undefined,\n          done: true\n        });\n      });\n\n      this._requests = [];\n    }\n\n    progressiveDone() {\n      if (this._done) {\n        return;\n      }\n\n      this._done = true;\n    }\n\n  }\n\n  class PDFDataTransportStreamRangeReader {\n    constructor(stream, begin, end) {\n      this._stream = stream;\n      this._begin = begin;\n      this._end = end;\n      this._queuedChunk = null;\n      this._requests = [];\n      this._done = false;\n      this.onProgress = null;\n    }\n\n    _enqueue(chunk) {\n      if (this._done) {\n        return;\n      }\n\n      if (this._requests.length === 0) {\n        this._queuedChunk = chunk;\n      } else {\n        const requestsCapability = this._requests.shift();\n\n        requestsCapability.resolve({\n          value: chunk,\n          done: false\n        });\n\n        this._requests.forEach(function (requestCapability) {\n          requestCapability.resolve({\n            value: undefined,\n            done: true\n          });\n        });\n\n        this._requests = [];\n      }\n\n      this._done = true;\n\n      this._stream._removeRangeReader(this);\n    }\n\n    get isStreamingSupported() {\n      return false;\n    }\n\n    async read() {\n      if (this._queuedChunk) {\n        const chunk = this._queuedChunk;\n        this._queuedChunk = null;\n        return {\n          value: chunk,\n          done: false\n        };\n      }\n\n      if (this._done) {\n        return {\n          value: undefined,\n          done: true\n        };\n      }\n\n      const requestCapability = (0, _util.createPromiseCapability)();\n\n      this._requests.push(requestCapability);\n\n      return requestCapability.promise;\n    }\n\n    cancel(reason) {\n      this._done = true;\n\n      this._requests.forEach(function (requestCapability) {\n        requestCapability.resolve({\n          value: undefined,\n          done: true\n        });\n      });\n\n      this._requests = [];\n\n      this._stream._removeRangeReader(this);\n    }\n\n  }\n\n  /***/ }),\n  /* 18 */\n  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\n  Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n  }));\n  exports.WebGLContext = void 0;\n\n  var _util = __w_pdfjs_require__(2);\n\n  class WebGLContext {\n    constructor({\n      enable = false\n    }) {\n      this._enabled = enable === true;\n    }\n\n    get isEnabled() {\n      let enabled = this._enabled;\n\n      if (enabled) {\n        enabled = WebGLUtils.tryInitGL();\n      }\n\n      return (0, _util.shadow)(this, \"isEnabled\", enabled);\n    }\n\n    composeSMask({\n      layer,\n      mask,\n      properties\n    }) {\n      return WebGLUtils.composeSMask(layer, mask, properties);\n    }\n\n    drawFigures({\n      width,\n      height,\n      backgroundColor,\n      figures,\n      context\n    }) {\n      return WebGLUtils.drawFigures(width, height, backgroundColor, figures, context);\n    }\n\n    clear() {\n      WebGLUtils.cleanup();\n    }\n\n  }\n\n  exports.WebGLContext = WebGLContext;\n\n  const WebGLUtils = function WebGLUtilsClosure() {\n    function loadShader(gl, code, shaderType) {\n      const shader = gl.createShader(shaderType);\n      gl.shaderSource(shader, code);\n      gl.compileShader(shader);\n      const compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n\n      if (!compiled) {\n        const errorMsg = gl.getShaderInfoLog(shader);\n        throw new Error(\"Error during shader compilation: \" + errorMsg);\n      }\n\n      return shader;\n    }\n\n    function createVertexShader(gl, code) {\n      return loadShader(gl, code, gl.VERTEX_SHADER);\n    }\n\n    function createFragmentShader(gl, code) {\n      return loadShader(gl, code, gl.FRAGMENT_SHADER);\n    }\n\n    function createProgram(gl, shaders) {\n      const program = gl.createProgram();\n\n      for (let i = 0, ii = shaders.length; i < ii; ++i) {\n        gl.attachShader(program, shaders[i]);\n      }\n\n      gl.linkProgram(program);\n      const linked = gl.getProgramParameter(program, gl.LINK_STATUS);\n\n      if (!linked) {\n        const errorMsg = gl.getProgramInfoLog(program);\n        throw new Error(\"Error during program linking: \" + errorMsg);\n      }\n\n      return program;\n    }\n\n    function createTexture(gl, image, textureId) {\n      gl.activeTexture(textureId);\n      const texture = gl.createTexture();\n      gl.bindTexture(gl.TEXTURE_2D, texture);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\n      return texture;\n    }\n\n    let currentGL, currentCanvas;\n\n    function generateGL() {\n      if (currentGL) {\n        return;\n      }\n\n      currentCanvas = document.createElement(\"canvas\");\n      currentGL = currentCanvas.getContext(\"webgl\", {\n        premultipliedalpha: false\n      });\n    }\n\n    const smaskVertexShaderCode = \"\\\n    attribute vec2 a_position;                                    \\\n    attribute vec2 a_texCoord;                                    \\\n                                                                  \\\n    uniform vec2 u_resolution;                                    \\\n                                                                  \\\n    varying vec2 v_texCoord;                                      \\\n                                                                  \\\n    void main() {                                                 \\\n      vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;   \\\n      gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);          \\\n                                                                  \\\n      v_texCoord = a_texCoord;                                    \\\n    }                                                             \";\n    const smaskFragmentShaderCode = \"\\\n    precision mediump float;                                      \\\n                                                                  \\\n    uniform vec4 u_backdrop;                                      \\\n    uniform int u_subtype;                                        \\\n    uniform sampler2D u_image;                                    \\\n    uniform sampler2D u_mask;                                     \\\n                                                                  \\\n    varying vec2 v_texCoord;                                      \\\n                                                                  \\\n    void main() {                                                 \\\n      vec4 imageColor = texture2D(u_image, v_texCoord);           \\\n      vec4 maskColor = texture2D(u_mask, v_texCoord);             \\\n      if (u_backdrop.a > 0.0) {                                   \\\n        maskColor.rgb = maskColor.rgb * maskColor.a +             \\\n                        u_backdrop.rgb * (1.0 - maskColor.a);     \\\n      }                                                           \\\n      float lum;                                                  \\\n      if (u_subtype == 0) {                                       \\\n        lum = maskColor.a;                                        \\\n      } else {                                                    \\\n        lum = maskColor.r * 0.3 + maskColor.g * 0.59 +            \\\n              maskColor.b * 0.11;                                 \\\n      }                                                           \\\n      imageColor.a *= lum;                                        \\\n      imageColor.rgb *= imageColor.a;                             \\\n      gl_FragColor = imageColor;                                  \\\n    }                                                             \";\n    let smaskCache = null;\n\n    function initSmaskGL() {\n      generateGL();\n      const canvas = currentCanvas;\n      currentCanvas = null;\n      const gl = currentGL;\n      currentGL = null;\n      const vertexShader = createVertexShader(gl, smaskVertexShaderCode);\n      const fragmentShader = createFragmentShader(gl, smaskFragmentShaderCode);\n      const program = createProgram(gl, [vertexShader, fragmentShader]);\n      gl.useProgram(program);\n      const cache = {};\n      cache.gl = gl;\n      cache.canvas = canvas;\n      cache.resolutionLocation = gl.getUniformLocation(program, \"u_resolution\");\n      cache.positionLocation = gl.getAttribLocation(program, \"a_position\");\n      cache.backdropLocation = gl.getUniformLocation(program, \"u_backdrop\");\n      cache.subtypeLocation = gl.getUniformLocation(program, \"u_subtype\");\n      const texCoordLocation = gl.getAttribLocation(program, \"a_texCoord\");\n      const texLayerLocation = gl.getUniformLocation(program, \"u_image\");\n      const texMaskLocation = gl.getUniformLocation(program, \"u_mask\");\n      const texCoordBuffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);\n      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), gl.STATIC_DRAW);\n      gl.enableVertexAttribArray(texCoordLocation);\n      gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);\n      gl.uniform1i(texLayerLocation, 0);\n      gl.uniform1i(texMaskLocation, 1);\n      smaskCache = cache;\n    }\n\n    function composeSMask(layer, mask, properties) {\n      const width = layer.width,\n            height = layer.height;\n\n      if (!smaskCache) {\n        initSmaskGL();\n      }\n\n      const cache = smaskCache,\n            canvas = cache.canvas,\n            gl = cache.gl;\n      canvas.width = width;\n      canvas.height = height;\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n      gl.uniform2f(cache.resolutionLocation, width, height);\n\n      if (properties.backdrop) {\n        gl.uniform4f(cache.resolutionLocation, properties.backdrop[0], properties.backdrop[1], properties.backdrop[2], 1);\n      } else {\n        gl.uniform4f(cache.resolutionLocation, 0, 0, 0, 0);\n      }\n\n      gl.uniform1i(cache.subtypeLocation, properties.subtype === \"Luminosity\" ? 1 : 0);\n      const texture = createTexture(gl, layer, gl.TEXTURE0);\n      const maskTexture = createTexture(gl, mask, gl.TEXTURE1);\n      const buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, width, 0, 0, height, 0, height, width, 0, width, height]), gl.STATIC_DRAW);\n      gl.enableVertexAttribArray(cache.positionLocation);\n      gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);\n      gl.clearColor(0, 0, 0, 0);\n      gl.enable(gl.BLEND);\n      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n      gl.drawArrays(gl.TRIANGLES, 0, 6);\n      gl.flush();\n      gl.deleteTexture(texture);\n      gl.deleteTexture(maskTexture);\n      gl.deleteBuffer(buffer);\n      return canvas;\n    }\n\n    const figuresVertexShaderCode = \"\\\n    attribute vec2 a_position;                                    \\\n    attribute vec3 a_color;                                       \\\n                                                                  \\\n    uniform vec2 u_resolution;                                    \\\n    uniform vec2 u_scale;                                         \\\n    uniform vec2 u_offset;                                        \\\n                                                                  \\\n    varying vec4 v_color;                                         \\\n                                                                  \\\n    void main() {                                                 \\\n      vec2 position = (a_position + u_offset) * u_scale;          \\\n      vec2 clipSpace = (position / u_resolution) * 2.0 - 1.0;     \\\n      gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);          \\\n                                                                  \\\n      v_color = vec4(a_color / 255.0, 1.0);                       \\\n    }                                                             \";\n    const figuresFragmentShaderCode = \"\\\n    precision mediump float;                                      \\\n                                                                  \\\n    varying vec4 v_color;                                         \\\n                                                                  \\\n    void main() {                                                 \\\n      gl_FragColor = v_color;                                     \\\n    }                                                             \";\n    let figuresCache = null;\n\n    function initFiguresGL() {\n      generateGL();\n      const canvas = currentCanvas;\n      currentCanvas = null;\n      const gl = currentGL;\n      currentGL = null;\n      const vertexShader = createVertexShader(gl, figuresVertexShaderCode);\n      const fragmentShader = createFragmentShader(gl, figuresFragmentShaderCode);\n      const program = createProgram(gl, [vertexShader, fragmentShader]);\n      gl.useProgram(program);\n      const cache = {};\n      cache.gl = gl;\n      cache.canvas = canvas;\n      cache.resolutionLocation = gl.getUniformLocation(program, \"u_resolution\");\n      cache.scaleLocation = gl.getUniformLocation(program, \"u_scale\");\n      cache.offsetLocation = gl.getUniformLocation(program, \"u_offset\");\n      cache.positionLocation = gl.getAttribLocation(program, \"a_position\");\n      cache.colorLocation = gl.getAttribLocation(program, \"a_color\");\n      figuresCache = cache;\n    }\n\n    function drawFigures(width, height, backgroundColor, figures, context) {\n      if (!figuresCache) {\n        initFiguresGL();\n      }\n\n      const cache = figuresCache,\n            canvas = cache.canvas,\n            gl = cache.gl;\n      canvas.width = width;\n      canvas.height = height;\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n      gl.uniform2f(cache.resolutionLocation, width, height);\n      let count = 0;\n\n      for (let i = 0, ii = figures.length; i < ii; i++) {\n        switch (figures[i].type) {\n          case \"lattice\":\n            const rows = figures[i].coords.length / figures[i].verticesPerRow | 0;\n            count += (rows - 1) * (figures[i].verticesPerRow - 1) * 6;\n            break;\n\n          case \"triangles\":\n            count += figures[i].coords.length;\n            break;\n        }\n      }\n\n      const coords = new Float32Array(count * 2);\n      const colors = new Uint8Array(count * 3);\n      const coordsMap = context.coords,\n            colorsMap = context.colors;\n      let pIndex = 0,\n          cIndex = 0;\n\n      for (let i = 0, ii = figures.length; i < ii; i++) {\n        const figure = figures[i],\n              ps = figure.coords,\n              cs = figure.colors;\n\n        switch (figure.type) {\n          case \"lattice\":\n            const cols = figure.verticesPerRow;\n            const rows = ps.length / cols | 0;\n\n            for (let row = 1; row < rows; row++) {\n              let offset = row * cols + 1;\n\n              for (let col = 1; col < cols; col++, offset++) {\n                coords[pIndex] = coordsMap[ps[offset - cols - 1]];\n                coords[pIndex + 1] = coordsMap[ps[offset - cols - 1] + 1];\n                coords[pIndex + 2] = coordsMap[ps[offset - cols]];\n                coords[pIndex + 3] = coordsMap[ps[offset - cols] + 1];\n                coords[pIndex + 4] = coordsMap[ps[offset - 1]];\n                coords[pIndex + 5] = coordsMap[ps[offset - 1] + 1];\n                colors[cIndex] = colorsMap[cs[offset - cols - 1]];\n                colors[cIndex + 1] = colorsMap[cs[offset - cols - 1] + 1];\n                colors[cIndex + 2] = colorsMap[cs[offset - cols - 1] + 2];\n                colors[cIndex + 3] = colorsMap[cs[offset - cols]];\n                colors[cIndex + 4] = colorsMap[cs[offset - cols] + 1];\n                colors[cIndex + 5] = colorsMap[cs[offset - cols] + 2];\n                colors[cIndex + 6] = colorsMap[cs[offset - 1]];\n                colors[cIndex + 7] = colorsMap[cs[offset - 1] + 1];\n                colors[cIndex + 8] = colorsMap[cs[offset - 1] + 2];\n                coords[pIndex + 6] = coords[pIndex + 2];\n                coords[pIndex + 7] = coords[pIndex + 3];\n                coords[pIndex + 8] = coords[pIndex + 4];\n                coords[pIndex + 9] = coords[pIndex + 5];\n                coords[pIndex + 10] = coordsMap[ps[offset]];\n                coords[pIndex + 11] = coordsMap[ps[offset] + 1];\n                colors[cIndex + 9] = colors[cIndex + 3];\n                colors[cIndex + 10] = colors[cIndex + 4];\n                colors[cIndex + 11] = colors[cIndex + 5];\n                colors[cIndex + 12] = colors[cIndex + 6];\n                colors[cIndex + 13] = colors[cIndex + 7];\n                colors[cIndex + 14] = colors[cIndex + 8];\n                colors[cIndex + 15] = colorsMap[cs[offset]];\n                colors[cIndex + 16] = colorsMap[cs[offset] + 1];\n                colors[cIndex + 17] = colorsMap[cs[offset] + 2];\n                pIndex += 12;\n                cIndex += 18;\n              }\n            }\n\n            break;\n\n          case \"triangles\":\n            for (let j = 0, jj = ps.length; j < jj; j++) {\n              coords[pIndex] = coordsMap[ps[j]];\n              coords[pIndex + 1] = coordsMap[ps[j] + 1];\n              colors[cIndex] = colorsMap[cs[j]];\n              colors[cIndex + 1] = colorsMap[cs[j] + 1];\n              colors[cIndex + 2] = colorsMap[cs[j] + 2];\n              pIndex += 2;\n              cIndex += 3;\n            }\n\n            break;\n        }\n      }\n\n      if (backgroundColor) {\n        gl.clearColor(backgroundColor[0] / 255, backgroundColor[1] / 255, backgroundColor[2] / 255, 1.0);\n      } else {\n        gl.clearColor(0, 0, 0, 0);\n      }\n\n      gl.clear(gl.COLOR_BUFFER_BIT);\n      const coordsBuffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, coordsBuffer);\n      gl.bufferData(gl.ARRAY_BUFFER, coords, gl.STATIC_DRAW);\n      gl.enableVertexAttribArray(cache.positionLocation);\n      gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);\n      const colorsBuffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, colorsBuffer);\n      gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);\n      gl.enableVertexAttribArray(cache.colorLocation);\n      gl.vertexAttribPointer(cache.colorLocation, 3, gl.UNSIGNED_BYTE, false, 0, 0);\n      gl.uniform2f(cache.scaleLocation, context.scaleX, context.scaleY);\n      gl.uniform2f(cache.offsetLocation, context.offsetX, context.offsetY);\n      gl.drawArrays(gl.TRIANGLES, 0, count);\n      gl.flush();\n      gl.deleteBuffer(coordsBuffer);\n      gl.deleteBuffer(colorsBuffer);\n      return canvas;\n    }\n\n    return {\n      tryInitGL() {\n        try {\n          generateGL();\n          return !!currentGL;\n        } catch (ex) {}\n\n        return false;\n      },\n\n      composeSMask,\n      drawFigures,\n\n      cleanup() {\n        if (smaskCache && smaskCache.canvas) { // lwf\n          smaskCache.canvas.width = 0;\n          smaskCache.canvas.height = 0;\n        }\n\n        if (figuresCache && figuresCache.canvas) { // lwf\n          figuresCache.canvas.width = 0;\n          figuresCache.canvas.height = 0;\n        }\n\n        smaskCache = null;\n        figuresCache = null;\n      }\n\n    };\n  }();\n\n  /***/ }),\n  /* 19 */\n  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\n  Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n  }));\n  exports.AnnotationLayer = void 0;\n\n  var _display_utils = __w_pdfjs_require__(1);\n\n  var _util = __w_pdfjs_require__(2);\n\n  var _annotation_storage = __w_pdfjs_require__(8);\n\n  var _scripting_utils = __w_pdfjs_require__(20);\n\n  class AnnotationElementFactory {\n    static create(parameters) {\n      const subtype = parameters.data.annotationType;\n\n      switch (subtype) {\n        case _util.AnnotationType.LINK:\n          return new LinkAnnotationElement(parameters);\n\n        case _util.AnnotationType.TEXT:\n          return new TextAnnotationElement(parameters);\n\n        case _util.AnnotationType.WIDGET:\n          const fieldType = parameters.data.fieldType;\n\n          switch (fieldType) {\n            case \"Tx\":\n              return new TextWidgetAnnotationElement(parameters);\n\n            case \"Btn\":\n              if (parameters.data.radioButton) {\n                return new RadioButtonWidgetAnnotationElement(parameters);\n              } else if (parameters.data.checkBox) {\n                return new CheckboxWidgetAnnotationElement(parameters);\n              }\n\n              return new PushButtonWidgetAnnotationElement(parameters);\n\n            case \"Ch\":\n              return new ChoiceWidgetAnnotationElement(parameters);\n          }\n\n          return new WidgetAnnotationElement(parameters);\n\n        case _util.AnnotationType.POPUP:\n          return new PopupAnnotationElement(parameters);\n\n        case _util.AnnotationType.FREETEXT:\n          return new FreeTextAnnotationElement(parameters);\n\n        case _util.AnnotationType.LINE:\n          return new LineAnnotationElement(parameters);\n\n        case _util.AnnotationType.SQUARE:\n          return new SquareAnnotationElement(parameters);\n\n        case _util.AnnotationType.CIRCLE:\n          return new CircleAnnotationElement(parameters);\n\n        case _util.AnnotationType.POLYLINE:\n          return new PolylineAnnotationElement(parameters);\n\n        case _util.AnnotationType.CARET:\n          return new CaretAnnotationElement(parameters);\n\n        case _util.AnnotationType.INK:\n          return new InkAnnotationElement(parameters);\n\n        case _util.AnnotationType.POLYGON:\n          return new PolygonAnnotationElement(parameters);\n\n        case _util.AnnotationType.HIGHLIGHT:\n          return new HighlightAnnotationElement(parameters);\n\n        case _util.AnnotationType.UNDERLINE:\n          return new UnderlineAnnotationElement(parameters);\n\n        case _util.AnnotationType.SQUIGGLY:\n          return new SquigglyAnnotationElement(parameters);\n\n        case _util.AnnotationType.STRIKEOUT:\n          return new StrikeOutAnnotationElement(parameters);\n\n        case _util.AnnotationType.STAMP:\n          return new StampAnnotationElement(parameters);\n\n        case _util.AnnotationType.FILEATTACHMENT:\n          return new FileAttachmentAnnotationElement(parameters);\n\n        default:\n          return new AnnotationElement(parameters);\n      }\n    }\n\n  }\n\n  class AnnotationElement {\n    constructor(parameters, {\n      isRenderable = false,\n      ignoreBorder = false,\n      createQuadrilaterals = false\n    } = {}) {\n      this.isRenderable = isRenderable;\n      this.data = parameters.data;\n      this.layer = parameters.layer;\n      this.page = parameters.page;\n      this.viewport = parameters.viewport;\n      this.linkService = parameters.linkService;\n      this.downloadManager = parameters.downloadManager;\n      this.imageResourcesPath = parameters.imageResourcesPath;\n      this.renderInteractiveForms = parameters.renderInteractiveForms;\n      this.svgFactory = parameters.svgFactory;\n      this.annotationStorage = parameters.annotationStorage;\n      this.enableScripting = parameters.enableScripting;\n      this.hasJSActions = parameters.hasJSActions;\n      this._mouseState = parameters.mouseState;\n\n      if (isRenderable) {\n        this.container = this._createContainer(ignoreBorder);\n      }\n\n      if (createQuadrilaterals) {\n        this.quadrilaterals = this._createQuadrilaterals(ignoreBorder);\n      }\n    }\n\n    _createContainer(ignoreBorder = false) {\n      const data = this.data,\n            page = this.page,\n            viewport = this.viewport;\n      const container = document.createElement(\"section\");\n      let width = data.rect[2] - data.rect[0];\n      let height = data.rect[3] - data.rect[1];\n      container.setAttribute(\"data-annotation-id\", data.id);\n\n      const rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);\n\n      container.style.transform = `matrix(${viewport.transform.join(\",\")})`;\n      container.style.transformOrigin = `${-rect[0]}px ${-rect[1]}px`;\n\n      if (!ignoreBorder && data.borderStyle.width > 0) {\n        container.style.borderWidth = `${data.borderStyle.width}px`;\n\n        if (data.borderStyle.style !== _util.AnnotationBorderStyleType.UNDERLINE) {\n          width = width - 2 * data.borderStyle.width;\n          height = height - 2 * data.borderStyle.width;\n        }\n\n        const horizontalRadius = data.borderStyle.horizontalCornerRadius;\n        const verticalRadius = data.borderStyle.verticalCornerRadius;\n\n        if (horizontalRadius > 0 || verticalRadius > 0) {\n          const radius = `${horizontalRadius}px / ${verticalRadius}px`;\n          container.style.borderRadius = radius;\n        }\n\n        switch (data.borderStyle.style) {\n          case _util.AnnotationBorderStyleType.SOLID:\n            container.style.borderStyle = \"solid\";\n            break;\n\n          case _util.AnnotationBorderStyleType.DASHED:\n            container.style.borderStyle = \"dashed\";\n            break;\n\n          case _util.AnnotationBorderStyleType.BEVELED:\n            (0, _util.warn)(\"Unimplemented border style: beveled\");\n            break;\n\n          case _util.AnnotationBorderStyleType.INSET:\n            (0, _util.warn)(\"Unimplemented border style: inset\");\n            break;\n\n          case _util.AnnotationBorderStyleType.UNDERLINE:\n            container.style.borderBottomStyle = \"solid\";\n            break;\n\n          default:\n            break;\n        }\n\n        if (data.color) {\n          container.style.borderColor = _util.Util.makeHexColor(data.color[0] | 0, data.color[1] | 0, data.color[2] | 0);\n        } else {\n          container.style.borderWidth = 0;\n        }\n      }\n\n      container.style.left = `${rect[0]}px`;\n      container.style.top = `${rect[1]}px`;\n      container.style.width = `${width}px`;\n      container.style.height = `${height}px`;\n      return container;\n    }\n\n    _createQuadrilaterals(ignoreBorder = false) {\n      if (!this.data.quadPoints) {\n        return null;\n      }\n\n      const quadrilaterals = [];\n      const savedRect = this.data.rect;\n\n      for (const quadPoint of this.data.quadPoints) {\n        this.data.rect = [quadPoint[2].x, quadPoint[2].y, quadPoint[1].x, quadPoint[1].y];\n        quadrilaterals.push(this._createContainer(ignoreBorder));\n      }\n\n      this.data.rect = savedRect;\n      return quadrilaterals;\n    }\n\n    _createPopup(trigger, data) {\n      let container = this.container;\n\n      if (this.quadrilaterals) {\n        trigger = trigger || this.quadrilaterals;\n        container = this.quadrilaterals[0];\n      }\n\n      if (!trigger) {\n        trigger = document.createElement(\"div\");\n        trigger.style.height = container.style.height;\n        trigger.style.width = container.style.width;\n        container.appendChild(trigger);\n      }\n\n      const popupElement = new PopupElement({\n        container,\n        trigger,\n        color: data.color,\n        title: data.title,\n        modificationDate: data.modificationDate,\n        contents: data.contents,\n        hideWrapper: true\n      });\n      const popup = popupElement.render();\n      popup.style.left = container.style.width;\n      container.appendChild(popup);\n    }\n\n    _renderQuadrilaterals(className) {\n      this.quadrilaterals.forEach(quadrilateral => {\n        quadrilateral.className = className;\n      });\n      return this.quadrilaterals;\n    }\n\n    render() {\n      (0, _util.unreachable)(\"Abstract method `AnnotationElement.render` called\");\n    }\n\n  }\n\n  class LinkAnnotationElement extends AnnotationElement {\n    constructor(parameters) {\n      const isRenderable = !!(parameters.data.url || parameters.data.dest || parameters.data.action || parameters.data.isTooltipOnly || parameters.data.actions && (parameters.data.actions.Action || parameters.data.actions[\"Mouse Up\"] || parameters.data.actions[\"Mouse Down\"]));\n      super(parameters, {\n        isRenderable,\n        createQuadrilaterals: true\n      });\n    }\n\n    render() {\n      const {\n        data,\n        linkService\n      } = this;\n      const link = document.createElement(\"a\");\n\n      if (data.url) {\n        (0, _display_utils.addLinkAttributes)(link, {\n          url: data.url,\n          target: data.newWindow ? _display_utils.LinkTarget.BLANK : linkService.externalLinkTarget,\n          rel: linkService.externalLinkRel,\n          enabled: linkService.externalLinkEnabled\n        });\n      } else if (data.action) {\n        this._bindNamedAction(link, data.action);\n      } else if (data.dest) {\n        this._bindLink(link, data.dest);\n      } else if (data.actions && (data.actions.Action || data.actions[\"Mouse Up\"] || data.actions[\"Mouse Down\"]) && this.enableScripting && this.hasJSActions) {\n        this._bindJSAction(link, data);\n      } else {\n        this._bindLink(link, \"\");\n      }\n\n      if (this.quadrilaterals) {\n        return this._renderQuadrilaterals(\"linkAnnotation\").map((quadrilateral, index) => {\n          const linkElement = index === 0 ? link : link.cloneNode();\n          quadrilateral.appendChild(linkElement);\n          return quadrilateral;\n        });\n      }\n\n      this.container.className = \"linkAnnotation\";\n      this.container.appendChild(link);\n      return this.container;\n    }\n\n    _bindLink(link, destination) {\n      link.href = this.linkService.getDestinationHash(destination);\n\n      link.onclick = () => {\n        if (destination) {\n          this.linkService.goToDestination(destination);\n        }\n\n        return false;\n      };\n\n      if (destination || destination === \"\") {\n        link.className = \"internalLink\";\n      }\n    }\n\n    _bindNamedAction(link, action) {\n      link.href = this.linkService.getAnchorUrl(\"\");\n\n      link.onclick = () => {\n        this.linkService.executeNamedAction(action);\n        return false;\n      };\n\n      link.className = \"internalLink\";\n    }\n\n    _bindJSAction(link, data) {\n      link.href = this.linkService.getAnchorUrl(\"\");\n      const map = new Map([[\"Action\", \"onclick\"], [\"Mouse Up\", \"onmouseup\"], [\"Mouse Down\", \"onmousedown\"]]);\n\n      for (const name of Object.keys(data.actions)) {\n        const jsName = map.get(name);\n\n        if (!jsName) {\n          continue;\n        }\n\n        link[jsName] = () => {\n          this.linkService.eventBus && this.linkService.eventBus.dispatch(\"dispatcheventinsandbox\", { // lwf\n            source: this,\n            detail: {\n              id: data.id,\n              name\n            }\n          });\n          return false;\n        };\n      }\n\n      link.className = \"internalLink\";\n    }\n\n  }\n\n  class TextAnnotationElement extends AnnotationElement {\n    constructor(parameters) {\n      const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n      super(parameters, {\n        isRenderable\n      });\n    }\n\n    render() {\n      this.container.className = \"textAnnotation\";\n      const image = document.createElement(\"img\");\n      image.style.height = this.container.style.height;\n      image.style.width = this.container.style.width;\n      image.src = this.imageResourcesPath + \"annotation-\" + this.data.name.toLowerCase() + \".svg\";\n      image.alt = \"[{{type}} Annotation]\";\n      image.dataset.l10nId = \"text_annotation_type\";\n      image.dataset.l10nArgs = JSON.stringify({\n        type: this.data.name\n      });\n\n      if (!this.data.hasPopup) {\n        this._createPopup(image, this.data);\n      }\n\n      this.container.appendChild(image);\n      return this.container;\n    }\n\n  }\n\n  class WidgetAnnotationElement extends AnnotationElement {\n    render() {\n      if (this.data.alternativeText) {\n        this.container.title = this.data.alternativeText;\n      }\n\n      return this.container;\n    }\n\n    _getKeyModifier(event) {\n      return navigator.platform.includes(\"Win\") && event.ctrlKey || navigator.platform.includes(\"Mac\") && event.metaKey;\n    }\n\n    _setEventListener(element, baseName, eventName, valueGetter) {\n      if (baseName.includes(\"mouse\")) {\n        element.addEventListener(baseName, event => {\n          this.linkService.eventBus && this.linkService.eventBus.dispatch(\"dispatcheventinsandbox\", { // lwf\n            source: this,\n            detail: {\n              id: this.data.id,\n              name: eventName,\n              value: valueGetter(event),\n              shift: event.shiftKey,\n              modifier: this._getKeyModifier(event)\n            }\n          });\n        });\n      } else {\n        element.addEventListener(baseName, event => {\n          this.linkService.eventBus && this.linkService.eventBus.dispatch(\"dispatcheventinsandbox\", { // lwf\n            source: this,\n            detail: {\n              id: this.data.id,\n              name: eventName,\n              value: event.target.checked\n            }\n          });\n        });\n      }\n    }\n\n    _setEventListeners(element, names, getter) {\n      for (const [baseName, eventName] of names) {\n        if (eventName === \"Action\" || this.data.actions && this.data.actions[eventName]) { // lwf\n          this._setEventListener(element, baseName, eventName, getter);\n        }\n      }\n    }\n\n  }\n\n  class TextWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters) {\n      const isRenderable = parameters.renderInteractiveForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;\n      super(parameters, {\n        isRenderable\n      });\n    }\n\n    render() {\n      const storage = this.annotationStorage;\n      const id = this.data.id;\n      this.container.className = \"textWidgetAnnotation\";\n      let element = null;\n\n      if (this.renderInteractiveForms) {\n        const textContent = storage.getOrCreateValue(id, {\n          value: this.data.fieldValue\n        }).value;\n        const elementData = {\n          userValue: null,\n          formattedValue: null,\n          beforeInputSelectionRange: null,\n          beforeInputValue: null\n        };\n\n        if (this.data.multiLine) {\n          element = document.createElement(\"textarea\");\n          element.textContent = textContent;\n        } else {\n          element = document.createElement(\"input\");\n          element.type = \"text\";\n          element.setAttribute(\"value\", textContent);\n        }\n\n        elementData.userValue = textContent;\n        element.setAttribute(\"id\", id);\n        element.addEventListener(\"input\", function (event) {\n          storage.setValue(id, {\n            value: event.target.value\n          });\n        });\n\n        let blurListener = event => {\n          if (elementData.formattedValue) {\n            event.target.value = elementData.formattedValue;\n          }\n\n          event.target.setSelectionRange(0, 0);\n          elementData.beforeInputSelectionRange = null;\n        };\n\n        if (this.enableScripting && this.hasJSActions) {\n          element.addEventListener(\"focus\", event => {\n            if (elementData.userValue) {\n              event.target.value = elementData.userValue;\n            }\n          });\n          element.addEventListener(\"updatefromsandbox\", function (event) {\n            const {\n              detail\n            } = event;\n            const actions = {\n              value() {\n                elementData.userValue = detail.value || \"\";\n                storage.setValue(id, {\n                  value: elementData.userValue.toString()\n                });\n\n                if (!elementData.formattedValue) {\n                  event.target.value = elementData.userValue;\n                }\n              },\n\n              valueAsString() {\n                elementData.formattedValue = detail.valueAsString || \"\";\n\n                if (event.target !== document.activeElement) {\n                  event.target.value = elementData.formattedValue;\n                }\n\n                storage.setValue(id, {\n                  formattedValue: elementData.formattedValue\n                });\n              },\n\n              focus() {\n                setTimeout(() => event.target.focus({\n                  preventScroll: false\n                }), 0);\n              },\n\n              userName() {\n                event.target.title = detail.userName;\n              },\n\n              hidden() {\n                event.target.style.visibility = detail.hidden ? \"hidden\" : \"visible\";\n                storage.setValue(id, {\n                  hidden: detail.hidden\n                });\n              },\n\n              editable() {\n                event.target.disabled = !detail.editable;\n              },\n\n              selRange() {\n                const [selStart, selEnd] = detail.selRange;\n\n                if (selStart >= 0 && selEnd < event.target.value.length) {\n                  event.target.setSelectionRange(selStart, selEnd);\n                }\n              },\n\n              strokeColor() {\n                const color = detail.strokeColor;\n                event.target.style.color = _scripting_utils.ColorConverters[`${color[0]}_HTML`](color.slice(1));\n              }\n\n            };\n            Object.keys(detail).filter(name => name in actions).forEach(name => actions[name]());\n          });\n\n          if (this.data.actions) {\n            element.addEventListener(\"keydown\", event => {\n              elementData.beforeInputValue = event.target.value;\n              let commitKey = -1;\n\n              if (event.key === \"Escape\") {\n                commitKey = 0;\n              } else if (event.key === \"Enter\") {\n                commitKey = 2;\n              } else if (event.key === \"Tab\") {\n                commitKey = 3;\n              }\n\n              if (commitKey === -1) {\n                return;\n              }\n\n              elementData.userValue = event.target.value;\n              this.linkService.eventBus && this.linkService.eventBus.dispatch(\"dispatcheventinsandbox\", { // lwf\n                source: this,\n                detail: {\n                  id,\n                  name: \"Keystroke\",\n                  value: event.target.value,\n                  willCommit: true,\n                  commitKey,\n                  selStart: event.target.selectionStart,\n                  selEnd: event.target.selectionEnd\n                }\n              });\n            });\n            const _blurListener = blurListener;\n            blurListener = null;\n            element.addEventListener(\"blur\", event => {\n              if (this._mouseState.isDown) {\n                elementData.userValue = event.target.value;\n                this.linkService.eventBus && this.linkService.eventBus.dispatch(\"dispatcheventinsandbox\", { // lwf\n                  source: this,\n                  detail: {\n                    id,\n                    name: \"Keystroke\",\n                    value: event.target.value,\n                    willCommit: true,\n                    commitKey: 1,\n                    selStart: event.target.selectionStart,\n                    selEnd: event.target.selectionEnd\n                  }\n                });\n              }\n\n              _blurListener(event);\n            });\n            element.addEventListener(\"mousedown\", event => {\n              elementData.beforeInputValue = event.target.value;\n              elementData.beforeInputSelectionRange = null;\n            });\n            element.addEventListener(\"keyup\", event => {\n              if (event.target.selectionStart === event.target.selectionEnd) {\n                elementData.beforeInputSelectionRange = null;\n              }\n            });\n            element.addEventListener(\"select\", event => {\n              elementData.beforeInputSelectionRange = [event.target.selectionStart, event.target.selectionEnd];\n            });\n\n            if (\"Keystroke\" in this.data.actions) {\n              element.addEventListener(\"input\", event => {\n                let selStart = -1;\n                let selEnd = -1;\n\n                if (elementData.beforeInputSelectionRange) {\n                  [selStart, selEnd] = elementData.beforeInputSelectionRange;\n                }\n\n                this.linkService.eventBus && this.linkService.eventBus.dispatch(\"dispatcheventinsandbox\", { // lwf\n                  source: this,\n                  detail: {\n                    id,\n                    name: \"Keystroke\",\n                    value: elementData.beforeInputValue,\n                    change: event.data,\n                    willCommit: false,\n                    selStart,\n                    selEnd\n                  }\n                });\n              });\n            }\n\n            this._setEventListeners(element, [[\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.value);\n          }\n        }\n\n        if (blurListener) {\n          element.addEventListener(\"blur\", blurListener);\n        }\n\n        element.disabled = this.data.readOnly;\n        element.name = this.data.fieldName;\n\n        if (this.data.maxLen !== null) {\n          element.maxLength = this.data.maxLen;\n        }\n\n        if (this.data.comb) {\n          const fieldWidth = this.data.rect[2] - this.data.rect[0];\n          const combWidth = fieldWidth / this.data.maxLen;\n          element.classList.add(\"comb\");\n          element.style.letterSpacing = `calc(${combWidth}px - 1ch)`;\n        }\n      } else {\n        element = document.createElement(\"div\");\n        element.textContent = this.data.fieldValue;\n        element.style.verticalAlign = \"middle\";\n        element.style.display = \"table-cell\";\n      }\n\n      this._setTextStyle(element);\n\n      this.container.appendChild(element);\n      return this.container;\n    }\n\n    _setTextStyle(element) {\n      const TEXT_ALIGNMENT = [\"left\", \"center\", \"right\"];\n      const {\n        fontSize,\n        fontColor\n      } = this.data.defaultAppearanceData;\n      const style = element.style;\n\n      if (fontSize) {\n        style.fontSize = `${fontSize}px`;\n      }\n\n      style.color = _util.Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);\n\n      if (this.data.textAlignment !== null) {\n        style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];\n      }\n    }\n\n  }\n\n  class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters) {\n      super(parameters, {\n        isRenderable: parameters.renderInteractiveForms\n      });\n    }\n\n    render() {\n      const storage = this.annotationStorage;\n      const data = this.data;\n      const id = data.id;\n      const value = storage.getOrCreateValue(id, {\n        value: data.fieldValue && data.fieldValue !== \"Off\"\n      }).value;\n      this.container.className = \"buttonWidgetAnnotation checkBox\";\n      const element = document.createElement(\"input\");\n      element.disabled = data.readOnly;\n      element.type = \"checkbox\";\n      element.name = this.data.fieldName;\n\n      if (value) {\n        element.setAttribute(\"checked\", true);\n      }\n\n      element.setAttribute(\"id\", id);\n      element.addEventListener(\"change\", function (event) {\n        const name = event.target.name;\n\n        for (const checkbox of document.getElementsByName(name)) {\n          if (checkbox !== event.target) {\n            checkbox.checked = false;\n            storage.setValue(checkbox.parentNode.getAttribute(\"data-annotation-id\"), {\n              value: false\n            });\n          }\n        }\n\n        storage.setValue(id, {\n          value: event.target.checked\n        });\n      });\n\n      if (this.enableScripting && this.hasJSActions) {\n        element.addEventListener(\"updatefromsandbox\", event => {\n          const {\n            detail\n          } = event;\n          const actions = {\n            value() {\n              event.target.checked = detail.value !== \"Off\";\n              storage.setValue(id, {\n                value: event.target.checked\n              });\n            },\n\n            focus() {\n              setTimeout(() => event.target.focus({\n                preventScroll: false\n              }), 0);\n            },\n\n            hidden() {\n              event.target.style.visibility = detail.hidden ? \"hidden\" : \"visible\";\n              storage.setValue(id, {\n                hidden: detail.hidden\n              });\n            },\n\n            editable() {\n              event.target.disabled = !detail.editable;\n            }\n\n          };\n          Object.keys(detail).filter(name => name in actions).forEach(name => actions[name]());\n        });\n\n        this._setEventListeners(element, [[\"change\", \"Validate\"], [\"change\", \"Action\"], [\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.checked);\n      }\n\n      this.container.appendChild(element);\n      return this.container;\n    }\n\n  }\n\n  class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters) {\n      super(parameters, {\n        isRenderable: parameters.renderInteractiveForms\n      });\n    }\n\n    render() {\n      this.container.className = \"buttonWidgetAnnotation radioButton\";\n      const storage = this.annotationStorage;\n      const data = this.data;\n      const id = data.id;\n      const value = storage.getOrCreateValue(id, {\n        value: data.fieldValue === data.buttonValue\n      }).value;\n      const element = document.createElement(\"input\");\n      element.disabled = data.readOnly;\n      element.type = \"radio\";\n      element.name = data.fieldName;\n\n      if (value) {\n        element.setAttribute(\"checked\", true);\n      }\n\n      element.setAttribute(\"pdfButtonValue\", data.buttonValue);\n      element.setAttribute(\"id\", id);\n      element.addEventListener(\"change\", function (event) {\n        const {\n          target\n        } = event;\n\n        for (const radio of document.getElementsByName(target.name)) {\n          if (radio !== target) {\n            storage.setValue(radio.getAttribute(\"id\"), {\n              value: false\n            });\n          }\n        }\n\n        storage.setValue(id, {\n          value: target.checked\n        });\n      });\n\n      if (this.enableScripting && this.hasJSActions) {\n        element.addEventListener(\"updatefromsandbox\", event => {\n          const {\n            detail\n          } = event;\n          const actions = {\n            value() {\n              const fieldValue = detail.value;\n\n              for (const radio of document.getElementsByName(event.target.name)) {\n                const radioId = radio.getAttribute(\"id\");\n\n                if (fieldValue === radio.getAttribute(\"pdfButtonValue\")) {\n                  radio.setAttribute(\"checked\", true);\n                  storage.setValue(radioId, {\n                    value: true\n                  });\n                } else {\n                  storage.setValue(radioId, {\n                    value: false\n                  });\n                }\n              }\n            },\n\n            focus() {\n              setTimeout(() => event.target.focus({\n                preventScroll: false\n              }), 0);\n            },\n\n            hidden() {\n              event.target.style.visibility = detail.hidden ? \"hidden\" : \"visible\";\n              storage.setValue(id, {\n                hidden: detail.hidden\n              });\n            },\n\n            editable() {\n              event.target.disabled = !detail.editable;\n            }\n\n          };\n          Object.keys(detail).filter(name => name in actions).forEach(name => actions[name]());\n        });\n\n        this._setEventListeners(element, [[\"change\", \"Validate\"], [\"change\", \"Action\"], [\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.checked);\n      }\n\n      this.container.appendChild(element);\n      return this.container;\n    }\n\n  }\n\n  class PushButtonWidgetAnnotationElement extends LinkAnnotationElement {\n    render() {\n      const container = super.render();\n      container.className = \"buttonWidgetAnnotation pushButton\";\n\n      if (this.data.alternativeText) {\n        container.title = this.data.alternativeText;\n      }\n\n      return container;\n    }\n\n  }\n\n  class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters) {\n      super(parameters, {\n        isRenderable: parameters.renderInteractiveForms\n      });\n    }\n\n    render() {\n      this.container.className = \"choiceWidgetAnnotation\";\n      const storage = this.annotationStorage;\n      const id = this.data.id;\n      storage.getOrCreateValue(id, {\n        value: this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : undefined\n      });\n      const selectElement = document.createElement(\"select\");\n      selectElement.disabled = this.data.readOnly;\n      selectElement.name = this.data.fieldName;\n      selectElement.setAttribute(\"id\", id);\n\n      if (!this.data.combo) {\n        selectElement.size = this.data.options.length;\n\n        if (this.data.multiSelect) {\n          selectElement.multiple = true;\n        }\n      }\n\n      for (const option of this.data.options) {\n        const optionElement = document.createElement(\"option\");\n        optionElement.textContent = option.displayValue;\n        optionElement.value = option.exportValue;\n\n        if (this.data.fieldValue.includes(option.exportValue)) {\n          optionElement.setAttribute(\"selected\", true);\n        }\n\n        selectElement.appendChild(optionElement);\n      }\n\n      function getValue(event) {\n        const options = event.target.options;\n        return options[options.selectedIndex].value;\n      }\n\n      if (this.enableScripting && this.hasJSActions) {\n        selectElement.addEventListener(\"updatefromsandbox\", event => {\n          const {\n            detail\n          } = event;\n          const actions = {\n            value() {\n              const options = event.target.options;\n              const value = detail.value;\n              const i = options.indexOf(value);\n\n              if (i !== -1) {\n                options.selectedIndex = i;\n                storage.setValue(id, {\n                  value\n                });\n              }\n            },\n\n            focus() {\n              setTimeout(() => event.target.focus({\n                preventScroll: false\n              }), 0);\n            },\n\n            hidden() {\n              event.target.style.visibility = detail.hidden ? \"hidden\" : \"visible\";\n              storage.setValue(id, {\n                hidden: detail.hidden\n              });\n            },\n\n            editable() {\n              event.target.disabled = !detail.editable;\n            }\n\n          };\n          Object.keys(detail).filter(name => name in actions).forEach(name => actions[name]());\n        });\n        selectElement.addEventListener(\"input\", event => {\n          const value = getValue(event);\n          storage.setValue(id, {\n            value\n          });\n          this.linkService.eventBus && this.linkService.eventBus.dispatch(\"dispatcheventinsandbox\", { //lwf\n            source: this,\n            detail: {\n              id,\n              name: \"Keystroke\",\n              changeEx: value,\n              willCommit: true,\n              commitKey: 1,\n              keyDown: false\n            }\n          });\n        });\n\n        this._setEventListeners(selectElement, [[\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.checked);\n      } else {\n        selectElement.addEventListener(\"input\", function (event) {\n          storage.setValue(id, {\n            value: getValue(event)\n          });\n        });\n      }\n\n      this.container.appendChild(selectElement);\n      return this.container;\n    }\n\n  }\n\n  class PopupAnnotationElement extends AnnotationElement {\n    constructor(parameters) {\n      const isRenderable = !!(parameters.data.title || parameters.data.contents);\n      super(parameters, {\n        isRenderable\n      });\n    }\n\n    render() {\n      const IGNORE_TYPES = [\"Line\", \"Square\", \"Circle\", \"PolyLine\", \"Polygon\", \"Ink\"];\n      this.container.className = \"popupAnnotation\";\n\n      if (IGNORE_TYPES.includes(this.data.parentType)) {\n        return this.container;\n      }\n\n      const selector = `[data-annotation-id=\"${this.data.parentId}\"]`;\n      const parentElements = this.layer.querySelectorAll(selector);\n\n      if (parentElements.length === 0) {\n        return this.container;\n      }\n\n      const popup = new PopupElement({\n        container: this.container,\n        trigger: Array.from(parentElements),\n        color: this.data.color,\n        title: this.data.title,\n        modificationDate: this.data.modificationDate,\n        contents: this.data.contents\n      });\n      const page = this.page;\n\n      const rect = _util.Util.normalizeRect([this.data.parentRect[0], page.view[3] - this.data.parentRect[1] + page.view[1], this.data.parentRect[2], page.view[3] - this.data.parentRect[3] + page.view[1]]);\n\n      const popupLeft = rect[0] + this.data.parentRect[2] - this.data.parentRect[0];\n      const popupTop = rect[1];\n      this.container.style.transformOrigin = `${-popupLeft}px ${-popupTop}px`;\n      this.container.style.left = `${popupLeft}px`;\n      this.container.style.top = `${popupTop}px`;\n      this.container.appendChild(popup.render());\n      return this.container;\n    }\n\n  }\n\n  class PopupElement {\n    constructor(parameters) {\n      this.container = parameters.container;\n      this.trigger = parameters.trigger;\n      this.color = parameters.color;\n      this.title = parameters.title;\n      this.modificationDate = parameters.modificationDate;\n      this.contents = parameters.contents;\n      this.hideWrapper = parameters.hideWrapper || false;\n      this.pinned = false;\n    }\n\n    render() {\n      const BACKGROUND_ENLIGHT = 0.7;\n      const wrapper = document.createElement(\"div\");\n      wrapper.className = \"popupWrapper\";\n      this.hideElement = this.hideWrapper ? wrapper : this.container;\n      this.hideElement.setAttribute(\"hidden\", true);\n      const popup = document.createElement(\"div\");\n      popup.className = \"popup\";\n      const color = this.color;\n\n      if (color) {\n        const r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];\n        const g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];\n        const b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];\n        popup.style.backgroundColor = _util.Util.makeHexColor(r | 0, g | 0, b | 0);\n      }\n\n      const title = document.createElement(\"h1\");\n      title.textContent = this.title;\n      popup.appendChild(title);\n\n      const dateObject = _display_utils.PDFDateString.toDateObject(this.modificationDate);\n\n      if (dateObject) {\n        const modificationDate = document.createElement(\"span\");\n        modificationDate.textContent = \"{{date}}, {{time}}\";\n        modificationDate.dataset.l10nId = \"annotation_date_string\";\n        modificationDate.dataset.l10nArgs = JSON.stringify({\n          date: dateObject.toLocaleDateString(),\n          time: dateObject.toLocaleTimeString()\n        });\n        popup.appendChild(modificationDate);\n      }\n\n      const contents = this._formatContents(this.contents);\n\n      popup.appendChild(contents);\n\n      if (!Array.isArray(this.trigger)) {\n        this.trigger = [this.trigger];\n      }\n\n      this.trigger.forEach(element => {\n        element.addEventListener(\"click\", this._toggle.bind(this));\n        element.addEventListener(\"mouseover\", this._show.bind(this, false));\n        element.addEventListener(\"mouseout\", this._hide.bind(this, false));\n      });\n      popup.addEventListener(\"click\", this._hide.bind(this, true));\n      wrapper.appendChild(popup);\n      return wrapper;\n    }\n\n    _formatContents(contents) {\n      const p = document.createElement(\"p\");\n      const lines = contents.split(/(?:\\r\\n?|\\n)/);\n\n      for (let i = 0, ii = lines.length; i < ii; ++i) {\n        const line = lines[i];\n        p.appendChild(document.createTextNode(line));\n\n        if (i < ii - 1) {\n          p.appendChild(document.createElement(\"br\"));\n        }\n      }\n\n      return p;\n    }\n\n    _toggle() {\n      if (this.pinned) {\n        this._hide(true);\n      } else {\n        this._show(true);\n      }\n    }\n\n    _show(pin = false) {\n      if (pin) {\n        this.pinned = true;\n      }\n\n      if (this.hideElement.hasAttribute(\"hidden\")) {\n        this.hideElement.removeAttribute(\"hidden\");\n        this.container.style.zIndex += 1;\n      }\n    }\n\n    _hide(unpin = true) {\n      if (unpin) {\n        this.pinned = false;\n      }\n\n      if (!this.hideElement.hasAttribute(\"hidden\") && !this.pinned) {\n        this.hideElement.setAttribute(\"hidden\", true);\n        this.container.style.zIndex -= 1;\n      }\n    }\n\n  }\n\n  class FreeTextAnnotationElement extends AnnotationElement {\n    constructor(parameters) {\n      const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n      super(parameters, {\n        isRenderable,\n        ignoreBorder: true\n      });\n    }\n\n    render() {\n      this.container.className = \"freeTextAnnotation\";\n\n      if (!this.data.hasPopup) {\n        this._createPopup(null, this.data);\n      }\n\n      return this.container;\n    }\n\n  }\n\n  class LineAnnotationElement extends AnnotationElement {\n    constructor(parameters) {\n      const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n      super(parameters, {\n        isRenderable,\n        ignoreBorder: true\n      });\n    }\n\n    render() {\n      this.container.className = \"lineAnnotation\";\n      const data = this.data;\n      const width = data.rect[2] - data.rect[0];\n      const height = data.rect[3] - data.rect[1];\n      const svg = this.svgFactory.create(width, height);\n      const line = this.svgFactory.createElement(\"svg:line\");\n      line.setAttribute(\"x1\", data.rect[2] - data.lineCoordinates[0]);\n      line.setAttribute(\"y1\", data.rect[3] - data.lineCoordinates[1]);\n      line.setAttribute(\"x2\", data.rect[2] - data.lineCoordinates[2]);\n      line.setAttribute(\"y2\", data.rect[3] - data.lineCoordinates[3]);\n      line.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n      line.setAttribute(\"stroke\", \"transparent\");\n      svg.appendChild(line);\n      this.container.append(svg);\n\n      this._createPopup(line, data);\n\n      return this.container;\n    }\n\n  }\n\n  class SquareAnnotationElement extends AnnotationElement {\n    constructor(parameters) {\n      const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n      super(parameters, {\n        isRenderable,\n        ignoreBorder: true\n      });\n    }\n\n    render() {\n      this.container.className = \"squareAnnotation\";\n      const data = this.data;\n      const width = data.rect[2] - data.rect[0];\n      const height = data.rect[3] - data.rect[1];\n      const svg = this.svgFactory.create(width, height);\n      const borderWidth = data.borderStyle.width;\n      const square = this.svgFactory.createElement(\"svg:rect\");\n      square.setAttribute(\"x\", borderWidth / 2);\n      square.setAttribute(\"y\", borderWidth / 2);\n      square.setAttribute(\"width\", width - borderWidth);\n      square.setAttribute(\"height\", height - borderWidth);\n      square.setAttribute(\"stroke-width\", borderWidth || 1);\n      square.setAttribute(\"stroke\", \"transparent\");\n      square.setAttribute(\"fill\", \"none\");\n      svg.appendChild(square);\n      this.container.append(svg);\n\n      this._createPopup(square, data);\n\n      return this.container;\n    }\n\n  }\n\n  class CircleAnnotationElement extends AnnotationElement {\n    constructor(parameters) {\n      const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n      super(parameters, {\n        isRenderable,\n        ignoreBorder: true\n      });\n    }\n\n    render() {\n      this.container.className = \"circleAnnotation\";\n      const data = this.data;\n      const width = data.rect[2] - data.rect[0];\n      const height = data.rect[3] - data.rect[1];\n      const svg = this.svgFactory.create(width, height);\n      const borderWidth = data.borderStyle.width;\n      const circle = this.svgFactory.createElement(\"svg:ellipse\");\n      circle.setAttribute(\"cx\", width / 2);\n      circle.setAttribute(\"cy\", height / 2);\n      circle.setAttribute(\"rx\", width / 2 - borderWidth / 2);\n      circle.setAttribute(\"ry\", height / 2 - borderWidth / 2);\n      circle.setAttribute(\"stroke-width\", borderWidth || 1);\n      circle.setAttribute(\"stroke\", \"transparent\");\n      circle.setAttribute(\"fill\", \"none\");\n      svg.appendChild(circle);\n      this.container.append(svg);\n\n      this._createPopup(circle, data);\n\n      return this.container;\n    }\n\n  }\n\n  class PolylineAnnotationElement extends AnnotationElement {\n    constructor(parameters) {\n      const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n      super(parameters, {\n        isRenderable,\n        ignoreBorder: true\n      });\n      this.containerClassName = \"polylineAnnotation\";\n      this.svgElementName = \"svg:polyline\";\n    }\n\n    render() {\n      this.container.className = this.containerClassName;\n      const data = this.data;\n      const width = data.rect[2] - data.rect[0];\n      const height = data.rect[3] - data.rect[1];\n      const svg = this.svgFactory.create(width, height);\n      let points = [];\n\n      for (const coordinate of data.vertices) {\n        const x = coordinate.x - data.rect[0];\n        const y = data.rect[3] - coordinate.y;\n        points.push(x + \",\" + y);\n      }\n\n      points = points.join(\" \");\n      const polyline = this.svgFactory.createElement(this.svgElementName);\n      polyline.setAttribute(\"points\", points);\n      polyline.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n      polyline.setAttribute(\"stroke\", \"transparent\");\n      polyline.setAttribute(\"fill\", \"none\");\n      svg.appendChild(polyline);\n      this.container.append(svg);\n\n      this._createPopup(polyline, data);\n\n      return this.container;\n    }\n\n  }\n\n  class PolygonAnnotationElement extends PolylineAnnotationElement {\n    constructor(parameters) {\n      super(parameters);\n      this.containerClassName = \"polygonAnnotation\";\n      this.svgElementName = \"svg:polygon\";\n    }\n\n  }\n\n  class CaretAnnotationElement extends AnnotationElement {\n    constructor(parameters) {\n      const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n      super(parameters, {\n        isRenderable,\n        ignoreBorder: true\n      });\n    }\n\n    render() {\n      this.container.className = \"caretAnnotation\";\n\n      if (!this.data.hasPopup) {\n        this._createPopup(null, this.data);\n      }\n\n      return this.container;\n    }\n\n  }\n\n  class InkAnnotationElement extends AnnotationElement {\n    constructor(parameters) {\n      const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n      super(parameters, {\n        isRenderable,\n        ignoreBorder: true\n      });\n      this.containerClassName = \"inkAnnotation\";\n      this.svgElementName = \"svg:polyline\";\n    }\n\n    render() {\n      this.container.className = this.containerClassName;\n      const data = this.data;\n      const width = data.rect[2] - data.rect[0];\n      const height = data.rect[3] - data.rect[1];\n      const svg = this.svgFactory.create(width, height);\n\n      for (const inkList of data.inkLists) {\n        let points = [];\n\n        for (const coordinate of inkList) {\n          const x = coordinate.x - data.rect[0];\n          const y = data.rect[3] - coordinate.y;\n          points.push(`${x},${y}`);\n        }\n\n        points = points.join(\" \");\n        const polyline = this.svgFactory.createElement(this.svgElementName);\n        polyline.setAttribute(\"points\", points);\n        polyline.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n        polyline.setAttribute(\"stroke\", \"transparent\");\n        polyline.setAttribute(\"fill\", \"none\");\n\n        this._createPopup(polyline, data);\n\n        svg.appendChild(polyline);\n      }\n\n      this.container.append(svg);\n      return this.container;\n    }\n\n  }\n\n  class HighlightAnnotationElement extends AnnotationElement {\n    constructor(parameters) {\n      const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n      super(parameters, {\n        isRenderable,\n        ignoreBorder: true,\n        createQuadrilaterals: true\n      });\n    }\n\n    render() {\n      if (!this.data.hasPopup) {\n        this._createPopup(null, this.data);\n      }\n\n      if (this.quadrilaterals) {\n        return this._renderQuadrilaterals(\"highlightAnnotation\");\n      }\n\n      this.container.className = \"highlightAnnotation\";\n      return this.container;\n    }\n\n  }\n\n  class UnderlineAnnotationElement extends AnnotationElement {\n    constructor(parameters) {\n      const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n      super(parameters, {\n        isRenderable,\n        ignoreBorder: true,\n        createQuadrilaterals: true\n      });\n    }\n\n    render() {\n      if (!this.data.hasPopup) {\n        this._createPopup(null, this.data);\n      }\n\n      if (this.quadrilaterals) {\n        return this._renderQuadrilaterals(\"underlineAnnotation\");\n      }\n\n      this.container.className = \"underlineAnnotation\";\n      return this.container;\n    }\n\n  }\n\n  class SquigglyAnnotationElement extends AnnotationElement {\n    constructor(parameters) {\n      const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n      super(parameters, {\n        isRenderable,\n        ignoreBorder: true,\n        createQuadrilaterals: true\n      });\n    }\n\n    render() {\n      if (!this.data.hasPopup) {\n        this._createPopup(null, this.data);\n      }\n\n      if (this.quadrilaterals) {\n        return this._renderQuadrilaterals(\"squigglyAnnotation\");\n      }\n\n      this.container.className = \"squigglyAnnotation\";\n      return this.container;\n    }\n\n  }\n\n  class StrikeOutAnnotationElement extends AnnotationElement {\n    constructor(parameters) {\n      const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n      super(parameters, {\n        isRenderable,\n        ignoreBorder: true,\n        createQuadrilaterals: true\n      });\n    }\n\n    render() {\n      if (!this.data.hasPopup) {\n        this._createPopup(null, this.data);\n      }\n\n      if (this.quadrilaterals) {\n        return this._renderQuadrilaterals(\"strikeoutAnnotation\");\n      }\n\n      this.container.className = \"strikeoutAnnotation\";\n      return this.container;\n    }\n\n  }\n\n  class StampAnnotationElement extends AnnotationElement {\n    constructor(parameters) {\n      const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n      super(parameters, {\n        isRenderable,\n        ignoreBorder: true\n      });\n    }\n\n    render() {\n      this.container.className = \"stampAnnotation\";\n\n      if (!this.data.hasPopup) {\n        this._createPopup(null, this.data);\n      }\n\n      return this.container;\n    }\n\n  }\n\n  class FileAttachmentAnnotationElement extends AnnotationElement {\n    constructor(parameters) {\n      super(parameters, {\n        isRenderable: true\n      });\n      const {\n        filename,\n        content\n      } = this.data.file;\n      this.filename = (0, _display_utils.getFilenameFromUrl)(filename);\n      this.content = content;\n      this.linkService.eventBus && this.linkService.eventBus.dispatch(\"fileattachmentannotation\", { // lwf\n        source: this,\n        id: (0, _util.stringToPDFString)(filename),\n        filename,\n        content\n      });\n    }\n\n    render() {\n      this.container.className = \"fileAttachmentAnnotation\";\n      const trigger = document.createElement(\"div\");\n      trigger.style.height = this.container.style.height;\n      trigger.style.width = this.container.style.width;\n      trigger.addEventListener(\"dblclick\", this._download.bind(this));\n\n      if (!this.data.hasPopup && (this.data.title || this.data.contents)) {\n        this._createPopup(trigger, this.data);\n      }\n\n      this.container.appendChild(trigger);\n      return this.container;\n    }\n\n    _download() {\n      if (!this.downloadManager) {\n        (0, _util.warn)(\"Download cannot be started due to unavailable download manager\");\n        return;\n      }\n\n      this.downloadManager.downloadData(this.content, this.filename, \"\");\n    }\n\n  }\n\n  class AnnotationLayer {\n    static render(parameters) {\n      const sortedAnnotations = [],\n            popupAnnotations = [];\n\n      for (const data of parameters.annotations) {\n        if (!data) {\n          continue;\n        }\n\n        if (data.annotationType === _util.AnnotationType.POPUP) {\n          popupAnnotations.push(data);\n          continue;\n        }\n\n        sortedAnnotations.push(data);\n      }\n\n      if (popupAnnotations.length) {\n        sortedAnnotations.push(...popupAnnotations);\n      }\n\n      for (const data of sortedAnnotations) {\n        const element = AnnotationElementFactory.create({\n          data,\n          layer: parameters.div,\n          page: parameters.page,\n          viewport: parameters.viewport,\n          linkService: parameters.linkService,\n          downloadManager: parameters.downloadManager,\n          imageResourcesPath: parameters.imageResourcesPath || \"\",\n          renderInteractiveForms: typeof parameters.renderInteractiveForms === \"boolean\" ? parameters.renderInteractiveForms : true,\n          svgFactory: new _display_utils.DOMSVGFactory(),\n          annotationStorage: parameters.annotationStorage || new _annotation_storage.AnnotationStorage(),\n          enableScripting: parameters.enableScripting,\n          hasJSActions: parameters.hasJSActions,\n          mouseState: parameters.mouseState || {\n            isDown: false\n          }\n        });\n\n        if (element.isRenderable) {\n          const rendered = element.render();\n\n          if (data.hidden) {\n            rendered.style.visibility = \"hidden\";\n          }\n\n          if (Array.isArray(rendered)) {\n            for (const renderedElement of rendered) {\n              parameters.div.appendChild(renderedElement);\n            }\n          } else {\n            if (element instanceof PopupAnnotationElement) {\n              parameters.div.prepend(rendered);\n            } else {\n              parameters.div.appendChild(rendered);\n            }\n          }\n        }\n      }\n    }\n\n    static update(parameters) {\n      const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n\n      for (const data of parameters.annotations) {\n        const elements = parameters.div.querySelectorAll(`[data-annotation-id=\"${data.id}\"]`);\n\n        if (elements) {\n          elements.forEach(element => {\n            element.style.transform = transform;\n          });\n        }\n      }\n\n      parameters.div.removeAttribute(\"hidden\");\n    }\n\n  }\n\n  exports.AnnotationLayer = AnnotationLayer;\n\n  /***/ }),\n  /* 20 */\n  /***/ ((__unused_webpack_module, exports) => {\n\n\n\n  Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n  }));\n  exports.ColorConverters = void 0;\n\n  function makeColorComp(n) {\n    return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, \"0\");\n  }\n\n  class ColorConverters {\n    static CMYK_G([c, y, m, k]) {\n      return [\"G\", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];\n    }\n\n    static G_CMYK([g]) {\n      return [\"CMYK\", 0, 0, 0, 1 - g];\n    }\n\n    static G_RGB([g]) {\n      return [\"RGB\", g, g, g];\n    }\n\n    static G_HTML([g]) {\n      const G = makeColorComp(g);\n      return `#${G}${G}${G}`;\n    }\n\n    static RGB_G([r, g, b]) {\n      return [\"G\", 0.3 * r + 0.59 * g + 0.11 * b];\n    }\n\n    static RGB_HTML([r, g, b]) {\n      const R = makeColorComp(r);\n      const G = makeColorComp(g);\n      const B = makeColorComp(b);\n      return `#${R}${G}${B}`;\n    }\n\n    static T_HTML() {\n      return \"#00000000\";\n    }\n\n    static CMYK_RGB([c, y, m, k]) {\n      return [\"RGB\", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];\n    }\n\n    static CMYK_HTML(components) {\n      return this.RGB_HTML(this.CMYK_RGB(components));\n    }\n\n    static RGB_CMYK([r, g, b]) {\n      const c = 1 - r;\n      const m = 1 - g;\n      const y = 1 - b;\n      const k = Math.min(c, m, y);\n      return [\"CMYK\", c, m, y, k];\n    }\n\n  }\n\n  exports.ColorConverters = ColorConverters;\n\n  /***/ }),\n  /* 21 */\n  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\n  Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n  }));\n  exports.renderTextLayer = void 0;\n\n  var _util = __w_pdfjs_require__(2);\n\n  const renderTextLayer = function renderTextLayerClosure() {\n    const MAX_TEXT_DIVS_TO_RENDER = 100000;\n    const NonWhitespaceRegexp = /\\S/;\n\n    function isAllWhitespace(str) {\n      return !NonWhitespaceRegexp.test(str);\n    }\n\n    function appendText(task, geom, styles) {\n      const textDiv = document.createElement(\"span\");\n      const textDivProperties = {\n        angle: 0,\n        canvasWidth: 0,\n        isWhitespace: false,\n        originalTransform: null,\n        paddingBottom: 0,\n        paddingLeft: 0,\n        paddingRight: 0,\n        paddingTop: 0,\n        scale: 1\n      };\n\n      task._textDivs.push(textDiv);\n\n      if (isAllWhitespace(geom.str)) {\n        textDivProperties.isWhitespace = true;\n\n        task._textDivProperties.set(textDiv, textDivProperties);\n\n        return;\n      }\n\n      const tx = _util.Util.transform(task._viewport.transform, geom.transform);\n\n      let angle = Math.atan2(tx[1], tx[0]);\n      const style = styles[geom.fontName];\n\n      if (style.vertical) {\n        angle += Math.PI / 2;\n      }\n\n      const fontHeight = Math.sqrt(tx[2] * tx[2] + tx[3] * tx[3]);\n      let fontAscent = fontHeight;\n\n      if (style.ascent) {\n        fontAscent = style.ascent * fontAscent;\n      } else if (style.descent) {\n        fontAscent = (1 + style.descent) * fontAscent;\n      }\n\n      let left, top;\n\n      if (angle === 0) {\n        left = tx[4];\n        top = tx[5] - fontAscent;\n      } else {\n        left = tx[4] + fontAscent * Math.sin(angle);\n        top = tx[5] - fontAscent * Math.cos(angle);\n      }\n\n      textDiv.style.left = `${left}px`;\n      textDiv.style.top = `${top}px`;\n      textDiv.style.fontSize = `${fontHeight}px`;\n      textDiv.style.fontFamily = style.fontFamily;\n      textDiv.textContent = geom.str;\n\n      if (task._fontInspectorEnabled) {\n        textDiv.dataset.fontName = geom.fontName;\n      }\n\n      if (angle !== 0) {\n        textDivProperties.angle = angle * (180 / Math.PI);\n      }\n\n      let shouldScaleText = false;\n\n      if (geom.str.length > 1) {\n        shouldScaleText = true;\n      } else if (geom.transform[0] !== geom.transform[3]) {\n        const absScaleX = Math.abs(geom.transform[0]),\n              absScaleY = Math.abs(geom.transform[3]);\n\n        if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {\n          shouldScaleText = true;\n        }\n      }\n\n      if (shouldScaleText) {\n        if (style.vertical) {\n          textDivProperties.canvasWidth = geom.height * task._viewport.scale;\n        } else {\n          textDivProperties.canvasWidth = geom.width * task._viewport.scale;\n        }\n      }\n\n      task._textDivProperties.set(textDiv, textDivProperties);\n\n      if (task._textContentStream) {\n        task._layoutText(textDiv);\n      }\n\n      if (task._enhanceTextSelection) {\n        let angleCos = 1,\n            angleSin = 0;\n\n        if (angle !== 0) {\n          angleCos = Math.cos(angle);\n          angleSin = Math.sin(angle);\n        }\n\n        const divWidth = (style.vertical ? geom.height : geom.width) * task._viewport.scale;\n        const divHeight = fontHeight;\n        let m, b;\n\n        if (angle !== 0) {\n          m = [angleCos, angleSin, -angleSin, angleCos, left, top];\n          b = _util.Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m);\n        } else {\n          b = [left, top, left + divWidth, top + divHeight];\n        }\n\n        task._bounds.push({\n          left: b[0],\n          top: b[1],\n          right: b[2],\n          bottom: b[3],\n          div: textDiv,\n          size: [divWidth, divHeight],\n          m\n        });\n      }\n    }\n\n    function render(task) {\n      if (task._canceled) {\n        return;\n      }\n\n      const textDivs = task._textDivs;\n      const capability = task._capability;\n      const textDivsLength = textDivs.length;\n\n      if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {\n        task._renderingDone = true;\n        capability.resolve();\n        return;\n      }\n\n      if (!task._textContentStream) {\n        for (let i = 0; i < textDivsLength; i++) {\n          task._layoutText(textDivs[i]);\n        }\n      }\n\n      task._renderingDone = true;\n      capability.resolve();\n    }\n\n    function findPositiveMin(ts, offset, count) {\n      let result = 0;\n\n      for (let i = 0; i < count; i++) {\n        const t = ts[offset++];\n\n        if (t > 0) {\n          result = result ? Math.min(t, result) : t;\n        }\n      }\n\n      return result;\n    }\n\n    function expand(task) {\n      const bounds = task._bounds;\n      const viewport = task._viewport;\n      const expanded = expandBounds(viewport.width, viewport.height, bounds);\n\n      for (let i = 0; i < expanded.length; i++) {\n        const div = bounds[i].div;\n\n        const divProperties = task._textDivProperties.get(div);\n\n        if (divProperties.angle === 0) {\n          divProperties.paddingLeft = bounds[i].left - expanded[i].left;\n          divProperties.paddingTop = bounds[i].top - expanded[i].top;\n          divProperties.paddingRight = expanded[i].right - bounds[i].right;\n          divProperties.paddingBottom = expanded[i].bottom - bounds[i].bottom;\n\n          task._textDivProperties.set(div, divProperties);\n\n          continue;\n        }\n\n        const e = expanded[i],\n              b = bounds[i];\n        const m = b.m,\n              c = m[0],\n              s = m[1];\n        const points = [[0, 0], [0, b.size[1]], [b.size[0], 0], b.size];\n        const ts = new Float64Array(64);\n        points.forEach(function (p, j) {\n          const t = _util.Util.applyTransform(p, m);\n\n          ts[j + 0] = c && (e.left - t[0]) / c;\n          ts[j + 4] = s && (e.top - t[1]) / s;\n          ts[j + 8] = c && (e.right - t[0]) / c;\n          ts[j + 12] = s && (e.bottom - t[1]) / s;\n          ts[j + 16] = s && (e.left - t[0]) / -s;\n          ts[j + 20] = c && (e.top - t[1]) / c;\n          ts[j + 24] = s && (e.right - t[0]) / -s;\n          ts[j + 28] = c && (e.bottom - t[1]) / c;\n          ts[j + 32] = c && (e.left - t[0]) / -c;\n          ts[j + 36] = s && (e.top - t[1]) / -s;\n          ts[j + 40] = c && (e.right - t[0]) / -c;\n          ts[j + 44] = s && (e.bottom - t[1]) / -s;\n          ts[j + 48] = s && (e.left - t[0]) / s;\n          ts[j + 52] = c && (e.top - t[1]) / -c;\n          ts[j + 56] = s && (e.right - t[0]) / s;\n          ts[j + 60] = c && (e.bottom - t[1]) / -c;\n        });\n        const boxScale = 1 + Math.min(Math.abs(c), Math.abs(s));\n        divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale;\n        divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale;\n        divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale;\n        divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale;\n\n        task._textDivProperties.set(div, divProperties);\n      }\n    }\n\n    function expandBounds(width, height, boxes) {\n      const bounds = boxes.map(function (box, i) {\n        return {\n          x1: box.left,\n          y1: box.top,\n          x2: box.right,\n          y2: box.bottom,\n          index: i,\n          x1New: undefined,\n          x2New: undefined\n        };\n      });\n      expandBoundsLTR(width, bounds);\n      const expanded = new Array(boxes.length);\n      bounds.forEach(function (b) {\n        const i = b.index;\n        expanded[i] = {\n          left: b.x1New,\n          top: 0,\n          right: b.x2New,\n          bottom: 0\n        };\n      });\n      boxes.map(function (box, i) {\n        const e = expanded[i],\n              b = bounds[i];\n        b.x1 = box.top;\n        b.y1 = width - e.right;\n        b.x2 = box.bottom;\n        b.y2 = width - e.left;\n        b.index = i;\n        b.x1New = undefined;\n        b.x2New = undefined;\n      });\n      expandBoundsLTR(height, bounds);\n      bounds.forEach(function (b) {\n        const i = b.index;\n        expanded[i].top = b.x1New;\n        expanded[i].bottom = b.x2New;\n      });\n      return expanded;\n    }\n\n    function expandBoundsLTR(width, bounds) {\n      bounds.sort(function (a, b) {\n        return a.x1 - b.x1 || a.index - b.index;\n      });\n      const fakeBoundary = {\n        x1: -Infinity,\n        y1: -Infinity,\n        x2: 0,\n        y2: Infinity,\n        index: -1,\n        x1New: 0,\n        x2New: 0\n      };\n      const horizon = [{\n        start: -Infinity,\n        end: Infinity,\n        boundary: fakeBoundary\n      }];\n      bounds.forEach(function (boundary) {\n        let i = 0;\n\n        while (i < horizon.length && horizon[i].end <= boundary.y1) {\n          i++;\n        }\n\n        let j = horizon.length - 1;\n\n        while (j >= 0 && horizon[j].start >= boundary.y2) {\n          j--;\n        }\n\n        let horizonPart, affectedBoundary;\n        let q,\n            k,\n            maxXNew = -Infinity;\n\n        for (q = i; q <= j; q++) {\n          horizonPart = horizon[q];\n          affectedBoundary = horizonPart.boundary;\n          let xNew;\n\n          if (affectedBoundary.x2 > boundary.x1) {\n            xNew = affectedBoundary.index > boundary.index ? affectedBoundary.x1New : boundary.x1;\n          } else if (affectedBoundary.x2New === undefined) {\n            xNew = (affectedBoundary.x2 + boundary.x1) / 2;\n          } else {\n            xNew = affectedBoundary.x2New;\n          }\n\n          if (xNew > maxXNew) {\n            maxXNew = xNew;\n          }\n        }\n\n        boundary.x1New = maxXNew;\n\n        for (q = i; q <= j; q++) {\n          horizonPart = horizon[q];\n          affectedBoundary = horizonPart.boundary;\n\n          if (affectedBoundary.x2New === undefined) {\n            if (affectedBoundary.x2 > boundary.x1) {\n              if (affectedBoundary.index > boundary.index) {\n                affectedBoundary.x2New = affectedBoundary.x2;\n              }\n            } else {\n              affectedBoundary.x2New = maxXNew;\n            }\n          } else if (affectedBoundary.x2New > maxXNew) {\n            affectedBoundary.x2New = Math.max(maxXNew, affectedBoundary.x2);\n          }\n        }\n\n        const changedHorizon = [];\n        let lastBoundary = null;\n\n        for (q = i; q <= j; q++) {\n          horizonPart = horizon[q];\n          affectedBoundary = horizonPart.boundary;\n          const useBoundary = affectedBoundary.x2 > boundary.x2 ? affectedBoundary : boundary;\n\n          if (lastBoundary === useBoundary) {\n            changedHorizon[changedHorizon.length - 1].end = horizonPart.end;\n          } else {\n            changedHorizon.push({\n              start: horizonPart.start,\n              end: horizonPart.end,\n              boundary: useBoundary\n            });\n            lastBoundary = useBoundary;\n          }\n        }\n\n        if (horizon[i].start < boundary.y1) {\n          changedHorizon[0].start = boundary.y1;\n          changedHorizon.unshift({\n            start: horizon[i].start,\n            end: boundary.y1,\n            boundary: horizon[i].boundary\n          });\n        }\n\n        if (boundary.y2 < horizon[j].end) {\n          changedHorizon[changedHorizon.length - 1].end = boundary.y2;\n          changedHorizon.push({\n            start: boundary.y2,\n            end: horizon[j].end,\n            boundary: horizon[j].boundary\n          });\n        }\n\n        for (q = i; q <= j; q++) {\n          horizonPart = horizon[q];\n          affectedBoundary = horizonPart.boundary;\n\n          if (affectedBoundary.x2New !== undefined) {\n            continue;\n          }\n\n          let used = false;\n\n          for (k = i - 1; !used && k >= 0 && horizon[k].start >= affectedBoundary.y1; k--) {\n            used = horizon[k].boundary === affectedBoundary;\n          }\n\n          for (k = j + 1; !used && k < horizon.length && horizon[k].end <= affectedBoundary.y2; k++) {\n            used = horizon[k].boundary === affectedBoundary;\n          }\n\n          for (k = 0; !used && k < changedHorizon.length; k++) {\n            used = changedHorizon[k].boundary === affectedBoundary;\n          }\n\n          if (!used) {\n            affectedBoundary.x2New = maxXNew;\n          }\n        }\n\n        Array.prototype.splice.apply(horizon, [i, j - i + 1].concat(changedHorizon));\n      });\n      horizon.forEach(function (horizonPart) {\n        const affectedBoundary = horizonPart.boundary;\n\n        if (affectedBoundary.x2New === undefined) {\n          affectedBoundary.x2New = Math.max(width, affectedBoundary.x2);\n        }\n      });\n    }\n\n    function TextLayerRenderTask({\n      textContent,\n      textContentStream,\n      container,\n      viewport,\n      textDivs,\n      textContentItemsStr,\n      enhanceTextSelection\n    }) {\n      this._textContent = textContent;\n      this._textContentStream = textContentStream;\n      this._container = container;\n      this._document = container.ownerDocument;\n      this._viewport = viewport;\n      this._textDivs = textDivs || [];\n      this._textContentItemsStr = textContentItemsStr || [];\n      this._enhanceTextSelection = !!enhanceTextSelection;\n      this._fontInspectorEnabled = !!(globalThis.FontInspector && globalThis.FontInspector.enabled); // lwf\n      this._reader = null;\n      this._layoutTextLastFontSize = null;\n      this._layoutTextLastFontFamily = null;\n      this._layoutTextCtx = null;\n      this._textDivProperties = new WeakMap();\n      this._renderingDone = false;\n      this._canceled = false;\n      this._capability = (0, _util.createPromiseCapability)();\n      this._renderTimer = null;\n      this._bounds = [];\n\n      this._capability.promise.finally(() => {\n        if (this._layoutTextCtx) {\n          this._layoutTextCtx.canvas.width = 0;\n          this._layoutTextCtx.canvas.height = 0;\n          this._layoutTextCtx = null;\n        }\n      }).catch(() => {});\n    }\n\n    TextLayerRenderTask.prototype = {\n      get promise() {\n        return this._capability.promise;\n      },\n\n      cancel: function TextLayer_cancel() {\n        this._canceled = true;\n\n        if (this._reader) {\n          this._reader.cancel(new _util.AbortException(\"TextLayer task cancelled.\"));\n\n          this._reader = null;\n        }\n\n        if (this._renderTimer !== null) {\n          clearTimeout(this._renderTimer);\n          this._renderTimer = null;\n        }\n\n        this._capability.reject(new Error(\"TextLayer task cancelled.\"));\n      },\n\n      _processItems(items, styleCache) {\n        for (let i = 0, len = items.length; i < len; i++) {\n          this._textContentItemsStr.push(items[i].str);\n\n          appendText(this, items[i], styleCache);\n        }\n      },\n\n      _layoutText(textDiv) {\n        const textDivProperties = this._textDivProperties.get(textDiv);\n\n        if (textDivProperties.isWhitespace) {\n          return;\n        }\n\n        let transform = \"\";\n\n        if (textDivProperties.canvasWidth !== 0) {\n          const {\n            fontSize,\n            fontFamily\n          } = textDiv.style;\n\n          if (fontSize !== this._layoutTextLastFontSize || fontFamily !== this._layoutTextLastFontFamily) {\n            this._layoutTextCtx.font = `${fontSize} ${fontFamily}`;\n            this._layoutTextLastFontSize = fontSize;\n            this._layoutTextLastFontFamily = fontFamily;\n          }\n\n          const {\n            width\n          } = this._layoutTextCtx.measureText(textDiv.textContent);\n\n          if (width > 0) {\n            textDivProperties.scale = textDivProperties.canvasWidth / width;\n            transform = `scaleX(${textDivProperties.scale})`;\n          }\n        }\n\n        if (textDivProperties.angle !== 0) {\n          transform = `rotate(${textDivProperties.angle}deg) ${transform}`;\n        }\n\n        if (transform.length > 0) {\n          if (this._enhanceTextSelection) {\n            textDivProperties.originalTransform = transform;\n          }\n\n          textDiv.style.transform = transform;\n        }\n\n        this._textDivProperties.set(textDiv, textDivProperties);\n\n        this._container.appendChild(textDiv);\n      },\n\n      _render: function TextLayer_render(timeout) {\n        const capability = (0, _util.createPromiseCapability)();\n        let styleCache = Object.create(null);\n\n        const canvas = this._document.createElement(\"canvas\");\n\n        canvas.mozOpaque = true;\n        this._layoutTextCtx = canvas.getContext(\"2d\", {\n          alpha: false\n        });\n\n        if (this._textContent) {\n          const textItems = this._textContent.items;\n          const textStyles = this._textContent.styles;\n\n          this._processItems(textItems, textStyles);\n\n          capability.resolve();\n        } else if (this._textContentStream) {\n          const pump = () => {\n            this._reader.read().then(({\n              value,\n              done\n            }) => {\n              if (done) {\n                capability.resolve();\n                return;\n              }\n\n              Object.assign(styleCache, value.styles);\n\n              this._processItems(value.items, styleCache);\n\n              pump();\n            }, capability.reject);\n          };\n\n          this._reader = this._textContentStream.getReader();\n          pump();\n        } else {\n          throw new Error('Neither \"textContent\" nor \"textContentStream\"' + \" parameters specified.\");\n        }\n\n        capability.promise.then(() => {\n          styleCache = null;\n\n          if (!timeout) {\n            render(this);\n          } else {\n            this._renderTimer = setTimeout(() => {\n              render(this);\n              this._renderTimer = null;\n            }, timeout);\n          }\n        }, this._capability.reject);\n      },\n      expandTextDivs: function TextLayer_expandTextDivs(expandDivs) {\n        if (!this._enhanceTextSelection || !this._renderingDone) {\n          return;\n        }\n\n        if (this._bounds !== null) {\n          expand(this);\n          this._bounds = null;\n        }\n\n        const transformBuf = [],\n              paddingBuf = [];\n\n        for (let i = 0, ii = this._textDivs.length; i < ii; i++) {\n          const div = this._textDivs[i];\n\n          const divProps = this._textDivProperties.get(div);\n\n          if (divProps.isWhitespace) {\n            continue;\n          }\n\n          if (expandDivs) {\n            transformBuf.length = 0;\n            paddingBuf.length = 0;\n\n            if (divProps.originalTransform) {\n              transformBuf.push(divProps.originalTransform);\n            }\n\n            if (divProps.paddingTop > 0) {\n              paddingBuf.push(`${divProps.paddingTop}px`);\n              transformBuf.push(`translateY(${-divProps.paddingTop}px)`);\n            } else {\n              paddingBuf.push(0);\n            }\n\n            if (divProps.paddingRight > 0) {\n              paddingBuf.push(`${divProps.paddingRight / divProps.scale}px`);\n            } else {\n              paddingBuf.push(0);\n            }\n\n            if (divProps.paddingBottom > 0) {\n              paddingBuf.push(`${divProps.paddingBottom}px`);\n            } else {\n              paddingBuf.push(0);\n            }\n\n            if (divProps.paddingLeft > 0) {\n              paddingBuf.push(`${divProps.paddingLeft / divProps.scale}px`);\n              transformBuf.push(`translateX(${-divProps.paddingLeft / divProps.scale}px)`);\n            } else {\n              paddingBuf.push(0);\n            }\n\n            div.style.padding = paddingBuf.join(\" \");\n\n            if (transformBuf.length) {\n              div.style.transform = transformBuf.join(\" \");\n            }\n          } else {\n            div.style.padding = null;\n            div.style.transform = divProps.originalTransform;\n          }\n        }\n      }\n    };\n\n    function renderTextLayer(renderParameters) {\n      const task = new TextLayerRenderTask({\n        textContent: renderParameters.textContent,\n        textContentStream: renderParameters.textContentStream,\n        container: renderParameters.container,\n        viewport: renderParameters.viewport,\n        textDivs: renderParameters.textDivs,\n        textContentItemsStr: renderParameters.textContentItemsStr,\n        enhanceTextSelection: renderParameters.enhanceTextSelection\n      });\n\n      task._render(renderParameters.timeout);\n\n      return task;\n    }\n\n    return renderTextLayer;\n  }();\n\n  exports.renderTextLayer = renderTextLayer;\n\n  /***/ }),\n  /* 22 */\n  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\n  Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n  }));\n  exports.SVGGraphics = void 0;\n\n  var _util = __w_pdfjs_require__(2);\n\n  var _display_utils = __w_pdfjs_require__(1);\n\n  var _is_node = __w_pdfjs_require__(4);\n\n  let SVGGraphics = function () {\n    throw new Error(\"Not implemented: SVGGraphics\");\n  };\n\n  exports.SVGGraphics = SVGGraphics;\n  {\n    const SVG_DEFAULTS = {\n      fontStyle: \"normal\",\n      fontWeight: \"normal\",\n      fillColor: \"#000000\"\n    };\n    const XML_NS = \"http://www.w3.org/XML/1998/namespace\";\n    const XLINK_NS = \"http://www.w3.org/1999/xlink\";\n    const LINE_CAP_STYLES = [\"butt\", \"round\", \"square\"];\n    const LINE_JOIN_STYLES = [\"miter\", \"round\", \"bevel\"];\n\n    const convertImgDataToPng = function () {\n      const PNG_HEADER = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);\n      const CHUNK_WRAPPER_SIZE = 12;\n      const crcTable = new Int32Array(256);\n\n      for (let i = 0; i < 256; i++) {\n        let c = i;\n\n        for (let h = 0; h < 8; h++) {\n          if (c & 1) {\n            c = 0xedb88320 ^ c >> 1 & 0x7fffffff;\n          } else {\n            c = c >> 1 & 0x7fffffff;\n          }\n        }\n\n        crcTable[i] = c;\n      }\n\n      function crc32(data, start, end) {\n        let crc = -1;\n\n        for (let i = start; i < end; i++) {\n          const a = (crc ^ data[i]) & 0xff;\n          const b = crcTable[a];\n          crc = crc >>> 8 ^ b;\n        }\n\n        return crc ^ -1;\n      }\n\n      function writePngChunk(type, body, data, offset) {\n        let p = offset;\n        const len = body.length;\n        data[p] = len >> 24 & 0xff;\n        data[p + 1] = len >> 16 & 0xff;\n        data[p + 2] = len >> 8 & 0xff;\n        data[p + 3] = len & 0xff;\n        p += 4;\n        data[p] = type.charCodeAt(0) & 0xff;\n        data[p + 1] = type.charCodeAt(1) & 0xff;\n        data[p + 2] = type.charCodeAt(2) & 0xff;\n        data[p + 3] = type.charCodeAt(3) & 0xff;\n        p += 4;\n        data.set(body, p);\n        p += body.length;\n        const crc = crc32(data, offset + 4, p);\n        data[p] = crc >> 24 & 0xff;\n        data[p + 1] = crc >> 16 & 0xff;\n        data[p + 2] = crc >> 8 & 0xff;\n        data[p + 3] = crc & 0xff;\n      }\n\n      function adler32(data, start, end) {\n        let a = 1;\n        let b = 0;\n\n        for (let i = start; i < end; ++i) {\n          a = (a + (data[i] & 0xff)) % 65521;\n          b = (b + a) % 65521;\n        }\n\n        return b << 16 | a;\n      }\n\n      function deflateSync(literals) {\n        if (!_is_node.isNodeJS) {\n          return deflateSyncUncompressed(literals);\n        }\n\n        try {\n          let input;\n\n          if (parseInt(process.versions.node) >= 8) {\n            input = literals;\n          } else {\n            input = Buffer.from(literals);\n          }\n\n          const output = require(\"zlib\").deflateSync(input, {\n            level: 9\n          });\n\n          return output instanceof Uint8Array ? output : new Uint8Array(output);\n        } catch (e) {\n          (0, _util.warn)(\"Not compressing PNG because zlib.deflateSync is unavailable: \" + e);\n        }\n\n        return deflateSyncUncompressed(literals);\n      }\n\n      function deflateSyncUncompressed(literals) {\n        let len = literals.length;\n        const maxBlockLength = 0xffff;\n        const deflateBlocks = Math.ceil(len / maxBlockLength);\n        const idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);\n        let pi = 0;\n        idat[pi++] = 0x78;\n        idat[pi++] = 0x9c;\n        let pos = 0;\n\n        while (len > maxBlockLength) {\n          idat[pi++] = 0x00;\n          idat[pi++] = 0xff;\n          idat[pi++] = 0xff;\n          idat[pi++] = 0x00;\n          idat[pi++] = 0x00;\n          idat.set(literals.subarray(pos, pos + maxBlockLength), pi);\n          pi += maxBlockLength;\n          pos += maxBlockLength;\n          len -= maxBlockLength;\n        }\n\n        idat[pi++] = 0x01;\n        idat[pi++] = len & 0xff;\n        idat[pi++] = len >> 8 & 0xff;\n        idat[pi++] = ~len & 0xffff & 0xff;\n        idat[pi++] = (~len & 0xffff) >> 8 & 0xff;\n        idat.set(literals.subarray(pos), pi);\n        pi += literals.length - pos;\n        const adler = adler32(literals, 0, literals.length);\n        idat[pi++] = adler >> 24 & 0xff;\n        idat[pi++] = adler >> 16 & 0xff;\n        idat[pi++] = adler >> 8 & 0xff;\n        idat[pi++] = adler & 0xff;\n        return idat;\n      }\n\n      function encode(imgData, kind, forceDataSchema, isMask) {\n        const width = imgData.width;\n        const height = imgData.height;\n        let bitDepth, colorType, lineSize;\n        const bytes = imgData.data;\n\n        switch (kind) {\n          case _util.ImageKind.GRAYSCALE_1BPP:\n            colorType = 0;\n            bitDepth = 1;\n            lineSize = width + 7 >> 3;\n            break;\n\n          case _util.ImageKind.RGB_24BPP:\n            colorType = 2;\n            bitDepth = 8;\n            lineSize = width * 3;\n            break;\n\n          case _util.ImageKind.RGBA_32BPP:\n            colorType = 6;\n            bitDepth = 8;\n            lineSize = width * 4;\n            break;\n\n          default:\n            throw new Error(\"invalid format\");\n        }\n\n        const literals = new Uint8Array((1 + lineSize) * height);\n        let offsetLiterals = 0,\n            offsetBytes = 0;\n\n        for (let y = 0; y < height; ++y) {\n          literals[offsetLiterals++] = 0;\n          literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);\n          offsetBytes += lineSize;\n          offsetLiterals += lineSize;\n        }\n\n        if (kind === _util.ImageKind.GRAYSCALE_1BPP && isMask) {\n          offsetLiterals = 0;\n\n          for (let y = 0; y < height; y++) {\n            offsetLiterals++;\n\n            for (let i = 0; i < lineSize; i++) {\n              literals[offsetLiterals++] ^= 0xff;\n            }\n          }\n        }\n\n        const ihdr = new Uint8Array([width >> 24 & 0xff, width >> 16 & 0xff, width >> 8 & 0xff, width & 0xff, height >> 24 & 0xff, height >> 16 & 0xff, height >> 8 & 0xff, height & 0xff, bitDepth, colorType, 0x00, 0x00, 0x00]);\n        const idat = deflateSync(literals);\n        const pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;\n        const data = new Uint8Array(pngLength);\n        let offset = 0;\n        data.set(PNG_HEADER, offset);\n        offset += PNG_HEADER.length;\n        writePngChunk(\"IHDR\", ihdr, data, offset);\n        offset += CHUNK_WRAPPER_SIZE + ihdr.length;\n        writePngChunk(\"IDATA\", idat, data, offset);\n        offset += CHUNK_WRAPPER_SIZE + idat.length;\n        writePngChunk(\"IEND\", new Uint8Array(0), data, offset);\n        return (0, _util.createObjectURL)(data, \"image/png\", forceDataSchema);\n      }\n\n      return function convertImgDataToPng(imgData, forceDataSchema, isMask) {\n        const kind = imgData.kind === undefined ? _util.ImageKind.GRAYSCALE_1BPP : imgData.kind;\n        return encode(imgData, kind, forceDataSchema, isMask);\n      };\n    }();\n\n    class SVGExtraState {\n      constructor() {\n        this.fontSizeScale = 1;\n        this.fontWeight = SVG_DEFAULTS.fontWeight;\n        this.fontSize = 0;\n        this.textMatrix = _util.IDENTITY_MATRIX;\n        this.fontMatrix = _util.FONT_IDENTITY_MATRIX;\n        this.leading = 0;\n        this.textRenderingMode = _util.TextRenderingMode.FILL;\n        this.textMatrixScale = 1;\n        this.x = 0;\n        this.y = 0;\n        this.lineX = 0;\n        this.lineY = 0;\n        this.charSpacing = 0;\n        this.wordSpacing = 0;\n        this.textHScale = 1;\n        this.textRise = 0;\n        this.fillColor = SVG_DEFAULTS.fillColor;\n        this.strokeColor = \"#000000\";\n        this.fillAlpha = 1;\n        this.strokeAlpha = 1;\n        this.lineWidth = 1;\n        this.lineJoin = \"\";\n        this.lineCap = \"\";\n        this.miterLimit = 0;\n        this.dashArray = [];\n        this.dashPhase = 0;\n        this.dependencies = [];\n        this.activeClipUrl = null;\n        this.clipGroup = null;\n        this.maskId = \"\";\n      }\n\n      clone() {\n        return Object.create(this);\n      }\n\n      setCurrentPoint(x, y) {\n        this.x = x;\n        this.y = y;\n      }\n\n    }\n\n    function opListToTree(opList) {\n      let opTree = [];\n      const tmp = [];\n\n      for (const opListElement of opList) {\n        if (opListElement.fn === \"save\") {\n          opTree.push({\n            fnId: 92,\n            fn: \"group\",\n            items: []\n          });\n          tmp.push(opTree);\n          opTree = opTree[opTree.length - 1].items;\n          continue;\n        }\n\n        if (opListElement.fn === \"restore\") {\n          opTree = tmp.pop();\n        } else {\n          opTree.push(opListElement);\n        }\n      }\n\n      return opTree;\n    }\n\n    function pf(value) {\n      if (Number.isInteger(value)) {\n        return value.toString();\n      }\n\n      const s = value.toFixed(10);\n      let i = s.length - 1;\n\n      if (s[i] !== \"0\") {\n        return s;\n      }\n\n      do {\n        i--;\n      } while (s[i] === \"0\");\n\n      return s.substring(0, s[i] === \".\" ? i : i + 1);\n    }\n\n    function pm(m) {\n      if (m[4] === 0 && m[5] === 0) {\n        if (m[1] === 0 && m[2] === 0) {\n          if (m[0] === 1 && m[3] === 1) {\n            return \"\";\n          }\n\n          return `scale(${pf(m[0])} ${pf(m[3])})`;\n        }\n\n        if (m[0] === m[3] && m[1] === -m[2]) {\n          const a = Math.acos(m[0]) * 180 / Math.PI;\n          return `rotate(${pf(a)})`;\n        }\n      } else {\n        if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {\n          return `translate(${pf(m[4])} ${pf(m[5])})`;\n        }\n      }\n\n      return `matrix(${pf(m[0])} ${pf(m[1])} ${pf(m[2])} ${pf(m[3])} ${pf(m[4])} ` + `${pf(m[5])})`;\n    }\n\n    let clipCount = 0;\n    let maskCount = 0;\n    let shadingCount = 0;\n    exports.SVGGraphics = SVGGraphics = class SVGGraphics {\n      constructor(commonObjs, objs, forceDataSchema = false) {\n        this.svgFactory = new _display_utils.DOMSVGFactory();\n        this.current = new SVGExtraState();\n        this.transformMatrix = _util.IDENTITY_MATRIX;\n        this.transformStack = [];\n        this.extraStack = [];\n        this.commonObjs = commonObjs;\n        this.objs = objs;\n        this.pendingClip = null;\n        this.pendingEOFill = false;\n        this.embedFonts = false;\n        this.embeddedFonts = Object.create(null);\n        this.cssStyle = null;\n        this.forceDataSchema = !!forceDataSchema;\n        this._operatorIdMapping = [];\n\n        for (const op in _util.OPS) {\n          this._operatorIdMapping[_util.OPS[op]] = op;\n        }\n      }\n\n      save() {\n        this.transformStack.push(this.transformMatrix);\n        const old = this.current;\n        this.extraStack.push(old);\n        this.current = old.clone();\n      }\n\n      restore() {\n        this.transformMatrix = this.transformStack.pop();\n        this.current = this.extraStack.pop();\n        this.pendingClip = null;\n        this.tgrp = null;\n      }\n\n      group(items) {\n        this.save();\n        this.executeOpTree(items);\n        this.restore();\n      }\n\n      loadDependencies(operatorList) {\n        const fnArray = operatorList.fnArray;\n        const argsArray = operatorList.argsArray;\n\n        for (let i = 0, ii = fnArray.length; i < ii; i++) {\n          if (fnArray[i] !== _util.OPS.dependency) {\n            continue;\n          }\n\n          for (const obj of argsArray[i]) {\n            const objsPool = obj.startsWith(\"g_\") ? this.commonObjs : this.objs;\n            const promise = new Promise(resolve => {\n              objsPool.get(obj, resolve);\n            });\n            this.current.dependencies.push(promise);\n          }\n        }\n\n        return Promise.all(this.current.dependencies);\n      }\n\n      transform(a, b, c, d, e, f) {\n        const transformMatrix = [a, b, c, d, e, f];\n        this.transformMatrix = _util.Util.transform(this.transformMatrix, transformMatrix);\n        this.tgrp = null;\n      }\n\n      getSVG(operatorList, viewport) {\n        this.viewport = viewport;\n\n        const svgElement = this._initialize(viewport);\n\n        return this.loadDependencies(operatorList).then(() => {\n          this.transformMatrix = _util.IDENTITY_MATRIX;\n          this.executeOpTree(this.convertOpList(operatorList));\n          return svgElement;\n        });\n      }\n\n      convertOpList(operatorList) {\n        const operatorIdMapping = this._operatorIdMapping;\n        const argsArray = operatorList.argsArray;\n        const fnArray = operatorList.fnArray;\n        const opList = [];\n\n        for (let i = 0, ii = fnArray.length; i < ii; i++) {\n          const fnId = fnArray[i];\n          opList.push({\n            fnId,\n            fn: operatorIdMapping[fnId],\n            args: argsArray[i]\n          });\n        }\n\n        return opListToTree(opList);\n      }\n\n      executeOpTree(opTree) {\n        for (const opTreeElement of opTree) {\n          const fn = opTreeElement.fn;\n          const fnId = opTreeElement.fnId;\n          const args = opTreeElement.args;\n\n          switch (fnId | 0) {\n            case _util.OPS.beginText:\n              this.beginText();\n              break;\n\n            case _util.OPS.dependency:\n              break;\n\n            case _util.OPS.setLeading:\n              this.setLeading(args);\n              break;\n\n            case _util.OPS.setLeadingMoveText:\n              this.setLeadingMoveText(args[0], args[1]);\n              break;\n\n            case _util.OPS.setFont:\n              this.setFont(args);\n              break;\n\n            case _util.OPS.showText:\n              this.showText(args[0]);\n              break;\n\n            case _util.OPS.showSpacedText:\n              this.showText(args[0]);\n              break;\n\n            case _util.OPS.endText:\n              this.endText();\n              break;\n\n            case _util.OPS.moveText:\n              this.moveText(args[0], args[1]);\n              break;\n\n            case _util.OPS.setCharSpacing:\n              this.setCharSpacing(args[0]);\n              break;\n\n            case _util.OPS.setWordSpacing:\n              this.setWordSpacing(args[0]);\n              break;\n\n            case _util.OPS.setHScale:\n              this.setHScale(args[0]);\n              break;\n\n            case _util.OPS.setTextMatrix:\n              this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);\n              break;\n\n            case _util.OPS.setTextRise:\n              this.setTextRise(args[0]);\n              break;\n\n            case _util.OPS.setTextRenderingMode:\n              this.setTextRenderingMode(args[0]);\n              break;\n\n            case _util.OPS.setLineWidth:\n              this.setLineWidth(args[0]);\n              break;\n\n            case _util.OPS.setLineJoin:\n              this.setLineJoin(args[0]);\n              break;\n\n            case _util.OPS.setLineCap:\n              this.setLineCap(args[0]);\n              break;\n\n            case _util.OPS.setMiterLimit:\n              this.setMiterLimit(args[0]);\n              break;\n\n            case _util.OPS.setFillRGBColor:\n              this.setFillRGBColor(args[0], args[1], args[2]);\n              break;\n\n            case _util.OPS.setStrokeRGBColor:\n              this.setStrokeRGBColor(args[0], args[1], args[2]);\n              break;\n\n            case _util.OPS.setStrokeColorN:\n              this.setStrokeColorN(args);\n              break;\n\n            case _util.OPS.setFillColorN:\n              this.setFillColorN(args);\n              break;\n\n            case _util.OPS.shadingFill:\n              this.shadingFill(args[0]);\n              break;\n\n            case _util.OPS.setDash:\n              this.setDash(args[0], args[1]);\n              break;\n\n            case _util.OPS.setRenderingIntent:\n              this.setRenderingIntent(args[0]);\n              break;\n\n            case _util.OPS.setFlatness:\n              this.setFlatness(args[0]);\n              break;\n\n            case _util.OPS.setGState:\n              this.setGState(args[0]);\n              break;\n\n            case _util.OPS.fill:\n              this.fill();\n              break;\n\n            case _util.OPS.eoFill:\n              this.eoFill();\n              break;\n\n            case _util.OPS.stroke:\n              this.stroke();\n              break;\n\n            case _util.OPS.fillStroke:\n              this.fillStroke();\n              break;\n\n            case _util.OPS.eoFillStroke:\n              this.eoFillStroke();\n              break;\n\n            case _util.OPS.clip:\n              this.clip(\"nonzero\");\n              break;\n\n            case _util.OPS.eoClip:\n              this.clip(\"evenodd\");\n              break;\n\n            case _util.OPS.paintSolidColorImageMask:\n              this.paintSolidColorImageMask();\n              break;\n\n            case _util.OPS.paintImageXObject:\n              this.paintImageXObject(args[0]);\n              break;\n\n            case _util.OPS.paintInlineImageXObject:\n              this.paintInlineImageXObject(args[0]);\n              break;\n\n            case _util.OPS.paintImageMaskXObject:\n              this.paintImageMaskXObject(args[0]);\n              break;\n\n            case _util.OPS.paintFormXObjectBegin:\n              this.paintFormXObjectBegin(args[0], args[1]);\n              break;\n\n            case _util.OPS.paintFormXObjectEnd:\n              this.paintFormXObjectEnd();\n              break;\n\n            case _util.OPS.closePath:\n              this.closePath();\n              break;\n\n            case _util.OPS.closeStroke:\n              this.closeStroke();\n              break;\n\n            case _util.OPS.closeFillStroke:\n              this.closeFillStroke();\n              break;\n\n            case _util.OPS.closeEOFillStroke:\n              this.closeEOFillStroke();\n              break;\n\n            case _util.OPS.nextLine:\n              this.nextLine();\n              break;\n\n            case _util.OPS.transform:\n              this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);\n              break;\n\n            case _util.OPS.constructPath:\n              this.constructPath(args[0], args[1]);\n              break;\n\n            case _util.OPS.endPath:\n              this.endPath();\n              break;\n\n            case 92:\n              this.group(opTreeElement.items);\n              break;\n\n            default:\n              (0, _util.warn)(`Unimplemented operator ${fn}`);\n              break;\n          }\n        }\n      }\n\n      setWordSpacing(wordSpacing) {\n        this.current.wordSpacing = wordSpacing;\n      }\n\n      setCharSpacing(charSpacing) {\n        this.current.charSpacing = charSpacing;\n      }\n\n      nextLine() {\n        this.moveText(0, this.current.leading);\n      }\n\n      setTextMatrix(a, b, c, d, e, f) {\n        const current = this.current;\n        current.textMatrix = current.lineMatrix = [a, b, c, d, e, f];\n        current.textMatrixScale = Math.sqrt(a * a + b * b);\n        current.x = current.lineX = 0;\n        current.y = current.lineY = 0;\n        current.xcoords = [];\n        current.ycoords = [];\n        current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n        current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n        current.tspan.setAttributeNS(null, \"font-size\", `${pf(current.fontSize)}px`);\n        current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n        current.txtElement = this.svgFactory.createElement(\"svg:text\");\n        current.txtElement.appendChild(current.tspan);\n      }\n\n      beginText() {\n        const current = this.current;\n        current.x = current.lineX = 0;\n        current.y = current.lineY = 0;\n        current.textMatrix = _util.IDENTITY_MATRIX;\n        current.lineMatrix = _util.IDENTITY_MATRIX;\n        current.textMatrixScale = 1;\n        current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n        current.txtElement = this.svgFactory.createElement(\"svg:text\");\n        current.txtgrp = this.svgFactory.createElement(\"svg:g\");\n        current.xcoords = [];\n        current.ycoords = [];\n      }\n\n      moveText(x, y) {\n        const current = this.current;\n        current.x = current.lineX += x;\n        current.y = current.lineY += y;\n        current.xcoords = [];\n        current.ycoords = [];\n        current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n        current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n        current.tspan.setAttributeNS(null, \"font-size\", `${pf(current.fontSize)}px`);\n        current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n      }\n\n      showText(glyphs) {\n        const current = this.current;\n        const font = current.font;\n        const fontSize = current.fontSize;\n\n        if (fontSize === 0) {\n          return;\n        }\n\n        const fontSizeScale = current.fontSizeScale;\n        const charSpacing = current.charSpacing;\n        const wordSpacing = current.wordSpacing;\n        const fontDirection = current.fontDirection;\n        const textHScale = current.textHScale * fontDirection;\n        const vertical = font.vertical;\n        const spacingDir = vertical ? 1 : -1;\n        const defaultVMetrics = font.defaultVMetrics;\n        const widthAdvanceScale = fontSize * current.fontMatrix[0];\n        let x = 0;\n\n        for (const glyph of glyphs) {\n          if (glyph === null) {\n            x += fontDirection * wordSpacing;\n            continue;\n          } else if ((0, _util.isNum)(glyph)) {\n            x += spacingDir * glyph * fontSize / 1000;\n            continue;\n          }\n\n          const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n          const character = glyph.fontChar;\n          let scaledX, scaledY;\n          let width = glyph.width;\n\n          if (vertical) {\n            let vx;\n            const vmetric = glyph.vmetric || defaultVMetrics;\n            vx = glyph.vmetric ? vmetric[1] : width * 0.5;\n            vx = -vx * widthAdvanceScale;\n            const vy = vmetric[2] * widthAdvanceScale;\n            width = vmetric ? -vmetric[0] : width;\n            scaledX = vx / fontSizeScale;\n            scaledY = (x + vy) / fontSizeScale;\n          } else {\n            scaledX = x / fontSizeScale;\n            scaledY = 0;\n          }\n\n          if (glyph.isInFont || font.missingFile) {\n            current.xcoords.push(current.x + scaledX);\n\n            if (vertical) {\n              current.ycoords.push(-current.y + scaledY);\n            }\n\n            current.tspan.textContent += character;\n          } else {}\n\n          let charWidth;\n\n          if (vertical) {\n            charWidth = width * widthAdvanceScale - spacing * fontDirection;\n          } else {\n            charWidth = width * widthAdvanceScale + spacing * fontDirection;\n          }\n\n          x += charWidth;\n        }\n\n        current.tspan.setAttributeNS(null, \"x\", current.xcoords.map(pf).join(\" \"));\n\n        if (vertical) {\n          current.tspan.setAttributeNS(null, \"y\", current.ycoords.map(pf).join(\" \"));\n        } else {\n          current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n        }\n\n        if (vertical) {\n          current.y -= x;\n        } else {\n          current.x += x * textHScale;\n        }\n\n        current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n        current.tspan.setAttributeNS(null, \"font-size\", `${pf(current.fontSize)}px`);\n\n        if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {\n          current.tspan.setAttributeNS(null, \"font-style\", current.fontStyle);\n        }\n\n        if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {\n          current.tspan.setAttributeNS(null, \"font-weight\", current.fontWeight);\n        }\n\n        const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n\n        if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n          if (current.fillColor !== SVG_DEFAULTS.fillColor) {\n            current.tspan.setAttributeNS(null, \"fill\", current.fillColor);\n          }\n\n          if (current.fillAlpha < 1) {\n            current.tspan.setAttributeNS(null, \"fill-opacity\", current.fillAlpha);\n          }\n        } else if (current.textRenderingMode === _util.TextRenderingMode.ADD_TO_PATH) {\n          current.tspan.setAttributeNS(null, \"fill\", \"transparent\");\n        } else {\n          current.tspan.setAttributeNS(null, \"fill\", \"none\");\n        }\n\n        if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n          const lineWidthScale = 1 / (current.textMatrixScale || 1);\n\n          this._setStrokeAttributes(current.tspan, lineWidthScale);\n        }\n\n        let textMatrix = current.textMatrix;\n\n        if (current.textRise !== 0) {\n          textMatrix = textMatrix.slice();\n          textMatrix[5] += current.textRise;\n        }\n\n        current.txtElement.setAttributeNS(null, \"transform\", `${pm(textMatrix)} scale(${pf(textHScale)}, -1)`);\n        current.txtElement.setAttributeNS(XML_NS, \"xml:space\", \"preserve\");\n        current.txtElement.appendChild(current.tspan);\n        current.txtgrp.appendChild(current.txtElement);\n\n        this._ensureTransformGroup().appendChild(current.txtElement);\n      }\n\n      setLeadingMoveText(x, y) {\n        this.setLeading(-y);\n        this.moveText(x, y);\n      }\n\n      addFontStyle(fontObj) {\n        if (!fontObj.data) {\n          throw new Error(\"addFontStyle: No font data available, \" + 'ensure that the \"fontExtraProperties\" API parameter is set.');\n        }\n\n        if (!this.cssStyle) {\n          this.cssStyle = this.svgFactory.createElement(\"svg:style\");\n          this.cssStyle.setAttributeNS(null, \"type\", \"text/css\");\n          this.defs.appendChild(this.cssStyle);\n        }\n\n        const url = (0, _util.createObjectURL)(fontObj.data, fontObj.mimetype, this.forceDataSchema);\n        this.cssStyle.textContent += `@font-face { font-family: \"${fontObj.loadedName}\";` + ` src: url(${url}); }\\n`;\n      }\n\n      setFont(details) {\n        const current = this.current;\n        const fontObj = this.commonObjs.get(details[0]);\n        let size = details[1];\n        current.font = fontObj;\n\n        if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) {\n          this.addFontStyle(fontObj);\n          this.embeddedFonts[fontObj.loadedName] = fontObj;\n        }\n\n        current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;\n        let bold = \"normal\";\n\n        if (fontObj.black) {\n          bold = \"900\";\n        } else if (fontObj.bold) {\n          bold = \"bold\";\n        }\n\n        const italic = fontObj.italic ? \"italic\" : \"normal\";\n\n        if (size < 0) {\n          size = -size;\n          current.fontDirection = -1;\n        } else {\n          current.fontDirection = 1;\n        }\n\n        current.fontSize = size;\n        current.fontFamily = fontObj.loadedName;\n        current.fontWeight = bold;\n        current.fontStyle = italic;\n        current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n        current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n        current.xcoords = [];\n        current.ycoords = [];\n      }\n\n      endText() {\n        const current = this.current;\n\n        if (current.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG && current.txtElement && current.txtElement.hasChildNodes()) { // lwf\n          current.element = current.txtElement;\n          this.clip(\"nonzero\");\n          this.endPath();\n        }\n      }\n\n      setLineWidth(width) {\n        if (width > 0) {\n          this.current.lineWidth = width;\n        }\n      }\n\n      setLineCap(style) {\n        this.current.lineCap = LINE_CAP_STYLES[style];\n      }\n\n      setLineJoin(style) {\n        this.current.lineJoin = LINE_JOIN_STYLES[style];\n      }\n\n      setMiterLimit(limit) {\n        this.current.miterLimit = limit;\n      }\n\n      setStrokeAlpha(strokeAlpha) {\n        this.current.strokeAlpha = strokeAlpha;\n      }\n\n      setStrokeRGBColor(r, g, b) {\n        this.current.strokeColor = _util.Util.makeHexColor(r, g, b);\n      }\n\n      setFillAlpha(fillAlpha) {\n        this.current.fillAlpha = fillAlpha;\n      }\n\n      setFillRGBColor(r, g, b) {\n        this.current.fillColor = _util.Util.makeHexColor(r, g, b);\n        this.current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n        this.current.xcoords = [];\n        this.current.ycoords = [];\n      }\n\n      setStrokeColorN(args) {\n        this.current.strokeColor = this._makeColorN_Pattern(args);\n      }\n\n      setFillColorN(args) {\n        this.current.fillColor = this._makeColorN_Pattern(args);\n      }\n\n      shadingFill(args) {\n        const width = this.viewport.width;\n        const height = this.viewport.height;\n\n        const inv = _util.Util.inverseTransform(this.transformMatrix);\n\n        const bl = _util.Util.applyTransform([0, 0], inv);\n\n        const br = _util.Util.applyTransform([0, height], inv);\n\n        const ul = _util.Util.applyTransform([width, 0], inv);\n\n        const ur = _util.Util.applyTransform([width, height], inv);\n\n        const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);\n        const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);\n        const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);\n        const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);\n        const rect = this.svgFactory.createElement(\"svg:rect\");\n        rect.setAttributeNS(null, \"x\", x0);\n        rect.setAttributeNS(null, \"y\", y0);\n        rect.setAttributeNS(null, \"width\", x1 - x0);\n        rect.setAttributeNS(null, \"height\", y1 - y0);\n        rect.setAttributeNS(null, \"fill\", this._makeShadingPattern(args));\n\n        if (this.current.fillAlpha < 1) {\n          rect.setAttributeNS(null, \"fill-opacity\", this.current.fillAlpha);\n        }\n\n        this._ensureTransformGroup().appendChild(rect);\n      }\n\n      _makeColorN_Pattern(args) {\n        if (args[0] === \"TilingPattern\") {\n          return this._makeTilingPattern(args);\n        }\n\n        return this._makeShadingPattern(args);\n      }\n\n      _makeTilingPattern(args) {\n        const color = args[1];\n        const operatorList = args[2];\n        const matrix = args[3] || _util.IDENTITY_MATRIX;\n        const [x0, y0, x1, y1] = args[4];\n        const xstep = args[5];\n        const ystep = args[6];\n        const paintType = args[7];\n        const tilingId = `shading${shadingCount++}`;\n\n        const [tx0, ty0] = _util.Util.applyTransform([x0, y0], matrix);\n\n        const [tx1, ty1] = _util.Util.applyTransform([x1, y1], matrix);\n\n        const [xscale, yscale] = _util.Util.singularValueDecompose2dScale(matrix);\n\n        const txstep = xstep * xscale;\n        const tystep = ystep * yscale;\n        const tiling = this.svgFactory.createElement(\"svg:pattern\");\n        tiling.setAttributeNS(null, \"id\", tilingId);\n        tiling.setAttributeNS(null, \"patternUnits\", \"userSpaceOnUse\");\n        tiling.setAttributeNS(null, \"width\", txstep);\n        tiling.setAttributeNS(null, \"height\", tystep);\n        tiling.setAttributeNS(null, \"x\", `${tx0}`);\n        tiling.setAttributeNS(null, \"y\", `${ty0}`);\n        const svg = this.svg;\n        const transformMatrix = this.transformMatrix;\n        const fillColor = this.current.fillColor;\n        const strokeColor = this.current.strokeColor;\n        const bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);\n        this.svg = bbox;\n        this.transformMatrix = matrix;\n\n        if (paintType === 2) {\n          const cssColor = _util.Util.makeHexColor(...color);\n\n          this.current.fillColor = cssColor;\n          this.current.strokeColor = cssColor;\n        }\n\n        this.executeOpTree(this.convertOpList(operatorList));\n        this.svg = svg;\n        this.transformMatrix = transformMatrix;\n        this.current.fillColor = fillColor;\n        this.current.strokeColor = strokeColor;\n        tiling.appendChild(bbox.childNodes[0]);\n        this.defs.appendChild(tiling);\n        return `url(#${tilingId})`;\n      }\n\n      _makeShadingPattern(args) {\n        switch (args[0]) {\n          case \"RadialAxial\":\n            const shadingId = `shading${shadingCount++}`;\n            const colorStops = args[3];\n            let gradient;\n\n            switch (args[1]) {\n              case \"axial\":\n                const point0 = args[4];\n                const point1 = args[5];\n                gradient = this.svgFactory.createElement(\"svg:linearGradient\");\n                gradient.setAttributeNS(null, \"id\", shadingId);\n                gradient.setAttributeNS(null, \"gradientUnits\", \"userSpaceOnUse\");\n                gradient.setAttributeNS(null, \"x1\", point0[0]);\n                gradient.setAttributeNS(null, \"y1\", point0[1]);\n                gradient.setAttributeNS(null, \"x2\", point1[0]);\n                gradient.setAttributeNS(null, \"y2\", point1[1]);\n                break;\n\n              case \"radial\":\n                const focalPoint = args[4];\n                const circlePoint = args[5];\n                const focalRadius = args[6];\n                const circleRadius = args[7];\n                gradient = this.svgFactory.createElement(\"svg:radialGradient\");\n                gradient.setAttributeNS(null, \"id\", shadingId);\n                gradient.setAttributeNS(null, \"gradientUnits\", \"userSpaceOnUse\");\n                gradient.setAttributeNS(null, \"cx\", circlePoint[0]);\n                gradient.setAttributeNS(null, \"cy\", circlePoint[1]);\n                gradient.setAttributeNS(null, \"r\", circleRadius);\n                gradient.setAttributeNS(null, \"fx\", focalPoint[0]);\n                gradient.setAttributeNS(null, \"fy\", focalPoint[1]);\n                gradient.setAttributeNS(null, \"fr\", focalRadius);\n                break;\n\n              default:\n                throw new Error(`Unknown RadialAxial type: ${args[1]}`);\n            }\n\n            for (const colorStop of colorStops) {\n              const stop = this.svgFactory.createElement(\"svg:stop\");\n              stop.setAttributeNS(null, \"offset\", colorStop[0]);\n              stop.setAttributeNS(null, \"stop-color\", colorStop[1]);\n              gradient.appendChild(stop);\n            }\n\n            this.defs.appendChild(gradient);\n            return `url(#${shadingId})`;\n\n          case \"Mesh\":\n            (0, _util.warn)(\"Unimplemented pattern Mesh\");\n            return null;\n\n          case \"Dummy\":\n            return \"hotpink\";\n\n          default:\n            throw new Error(`Unknown IR type: ${args[0]}`);\n        }\n      }\n\n      setDash(dashArray, dashPhase) {\n        this.current.dashArray = dashArray;\n        this.current.dashPhase = dashPhase;\n      }\n\n      constructPath(ops, args) {\n        const current = this.current;\n        let x = current.x,\n            y = current.y;\n        let d = [];\n        let j = 0;\n\n        for (const op of ops) {\n          switch (op | 0) {\n            case _util.OPS.rectangle:\n              x = args[j++];\n              y = args[j++];\n              const width = args[j++];\n              const height = args[j++];\n              const xw = x + width;\n              const yh = y + height;\n              d.push(\"M\", pf(x), pf(y), \"L\", pf(xw), pf(y), \"L\", pf(xw), pf(yh), \"L\", pf(x), pf(yh), \"Z\");\n              break;\n\n            case _util.OPS.moveTo:\n              x = args[j++];\n              y = args[j++];\n              d.push(\"M\", pf(x), pf(y));\n              break;\n\n            case _util.OPS.lineTo:\n              x = args[j++];\n              y = args[j++];\n              d.push(\"L\", pf(x), pf(y));\n              break;\n\n            case _util.OPS.curveTo:\n              x = args[j + 4];\n              y = args[j + 5];\n              d.push(\"C\", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));\n              j += 6;\n              break;\n\n            case _util.OPS.curveTo2:\n              d.push(\"C\", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));\n              x = args[j + 2];\n              y = args[j + 3];\n              j += 4;\n              break;\n\n            case _util.OPS.curveTo3:\n              x = args[j + 2];\n              y = args[j + 3];\n              d.push(\"C\", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));\n              j += 4;\n              break;\n\n            case _util.OPS.closePath:\n              d.push(\"Z\");\n              break;\n          }\n        }\n\n        d = d.join(\" \");\n\n        if (current.path && ops.length > 0 && ops[0] !== _util.OPS.rectangle && ops[0] !== _util.OPS.moveTo) {\n          d = current.path.getAttributeNS(null, \"d\") + d;\n        } else {\n          current.path = this.svgFactory.createElement(\"svg:path\");\n\n          this._ensureTransformGroup().appendChild(current.path);\n        }\n\n        current.path.setAttributeNS(null, \"d\", d);\n        current.path.setAttributeNS(null, \"fill\", \"none\");\n        current.element = current.path;\n        current.setCurrentPoint(x, y);\n      }\n\n      endPath() {\n        const current = this.current;\n        current.path = null;\n\n        if (!this.pendingClip) {\n          return;\n        }\n\n        if (!current.element) {\n          this.pendingClip = null;\n          return;\n        }\n\n        const clipId = `clippath${clipCount++}`;\n        const clipPath = this.svgFactory.createElement(\"svg:clipPath\");\n        clipPath.setAttributeNS(null, \"id\", clipId);\n        clipPath.setAttributeNS(null, \"transform\", pm(this.transformMatrix));\n        const clipElement = current.element.cloneNode(true);\n\n        if (this.pendingClip === \"evenodd\") {\n          clipElement.setAttributeNS(null, \"clip-rule\", \"evenodd\");\n        } else {\n          clipElement.setAttributeNS(null, \"clip-rule\", \"nonzero\");\n        }\n\n        this.pendingClip = null;\n        clipPath.appendChild(clipElement);\n        this.defs.appendChild(clipPath);\n\n        if (current.activeClipUrl) {\n          current.clipGroup = null;\n          this.extraStack.forEach(function (prev) {\n            prev.clipGroup = null;\n          });\n          clipPath.setAttributeNS(null, \"clip-path\", current.activeClipUrl);\n        }\n\n        current.activeClipUrl = `url(#${clipId})`;\n        this.tgrp = null;\n      }\n\n      clip(type) {\n        this.pendingClip = type;\n      }\n\n      closePath() {\n        const current = this.current;\n\n        if (current.path) {\n          const d = `${current.path.getAttributeNS(null, \"d\")}Z`;\n          current.path.setAttributeNS(null, \"d\", d);\n        }\n      }\n\n      setLeading(leading) {\n        this.current.leading = -leading;\n      }\n\n      setTextRise(textRise) {\n        this.current.textRise = textRise;\n      }\n\n      setTextRenderingMode(textRenderingMode) {\n        this.current.textRenderingMode = textRenderingMode;\n      }\n\n      setHScale(scale) {\n        this.current.textHScale = scale / 100;\n      }\n\n      setRenderingIntent(intent) {}\n\n      setFlatness(flatness) {}\n\n      setGState(states) {\n        for (const [key, value] of states) {\n          switch (key) {\n            case \"LW\":\n              this.setLineWidth(value);\n              break;\n\n            case \"LC\":\n              this.setLineCap(value);\n              break;\n\n            case \"LJ\":\n              this.setLineJoin(value);\n              break;\n\n            case \"ML\":\n              this.setMiterLimit(value);\n              break;\n\n            case \"D\":\n              this.setDash(value[0], value[1]);\n              break;\n\n            case \"RI\":\n              this.setRenderingIntent(value);\n              break;\n\n            case \"FL\":\n              this.setFlatness(value);\n              break;\n\n            case \"Font\":\n              this.setFont(value);\n              break;\n\n            case \"CA\":\n              this.setStrokeAlpha(value);\n              break;\n\n            case \"ca\":\n              this.setFillAlpha(value);\n              break;\n\n            default:\n              (0, _util.warn)(`Unimplemented graphic state operator ${key}`);\n              break;\n          }\n        }\n      }\n\n      fill() {\n        const current = this.current;\n\n        if (current.element) {\n          current.element.setAttributeNS(null, \"fill\", current.fillColor);\n          current.element.setAttributeNS(null, \"fill-opacity\", current.fillAlpha);\n          this.endPath();\n        }\n      }\n\n      stroke() {\n        const current = this.current;\n\n        if (current.element) {\n          this._setStrokeAttributes(current.element);\n\n          current.element.setAttributeNS(null, \"fill\", \"none\");\n          this.endPath();\n        }\n      }\n\n      _setStrokeAttributes(element, lineWidthScale = 1) {\n        const current = this.current;\n        let dashArray = current.dashArray;\n\n        if (lineWidthScale !== 1 && dashArray.length > 0) {\n          dashArray = dashArray.map(function (value) {\n            return lineWidthScale * value;\n          });\n        }\n\n        element.setAttributeNS(null, \"stroke\", current.strokeColor);\n        element.setAttributeNS(null, \"stroke-opacity\", current.strokeAlpha);\n        element.setAttributeNS(null, \"stroke-miterlimit\", pf(current.miterLimit));\n        element.setAttributeNS(null, \"stroke-linecap\", current.lineCap);\n        element.setAttributeNS(null, \"stroke-linejoin\", current.lineJoin);\n        element.setAttributeNS(null, \"stroke-width\", pf(lineWidthScale * current.lineWidth) + \"px\");\n        element.setAttributeNS(null, \"stroke-dasharray\", dashArray.map(pf).join(\" \"));\n        element.setAttributeNS(null, \"stroke-dashoffset\", pf(lineWidthScale * current.dashPhase) + \"px\");\n      }\n\n      eoFill() {\n        if (this.current.element) {\n          this.current.element.setAttributeNS(null, \"fill-rule\", \"evenodd\");\n        }\n\n        this.fill();\n      }\n\n      fillStroke() {\n        this.stroke();\n        this.fill();\n      }\n\n      eoFillStroke() {\n        if (this.current.element) {\n          this.current.element.setAttributeNS(null, \"fill-rule\", \"evenodd\");\n        }\n\n        this.fillStroke();\n      }\n\n      closeStroke() {\n        this.closePath();\n        this.stroke();\n      }\n\n      closeFillStroke() {\n        this.closePath();\n        this.fillStroke();\n      }\n\n      closeEOFillStroke() {\n        this.closePath();\n        this.eoFillStroke();\n      }\n\n      paintSolidColorImageMask() {\n        const rect = this.svgFactory.createElement(\"svg:rect\");\n        rect.setAttributeNS(null, \"x\", \"0\");\n        rect.setAttributeNS(null, \"y\", \"0\");\n        rect.setAttributeNS(null, \"width\", \"1px\");\n        rect.setAttributeNS(null, \"height\", \"1px\");\n        rect.setAttributeNS(null, \"fill\", this.current.fillColor);\n\n        this._ensureTransformGroup().appendChild(rect);\n      }\n\n      paintImageXObject(objId) {\n        const imgData = objId.startsWith(\"g_\") ? this.commonObjs.get(objId) : this.objs.get(objId);\n\n        if (!imgData) {\n          (0, _util.warn)(`Dependent image with object ID ${objId} is not ready yet`);\n          return;\n        }\n\n        this.paintInlineImageXObject(imgData);\n      }\n\n      paintInlineImageXObject(imgData, mask) {\n        const width = imgData.width;\n        const height = imgData.height;\n        const imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);\n        const cliprect = this.svgFactory.createElement(\"svg:rect\");\n        cliprect.setAttributeNS(null, \"x\", \"0\");\n        cliprect.setAttributeNS(null, \"y\", \"0\");\n        cliprect.setAttributeNS(null, \"width\", pf(width));\n        cliprect.setAttributeNS(null, \"height\", pf(height));\n        this.current.element = cliprect;\n        this.clip(\"nonzero\");\n        const imgEl = this.svgFactory.createElement(\"svg:image\");\n        imgEl.setAttributeNS(XLINK_NS, \"xlink:href\", imgSrc);\n        imgEl.setAttributeNS(null, \"x\", \"0\");\n        imgEl.setAttributeNS(null, \"y\", pf(-height));\n        imgEl.setAttributeNS(null, \"width\", pf(width) + \"px\");\n        imgEl.setAttributeNS(null, \"height\", pf(height) + \"px\");\n        imgEl.setAttributeNS(null, \"transform\", `scale(${pf(1 / width)} ${pf(-1 / height)})`);\n\n        if (mask) {\n          mask.appendChild(imgEl);\n        } else {\n          this._ensureTransformGroup().appendChild(imgEl);\n        }\n      }\n\n      paintImageMaskXObject(imgData) {\n        const current = this.current;\n        const width = imgData.width;\n        const height = imgData.height;\n        const fillColor = current.fillColor;\n        current.maskId = `mask${maskCount++}`;\n        const mask = this.svgFactory.createElement(\"svg:mask\");\n        mask.setAttributeNS(null, \"id\", current.maskId);\n        const rect = this.svgFactory.createElement(\"svg:rect\");\n        rect.setAttributeNS(null, \"x\", \"0\");\n        rect.setAttributeNS(null, \"y\", \"0\");\n        rect.setAttributeNS(null, \"width\", pf(width));\n        rect.setAttributeNS(null, \"height\", pf(height));\n        rect.setAttributeNS(null, \"fill\", fillColor);\n        rect.setAttributeNS(null, \"mask\", `url(#${current.maskId})`);\n        this.defs.appendChild(mask);\n\n        this._ensureTransformGroup().appendChild(rect);\n\n        this.paintInlineImageXObject(imgData, mask);\n      }\n\n      paintFormXObjectBegin(matrix, bbox) {\n        if (Array.isArray(matrix) && matrix.length === 6) {\n          this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\n        }\n\n        if (bbox) {\n          const width = bbox[2] - bbox[0];\n          const height = bbox[3] - bbox[1];\n          const cliprect = this.svgFactory.createElement(\"svg:rect\");\n          cliprect.setAttributeNS(null, \"x\", bbox[0]);\n          cliprect.setAttributeNS(null, \"y\", bbox[1]);\n          cliprect.setAttributeNS(null, \"width\", pf(width));\n          cliprect.setAttributeNS(null, \"height\", pf(height));\n          this.current.element = cliprect;\n          this.clip(\"nonzero\");\n          this.endPath();\n        }\n      }\n\n      paintFormXObjectEnd() {}\n\n      _initialize(viewport) {\n        const svg = this.svgFactory.create(viewport.width, viewport.height);\n        const definitions = this.svgFactory.createElement(\"svg:defs\");\n        svg.appendChild(definitions);\n        this.defs = definitions;\n        const rootGroup = this.svgFactory.createElement(\"svg:g\");\n        rootGroup.setAttributeNS(null, \"transform\", pm(viewport.transform));\n        svg.appendChild(rootGroup);\n        this.svg = rootGroup;\n        return svg;\n      }\n\n      _ensureClipGroup() {\n        if (!this.current.clipGroup) {\n          const clipGroup = this.svgFactory.createElement(\"svg:g\");\n          clipGroup.setAttributeNS(null, \"clip-path\", this.current.activeClipUrl);\n          this.svg.appendChild(clipGroup);\n          this.current.clipGroup = clipGroup;\n        }\n\n        return this.current.clipGroup;\n      }\n\n      _ensureTransformGroup() {\n        if (!this.tgrp) {\n          this.tgrp = this.svgFactory.createElement(\"svg:g\");\n          this.tgrp.setAttributeNS(null, \"transform\", pm(this.transformMatrix));\n\n          if (this.current.activeClipUrl) {\n            this._ensureClipGroup().appendChild(this.tgrp);\n          } else {\n            this.svg.appendChild(this.tgrp);\n          }\n        }\n\n        return this.tgrp;\n      }\n\n    };\n  }\n\n  /***/ }),\n  /* 23 */\n  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\n  Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n  }));\n  exports.PDFNodeStream = void 0;\n\n  var _util = __w_pdfjs_require__(2);\n\n  var _network_utils = __w_pdfjs_require__(24);\n\n  ;\n\n  const fs = require(\"fs\");\n\n  const http = require(\"http\");\n\n  const https = require(\"https\");\n\n  const url = require(\"url\");\n\n  const fileUriRegex = /^file:\\/\\/\\/[a-zA-Z]:\\//;\n\n  function parseUrl(sourceUrl) {\n    const parsedUrl = url.parse(sourceUrl);\n\n    if (parsedUrl.protocol === \"file:\" || parsedUrl.host) {\n      return parsedUrl;\n    }\n\n    if (/^[a-z]:[/\\\\]/i.test(sourceUrl)) {\n      return url.parse(`file:///${sourceUrl}`);\n    }\n\n    if (!parsedUrl.host) {\n      parsedUrl.protocol = \"file:\";\n    }\n\n    return parsedUrl;\n  }\n\n  class PDFNodeStream {\n    constructor(source) {\n      this.source = source;\n      this.url = parseUrl(source.url);\n      this.isHttp = this.url.protocol === \"http:\" || this.url.protocol === \"https:\";\n      this.isFsUrl = this.url.protocol === \"file:\";\n      this.httpHeaders = this.isHttp && source.httpHeaders || {};\n      this._fullRequestReader = null;\n      this._rangeRequestReaders = [];\n    }\n\n    get _progressiveDataLength() {\n      return this._fullRequestReader && this._fullRequestReader._loaded || 0; // lwf\n    }\n\n    getFullReader() {\n      (0, _util.assert)(!this._fullRequestReader, \"PDFNodeStream.getFullReader can only be called once.\");\n      this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);\n      return this._fullRequestReader;\n    }\n\n    getRangeReader(start, end) {\n      if (end <= this._progressiveDataLength) {\n        return null;\n      }\n\n      const rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);\n\n      this._rangeRequestReaders.push(rangeReader);\n\n      return rangeReader;\n    }\n\n    cancelAllRequests(reason) {\n      if (this._fullRequestReader) {\n        this._fullRequestReader.cancel(reason);\n      }\n\n      const readers = this._rangeRequestReaders.slice(0);\n\n      readers.forEach(function (reader) {\n        reader.cancel(reason);\n      });\n    }\n\n  }\n\n  exports.PDFNodeStream = PDFNodeStream;\n\n  class BaseFullReader {\n    constructor(stream) {\n      this._url = stream.url;\n      this._done = false;\n      this._storedError = null;\n      this.onProgress = null;\n      const source = stream.source;\n      this._contentLength = source.length;\n      this._loaded = 0;\n      this._filename = null;\n      this._disableRange = source.disableRange || false;\n      this._rangeChunkSize = source.rangeChunkSize;\n\n      if (!this._rangeChunkSize && !this._disableRange) {\n        this._disableRange = true;\n      }\n\n      this._isStreamingSupported = !source.disableStream;\n      this._isRangeSupported = !source.disableRange;\n      this._readableStream = null;\n      this._readCapability = (0, _util.createPromiseCapability)();\n      this._headersCapability = (0, _util.createPromiseCapability)();\n    }\n\n    get headersReady() {\n      return this._headersCapability.promise;\n    }\n\n    get filename() {\n      return this._filename;\n    }\n\n    get contentLength() {\n      return this._contentLength;\n    }\n\n    get isRangeSupported() {\n      return this._isRangeSupported;\n    }\n\n    get isStreamingSupported() {\n      return this._isStreamingSupported;\n    }\n\n    async read() {\n      await this._readCapability.promise;\n\n      if (this._done) {\n        return {\n          value: undefined,\n          done: true\n        };\n      }\n\n      if (this._storedError) {\n        throw this._storedError;\n      }\n\n      const chunk = this._readableStream.read();\n\n      if (chunk === null) {\n        this._readCapability = (0, _util.createPromiseCapability)();\n        return this.read();\n      }\n\n      this._loaded += chunk.length;\n\n      if (this.onProgress) {\n        this.onProgress({\n          loaded: this._loaded,\n          total: this._contentLength\n        });\n      }\n\n      const buffer = new Uint8Array(chunk).buffer;\n      return {\n        value: buffer,\n        done: false\n      };\n    }\n\n    cancel(reason) {\n      if (!this._readableStream) {\n        this._error(reason);\n\n        return;\n      }\n\n      this._readableStream.destroy(reason);\n    }\n\n    _error(reason) {\n      this._storedError = reason;\n\n      this._readCapability.resolve();\n    }\n\n    _setReadableStream(readableStream) {\n      this._readableStream = readableStream;\n      readableStream.on(\"readable\", () => {\n        this._readCapability.resolve();\n      });\n      readableStream.on(\"end\", () => {\n        readableStream.destroy();\n        this._done = true;\n\n        this._readCapability.resolve();\n      });\n      readableStream.on(\"error\", reason => {\n        this._error(reason);\n      });\n\n      if (!this._isStreamingSupported && this._isRangeSupported) {\n        this._error(new _util.AbortException(\"streaming is disabled\"));\n      }\n\n      if (this._storedError) {\n        this._readableStream.destroy(this._storedError);\n      }\n    }\n\n  }\n\n  class BaseRangeReader {\n    constructor(stream) {\n      this._url = stream.url;\n      this._done = false;\n      this._storedError = null;\n      this.onProgress = null;\n      this._loaded = 0;\n      this._readableStream = null;\n      this._readCapability = (0, _util.createPromiseCapability)();\n      const source = stream.source;\n      this._isStreamingSupported = !source.disableStream;\n    }\n\n    get isStreamingSupported() {\n      return this._isStreamingSupported;\n    }\n\n    async read() {\n      await this._readCapability.promise;\n\n      if (this._done) {\n        return {\n          value: undefined,\n          done: true\n        };\n      }\n\n      if (this._storedError) {\n        throw this._storedError;\n      }\n\n      const chunk = this._readableStream.read();\n\n      if (chunk === null) {\n        this._readCapability = (0, _util.createPromiseCapability)();\n        return this.read();\n      }\n\n      this._loaded += chunk.length;\n\n      if (this.onProgress) {\n        this.onProgress({\n          loaded: this._loaded\n        });\n      }\n\n      const buffer = new Uint8Array(chunk).buffer;\n      return {\n        value: buffer,\n        done: false\n      };\n    }\n\n    cancel(reason) {\n      if (!this._readableStream) {\n        this._error(reason);\n\n        return;\n      }\n\n      this._readableStream.destroy(reason);\n    }\n\n    _error(reason) {\n      this._storedError = reason;\n\n      this._readCapability.resolve();\n    }\n\n    _setReadableStream(readableStream) {\n      this._readableStream = readableStream;\n      readableStream.on(\"readable\", () => {\n        this._readCapability.resolve();\n      });\n      readableStream.on(\"end\", () => {\n        readableStream.destroy();\n        this._done = true;\n\n        this._readCapability.resolve();\n      });\n      readableStream.on(\"error\", reason => {\n        this._error(reason);\n      });\n\n      if (this._storedError) {\n        this._readableStream.destroy(this._storedError);\n      }\n    }\n\n  }\n\n  function createRequestOptions(parsedUrl, headers) {\n    return {\n      protocol: parsedUrl.protocol,\n      auth: parsedUrl.auth,\n      host: parsedUrl.hostname,\n      port: parsedUrl.port,\n      path: parsedUrl.path,\n      method: \"GET\",\n      headers\n    };\n  }\n\n  class PDFNodeStreamFullReader extends BaseFullReader {\n    constructor(stream) {\n      super(stream);\n\n      const handleResponse = response => {\n        if (response.statusCode === 404) {\n          const error = new _util.MissingPDFException(`Missing PDF \"${this._url}\".`);\n          this._storedError = error;\n\n          this._headersCapability.reject(error);\n\n          return;\n        }\n\n        this._headersCapability.resolve();\n\n        this._setReadableStream(response);\n\n        const getResponseHeader = name => {\n          return this._readableStream.headers[name.toLowerCase()];\n        };\n\n        const {\n          allowRangeRequests,\n          suggestedLength\n        } = (0, _network_utils.validateRangeRequestCapabilities)({\n          getResponseHeader,\n          isHttp: stream.isHttp,\n          rangeChunkSize: this._rangeChunkSize,\n          disableRange: this._disableRange\n        });\n        this._isRangeSupported = allowRangeRequests;\n        this._contentLength = suggestedLength || this._contentLength;\n        this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n      };\n\n      this._request = null;\n\n      if (this._url.protocol === \"http:\") {\n        this._request = http.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);\n      } else {\n        this._request = https.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);\n      }\n\n      this._request.on(\"error\", reason => {\n        this._storedError = reason;\n\n        this._headersCapability.reject(reason);\n      });\n\n      this._request.end();\n    }\n\n  }\n\n  class PDFNodeStreamRangeReader extends BaseRangeReader {\n    constructor(stream, start, end) {\n      super(stream);\n      this._httpHeaders = {};\n\n      for (const property in stream.httpHeaders) {\n        const value = stream.httpHeaders[property];\n\n        if (typeof value === \"undefined\") {\n          continue;\n        }\n\n        this._httpHeaders[property] = value;\n      }\n\n      this._httpHeaders.Range = `bytes=${start}-${end - 1}`;\n\n      const handleResponse = response => {\n        if (response.statusCode === 404) {\n          const error = new _util.MissingPDFException(`Missing PDF \"${this._url}\".`);\n          this._storedError = error;\n          return;\n        }\n\n        this._setReadableStream(response);\n      };\n\n      this._request = null;\n\n      if (this._url.protocol === \"http:\") {\n        this._request = http.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);\n      } else {\n        this._request = https.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);\n      }\n\n      this._request.on(\"error\", reason => {\n        this._storedError = reason;\n      });\n\n      this._request.end();\n    }\n\n  }\n\n  class PDFNodeStreamFsFullReader extends BaseFullReader {\n    constructor(stream) {\n      super(stream);\n      let path = decodeURIComponent(this._url.path);\n\n      if (fileUriRegex.test(this._url.href)) {\n        path = path.replace(/^\\//, \"\");\n      }\n\n      fs.lstat(path, (error, stat) => {\n        if (error) {\n          if (error.code === \"ENOENT\") {\n            error = new _util.MissingPDFException(`Missing PDF \"${path}\".`);\n          }\n\n          this._storedError = error;\n\n          this._headersCapability.reject(error);\n\n          return;\n        }\n\n        this._contentLength = stat.size;\n\n        this._setReadableStream(fs.createReadStream(path));\n\n        this._headersCapability.resolve();\n      });\n    }\n\n  }\n\n  class PDFNodeStreamFsRangeReader extends BaseRangeReader {\n    constructor(stream, start, end) {\n      super(stream);\n      let path = decodeURIComponent(this._url.path);\n\n      if (fileUriRegex.test(this._url.href)) {\n        path = path.replace(/^\\//, \"\");\n      }\n\n      this._setReadableStream(fs.createReadStream(path, {\n        start,\n        end: end - 1\n      }));\n    }\n\n  }\n\n  /***/ }),\n  /* 24 */\n  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\n  Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n  }));\n  exports.createResponseStatusError = createResponseStatusError;\n  exports.extractFilenameFromHeader = extractFilenameFromHeader;\n  exports.validateRangeRequestCapabilities = validateRangeRequestCapabilities;\n  exports.validateResponseStatus = validateResponseStatus;\n\n  var _util = __w_pdfjs_require__(2);\n\n  var _content_disposition = __w_pdfjs_require__(25);\n\n  function validateRangeRequestCapabilities({\n    getResponseHeader,\n    isHttp,\n    rangeChunkSize,\n    disableRange\n  }) {\n    (0, _util.assert)(rangeChunkSize > 0, \"Range chunk size must be larger than zero\");\n    const returnValues = {\n      allowRangeRequests: false,\n      suggestedLength: undefined\n    };\n    const length = parseInt(getResponseHeader(\"Content-Length\"), 10);\n\n    if (!Number.isInteger(length)) {\n      return returnValues;\n    }\n\n    returnValues.suggestedLength = length;\n\n    if (length <= 2 * rangeChunkSize) {\n      return returnValues;\n    }\n\n    if (disableRange || !isHttp) {\n      return returnValues;\n    }\n\n    if (getResponseHeader(\"Accept-Ranges\") !== \"bytes\") {\n      return returnValues;\n    }\n\n    const contentEncoding = getResponseHeader(\"Content-Encoding\") || \"identity\";\n\n    if (contentEncoding !== \"identity\") {\n      return returnValues;\n    }\n\n    returnValues.allowRangeRequests = true;\n    return returnValues;\n  }\n\n  function extractFilenameFromHeader(getResponseHeader) {\n    const contentDisposition = getResponseHeader(\"Content-Disposition\");\n\n    if (contentDisposition) {\n      let filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);\n\n      if (filename.includes(\"%\")) {\n        try {\n          filename = decodeURIComponent(filename);\n        } catch (ex) {}\n      }\n\n      if (/\\.pdf$/i.test(filename)) {\n        return filename;\n      }\n    }\n\n    return null;\n  }\n\n  function createResponseStatusError(status, url) {\n    if (status === 404 || status === 0 && url.startsWith(\"file:\")) {\n      return new _util.MissingPDFException('Missing PDF \"' + url + '\".');\n    }\n\n    return new _util.UnexpectedResponseException(\"Unexpected server response (\" + status + ') while retrieving PDF \"' + url + '\".', status);\n  }\n\n  function validateResponseStatus(status) {\n    return status === 200 || status === 206;\n  }\n\n  /***/ }),\n  /* 25 */\n  /***/ ((__unused_webpack_module, exports) => {\n\n\n\n  Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n  }));\n  exports.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;\n\n  function getFilenameFromContentDispositionHeader(contentDisposition) {\n    let needsEncodingFixup = true;\n    let tmp = toParamRegExp(\"filename\\\\*\", \"i\").exec(contentDisposition);\n\n    if (tmp) {\n      tmp = tmp[1];\n      let filename = rfc2616unquote(tmp);\n      filename = unescape(filename);\n      filename = rfc5987decode(filename);\n      filename = rfc2047decode(filename);\n      return fixupEncoding(filename);\n    }\n\n    tmp = rfc2231getparam(contentDisposition);\n\n    if (tmp) {\n      const filename = rfc2047decode(tmp);\n      return fixupEncoding(filename);\n    }\n\n    tmp = toParamRegExp(\"filename\", \"i\").exec(contentDisposition);\n\n    if (tmp) {\n      tmp = tmp[1];\n      let filename = rfc2616unquote(tmp);\n      filename = rfc2047decode(filename);\n      return fixupEncoding(filename);\n    }\n\n    function toParamRegExp(attributePattern, flags) {\n      return new RegExp(\"(?:^|;)\\\\s*\" + attributePattern + \"\\\\s*=\\\\s*\" + \"(\" + '[^\";\\\\s][^;\\\\s]*' + \"|\" + '\"(?:[^\"\\\\\\\\]|\\\\\\\\\"?)+\"?' + \")\", flags);\n    }\n\n    function textdecode(encoding, value) {\n      if (encoding) {\n        if (!/^[\\x00-\\xFF]+$/.test(value)) {\n          return value;\n        }\n\n        try {\n          const decoder = new TextDecoder(encoding, {\n            fatal: true\n          });\n          const bytes = Array.from(value, function (ch) {\n            return ch.charCodeAt(0) & 0xff;\n          });\n          value = decoder.decode(new Uint8Array(bytes));\n          needsEncodingFixup = false;\n        } catch (e) {\n          if (/^utf-?8$/i.test(encoding)) {\n            try {\n              value = decodeURIComponent(escape(value));\n              needsEncodingFixup = false;\n            } catch (err) {}\n          }\n        }\n      }\n\n      return value;\n    }\n\n    function fixupEncoding(value) {\n      if (needsEncodingFixup && /[\\x80-\\xff]/.test(value)) {\n        value = textdecode(\"utf-8\", value);\n\n        if (needsEncodingFixup) {\n          value = textdecode(\"iso-8859-1\", value);\n        }\n      }\n\n      return value;\n    }\n\n    function rfc2231getparam(contentDispositionStr) {\n      const matches = [];\n      let match;\n      const iter = toParamRegExp(\"filename\\\\*((?!0\\\\d)\\\\d+)(\\\\*?)\", \"ig\");\n\n      while ((match = iter.exec(contentDispositionStr)) !== null) {\n        let [, n, quot, part] = match;\n        n = parseInt(n, 10);\n\n        if (n in matches) {\n          if (n === 0) {\n            break;\n          }\n\n          continue;\n        }\n\n        matches[n] = [quot, part];\n      }\n\n      const parts = [];\n\n      for (let n = 0; n < matches.length; ++n) {\n        if (!(n in matches)) {\n          break;\n        }\n\n        let [quot, part] = matches[n];\n        part = rfc2616unquote(part);\n\n        if (quot) {\n          part = unescape(part);\n\n          if (n === 0) {\n            part = rfc5987decode(part);\n          }\n        }\n\n        parts.push(part);\n      }\n\n      return parts.join(\"\");\n    }\n\n    function rfc2616unquote(value) {\n      if (value.startsWith('\"')) {\n        const parts = value.slice(1).split('\\\\\"');\n\n        for (let i = 0; i < parts.length; ++i) {\n          const quotindex = parts[i].indexOf('\"');\n\n          if (quotindex !== -1) {\n            parts[i] = parts[i].slice(0, quotindex);\n            parts.length = i + 1;\n          }\n\n          parts[i] = parts[i].replace(/\\\\(.)/g, \"$1\");\n        }\n\n        value = parts.join('\"');\n      }\n\n      return value;\n    }\n\n    function rfc5987decode(extvalue) {\n      const encodingend = extvalue.indexOf(\"'\");\n\n      if (encodingend === -1) {\n        return extvalue;\n      }\n\n      const encoding = extvalue.slice(0, encodingend);\n      const langvalue = extvalue.slice(encodingend + 1);\n      const value = langvalue.replace(/^[^']*'/, \"\");\n      return textdecode(encoding, value);\n    }\n\n    function rfc2047decode(value) {\n      if (!value.startsWith(\"=?\") || /[\\x00-\\x19\\x80-\\xff]/.test(value)) {\n        return value;\n      }\n\n      return value.replace(/=\\?([\\w-]*)\\?([QqBb])\\?((?:[^?]|\\?(?!=))*)\\?=/g, function (matches, charset, encoding, text) {\n        if (encoding === \"q\" || encoding === \"Q\") {\n          text = text.replace(/_/g, \" \");\n          text = text.replace(/=([0-9a-fA-F]{2})/g, function (match, hex) {\n            return String.fromCharCode(parseInt(hex, 16));\n          });\n          return textdecode(charset, text);\n        }\n\n        try {\n          text = atob(text);\n        } catch (e) {}\n\n        return textdecode(charset, text);\n      });\n    }\n\n    return \"\";\n  }\n\n  /***/ }),\n  /* 26 */\n  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\n  Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n  }));\n  exports.PDFNetworkStream = void 0;\n\n  var _util = __w_pdfjs_require__(2);\n\n  var _network_utils = __w_pdfjs_require__(24);\n\n  ;\n  const OK_RESPONSE = 200;\n  const PARTIAL_CONTENT_RESPONSE = 206;\n\n  function getArrayBuffer(xhr) {\n    const data = xhr.response;\n\n    if (typeof data !== \"string\") {\n      return data;\n    }\n\n    const array = (0, _util.stringToBytes)(data);\n    return array.buffer;\n  }\n\n  class NetworkManager {\n    constructor(url, args) {\n      this.url = url;\n      args = args || {};\n      this.isHttp = /^https?:/i.test(url);\n      this.httpHeaders = this.isHttp && args.httpHeaders || {};\n      this.withCredentials = args.withCredentials || false;\n\n      this.getXhr = args.getXhr || function NetworkManager_getXhr() {\n        return new XMLHttpRequest();\n      };\n\n      this.currXhrId = 0;\n      this.pendingRequests = Object.create(null);\n    }\n\n    requestRange(begin, end, listeners) {\n      const args = {\n        begin,\n        end\n      };\n\n      for (const prop in listeners) {\n        args[prop] = listeners[prop];\n      }\n\n      return this.request(args);\n    }\n\n    requestFull(listeners) {\n      return this.request(listeners);\n    }\n\n    request(args) {\n      const xhr = this.getXhr();\n      const xhrId = this.currXhrId++;\n      const pendingRequest = this.pendingRequests[xhrId] = {\n        xhr\n      };\n      xhr.open(\"GET\", this.url);\n      xhr.withCredentials = this.withCredentials;\n\n      for (const property in this.httpHeaders) {\n        const value = this.httpHeaders[property];\n\n        if (typeof value === \"undefined\") {\n          continue;\n        }\n\n        xhr.setRequestHeader(property, value);\n      }\n\n      if (this.isHttp && \"begin\" in args && \"end\" in args) {\n        xhr.setRequestHeader(\"Range\", `bytes=${args.begin}-${args.end - 1}`);\n        pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;\n      } else {\n        pendingRequest.expectedStatus = OK_RESPONSE;\n      }\n\n      xhr.responseType = \"arraybuffer\";\n\n      if (args.onError) {\n        xhr.onerror = function (evt) {\n          args.onError(xhr.status);\n        };\n      }\n\n      xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);\n      xhr.onprogress = this.onProgress.bind(this, xhrId);\n      pendingRequest.onHeadersReceived = args.onHeadersReceived;\n      pendingRequest.onDone = args.onDone;\n      pendingRequest.onError = args.onError;\n      pendingRequest.onProgress = args.onProgress;\n      xhr.send(null);\n      return xhrId;\n    }\n\n    onProgress(xhrId, evt) {\n      const pendingRequest = this.pendingRequests[xhrId];\n\n      if (!pendingRequest) {\n        return;\n      }\n\n      if (pendingRequest.onProgress) {\n        pendingRequest.onProgress(evt);\n      }\n    }\n\n    onStateChange(xhrId, evt) {\n      const pendingRequest = this.pendingRequests[xhrId];\n\n      if (!pendingRequest) {\n        return;\n      }\n\n      const xhr = pendingRequest.xhr;\n\n      if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {\n        pendingRequest.onHeadersReceived();\n        delete pendingRequest.onHeadersReceived;\n      }\n\n      if (xhr.readyState !== 4) {\n        return;\n      }\n\n      if (!(xhrId in this.pendingRequests)) {\n        return;\n      }\n\n      delete this.pendingRequests[xhrId];\n\n      if (xhr.status === 0 && this.isHttp) {\n        if (pendingRequest.onError) {\n          pendingRequest.onError(xhr.status);\n        }\n\n        return;\n      }\n\n      const xhrStatus = xhr.status || OK_RESPONSE;\n      const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;\n\n      if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {\n        if (pendingRequest.onError) {\n          pendingRequest.onError(xhr.status);\n        }\n\n        return;\n      }\n\n      const chunk = getArrayBuffer(xhr);\n\n      if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {\n        const rangeHeader = xhr.getResponseHeader(\"Content-Range\");\n        const matches = /bytes (\\d+)-(\\d+)\\/(\\d+)/.exec(rangeHeader);\n        pendingRequest.onDone({\n          begin: parseInt(matches[1], 10),\n          chunk\n        });\n      } else if (chunk) {\n        pendingRequest.onDone({\n          begin: 0,\n          chunk\n        });\n      } else if (pendingRequest.onError) {\n        pendingRequest.onError(xhr.status);\n      }\n    }\n\n    getRequestXhr(xhrId) {\n      return this.pendingRequests[xhrId].xhr;\n    }\n\n    isPendingRequest(xhrId) {\n      return xhrId in this.pendingRequests;\n    }\n\n    abortRequest(xhrId) {\n      const xhr = this.pendingRequests[xhrId].xhr;\n      delete this.pendingRequests[xhrId];\n      xhr.abort();\n    }\n\n  }\n\n  class PDFNetworkStream {\n    constructor(source) {\n      this._source = source;\n      this._manager = new NetworkManager(source.url, {\n        httpHeaders: source.httpHeaders,\n        withCredentials: source.withCredentials\n      });\n      this._rangeChunkSize = source.rangeChunkSize;\n      this._fullRequestReader = null;\n      this._rangeRequestReaders = [];\n    }\n\n    _onRangeRequestReaderClosed(reader) {\n      const i = this._rangeRequestReaders.indexOf(reader);\n\n      if (i >= 0) {\n        this._rangeRequestReaders.splice(i, 1);\n      }\n    }\n\n    getFullReader() {\n      (0, _util.assert)(!this._fullRequestReader, \"PDFNetworkStream.getFullReader can only be called once.\");\n      this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);\n      return this._fullRequestReader;\n    }\n\n    getRangeReader(begin, end) {\n      const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);\n      reader.onClosed = this._onRangeRequestReaderClosed.bind(this);\n\n      this._rangeRequestReaders.push(reader);\n\n      return reader;\n    }\n\n    cancelAllRequests(reason) {\n      if (this._fullRequestReader) {\n        this._fullRequestReader.cancel(reason);\n      }\n\n      const readers = this._rangeRequestReaders.slice(0);\n\n      readers.forEach(function (reader) {\n        reader.cancel(reason);\n      });\n    }\n\n  }\n\n  exports.PDFNetworkStream = PDFNetworkStream;\n\n  class PDFNetworkStreamFullRequestReader {\n    constructor(manager, source) {\n      this._manager = manager;\n      const args = {\n        onHeadersReceived: this._onHeadersReceived.bind(this),\n        onDone: this._onDone.bind(this),\n        onError: this._onError.bind(this),\n        onProgress: this._onProgress.bind(this)\n      };\n      this._url = source.url;\n      this._fullRequestId = manager.requestFull(args);\n      this._headersReceivedCapability = (0, _util.createPromiseCapability)();\n      this._disableRange = source.disableRange || false;\n      this._contentLength = source.length;\n      this._rangeChunkSize = source.rangeChunkSize;\n\n      if (!this._rangeChunkSize && !this._disableRange) {\n        this._disableRange = true;\n      }\n\n      this._isStreamingSupported = false;\n      this._isRangeSupported = false;\n      this._cachedChunks = [];\n      this._requests = [];\n      this._done = false;\n      this._storedError = undefined;\n      this._filename = null;\n      this.onProgress = null;\n    }\n\n    _onHeadersReceived() {\n      const fullRequestXhrId = this._fullRequestId;\n\n      const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);\n\n      const getResponseHeader = name => {\n        return fullRequestXhr.getResponseHeader(name);\n      };\n\n      const {\n        allowRangeRequests,\n        suggestedLength\n      } = (0, _network_utils.validateRangeRequestCapabilities)({\n        getResponseHeader,\n        isHttp: this._manager.isHttp,\n        rangeChunkSize: this._rangeChunkSize,\n        disableRange: this._disableRange\n      });\n\n      if (allowRangeRequests) {\n        this._isRangeSupported = true;\n      }\n\n      this._contentLength = suggestedLength || this._contentLength;\n      this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n\n      if (this._isRangeSupported) {\n        this._manager.abortRequest(fullRequestXhrId);\n      }\n\n      this._headersReceivedCapability.resolve();\n    }\n\n    _onDone(args) {\n      if (args) {\n        if (this._requests.length > 0) {\n          const requestCapability = this._requests.shift();\n\n          requestCapability.resolve({\n            value: args.chunk,\n            done: false\n          });\n        } else {\n          this._cachedChunks.push(args.chunk);\n        }\n      }\n\n      this._done = true;\n\n      if (this._cachedChunks.length > 0) {\n        return;\n      }\n\n      this._requests.forEach(function (requestCapability) {\n        requestCapability.resolve({\n          value: undefined,\n          done: true\n        });\n      });\n\n      this._requests = [];\n    }\n\n    _onError(status) {\n      const url = this._url;\n      const exception = (0, _network_utils.createResponseStatusError)(status, url);\n      this._storedError = exception;\n\n      this._headersReceivedCapability.reject(exception);\n\n      this._requests.forEach(function (requestCapability) {\n        requestCapability.reject(exception);\n      });\n\n      this._requests = [];\n      this._cachedChunks = [];\n    }\n\n    _onProgress(data) {\n      if (this.onProgress) {\n        this.onProgress({\n          loaded: data.loaded,\n          total: data.lengthComputable ? data.total : this._contentLength\n        });\n      }\n    }\n\n    get filename() {\n      return this._filename;\n    }\n\n    get isRangeSupported() {\n      return this._isRangeSupported;\n    }\n\n    get isStreamingSupported() {\n      return this._isStreamingSupported;\n    }\n\n    get contentLength() {\n      return this._contentLength;\n    }\n\n    get headersReady() {\n      return this._headersReceivedCapability.promise;\n    }\n\n    async read() {\n      if (this._storedError) {\n        throw this._storedError;\n      }\n\n      if (this._cachedChunks.length > 0) {\n        const chunk = this._cachedChunks.shift();\n\n        return {\n          value: chunk,\n          done: false\n        };\n      }\n\n      if (this._done) {\n        return {\n          value: undefined,\n          done: true\n        };\n      }\n\n      const requestCapability = (0, _util.createPromiseCapability)();\n\n      this._requests.push(requestCapability);\n\n      return requestCapability.promise;\n    }\n\n    cancel(reason) {\n      this._done = true;\n\n      this._headersReceivedCapability.reject(reason);\n\n      this._requests.forEach(function (requestCapability) {\n        requestCapability.resolve({\n          value: undefined,\n          done: true\n        });\n      });\n\n      this._requests = [];\n\n      if (this._manager.isPendingRequest(this._fullRequestId)) {\n        this._manager.abortRequest(this._fullRequestId);\n      }\n\n      this._fullRequestReader = null;\n    }\n\n  }\n\n  class PDFNetworkStreamRangeRequestReader {\n    constructor(manager, begin, end) {\n      this._manager = manager;\n      const args = {\n        onDone: this._onDone.bind(this),\n        onProgress: this._onProgress.bind(this)\n      };\n      this._requestId = manager.requestRange(begin, end, args);\n      this._requests = [];\n      this._queuedChunk = null;\n      this._done = false;\n      this.onProgress = null;\n      this.onClosed = null;\n    }\n\n    _close() {\n      if (this.onClosed) {\n        this.onClosed(this);\n      }\n    }\n\n    _onDone(data) {\n      const chunk = data.chunk;\n\n      if (this._requests.length > 0) {\n        const requestCapability = this._requests.shift();\n\n        requestCapability.resolve({\n          value: chunk,\n          done: false\n        });\n      } else {\n        this._queuedChunk = chunk;\n      }\n\n      this._done = true;\n\n      this._requests.forEach(function (requestCapability) {\n        requestCapability.resolve({\n          value: undefined,\n          done: true\n        });\n      });\n\n      this._requests = [];\n\n      this._close();\n    }\n\n    _onProgress(evt) {\n      if (!this.isStreamingSupported && this.onProgress) {\n        this.onProgress({\n          loaded: evt.loaded\n        });\n      }\n    }\n\n    get isStreamingSupported() {\n      return false;\n    }\n\n    async read() {\n      if (this._queuedChunk !== null) {\n        const chunk = this._queuedChunk;\n        this._queuedChunk = null;\n        return {\n          value: chunk,\n          done: false\n        };\n      }\n\n      if (this._done) {\n        return {\n          value: undefined,\n          done: true\n        };\n      }\n\n      const requestCapability = (0, _util.createPromiseCapability)();\n\n      this._requests.push(requestCapability);\n\n      return requestCapability.promise;\n    }\n\n    cancel(reason) {\n      this._done = true;\n\n      this._requests.forEach(function (requestCapability) {\n        requestCapability.resolve({\n          value: undefined,\n          done: true\n        });\n      });\n\n      this._requests = [];\n\n      if (this._manager.isPendingRequest(this._requestId)) {\n        this._manager.abortRequest(this._requestId);\n      }\n\n      this._close();\n    }\n\n  }\n\n  /***/ }),\n  /* 27 */\n  /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\n  Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n  }));\n  exports.PDFFetchStream = void 0;\n\n  var _util = __w_pdfjs_require__(2);\n\n  var _network_utils = __w_pdfjs_require__(24);\n\n  ;\n\n  function createFetchOptions(headers, withCredentials, abortController) {\n    return {\n      method: \"GET\",\n      headers,\n      signal: abortController && abortController.signal, // lwf\n      mode: \"cors\",\n      credentials: withCredentials ? \"include\" : \"same-origin\",\n      redirect: \"follow\"\n    };\n  }\n\n  function createHeaders(httpHeaders) {\n    const headers = new Headers();\n\n    for (const property in httpHeaders) {\n      const value = httpHeaders[property];\n\n      if (typeof value === \"undefined\") {\n        continue;\n      }\n\n      headers.append(property, value);\n    }\n\n    return headers;\n  }\n\n  class PDFFetchStream {\n    constructor(source) {\n      this.source = source;\n      this.isHttp = /^https?:/i.test(source.url);\n      this.httpHeaders = this.isHttp && source.httpHeaders || {};\n      this._fullRequestReader = null;\n      this._rangeRequestReaders = [];\n    }\n\n    get _progressiveDataLength() {\n      return this._fullRequestReader && this._fullRequestReader._loaded || 0; // lwf\n    }\n\n    getFullReader() {\n      (0, _util.assert)(!this._fullRequestReader, \"PDFFetchStream.getFullReader can only be called once.\");\n      this._fullRequestReader = new PDFFetchStreamReader(this);\n      return this._fullRequestReader;\n    }\n\n    getRangeReader(begin, end) {\n      if (end <= this._progressiveDataLength) {\n        return null;\n      }\n\n      const reader = new PDFFetchStreamRangeReader(this, begin, end);\n\n      this._rangeRequestReaders.push(reader);\n\n      return reader;\n    }\n\n    cancelAllRequests(reason) {\n      if (this._fullRequestReader) {\n        this._fullRequestReader.cancel(reason);\n      }\n\n      const readers = this._rangeRequestReaders.slice(0);\n\n      readers.forEach(function (reader) {\n        reader.cancel(reason);\n      });\n    }\n\n  }\n\n  exports.PDFFetchStream = PDFFetchStream;\n\n  class PDFFetchStreamReader {\n    constructor(stream) {\n      this._stream = stream;\n      this._reader = null;\n      this._loaded = 0;\n      this._filename = null;\n      const source = stream.source;\n      this._withCredentials = source.withCredentials || false;\n      this._contentLength = source.length;\n      this._headersCapability = (0, _util.createPromiseCapability)();\n      this._disableRange = source.disableRange || false;\n      this._rangeChunkSize = source.rangeChunkSize;\n\n      if (!this._rangeChunkSize && !this._disableRange) {\n        this._disableRange = true;\n      }\n\n      if (typeof AbortController !== \"undefined\") {\n        this._abortController = new AbortController();\n      }\n\n      this._isStreamingSupported = !source.disableStream;\n      this._isRangeSupported = !source.disableRange;\n      this._headers = createHeaders(this._stream.httpHeaders);\n      const url = source.url;\n      fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {\n        if (!(0, _network_utils.validateResponseStatus)(response.status)) {\n          throw (0, _network_utils.createResponseStatusError)(response.status, url);\n        }\n\n        this._reader = response.body.getReader();\n\n        this._headersCapability.resolve();\n\n        const getResponseHeader = name => {\n          return response.headers.get(name);\n        };\n\n        const {\n          allowRangeRequests,\n          suggestedLength\n        } = (0, _network_utils.validateRangeRequestCapabilities)({\n          getResponseHeader,\n          isHttp: this._stream.isHttp,\n          rangeChunkSize: this._rangeChunkSize,\n          disableRange: this._disableRange\n        });\n        this._isRangeSupported = allowRangeRequests;\n        this._contentLength = suggestedLength || this._contentLength;\n        this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n\n        if (!this._isStreamingSupported && this._isRangeSupported) {\n          this.cancel(new _util.AbortException(\"Streaming is disabled.\"));\n        }\n      }).catch(this._headersCapability.reject);\n      this.onProgress = null;\n    }\n\n    get headersReady() {\n      return this._headersCapability.promise;\n    }\n\n    get filename() {\n      return this._filename;\n    }\n\n    get contentLength() {\n      return this._contentLength;\n    }\n\n    get isRangeSupported() {\n      return this._isRangeSupported;\n    }\n\n    get isStreamingSupported() {\n      return this._isStreamingSupported;\n    }\n\n    async read() {\n      await this._headersCapability.promise;\n      const {\n        value,\n        done\n      } = await this._reader.read();\n\n      if (done) {\n        return {\n          value,\n          done\n        };\n      }\n\n      this._loaded += value.byteLength;\n\n      if (this.onProgress) {\n        this.onProgress({\n          loaded: this._loaded,\n          total: this._contentLength\n        });\n      }\n\n      const buffer = new Uint8Array(value).buffer;\n      return {\n        value: buffer,\n        done: false\n      };\n    }\n\n    cancel(reason) {\n      if (this._reader) {\n        this._reader.cancel(reason);\n      }\n\n      if (this._abortController) {\n        this._abortController.abort();\n      }\n    }\n\n  }\n\n  class PDFFetchStreamRangeReader {\n    constructor(stream, begin, end) {\n      this._stream = stream;\n      this._reader = null;\n      this._loaded = 0;\n      const source = stream.source;\n      this._withCredentials = source.withCredentials || false;\n      this._readCapability = (0, _util.createPromiseCapability)();\n      this._isStreamingSupported = !source.disableStream;\n\n      if (typeof AbortController !== \"undefined\") {\n        this._abortController = new AbortController();\n      }\n\n      this._headers = createHeaders(this._stream.httpHeaders);\n\n      this._headers.append(\"Range\", `bytes=${begin}-${end - 1}`);\n\n      const url = source.url;\n      fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {\n        if (!(0, _network_utils.validateResponseStatus)(response.status)) {\n          throw (0, _network_utils.createResponseStatusError)(response.status, url);\n        }\n\n        this._readCapability.resolve();\n\n        this._reader = response.body.getReader();\n      }).catch(reason => {\n        if (reason && reason.name === \"AbortError\") { // lwf\n          return;\n        }\n\n        throw reason;\n      });\n      this.onProgress = null;\n    }\n\n    get isStreamingSupported() {\n      return this._isStreamingSupported;\n    }\n\n    async read() {\n      await this._readCapability.promise;\n      const {\n        value,\n        done\n      } = await this._reader.read();\n\n      if (done) {\n        return {\n          value,\n          done\n        };\n      }\n\n      this._loaded += value.byteLength;\n\n      if (this.onProgress) {\n        this.onProgress({\n          loaded: this._loaded\n        });\n      }\n\n      const buffer = new Uint8Array(value).buffer;\n      return {\n        value: buffer,\n        done: false\n      };\n    }\n\n    cancel(reason) {\n      if (this._reader) {\n        this._reader.cancel(reason);\n      }\n\n      if (this._abortController) {\n        this._abortController.abort();\n      }\n    }\n\n  }\n/***/ })\n/******/  ]);\n/************************************************************************/\n/******/  // The module cache\n/******/  var __webpack_module_cache__ = {};\n/******/  \n/******/  // The require function\n/******/  function __w_pdfjs_require__(moduleId) {\n/******/    // Check if module is in cache\n/******/    if(__webpack_module_cache__[moduleId]) {\n/******/      return __webpack_module_cache__[moduleId].exports;\n/******/    }\n/******/    // Create a new module (and put it into the cache)\n/******/    var module = __webpack_module_cache__[moduleId] = {\n/******/      // no module.id needed\n/******/      // no module.loaded needed\n/******/      exports: {}\n/******/    };\n/******/  \n/******/    // Execute the module function\n/******/    __webpack_modules__[moduleId](module, module.exports, __w_pdfjs_require__);\n/******/  \n/******/    // Return the exports of the module\n/******/    return module.exports;\n/******/  }\n/******/  \n/************************************************************************/\n/******/  // module exports must be returned from runtime so entry inlining is disabled\n/******/  // startup\n/******/  // Load entry module and return exports\n/******/  return __w_pdfjs_require__(0);\n/******/ })()\n;\n});\n\ndefine('skylark-pdfjs-display/main',[\r\n\t\"./display\"\r\n],function(display) {\r\n\treturn display;\r\n});\ndefine('skylark-pdfjs-display', ['skylark-pdfjs-display/main'], function (main) { return main; });\n\ndefine('skylark-viewerjs/ui_utils',[\n    \"./viewerjs\"\n],function(viewerjs) {\n  'use strict';\n\n  var CSS_UNITS = 96.0 / 72.0;\n  var DEFAULT_SCALE = 'auto';\n  var UNKNOWN_SCALE = 0;\n  var MAX_AUTO_SCALE = 1.25;\n  var SCROLLBAR_PADDING = 40;\n  var VERTICAL_PADDING = 5;\n\n  // optimised CSS custom property getter/setter\n  var CustomStyle = (function CustomStyleClosure() {\n\n    // As noted on: http://www.zachstronaut.com/posts/2009/02/17/\n    //              animate-css-transforms-firefox-webkit.html\n    // in some versions of IE9 it is critical that ms appear in this list\n    // before Moz\n    var prefixes = ['ms', 'Moz', 'Webkit', 'O'];\n    var _cache = {};\n\n    function CustomStyle() {}\n\n    CustomStyle.getProp = function get(propName, element) {\n      // check cache only when no element is given\n      if (arguments.length === 1 && typeof _cache[propName] === 'string') {\n        return _cache[propName];\n      }\n\n      element = element || document.documentElement;\n      var style = element.style, prefixed, uPropName;\n\n      // test standard property first\n      if (typeof style[propName] === 'string') {\n        return (_cache[propName] = propName);\n      }\n\n      // capitalize\n      uPropName = propName.charAt(0).toUpperCase() + propName.slice(1);\n\n      // test vendor specific properties\n      for (var i = 0, l = prefixes.length; i < l; i++) {\n        prefixed = prefixes[i] + uPropName;\n        if (typeof style[prefixed] === 'string') {\n          return (_cache[propName] = prefixed);\n        }\n      }\n\n      //if all fails then set to undefined\n      return (_cache[propName] = 'undefined');\n    };\n\n    CustomStyle.setProp = function set(propName, element, str) {\n      var prop = this.getProp(propName);\n      if (prop !== 'undefined') {\n        element.style[prop] = str;\n      }\n    };\n\n    return CustomStyle;\n  })();\n\n  function getFileName(url) {\n    var anchor = url.indexOf('#');\n    var query = url.indexOf('?');\n    var end = Math.min(\n      anchor > 0 ? anchor : url.length,\n      query > 0 ? query : url.length);\n    return url.substring(url.lastIndexOf('/', end) + 1, end);\n  }\n\n  /**\n   * Returns scale factor for the canvas. It makes sense for the HiDPI displays.\n   * @return {Object} The object with horizontal (sx) and vertical (sy)\n                      scales. The scaled property is set to false if scaling is\n                      not required, true otherwise.\n   */\n  function getOutputScale(ctx) {\n    var devicePixelRatio = window.devicePixelRatio || 1;\n    var backingStoreRatio = ctx.webkitBackingStorePixelRatio ||\n                            ctx.mozBackingStorePixelRatio ||\n                            ctx.msBackingStorePixelRatio ||\n                            ctx.oBackingStorePixelRatio ||\n                            ctx.backingStorePixelRatio || 1;\n    var pixelRatio = devicePixelRatio / backingStoreRatio;\n    return {\n      sx: pixelRatio,\n      sy: pixelRatio,\n      scaled: pixelRatio !== 1\n    };\n  }\n\n  /**\n   * Scrolls specified element into view of its parent.\n   * element {Object} The element to be visible.\n   * spot {Object} An object with optional top and left properties,\n   *               specifying the offset from the top left edge.\n   */\n  function scrollIntoView(element, spot) {\n    // Assuming offsetParent is available (it's not available when viewer is in\n    // hidden iframe or object). We have to scroll: if the offsetParent is not set\n    // producing the error. See also animationStartedClosure.\n    var parent = element.offsetParent;\n    var offsetY = element.offsetTop + element.clientTop;\n    var offsetX = element.offsetLeft + element.clientLeft;\n    if (!parent) {\n      console.error('offsetParent is not set -- cannot scroll');\n      return;\n    }\n    while (parent.clientHeight === parent.scrollHeight) {\n      if (parent.dataset._scaleY) {\n        offsetY /= parent.dataset._scaleY;\n        offsetX /= parent.dataset._scaleX;\n      }\n      offsetY += parent.offsetTop;\n      offsetX += parent.offsetLeft;\n      parent = parent.offsetParent;\n      if (!parent) {\n        return; // no need to scroll\n      }\n    }\n    if (spot) {\n      if (spot.top !== undefined) {\n        offsetY += spot.top;\n      }\n      if (spot.left !== undefined) {\n        offsetX += spot.left;\n        parent.scrollLeft = offsetX;\n      }\n    }\n    parent.scrollTop = offsetY;\n  }\n\n  /**\n   * Helper function to start monitoring the scroll event and converting them into\n   * PDF.js friendly one: with scroll debounce and scroll direction.\n   */\n  function watchScroll(viewAreaElement, callback) {\n    var debounceScroll = function debounceScroll(evt) {\n      if (rAF) {\n        return;\n      }\n      // schedule an invocation of scroll for next animation frame.\n      rAF = window.requestAnimationFrame(function viewAreaElementScrolled() {\n        rAF = null;\n\n        var currentY = viewAreaElement.scrollTop;\n        var lastY = state.lastY;\n        if (currentY !== lastY) {\n          state.down = currentY > lastY;\n        }\n        state.lastY = currentY;\n        callback(state);\n      });\n    };\n\n    var state = {\n      down: true,\n      lastY: viewAreaElement.scrollTop,\n      _eventHandler: debounceScroll\n    };\n\n    var rAF = null;\n    viewAreaElement.addEventListener('scroll', debounceScroll, true);\n    return state;\n  }\n\n  /**\n   * Use binary search to find the index of the first item in a given array which\n   * passes a given condition. The items are expected to be sorted in the sense\n   * that if the condition is true for one item in the array, then it is also true\n   * for all following items.\n   *\n   * @returns {Number} Index of the first array element to pass the test,\n   *                   or |items.length| if no such element exists.\n   */\n  function binarySearchFirstItem(items, condition) {\n    var minIndex = 0;\n    var maxIndex = items.length - 1;\n\n    if (items.length === 0 || !condition(items[maxIndex])) {\n      return items.length;\n    }\n    if (condition(items[minIndex])) {\n      return minIndex;\n    }\n\n    while (minIndex < maxIndex) {\n      var currentIndex = (minIndex + maxIndex) >> 1;\n      var currentItem = items[currentIndex];\n      if (condition(currentItem)) {\n        maxIndex = currentIndex;\n      } else {\n        minIndex = currentIndex + 1;\n      }\n    }\n    return minIndex; /* === maxIndex */\n  }\n\n  /**\n   * Generic helper to find out what elements are visible within a scroll pane.\n   */\n  function getVisibleElements(scrollEl, views, sortByVisibility) {\n    var top = scrollEl.scrollTop, bottom = top + scrollEl.clientHeight;\n    var left = scrollEl.scrollLeft, right = left + scrollEl.clientWidth;\n\n    function isElementBottomBelowViewTop(view) {\n      var element = view.div;\n      var elementBottom =\n        element.offsetTop + element.clientTop + element.clientHeight;\n      return elementBottom > top;\n    }\n\n    var visible = [], view, element;\n    var currentHeight, viewHeight, hiddenHeight, percentHeight;\n    var currentWidth, viewWidth;\n    var firstVisibleElementInd = (views.length === 0) ? 0 :\n      binarySearchFirstItem(views, isElementBottomBelowViewTop);\n\n    for (var i = firstVisibleElementInd, ii = views.length; i < ii; i++) {\n      view = views[i];\n      element = view.div;\n      currentHeight = element.offsetTop + element.clientTop;\n      viewHeight = element.clientHeight;\n\n      if (currentHeight > bottom) {\n        break;\n      }\n\n      currentWidth = element.offsetLeft + element.clientLeft;\n      viewWidth = element.clientWidth;\n      if (currentWidth + viewWidth < left || currentWidth > right) {\n        continue;\n      }\n      hiddenHeight = Math.max(0, top - currentHeight) +\n        Math.max(0, currentHeight + viewHeight - bottom);\n      percentHeight = ((viewHeight - hiddenHeight) * 100 / viewHeight) | 0;\n\n      visible.push({\n        id: view.id,\n        x: currentWidth,\n        y: currentHeight,\n        view: view,\n        percent: percentHeight\n      });\n    }\n\n    var first = visible[0];\n    var last = visible[visible.length - 1];\n\n    if (sortByVisibility) {\n      visible.sort(function(a, b) {\n        var pc = a.percent - b.percent;\n        if (Math.abs(pc) > 0.001) {\n          return -pc;\n        }\n        return a.id - b.id; // ensure stability\n      });\n    }\n    return {first: first, last: last, views: visible};\n  }\n\n  /**\n   * Event handler to suppress context menu.\n   */\n  function noContextMenuHandler(e) {\n    e.preventDefault();\n  }\n\n  /**\n   * Returns the filename or guessed filename from the url (see issue 3455).\n   * url {String} The original PDF location.\n   * @return {String} Guessed PDF file name.\n   */\n  function getPDFFileNameFromURL(url) {\n    var reURI = /^(?:([^:]+:)?\\/\\/[^\\/]+)?([^?#]*)(\\?[^#]*)?(#.*)?$/;\n    //            SCHEME      HOST         1.PATH  2.QUERY   3.REF\n    // Pattern to get last matching NAME.pdf\n    var reFilename = /[^\\/?#=]+\\.pdf\\b(?!.*\\.pdf\\b)/i;\n    var splitURI = reURI.exec(url);\n    var suggestedFilename = reFilename.exec(splitURI[1]) ||\n                             reFilename.exec(splitURI[2]) ||\n                             reFilename.exec(splitURI[3]);\n    if (suggestedFilename) {\n      suggestedFilename = suggestedFilename[0];\n      if (suggestedFilename.indexOf('%') !== -1) {\n        // URL-encoded %2Fpath%2Fto%2Ffile.pdf should be file.pdf\n        try {\n          suggestedFilename =\n            reFilename.exec(decodeURIComponent(suggestedFilename))[0];\n        } catch(e) { // Possible (extremely rare) errors:\n          // URIError \"Malformed URI\", e.g. for \"%AA.pdf\"\n          // TypeError \"null has no properties\", e.g. for \"%2F.pdf\"\n        }\n      }\n    }\n    return suggestedFilename || 'document.pdf';\n  }\n\n  var ProgressBar = (function ProgressBarClosure() {\n\n    function clamp(v, min, max) {\n      return Math.min(Math.max(v, min), max);\n    }\n\n    function ProgressBar(id, opts) {\n      this.visible = true;\n\n      // Fetch the sub-elements for later.\n      this.div = document.querySelector(id + ' .progress');\n\n      // Get the loading bar element, so it can be resized to fit the viewer.\n      this.bar = this.div.parentNode;\n\n      // Get options, with sensible defaults.\n      this.height = opts.height || 100;\n      this.width = opts.width || 100;\n      this.units = opts.units || '%';\n\n      // Initialize heights.\n      this.div.style.height = this.height + this.units;\n      this.percent = 0;\n    }\n\n    ProgressBar.prototype = {\n\n      updateBar: function ProgressBar_updateBar() {\n        if (this._indeterminate) {\n          this.div.classList.add('indeterminate');\n          this.div.style.width = this.width + this.units;\n          return;\n        }\n\n        this.div.classList.remove('indeterminate');\n        var progressSize = this.width * this._percent / 100;\n        this.div.style.width = progressSize + this.units;\n      },\n\n      get percent() {\n        return this._percent;\n      },\n\n      set percent(val) {\n        this._indeterminate = isNaN(val);\n        this._percent = clamp(val, 0, 100);\n        this.updateBar();\n      },\n\n      setWidth: function ProgressBar_setWidth(viewer) {\n        if (viewer) {\n          var container = viewer.parentNode;\n          var scrollbarWidth = container.offsetWidth - viewer.offsetWidth;\n          if (scrollbarWidth > 0) {\n            this.bar.setAttribute('style', 'width: calc(100% - ' +\n                                           scrollbarWidth + 'px);');\n          }\n        }\n      },\n\n      hide: function ProgressBar_hide() {\n        if (!this.visible) {\n          return;\n        }\n        this.visible = false;\n        this.bar.classList.add('hidden');\n        document.body.classList.remove('loadingInProgress');\n      },\n\n      show: function ProgressBar_show() {\n        if (this.visible) {\n          return;\n        }\n        this.visible = true;\n        document.body.classList.add('loadingInProgress');\n        this.bar.classList.remove('hidden');\n      }\n    };\n\n    return ProgressBar;\n  })();\n\n  return viewerjs.uiutils = {\n    CustomStyle,\n    getFileName,\n    getOutputScale,\n    scrollIntoView,\n    watchScroll,\n    binarySearchFirstItem,\n    getVisibleElements,\n    getPDFFileNameFromURL,\n    ProgressBar\n  };\n});\ndefine('skylark-viewerjs/text_layer_builder',[\n    \"skylark-pdfjs-display\",\n    \"./viewerjs\",\n    \"./ui_utils\"\n],function(PDFJS,viewerjs,uiutils) {\n  'use strict';\n\n  var MAX_TEXT_DIVS_TO_RENDER = 100000;\n\n  var NonWhitespaceRegexp = /\\S/;\n\n  function isAllWhitespace(str) {\n    return !NonWhitespaceRegexp.test(str);\n  }\n\n  /**\n   * @typedef {Object} TextLayerBuilderOptions\n   * @property {HTMLDivElement} textLayerDiv - The text layer container.\n   * @property {number} pageIndex - The page index.\n   * @property {PageViewport} viewport - The viewport of the text layer.\n   * @property {PDFFindController} findController\n   */\n\n  /**\n   * TextLayerBuilder provides text-selection functionality for the PDF.\n   * It does this by creating overlay divs over the PDF text. These divs\n   * contain text that matches the PDF text they are overlaying. This object\n   * also provides a way to highlight text that is being searched for.\n   * @class\n   */\n  function TextLayerBuilder(options) {\n    this.textLayerDiv = options.textLayerDiv;\n    this.renderingDone = false;\n    this.divContentDone = false;\n    this.pageIdx = options.pageIndex;\n    this.pageNumber = this.pageIdx + 1;\n    this.matches = [];\n    this.viewport = options.viewport;\n    this.textDivs = [];\n    this.findController = options.findController || null;\n  }\n\n  TextLayerBuilder.prototype = {\n    _finishRendering: function TextLayerBuilder_finishRendering() {\n      this.renderingDone = true;\n\n      var event = document.createEvent('CustomEvent');\n      event.initCustomEvent('textlayerrendered', true, true, {\n        pageNumber: this.pageNumber\n      });\n      this.textLayerDiv.dispatchEvent(event);\n    },\n\n    renderLayer: function TextLayerBuilder_renderLayer() {\n      var textLayerFrag = document.createDocumentFragment();\n      var textDivs = this.textDivs;\n      var textDivsLength = textDivs.length;\n      var canvas = document.createElement('canvas');\n      var ctx = canvas.getContext('2d');\n\n      // No point in rendering many divs as it would make the browser\n      // unusable even after the divs are rendered.\n      if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {\n        this._finishRendering();\n        return;\n      }\n\n      var lastFontSize;\n      var lastFontFamily;\n      for (var i = 0; i < textDivsLength; i++) {\n        var textDiv = textDivs[i];\n        if (textDiv.dataset.isWhitespace !== undefined) {\n          continue;\n        }\n\n        var fontSize = textDiv.style.fontSize;\n        var fontFamily = textDiv.style.fontFamily;\n\n        // Only build font string and set to context if different from last.\n        if (fontSize !== lastFontSize || fontFamily !== lastFontFamily) {\n          ctx.font = fontSize + ' ' + fontFamily;\n          lastFontSize = fontSize;\n          lastFontFamily = fontFamily;\n        }\n\n        var width = ctx.measureText(textDiv.textContent).width;\n        if (width > 0) {\n          textLayerFrag.appendChild(textDiv);\n          var transform;\n          if (textDiv.dataset.canvasWidth !== undefined) {\n            // Dataset values come of type string.\n            var textScale = textDiv.dataset.canvasWidth / width;\n            transform = 'scaleX(' + textScale + ')';\n          } else {\n            transform = '';\n          }\n          var rotation = textDiv.dataset.angle;\n          if (rotation) {\n            transform = 'rotate(' + rotation + 'deg) ' + transform;\n          }\n          if (transform) {\n            uiutils.CustomStyle.setProp('transform' , textDiv, transform);\n          }\n        }\n      }\n\n      this.textLayerDiv.appendChild(textLayerFrag);\n      this._finishRendering();\n      this.updateMatches();\n    },\n\n    /**\n     * Renders the text layer.\n     * @param {number} timeout (optional) if specified, the rendering waits\n     *   for specified amount of ms.\n     */\n    render: function TextLayerBuilder_render(timeout) {\n      if (!this.divContentDone || this.renderingDone) {\n        return;\n      }\n\n      if (this.renderTimer) {\n        clearTimeout(this.renderTimer);\n        this.renderTimer = null;\n      }\n\n      if (!timeout) { // Render right away\n        this.renderLayer();\n      } else { // Schedule\n        var self = this;\n        this.renderTimer = setTimeout(function() {\n          self.renderLayer();\n          self.renderTimer = null;\n        }, timeout);\n      }\n    },\n\n    appendText: function TextLayerBuilder_appendText(geom, styles) {\n      var style = styles[geom.fontName];\n      var textDiv = document.createElement('div');\n      this.textDivs.push(textDiv);\n      if (isAllWhitespace(geom.str)) {\n        textDiv.dataset.isWhitespace = true;\n        return;\n      }\n      var tx = PDFJS.Util.transform(this.viewport.transform, geom.transform);\n      var angle = Math.atan2(tx[1], tx[0]);\n      if (style.vertical) {\n        angle += Math.PI / 2;\n      }\n      var fontHeight = Math.sqrt((tx[2] * tx[2]) + (tx[3] * tx[3]));\n      var fontAscent = fontHeight;\n      if (style.ascent) {\n        fontAscent = style.ascent * fontAscent;\n      } else if (style.descent) {\n        fontAscent = (1 + style.descent) * fontAscent;\n      }\n\n      var left;\n      var top;\n      if (angle === 0) {\n        left = tx[4];\n        top = tx[5] - fontAscent;\n      } else {\n        left = tx[4] + (fontAscent * Math.sin(angle));\n        top = tx[5] - (fontAscent * Math.cos(angle));\n      }\n      textDiv.style.left = left + 'px';\n      textDiv.style.top = top + 'px';\n      textDiv.style.fontSize = fontHeight + 'px';\n      textDiv.style.fontFamily = style.fontFamily;\n\n      textDiv.textContent = geom.str;\n      // |fontName| is only used by the Font Inspector. This test will succeed\n      // when e.g. the Font Inspector is off but the Stepper is on, but it's\n      // not worth the effort to do a more accurate test.\n      if (PDFJS.pdfBug) {\n        textDiv.dataset.fontName = geom.fontName;\n      }\n      // Storing into dataset will convert number into string.\n      if (angle !== 0) {\n        textDiv.dataset.angle = angle * (180 / Math.PI);\n      }\n      // We don't bother scaling single-char text divs, because it has very\n      // little effect on text highlighting. This makes scrolling on docs with\n      // lots of such divs a lot faster.\n      if (textDiv.textContent.length > 1) {\n        if (style.vertical) {\n          textDiv.dataset.canvasWidth = geom.height * this.viewport.scale;\n        } else {\n          textDiv.dataset.canvasWidth = geom.width * this.viewport.scale;\n        }\n      }\n    },\n\n    setTextContent: function TextLayerBuilder_setTextContent(textContent) {\n      this.textContent = textContent;\n\n      var textItems = textContent.items;\n      for (var i = 0, len = textItems.length; i < len; i++) {\n        this.appendText(textItems[i], textContent.styles);\n      }\n      this.divContentDone = true;\n    },\n\n    convertMatches: function TextLayerBuilder_convertMatches(matches) {\n      var i = 0;\n      var iIndex = 0;\n      var bidiTexts = this.textContent.items;\n      var end = bidiTexts.length - 1;\n      var queryLen = (this.findController === null ?\n                      0 : this.findController.state.query.length);\n      var ret = [];\n\n      for (var m = 0, len = matches.length; m < len; m++) {\n        // Calculate the start position.\n        var matchIdx = matches[m];\n\n        // Loop over the divIdxs.\n        while (i !== end && matchIdx >= (iIndex + bidiTexts[i].str.length)) {\n          iIndex += bidiTexts[i].str.length;\n          i++;\n        }\n\n        if (i === bidiTexts.length) {\n          console.error('Could not find a matching mapping');\n        }\n\n        var match = {\n          begin: {\n            divIdx: i,\n            offset: matchIdx - iIndex\n          }\n        };\n\n        // Calculate the end position.\n        matchIdx += queryLen;\n\n        // Somewhat the same array as above, but use > instead of >= to get\n        // the end position right.\n        while (i !== end && matchIdx > (iIndex + bidiTexts[i].str.length)) {\n          iIndex += bidiTexts[i].str.length;\n          i++;\n        }\n\n        match.end = {\n          divIdx: i,\n          offset: matchIdx - iIndex\n        };\n        ret.push(match);\n      }\n\n      return ret;\n    },\n\n    renderMatches: function TextLayerBuilder_renderMatches(matches) {\n      // Early exit if there is nothing to render.\n      if (matches.length === 0) {\n        return;\n      }\n\n      var bidiTexts = this.textContent.items;\n      var textDivs = this.textDivs;\n      var prevEnd = null;\n      var pageIdx = this.pageIdx;\n      var isSelectedPage = (this.findController === null ?\n        false : (pageIdx === this.findController.selected.pageIdx));\n      var selectedMatchIdx = (this.findController === null ?\n                              -1 : this.findController.selected.matchIdx);\n      var highlightAll = (this.findController === null ?\n                          false : this.findController.state.highlightAll);\n      var infinity = {\n        divIdx: -1,\n        offset: undefined\n      };\n\n      function beginText(begin, className) {\n        var divIdx = begin.divIdx;\n        textDivs[divIdx].textContent = '';\n        appendTextToDiv(divIdx, 0, begin.offset, className);\n      }\n\n      function appendTextToDiv(divIdx, fromOffset, toOffset, className) {\n        var div = textDivs[divIdx];\n        var content = bidiTexts[divIdx].str.substring(fromOffset, toOffset);\n        var node = document.createTextNode(content);\n        if (className) {\n          var span = document.createElement('span');\n          span.className = className;\n          span.appendChild(node);\n          div.appendChild(span);\n          return;\n        }\n        div.appendChild(node);\n      }\n\n      var i0 = selectedMatchIdx, i1 = i0 + 1;\n      if (highlightAll) {\n        i0 = 0;\n        i1 = matches.length;\n      } else if (!isSelectedPage) {\n        // Not highlighting all and this isn't the selected page, so do nothing.\n        return;\n      }\n\n      for (var i = i0; i < i1; i++) {\n        var match = matches[i];\n        var begin = match.begin;\n        var end = match.end;\n        var isSelected = (isSelectedPage && i === selectedMatchIdx);\n        var highlightSuffix = (isSelected ? ' selected' : '');\n\n        if (this.findController) {\n          this.findController.updateMatchPosition(pageIdx, i, textDivs,\n                                                  begin.divIdx, end.divIdx);\n        }\n\n        // Match inside new div.\n        if (!prevEnd || begin.divIdx !== prevEnd.divIdx) {\n          // If there was a previous div, then add the text at the end.\n          if (prevEnd !== null) {\n            appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);\n          }\n          // Clear the divs and set the content until the starting point.\n          beginText(begin);\n        } else {\n          appendTextToDiv(prevEnd.divIdx, prevEnd.offset, begin.offset);\n        }\n\n        if (begin.divIdx === end.divIdx) {\n          appendTextToDiv(begin.divIdx, begin.offset, end.offset,\n                          'highlight' + highlightSuffix);\n        } else {\n          appendTextToDiv(begin.divIdx, begin.offset, infinity.offset,\n                          'highlight begin' + highlightSuffix);\n          for (var n0 = begin.divIdx + 1, n1 = end.divIdx; n0 < n1; n0++) {\n            textDivs[n0].className = 'highlight middle' + highlightSuffix;\n          }\n          beginText(end, 'highlight end' + highlightSuffix);\n        }\n        prevEnd = end;\n      }\n\n      if (prevEnd) {\n        appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);\n      }\n    },\n\n    updateMatches: function TextLayerBuilder_updateMatches() {\n      // Only show matches when all rendering is done.\n      if (!this.renderingDone) {\n        return;\n      }\n\n      // Clear all matches.\n      var matches = this.matches;\n      var textDivs = this.textDivs;\n      var bidiTexts = this.textContent.items;\n      var clearedUntilDivIdx = -1;\n\n      // Clear all current matches.\n      for (var i = 0, len = matches.length; i < len; i++) {\n        var match = matches[i];\n        var begin = Math.max(clearedUntilDivIdx, match.begin.divIdx);\n        for (var n = begin, end = match.end.divIdx; n <= end; n++) {\n          var div = textDivs[n];\n          div.textContent = bidiTexts[n].str;\n          div.className = '';\n        }\n        clearedUntilDivIdx = match.end.divIdx + 1;\n      }\n\n      if (this.findController === null || !this.findController.active) {\n        return;\n      }\n\n      // Convert the matches on the page controller into the match format\n      // used for the textLayer.\n      this.matches = this.convertMatches(this.findController === null ?\n        [] : (this.findController.pageMatches[this.pageIdx] || []));\n      this.renderMatches(this.matches);\n    }\n  };\n\n  /**\n   * @constructor\n   * @implements IPDFTextLayerFactory\n   */\n  function DefaultTextLayerFactory() {}\n  DefaultTextLayerFactory.prototype = {\n    /**\n     * @param {HTMLDivElement} textLayerDiv\n     * @param {number} pageIndex\n     * @param {PageViewport} viewport\n     * @returns {TextLayerBuilder}\n     */\n    createTextLayerBuilder: function (textLayerDiv, pageIndex, viewport) {\n      return new TextLayerBuilder({\n        textLayerDiv: textLayerDiv,\n        pageIndex: pageIndex,\n        viewport: viewport\n      });\n    }\n  };\n\n  TextLayerBuilder.DefaultTextLayerFactory = DefaultTextLayerFactory;\n\n  return viewerjs.TextLayerBuilder = TextLayerBuilder\n});\ndefine('skylark-viewerjs/PDFViewerPlugin',[\n    \"skylark-pdfjs-display\",\n    \"./viewerjs\",\n    \"./ui_utils\",\n    \"./text_layer_builder\"\n],function(PDFJS,viewerjs,uiutils,TextLayerBuilder) {\n    function PDFViewerPlugin() {\n        \"use strict\";\n\n        function loadScript(path, callback) {\n            var script = document.createElement('script');\n            script.async = false;\n            script.src = path;\n            script.type = 'text/javascript';\n            script.onload = callback || script.onload;\n            document.getElementsByTagName('head')[0].appendChild(script);\n        }\n\n        function init(callback) {\n            var pluginCSS;\n\n            /*\n            loadScript('./compatibility.js', function () {\n                loadScript('./pdf.js');\n                loadScript('./ui_utils.js');\n                loadScript('./text_layer_builder.js');\n                loadScript('./pdfjsversion.js', callback);\n            });\n            */\n            callback();\n\n        }\n\n        var self = this,\n            pages = [],\n            domPages = [],\n            pageText = [],\n            renderingStates = [],\n            RENDERING = {\n                BLANK: 0,\n                RUNNING: 1,\n                FINISHED: 2,\n                RUNNINGOUTDATED: 3\n            },\n            TEXT_LAYER_RENDER_DELAY = 200, // ms\n            container = null,\n            pdfDocument = null,\n            pageViewScroll = null,\n            isGuessedSlideshow = true, // assume true as default, any non-matching page will unset this\n            isPresentationMode = false,\n            scale = 1,\n            currentPage = 1,\n            maxPageWidth = 0,\n            maxPageHeight = 0,\n            createdPageCount = 0;\n\n        function scrollIntoView(elem) {\n            elem.parentNode.scrollTop = elem.offsetTop;\n        }\n\n        function isScrolledIntoView(elem) {\n            if (elem.style.display === \"none\") {\n                return false;\n            }\n\n            var docViewTop = container.scrollTop,\n                docViewBottom = docViewTop + container.clientHeight,\n                elemTop = elem.offsetTop,\n                elemBottom = elemTop + elem.clientHeight;\n\n            // Is in view if either the top or the bottom of the page is between the\n            // document viewport bounds,\n            // or if the top is above the viewport and the bottom is below it.\n            return (elemTop >= docViewTop && elemTop < docViewBottom)\n                    || (elemBottom >= docViewTop && elemBottom < docViewBottom)\n                    || (elemTop < docViewTop && elemBottom >= docViewBottom);\n        }\n\n        function getDomPage(page) {\n            return domPages[page.pageNumber-1]; //modified by lwf for new pdf version\n        }\n        function getPageText(page) {\n            return pageText[page.pageNumber-1];//modified by lwf for new pdf version\n        }\n        function getRenderingStatus(page) {\n            return renderingStates[page.pageNumber-1];//modified by lwf for new pdf version\n        }\n        function setRenderingStatus(page, renderStatus) {\n            renderingStates[page.pageNumber-1] = renderStatus;//modified by lwf for new pdf version\n        }\n\n        function updatePageDimensions(page, width, height) {\n            var domPage = getDomPage(page),\n                canvas = domPage.getElementsByTagName('canvas')[0],\n                textLayer = domPage.getElementsByTagName('div')[0],\n                cssScale = 'scale(' + scale + ', ' + scale + ')';\n\n            domPage.style.width = width + \"px\";\n            domPage.style.height = height + \"px\";\n\n            canvas.width = width;\n            canvas.height = height;\n            canvas.style.width = width + \"px\";\n            canvas.style.height = height + \"px\";\n\n\n            textLayer.style.width = width + \"px\";\n            textLayer.style.height = height + \"px\";\n\n            uiutils.CustomStyle.setProp('transform', textLayer, cssScale);\n            uiutils.CustomStyle.setProp('transformOrigin', textLayer, '0% 0%');\n\n            if (getRenderingStatus(page) === RENDERING.RUNNING) {\n                // TODO: should be able to cancel that rendering\n                setRenderingStatus(page, RENDERING.RUNNINGOUTDATED);\n            } else {\n                // Once the page dimension is updated, the rendering state is blank.\n                setRenderingStatus(page, RENDERING.BLANK);\n            }\n        }\n\n        function ensurePageRendered(page) {\n            var domPage, textLayer, canvas;\n\n            if (getRenderingStatus(page) === RENDERING.BLANK) {\n                setRenderingStatus(page, RENDERING.RUNNING);\n\n                domPage = getDomPage(page);\n                textLayer = getPageText(page);\n                canvas = domPage.getElementsByTagName('canvas')[0];\n\n                page.render({\n                    canvasContext: canvas.getContext('2d'),\n                    textLayer: textLayer,\n                    viewport: page.getViewport({scale}) //modified by lwf for new pdf version\n                }).promise.then(function () {\n                    /*\n                    if (getRenderingStatus(page) === RENDERING.RUNNINGOUTDATED) {\n                        // restart\n                        setRenderingStatus(page, RENDERING.BLANK);\n                        ensurePageRendered(page);\n                    } else {\n                        setRenderingStatus(page, RENDERING.FINISHED);\n                    }\n                    */\n                });\n            }\n        }\n\n        function completeLoading() {\n            var allPagesVisible = !self.isSlideshow();\n            domPages.forEach(function (domPage) {\n                if (allPagesVisible) {\n                    domPage.style.display = \"block\";\n                }\n                container.appendChild(domPage);\n            });\n\n            self.onLoad();\n            self.showPage(1);\n        }\n\n        function createPage(page) {\n            var pageNumber,\n                textLayerDiv,\n                textLayer,\n                canvas,\n                domPage,\n                viewport;\n\n            pageNumber = page.pageNumber; // page.pageIndex + 1; modified by lwf for new pdf version\n\n            viewport = page.getViewport({scale});//viewport = page.getViewport(scale);modified by lwf for new pdf version\n\n            domPage = document.createElement('div');\n            domPage.id = 'pageContainer' + pageNumber;\n            domPage.className = 'page';\n            domPage.style.display = \"none\";\n\n            canvas = document.createElement('canvas');\n            canvas.id = 'canvas' + pageNumber;\n\n            textLayerDiv = document.createElement('div');\n            textLayerDiv.className = 'textLayer';\n            textLayerDiv.id = 'textLayer' + pageNumber;\n\n            domPage.appendChild(canvas);\n            domPage.appendChild(textLayerDiv);\n\n            pages[page.pageNumber-1] = page; //modified by lwf for new pdf version\n            domPages[page.pageNumber-1] = domPage; //modified by lwf for new pdf version\n            renderingStates[page.pageNumber-1] = RENDERING.BLANK;\n\n            updatePageDimensions(page, viewport.width, viewport.height);\n            if (maxPageWidth < viewport.width) {\n                maxPageWidth = viewport.width;\n            }\n            if (maxPageHeight < viewport.height) {\n                maxPageHeight = viewport.height;\n            }\n            // A very simple but generally true guess - if any page has the height greater than the width, treat it no longer as a slideshow\n            if (viewport.width < viewport.height) {\n                isGuessedSlideshow = false;\n            }\n\n            textLayer = new TextLayerBuilder({\n                textLayerDiv: textLayerDiv,\n                viewport: viewport,\n                pageIndex: pageNumber - 1\n            });\n            page.getTextContent().then(function (textContent) {\n                textLayer.setTextContent(textContent);\n                textLayer.render(TEXT_LAYER_RENDER_DELAY);\n            });\n            pageText[page.pageNumber-1] = textLayer; //modified by lwf for new pdf version\n\n            createdPageCount += 1;\n            if (createdPageCount === (pdfDocument.numPages)) {\n                completeLoading();\n            }\n        }\n\n        this.initialize = function (viewContainer, location) {\n            var self = this,\n                i,\n                pluginCSS;\n\n\n            init(function () {\n                PDFJS.GlobalWorkerOptions.workerSrc = \"./skylark-pdfjs-worker-all.js\"; //PDFJS.workerSrc = \"./skylark-pdfjs-worker-all.js\"; modified by lwf for new pdf version\n                //PDFJS.getDocument(location).then(function loadPDF(doc) {\n                PDFJS.getDocument(location).promise.then(function loadPDF(doc) {\n                    pdfDocument = doc;\n                    container = viewContainer;\n\n                    for (i = 0; i < pdfDocument.numPages; i += 1) {\n                        pdfDocument.getPage(i + 1).then(createPage);\n                    }\n                });\n            });\n        };\n\n        this.isSlideshow = function () {\n            return isGuessedSlideshow;\n        };\n\n        this.onLoad = function () {};\n\n        this.getPages = function () {\n            return domPages;\n        };\n\n        this.fitToWidth = function (width) {\n            var zoomLevel;\n\n            if (maxPageWidth === width) {\n                return;\n            }\n            zoomLevel = width / maxPageWidth;\n            self.setZoomLevel(zoomLevel);\n        };\n\n        this.fitToHeight = function (height) {\n            var zoomLevel;\n\n            if (maxPageHeight === height) {\n                return;\n            }\n            zoomLevel = height / maxPageHeight;\n            self.setZoomLevel(zoomLevel);\n        };\n\n        this.fitToPage = function (width, height) {\n            var zoomLevel = width / maxPageWidth;\n            if (height / maxPageHeight < zoomLevel) {\n                zoomLevel = height / maxPageHeight;\n            }\n            self.setZoomLevel(zoomLevel);\n        };\n\n        this.fitSmart = function (width, height) {\n            var zoomLevel = width / maxPageWidth;\n            if (height && (height / maxPageHeight) < zoomLevel) {\n                zoomLevel = height / maxPageHeight;\n            }\n            zoomLevel = Math.min(1.0, zoomLevel);\n            self.setZoomLevel(zoomLevel);\n        };\n\n        this.setZoomLevel = function (zoomLevel) {\n            var i, viewport;\n\n            if (scale !== zoomLevel) {\n                scale = zoomLevel;\n\n                for (i = 0; i < pages.length; i += 1) {\n                    viewport = pages[i].getViewport({scale}); //modified by lwf for new pdf version\n                    updatePageDimensions(pages[i], viewport.width, viewport.height);\n                }\n            }\n        };\n\n        this.getZoomLevel = function () {\n            return scale;\n        };\n\n        this.onScroll = function () {\n            var i;\n\n            for (i = 0; i < domPages.length; i += 1) {\n                if (isScrolledIntoView(domPages[i])) {\n                    ensurePageRendered(pages[i]);\n                }\n            }\n        };\n\n        this.getPageInView = function () {\n            var i;\n\n            if (self.isSlideshow()) {\n                return currentPage;\n            } else {\n                for (i = 0; i < domPages.length; i += 1) {\n                    if (isScrolledIntoView(domPages[i])) {\n                        return i + 1;\n                    }\n                }\n            }\n        };\n\n        this.showPage = function (n) {\n            if (self.isSlideshow()) {\n                domPages[currentPage - 1].style.display = \"none\";\n                currentPage = n;\n                ensurePageRendered(pages[n - 1]);\n                domPages[n - 1].style.display = \"block\";\n            } else {\n                scrollIntoView(domPages[n - 1]);\n            }\n        };\n\n        this.getPluginName = function () {\n            return \"PDF.js\"\n        };\n\n        this.getPluginVersion = function () {\n            var version = (String(typeof pdfjs_version) !== \"undefined\"\n                ? pdfjs_version\n                : \"From Source\"\n            );\n            return version;\n        };\n\n        this.getPluginURL = function () {\n            return \"https://github.com/mozilla/pdf.js/\";\n        };\n    }\n\n    return viewerjs.PDFViewerPlugin = PDFViewerPlugin;\n});\ndefine('skylark-viewerjs/plugin_registry',[\n    \"./viewerjs\",\n    \"./ODFViewerPlugin\",\n    \"./PDFViewerPlugin\"\n],function(viewerjs,ODFViewerPlugin,PDFViewerPlugin) {\n    var css,\n        pluginRegistry = [\n        (function() {\n            var odfMimetypes = [\n                'application/vnd.oasis.opendocument.text',\n                'application/vnd.oasis.opendocument.text-flat-xml',\n                'application/vnd.oasis.opendocument.text-template',\n                'application/vnd.oasis.opendocument.presentation',\n                'application/vnd.oasis.opendocument.presentation-flat-xml',\n                'application/vnd.oasis.opendocument.presentation-template',\n                'application/vnd.oasis.opendocument.spreadsheet',\n                'application/vnd.oasis.opendocument.spreadsheet-flat-xml',\n                'application/vnd.oasis.opendocument.spreadsheet-template'];\n            var odfFileExtensions = [\n                'odt',\n                'fodt',\n                'ott',\n                'odp',\n                'fodp',\n                'otp',\n                'ods',\n                'fods',\n                'ots'];\n\n            return {\n                supportsMimetype: function(mimetype) {\n                    return (odfMimetypes.indexOf(mimetype) !== -1);\n                },\n                supportsFileExtension: function(extension) {\n                    return (odfFileExtensions.indexOf(extension) !== -1);\n                },\n                path: \"./ODFViewerPlugin\",\n                getClass: function() { return ODFViewerPlugin; }\n            };\n        }()),\n        {\n            supportsMimetype: function(mimetype) {\n                return (mimetype === 'application/pdf');\n            },\n            supportsFileExtension: function(extension) {\n                return (extension === 'pdf');\n            },\n            path: \"./PDFViewerPlugin\",\n            getClass: function() { return PDFViewerPlugin; }\n        }\n    ];\n\n\n\n    return viewerjs.pluginRegistry = pluginRegistry\n\n});\n\ndefine('skylark-viewerjs/init',[\r\n    \"./viewerjs\",\r\n\t\"./viewer\",\r\n\t\"./plugin_registry\"\r\n\r\n],function(viewerjs,Viewer,pluginRegistry){\r\n\tvar viewer;\r\n\r\n    function parseSearchParameters(location) {\r\n        var parameters = {},\r\n            search = location.search || \"?\";\r\n\r\n        search.substr(1).split('&').forEach(function (q) {\r\n            // skip empty strings\r\n            if (!q) {\r\n                return;\r\n            }\r\n            // if there is no '=', have it handled as if given key was set to undefined\r\n            var s = q.split('=', 2);\r\n            parameters[decodeURIComponent(s[0])] = decodeURIComponent(s[1]);\r\n        });\r\n\r\n        return parameters;\r\n    }\r\n\r\n    function estimateTypeByHeaderContentType(documentUrl, cb) {\r\n        var xhr = new XMLHttpRequest();\r\n        xhr.onreadystatechange = function() {\r\n            var mimetype, matchingPluginData;\r\n            if (xhr.readyState === 4) {\r\n                if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 0) {\r\n                    mimetype = xhr.getResponseHeader('content-type');\r\n\r\n                    if (mimetype) {\r\n                        pluginRegistry.some(function(pluginData) {\r\n                            if (pluginData.supportsMimetype(mimetype)) {\r\n                                matchingPluginData = pluginData;\r\n                                console.log('Found plugin by mimetype and xhr head: ' + mimetype);\r\n                                return true;\r\n                            }\r\n                            return false;\r\n                        });\r\n                    }\r\n                }\r\n                cb(matchingPluginData);\r\n            }\r\n        };\r\n        xhr.open(\"HEAD\", documentUrl, true);\r\n        xhr.send();\r\n    }\r\n\r\n\r\n    function doEstimateTypeByFileExtension(extension) {\r\n        var matchingPluginData;\r\n\r\n        pluginRegistry.some(function(pluginData) {\r\n            if (pluginData.supportsFileExtension(extension)) {\r\n                matchingPluginData = pluginData;\r\n                return true;\r\n            }\r\n            return false;\r\n        });\r\n\r\n        return matchingPluginData;\r\n    }\r\n\r\n\r\n    function estimateTypeByFileExtension(extension) {\r\n        var matchingPluginData = doEstimateTypeByFileExtension(extension)\r\n\r\n        if (matchingPluginData) {\r\n            console.log('Found plugin by parameter type: ' + extension);\r\n        }\r\n\r\n        return matchingPluginData;\r\n    }\r\n\r\n\r\n    function estimateTypeByFileExtensionFromPath(documentUrl) {\r\n        // See to get any path from the url and grep what could be a file extension\r\n        var documentPath = documentUrl.split('?')[0],\r\n            extension = documentPath.split('.').pop(),\r\n            matchingPluginData = doEstimateTypeByFileExtension(extension)\r\n\r\n        if (matchingPluginData) {\r\n            console.log('Found plugin by file extension from path: ' + extension);\r\n        }\r\n\r\n        return matchingPluginData;\r\n    }\r\n\r\n\tfunction init() {\r\n\t   window.onload = function () {\r\n\t        var viewer,\r\n\t            documentUrl = document.location.hash.substring(1),\r\n\t            parameters = parseSearchParameters(document.location),\r\n\t            Plugin;\r\n\r\n\t        if (documentUrl) {\r\n\t            // try to guess the title as filename from the location, if not set by parameter\r\n\t            if (!parameters.title) {\r\n\t                parameters.title = documentUrl.replace(/^.*[\\\\\\/]/, '');\r\n\t            }\r\n\r\n\t            parameters.documentUrl = documentUrl;\r\n\r\n\t            // trust the server most\r\n\t            estimateTypeByHeaderContentType(documentUrl, function(pluginData) {\r\n\t                if (!pluginData) {\r\n\t                    if (parameters.type) {\r\n\t                        pluginData = estimateTypeByFileExtension(parameters.type);\r\n\t                    } else {\r\n\t                        // last ressort: try to guess from path\r\n\t                        pluginData = estimateTypeByFileExtensionFromPath(documentUrl);\r\n\t                    }\r\n\t                }\r\n\r\n\t                if (pluginData) {\r\n\t                    if (String(typeof loadPlugin) !== \"undefined\") {\r\n\t                        loadPlugin(pluginData.path, function () {\r\n\t                            Plugin = pluginData.getClass();\r\n\t                            viewer = new Viewer(new Plugin(), parameters);\r\n\t                        });\r\n\t                    } else {\r\n\t                        Plugin = pluginData.getClass();\r\n\t                        viewer = new Viewer(new Plugin(), parameters);\r\n\t                    }\r\n\t                } else {\r\n\t                    viewer = new Viewer();\r\n\t                }\r\n\t            });\r\n\t        } else {\r\n\t            viewer = new Viewer();\r\n\t        }\r\n\t    };\r\n\t}\r\n \r\n \treturn viewerjs.init = init;\r\n});\r\n\r\n\r\n\ndefine('skylark-viewerjs/main',[\r\n\t\"./viewerjs\",\r\n\t\"./viewer\",\r\n\t\"./ODFViewerPlugin\",\r\n\t\"./PDFViewerPlugin\",\r\n\t\"./plugin_registry\",\r\n\t\"./text_layer_builder\",\r\n\t\"./ui_utils\",\r\n\t\"./init\"\r\n],function(viewerjs) {\r\n\treturn viewerjs;\r\n});\ndefine('skylark-viewerjs', ['skylark-viewerjs/main'], function (main) { return main; });\n\n"]}